<div class="document">




<h4></h4>

<p>

Средства определения схемы БД в стандарте SQL/89 относятся к наиболее слабым и допускающим различную интерпретацию частям стандарта. Более того, мне неизвестна ни одна реализация, в которой поддерживался бы в точности такой набор средств определения схемы.

</p>
<p>

Поэтому, чтобы добиться мобильности прикладной системы в достаточно широком классе реализаций SQL/89, необходимо тщательно локализовать компоненты определения схемы БД. Думаю, что лучше всего сосредоточить всю работу со схемой БД в одном модуле и иметь в виду, что при переходе к другой СУБД очень вероятно потребуется переделка этого модуля.

</p>
<p>

Особо отметим, что в SQL/89 вообще отсутствуют какие-либо средства изменения схемы БД: нет возможности удалить схему таблицы, добавить к схеме таблицы новый столбец и т.д. Во всех реализациях такие средства поддерживаются, но они могут различаться и синтаксисом, и семантикой.

</p>
<p>

Несмотря на отсутствие особых надежд на то, что удастся встретить реализацию, поддерживающую язык определения схем SQL/89, мы коротко опишем этот язык (без синтаксических деталей), чтобы оценить на содержательном уровне возможности SQL/89 в этой части и получить хотя бы какие-то средства сравнения разных реализаций.

</p>
<h5></h5>

<p>

В соответствии с правилами SQL/89 каждая таблица данной БД имеет простое и квалифицированное имена. В качестве квалификатора имени выступает "идентификатор полномочий" таблицы, который обычно в реализациях совпадает с именем некоторого пользователя, и квалифицированное имя таблицы имеет вид:

</p>
<pre>   &lt;идентификатор полномочий&gt;.&lt;простое имя&gt;</pre>

<p>

Подход к определению схемы в SQL/89 состоит в том, что все таблицы с одним идентификатором полномочий создаются (определяются) путем выполнения одного оператора определения схемы. При этом в стандарте не определяется способ выполнения оператора определения схемы: должен ли он выполняться только в интерактивном режиме или может быть встроен в программу, написанную на традиционном языке программирования.

</p>
<p>

В операторе определения схемы содержится идентификатор полномочий и список элементов схемы, каждый из которых может быть определением таблицы, определением представления (view) или определением привилегий. Каждое из этих определений представляется отдельным оператором SQL/89, но все они, как уже говорилось, должны быть встроены в оператор определения схемы.

</p>
<p>

Для этих операторов мы приведем синтаксис, поскольку это позволит более четко описать их особенности.

</p>
<h5></h5>

<p>

Оператор определения таблицы имеет следующий синтаксис:

</p>
<pre>&lt;table definition&gt; ::=

   CREATE TABLE  &lt;table  name&gt;   (&lt;table   element&gt;

   [{,&lt;table element&gt;}...])

&lt;table element&gt; ::=

  &lt;column definition&gt;

| &lt;table constraint definition&gt;</pre>

<p>

Кроме имени таблицы, в операторе специфицируется список элементов таблицы, каждый из которых служит либо для определения столбца, либо для определения ограничения целостности определяемой таблицы. Требуется наличие хотя бы одного определения столбца. Оператор CREATE TABLE определяет так называемую базовую таблицу, т.е. реальное хранилище данных.

</p>
<p>

Для определения столбцов таблицы и ограничений целостности используются специальные операторы, которые должны быть вложены в оператор определения таблицы.

</p>
<h5></h5>

<p>

Оператор определения столбца описывается следующими синтаксическими правилами:

</p>
<pre>&lt;column definition&gt; ::=

    &lt;column name&gt; &lt;data type&gt;

    [&lt;default clause&gt;] [&lt;column constraint&gt;...]

&lt;default clause&gt; ::=

    DEFAULT { &lt;literal&gt; | USER | NULL }

&lt;column constraint&gt; ::=

    NOT NULL [&lt;unique specification&gt;]

  | &lt;references specification&gt;

  | CHECK (&lt;search condition&gt;)</pre>

<p>

Как видно, кроме обязательной части, в которой определяется имя столбца и его тип данных, определение столбца может содержать два необязательных раздела: раздел значения столбца по умолчанию и раздел ограничений целостности столбца.

</p>
<p>

В разделе значения по умолчанию указывается значение, которое должно быть помещено с строку, заносимую в данную таблицу, если значение данного столбца явно не указано. Значение по умолчанию может быть указано в виде литеральной константы с типом, соответствующим типу столбца; путем задания ключевого слова USER, которому при выполнении оператора занесения строки соответствует символьная строка, содержащая имя текущего пользователя (в этом случае столбец должен иметь тип символьных строк); или путем задания ключевого слова NULL, означающего, что значением по умолчанию является неопределенное значение. Если значение столбца по умолчанию не специфицировано, и в разделе ограничений целостности столбца указано NOT NULL, то попытка занести в таблицу строку с неспецифицированным значением данного столбца приведет к ошибке.

</p>
<p>

Указание в разделе ограничений целостности NOT NULL приводит к неявному порождению проверочного ограничения целостности для всей таблицы (см. следующий подраздел) "CHECK (C IS NOT NULL)" (где C - имя данного столбца). Если ограничение NOT NULL не указано, и раздел умолчаний отсутствует, то неявно порождается раздел умолчаний DEFAULT NULL. Если указана спецификация уникальности, то порождается соответствующая спецификация уникальности для таблицы.

</p>
<p>

Если в разделе ограничений целостности указано ограничение по ссылкам данного столбца (&lt;reference specification&gt;), то порождается соответствующее определение ограничения по ссылкам для таблицы:

</p>
<pre>FOREIGN KEY(C) &lt;reference specification&gt;.</pre>

<p>

Наконец, если указано проверочное ограничение столбца, то условие поиска этого ограничения должно ссылаться только на данный столбец, и неявно порождается соответствующее проверочное ограничение для всей таблицы.

</p>
<h5></h5>

<p>

Ограничения целостности таблицы обладают следующим синтаксисом:

</p>
<pre>&lt;table constraint definition&gt; ::=

    &lt;unique constraint definition&gt;

  | &lt;referential constraint definition&gt;

  | &lt;check constraint definition&gt;

&lt;unique constraint definition&gt; ::=

    &lt;unique specification&gt; (&lt;unique column list&gt;)

&lt;unique specification&gt; ::= UNIQUE | PRIMARY KEY

&lt;unique column list&gt; ::= &lt;column name&gt; [{,&lt;column name&gt;}...]

&lt;referential constraint definition&gt; ::=

    FOREIGN KEY (&lt;referencing columns&gt;) &lt;references specification&gt;

&lt;references specification&gt; ::=

    REFERENCES &lt;referenced table and columns&gt;

&lt;referencing columns&gt; ::= &lt;reference column list&gt;

&lt;referenced table and columns&gt; ::=

    &lt;table name&gt; [(&lt;reference column list&gt;)]

&lt;reference column list&gt; ::= &lt;column name&gt; [{,&lt;column name&gt;}...]

&lt;check constraint definition&gt; ::= CHECK (&lt;search condition&gt;)</pre>

<p>

Для одной таблицы может быть задано несколько ограничений целостности, в том числе те, которые неявно порождаются ограничениями целостности столбцов. Стандарт SQL/89 устанавливает, что ограничения таблицы фактически проверяются при выполнении каждого оператора SQL.

</p>
<p>

Замечание: Наличие правильно подобранного набора ограничений БД очень важно для надежного функционирования прикладной информационной системы. Вместе с тем, в некоторых СУБД ограничения целостности практически не поддерживаются. Поэтому при проектировании прикладной системы необходимо принять решение о том, что более существенно: рассчитывать на поддержку ограничений целостности, но ограничить набор возможных СУБД, или отказаться от их использования на уровне SQL, сохранив возможность использования не самых современных СУБД.

</p>
<p>

Далее T обозначает таблицу, для которой определяются ограничения целостности.

</p>
<p>

<b>Ограничение уникальности

</b></p>
<p>

Каждое имя столбца в списке уникальности должно именовать столбец T и не должно входить в этот список более одного раза. При определении столбца, входящего в список уникальности, должно быть указано ограничение столбца NO NULL. Среди ограничений уникальности T не должно быть более одного определения первичного ключа (ограничения уникальности с ключевым словом RIMARY KEY).

</p>
<p>

Действие ограничения уникальности состоит в том, что в таблице T не допускается появление двух или более строк, значения столбцов уникальности которых совпадают.

</p>
<p>

<b>Ограничение по ссылкам

</b></p>
<p>

Ограничение по ссылкам от заданного набора столбцов CT таблицы T на заданный набор столбцов CT1 некоторой определенной к этому моменту таблицы T1 определяет условие на содержимое обеих этих таблиц, при котором ссылки можно считать корректными.

</p>
<p>

Если список столбцов CT1 явно специфицирован в определении ограничения по ссылкам, то требуется, чтобы этот список явно входил в какое-либо определение уникальности таблицы T1. Если же список CT1 не специфицирован явно в определении ограничения по ссылкам таблицы T, то требуется, чтобы в определении таблицы T1 присутствовало определение первичного ключа, и список CT1 неявно полагается совпадающим со списком имен столбцов из определения первичного ключа таблицы T1. Имена столбцов списков CT и CT1 должны именовать столбцы таблиц T и T1 соответственно, и не должны появляться в списках более одного раза. Списки столбцов CT и CT1 должны содержать одинаковое число элементов, и столбец таблицы T, идентифицируемый i-ым элементом списка CT должен иметь тот же тип, что столбец таблицы T1, идентифицируемый i-ым элементом списка CT1.

</p>
<p>

По определению, таблицы T и T1 удовлетворяют заданному ограничению по ссылкам, если для каждой строки s таблицы T такой, что все значения столбцов s, идентифицируемых списком CT, не являются неопределенными, существует строка s1 таблицы T1 такая, что значения столбцов s1, идентифицируемых списком CT1, позиционно равны значениям столбцов s, идентифицируемых списком CT. По человечески это можно сформулировать так: ограничение по ссылкам удовлетворяется, если для каждой корректной ссылки существует объект, на который она ссылается. В привычной программистам терминологии, ограничение по ссылкам не позволяет производить "висячие" ссылки, не ведущие ни к какому объекту.

</p>
<p>

<b>Проверочное ограничение

</b></p>
<p>

Проверочное ограничение специфицирует условие, которому должна удовлетворять в отдельности каждая строка таблицы T. Это условие не должно содержать подзапросов, спецификаций агрегатных функций, а также ссылок на внешние переменные или параметров. В него могут входить только имена столбцов данной таблицы и литеральные константы.

</p>
<p>

Таблица удовлетворяет проверочному ограничению целостности в том и только в том случае, когда вычисление условия для каждой строки таблицы дает true.

</p>
<p>

Замечание: В некоторых реализациях допускаются расширенные механизмы ограничений по ссылкам и проверочных ограничений. Следует быть внимательным, если не желать выходить за пределы возможностей стандарта.

</p>
<h5></h5>

<p>

Механизм представлений (view) является мощным средством языка SQL, позволяющим скрыть реальную структуру БД от некоторых пользователей за счет определения представления БД, которое реально является некоторым хранимым в БД запросом с именованными столбцами, а для пользователя ничем не отличается от базовой таблицы БД (с учетом технических ограничений). Любая реализация должна гарантировать, что состояние представляемой таблицы точно соответствует состоянию базовых таблиц, на которых определено представление. Обычно вычисление представляемой таблицы (материализация соответствующего запроса) производится каждый раз при использовании представления.

</p>
<p>

В стандарте SQL/89 оператор определения представления имеет следующий синтаксис:

</p>
<pre>&lt;view definition&gt; ::=

     CREATE VIEW &lt;table name&gt; [(&lt;view  column  list&gt;)]

     AS &lt;query specification&gt; [WITH CHECK OPTION]

&lt;view column list&gt; ::= &lt;column name&gt; [{,&lt;column name&gt;}...]</pre>

<p>

Определяемая представляемая таблица V является изменяемой (т.е. по отношению к V можно использовать операторы DELETE и UPDATE) в том и только в том случае, если выполняются следующие условия для спецификации запроса:

</p>
<ul type="disc">

<li>В списке выборки не указано ключевое слово DISTINCT;

</li>
<li>Каждое арифметическое выражение в списке выборки представляет собой одну спецификацию столбца, и спецификация одного столбца не появляется более одного раза;

</li>
<li>В разделе FROM указана только одна таблица, являющаяся либо базовой таблицей, либо изменяемой представляемой таблицей;

</li>
<li>В условии выборки раздела WHERE не используются подзапросы;

</li>
<li>В табличном выражении отсутствуют разделы GROUP BY и HAVING.

</li>
</ul>

<p>

Замечание: Эти ограничения являются очень сильными. В реализациях они могут быть ослаблены. Но если стремиться к мобильности, не следует пользоваться расширенными возможностями.

</p>
<p>

Если в списке выборки спецификации запроса имеется хотя бы одно арифметическое выражение, состоящее не из одной спецификации столбца, или если одно имя столбца участвует в списке выборки более одного раза, определение представления должно содержать список имен столбцов представляемой таблицы. Более просто, нужно явно именовать столбцы представляемой таблицы, если эти имена не наследуются от столбцов таблиц раздела FROM спецификации запроса.

</p>
<p>

Требование WITH CHECK OPTION в определении представления имеет смысл только в случае определения изменяемой представляемой таблицы, которая определяется спецификацией запроса, содержащей раздел WHERE. При наличии этого требования не допускаются изменения представляемой таблицы, которые приводят к появлению в базовых таблиц строк, не видимых в представляемой таблице (т.е. таких строк, которые не удовлетворяют условию поиска раздела WHERE спецификации запроса). Если WITH CHECK OPTION в определении представления отсутствует, такой контроль не производится.

</p>
<h5></h5>

<p>

В соответствии с идеологией языка SQL контроль прав доступа данного пользователя к таблицам БД производится на основе механизма привилегий. Фактически, этот механизм состоит в том, что для выполнения любого действия над таблицей пользователь должен обладать соответствующей привилегией (реально все возможные действия описываются фиксированным стандартным набором привилегий). Пользователь, создавший таблицу, автоматически становится владельцем всех возможных привилегий на выполнение операций над этой таблицей. В число этих привилегий входит привилегия на передачу всех или некоторых привилегий по отношению к данной таблице другому пользователю, включая привилегию на передачу привилегий. Иногда поддерживается и обратная операция изъятия привилегий от пользователя, ранее их получившего.

</p>
<p>

В SQL/89 определяется упрощенная схема механизма привилегий. Во-первых, "раздача" привилегий возможна только при определении таблицы. Во-вторых, пользователь, получивший некоторые привилегии от других пользователей, может передать их дальше только при определении схемы.

</p>
<p>

Определение привилегий производится в следующем синтаксисе:

</p>
<pre>&lt;privilege definition&gt; ::=

    GRANT &lt;privileges&gt;  ON &lt;table name&gt; TO &lt;grantee&gt;

    [{,&lt;grantee&gt;}...] [WITH GRANT OPTION]

&lt;privileges&gt; ::=

    ALL PRIVILEGES

  | &lt;action&gt; [{,&lt;action&gt;}...]

&lt;action&gt; ::=  SELECT | INSERT | DELETE

            | UPDATE [(&lt;grant column list&gt;)]

            | REFERENCES [(&lt;grant column list&gt;]

&lt;grant column list&gt; ::= &lt;column name&gt; [{,&lt;column name&gt;}...]

&lt;grantee&gt; ::= PUBLIC | &lt;authorization identifier&gt;</pre>

<p>

Смысл механизма определения привилегий в SQL/89 достаточно понятен из этого синтаксиса. Заметим лишь, что привилегией REFERENCES по отношению к указанным столбцам таблицы T1 необходимо обладать, чтобы иметь возможность при определении таблицы T определить ограничение по ссылкам между этой таблицей и существующей к этому моменту таблицей T1.

</p>
<p>

Еще раз заметим, что хотя в общем смысле во всех SQL-ориентированных СУБД поддерживается механизм защиты доступа на основе привилегий, реализации могут различаться в деталях. Это опять то место, которое нужно локализовывать, если стремиться к созданию мобильной прикладной системы.



</p>
<p></p>
<center> ||  || <p>

</p>
<p></p>
</center>
</div>