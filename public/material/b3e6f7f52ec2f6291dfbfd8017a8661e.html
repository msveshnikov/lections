# encoding: windows-1251







<p>В этой лекции рассматривается спецификация DB–API 2.0 и модуль для работы с конкретной базой данных, дается начальное представление о языке запросов SQL.</p>
<p>Основные понятия реляционной СУБД</p>
<p>Реляционная база данных — это набор таблиц с данными.</p>
<p>Таблица — это прямоугольная матрица, состоящая из строк и столбцов. Таблица задает отношение (relation).</p>
<p>Строка — запись, состоящая из полей — столбцов. В каждом поле может содержаться некоторое значение, либо специальное значение NULL (пусто). В таблице может быть произвольное количество строк. Для реляционной модели порядок расположения строк не определен и не важен.</p>
<p>Каждый столбец в таблице имеет собственное имя и тип.</p>
<p>Что такое DB–API 2</p>
<p>Вынесенная в заголовок аббревиатура объединяет два понятия: DB (Database, база данных) и API (Application Program Interface, интерфейс прикладной программы).</p>
<p>Таким образом, DB–API определяет интерфейс прикладной программы с базой данных. Этот интерфейс, описываемый ниже, должен реализовывать все модули расширения, которые служат для связи Python–программ с базами данных. Единый API (в настоящий момент его вторая версия) позволяет абстрагироваться от марки используемой базы данных, при необходимости довольно легко менять одну СУБД на другую, изучив всего один набор функций и методов.</p>
<p>DB–API 2.0 описан в PEP 249 (сайт http://www.python.org/peps/pep–0249.html/), и данное ниже описание основано именно на нем.</p>
<p>Описание DB API 2.0</p>
<p>DB API 2.0 регламентирует интерфейсы модуля расширения для работы с базой данных, методы объекта–соединения с базой, объекта–курсора текущей обрабатываемой записи, объектов различных для типов данных и их конструкторов, а также содержит рекомендации для разработчиков по реализации модулей. На сегодня Python поддерживает через модули расширения многие известные базы данных (уточнить можно на web–странице по адресу http://www.python.org/topics/database/). Ниже рассматриваются почти все положения DB–API за исключением рекомендаций для разработчиков новых модулей.</p>
<p>Интерфейс модуля</p>
<p>Здесь необходимо сказать о том, что должен предоставлять модуль для удовлетворения требований DB–API 2.0.</p>
<p>Доступ к базе данных осуществляется с помощью объекта–соединения (connection object). DB–API–совместимый модуль должен предоставлять функцию–конструктор connect() для класса объектов–соединений. Конструктор должен иметь следующие именованные параметры:</p>
<p>dsn Название источника данных в виде строки</p>
<p>user Имя пользователя</p>
<p>password Пароль</p>
<p>host Адрес хоста, на котором работает СУБД</p>
<p>database Имя базы данных.</p>
<p>Методы объекта–соединения будут рассмотрены чуть позже.</p>
<p>Модуль определяет константы, содержащие его основные характеристики:</p>
<p>apilevel Версия DB–API («1.0» или «2.0»).</p>
<p>threadsafety Целочисленная константа, описывающая возможности модуля при использовании потоков управления:</p>
<p>0 Модуль не поддерживает потоки.</p>
<p>1 Потоки могут совместно использовать модуль, но не соединения.</p>
<p>2 Потоки могут совместно использовать модуль и соединения.</p>
<p>3 Потоки могут совместно использовать модуль, соединения и курсоры. (Под совместным использованием здесь понимается возможность использования упомянутых ресурсов без применения семафоров).</p>
<p>paramstyle Тип используемых пометок при подстановке параметров. Возможны следующие значения этой константы:</p>
<p>«format» Форматирование в стиле языка ANSI C (например, "%s», "%i»).</p>
<p>«pyformat» Использование именованных спецификаторов формата в стиле Python ("%(item)s»)</p>
<p>«qmark» Использование знаков "?» для пометки мест подстановки параметров.</p>
<p>«numeric» Использование номеров позиций (":1»).</p>
<p>«named» Использование имен подставляемых параметров (":name»).</p>
<p>Модуль должен определять ряд исключений для обозначения типичных исключительных ситуаций: Warning (предупреждение), Error (ошибка), InterfaceError (ошибка интерфейса), DatabaseError (ошибка, относящаяся к базе данных). А также подклассы этого последнего исключения: DataError (ошибка обработки данных), OperationalError (ошибка в работе или сбой соединения с базой данных), IntegrityError (ошибка целостности базы данных), InternalError (внутренняя ошибка базы данных), ProgrammingError (программная ошибка, например, ошибка в синтаксисе SQL–запроса), NotSupportedError (при отсутствии поддержки запрошенного свойства).</p>
<p>Объект–соединение</p>
<p>Объект–соединение, получаемый в результате успешного вызова функции connect(), должен иметь следующие методы:</p>
<p>close() Закрывает соединение с базой данных.</p>
<p>commit() Завершает транзакцию.</p>
<p>rollback() Откатывает начатую транзакцию (восстанавливает исходное состояние). Закрытие соединения при незавершенной транзакции автоматически производит откат транзакции.</p>
<p>cursor() Возвращает объект–курсор, использующий данное соединение. Если база данных не поддерживает курсоры, модуль сопряжения должен их имитировать.</p>
<p>Под транзакцией понимается группа из одной или нескольких операций, которые изменяют базу данных. Транзакция соответствует логически неделимой операции над базой данных, а частичное выполнение транзакции приводит к нарушению целостности БД. Например, при переводе денег с одного счета на другой операции по уменьшению первого счета и увеличению второго являются транзакцией. Методы commit() и rollback() обозначают начало и конец транзакции в явном виде. Кстати, не все базы данных поддерживают механизм транзакций.</p>
<p>Следует отметить, что в зависимости от реализации DB–API 2.0 модуля, необходимо сохранять ссылку на объект–соединение в продолжение работы курсоров этого соединения. В частности, это означает, что нельзя сразу же получать объект–курсор, не привязывая объект–соединение к некоторому имени. Также нельзя оставлять объект–соединение в локальной переменной, возвращая из функции или метода объект–курсор.</p>
<p>Объект–курсор</p>
<p>Курсор (от англ. cursor — CURrrent Set Of Records, текущий набор записей) служит для работы с результатом запроса. Результатом запроса обычно является одна или несколько прямоугольных таблиц со столбцами–полями и строками–записями. Приложение может читать и обрабатывать полученные таблицы и записи в таблице по одной, поэтому в курсоре хранится информация о текущей таблице и записи. Конкретный курсор в любой момент времени связан с выполнением одной SQL–инструкции.</p>
<p>Атрибуты объекта–курсора тоже определены DB–API:</p>
<p>arraysize Атрибут, равный количеству записей, возвращаемых методом fetchmany(). По умолчанию равен 1.</p>
<p>callproc(procname[, params]) Вызывает хранимую процедуру procname с параметрами из изменчивой последовательности params. Хранимая процедура может изменить значения некоторых параметров последовательности. Метод может возвратить результат, доступ к которому осуществляется через fetch–методы.</p>
<p>close() Закрывает объект–курсор.</p>
<p>description Этот доступный только для чтения атрибут является последовательностью из семиэлементных последовательностей. Каждая из этих последовательностей содержит информацию, описывающую один столбец результата:</p>
<p>(name, type_code, display_size, internal_size, precision, scale, null_ok) Первые два элемента (имя и тип) обязательны, а вместо остальных (размер для вывода, внутренний размер, точность, масштаб, возможность задания пустого значения) может быть значение None. Этот атрибут может быть равным None для операций, не возвращающих значения.</p>
<p>execute(operation[, parameters]) Исполняет запрос к базе данных или команду СУБД. Параметры (parameters) могут быть представлены в принятой в базе данных нотации в соответствии с атрибутом paramstyle, описанным выше.</p>
<p>executemany(operation, seq_of_parameters) Выполняет серию запросов или команд, подставляя параметры в заданный шаблон. Параметр seq_of_parameters задает последовательность наборов параметров.</p>
<p>fetchall() Возвращает все (или все оставшиеся) записи результата запроса.</p>
<p>fetchmany([size]) Возвращает следующие несколько записей из результатов запроса в виде последовательности последовательностей. Пустая последовательность означает отсутствие данных. Необязательный параметр size указывает количество возвращаемых записей (реально возвращаемых записей может быть меньше). По умолчанию size равен атрибуту arraysize объекта–курсора.</p>
<p>fetchone() Возвращает следующую запись (в виде последовательности) из результата запроса или None при отсутствии данных.</p>
<p>nextset() Переводит курсор к началу следующего набора данных, полученного в результате запроса (при этом часть записей в предыдущем наборе может остаться непрочитанной). Если наборов больше нет, возвращает None. Не все базы данных поддерживают возврат нескольких наборов результатов за одну операцию.</p>
<p>rowcount Количество записей, полученных или затронутых в результате выполнения последнего запроса. В случае отсутствия execute–запросов или невозможности указать количество записей равен–1.</p>
<p>setinputsizes(sizes) Предопределяет области памяти для параметров, используемых в операциях. Аргумент sizes задает последовательность, где каждый элемент соответствует одному входному параметру. Элемент может быть объектом–типом соответствующего параметра или целым числом, задающим длину строки. Он также может иметь значение None, если о размере входного параметра ничего нельзя сказать заранее или он предполагается очень большим. Метод должен быть вызван до execute–методов.</p>
<p>setoutputsize(size[, column]) Устанавливает размер буфера для выходного параметра из столбца с номером column. Если column не задан, метод устанавливает размер для всех больших выходных параметров. Может использоваться, например, для получения больших бинарных объектов (Binary Large Object, BLOB).</p>
<p>Объекты–типы</p>
<p>DB–API 2.0 предусматривает названия для объектов–типов, используемых для описания полей базы данных:</p>
<p>Объект Тип</p>
<p>STRING Строка и символ</p>
<p>BINARY Бинарный объект</p>
<p>NUMBER Число</p>
<p>DATETIME Дата и время</p>
<p>ROWID Идентификатор записи</p>
<p>None NULL–значение (отсутствующее значение)</p>
<p>С каждым типом данных (в реальности это — классы) связан конструктор. Совместимый с DB–API модуль должен определять следующие конструкторы:</p>
<p>Date(год, месяц, день) Дата.</p>
<p>Time(час, минута, секунда) Время.</p>
<p>Timestamp(год, месяц, день, час, минута, секунда) Дата–время.</p>
<p>DateFromTicks(secs) Дата в виде числа секунд secs от начала эпохи (1 января 1970 года).</p>
<p>TimeFromTicks(secs) Время, то же.</p>
<p>TimestampFromTicks(secs) Дата–время, то же.</p>
<p>Binary(string) Большой бинарный объект на основании строки string.</p>
<p>Работа с базой данных из Python–приложения</p>
<p>Далее в лекции на конкретных примерах будет показано, как работать с базой данных из программы на языке Python. Нужно отметить, что здесь не ставится цели постичь премудрости языка запросов (это тема отдельного курса). Простые примеры позволят понять, что при программировании на Python доступ к базе данных не сложнее доступа к другим источникам данных (файлам, сетевым объектам).</p>
<p>Именно поэтому для демонстрации выбрана СУБД SQLite, работающая как под Unix, так и под Windows. Кроме установки собственно SQLite (сайт http://sqlite.org) и модуля сопряжения с Python (http://pysqlite.org), каких–либо дополнительных настроек проводить не требуется, так как SQLite хранит данные базы в отдельном файле: сразу приступать к созданию таблиц, занесению в них данных и произведению запросов нельзя. Выбранная СУБД (в силу своей «легкости») имеет одну существенную особенность: за одним небольшим исключением, СУБД SQLite не обращает внимания на типы данных (она хранит все данные в виде строк), поэтому модуль расширения sqlite для Python проделывает дополнительную работу по преобразованию типов. Кроме того, СУБД SQLite поддерживает достаточно большое подмножество свойств стандарта SQL92, оставаясь при этом небольшой и быстрой, что немаловажно, например, для web–приложений. Достаточно сказать, что SQLite поддерживает даже транзакции.</p>
<p>Еще раз стоит повторить, что выбор учебной базы данных не влияет на синтаксис использованных средств, так как модуль sqlite, который будет использоваться, поддерживает DB–API 2.0, а значит, переход на любую другую СУБД потребует минимальных изменений в вызове функции connect() и, возможно, использования более удачных типов данных, свойственных целевой СУБД.</p>
<p>Схематично работа с базой данных может выглядеть примерно так:</p>
<p>Подключение к базе данных (вызов connect() с получением объекта–соединения).</p>
<p>Создание одного или нескольких курсоров (вызов метода объекта–соединения cursor() с получением объекта–курсора).</p>
<p>Исполнение команды или запроса (вызов метода execute() или его вариантов).</p>
<p>Получение результатов запроса (вызов метода fetchone() или его вариантов).</p>
<p>Завершение транзакции или ее откат (вызов метода объекта–соединения commit() или rollback()).</p>
<p>Когда все необходимые транзакции произведены, подключение закрывается вызовом метода close() объекта–соединения.</p>
<p>Знакомство с СУБД</p>
<p>Допустим, программное обеспечение установлено правильно, и можно работать с модулем sqlite. Стоит посмотреть, чему будут равны константы:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import sqlite</p>
<p>&gt;&gt;&gt; sqlite.apilevel</p>
<p>'2.0'</p>
<p>&gt;&gt;&gt; sqlite.paramstyle</p>
<p>'pyformat'</p>
<p>&gt;&gt;&gt; sqlite.threadsafety</p>
<p>1</p>
<p>Отсюда следует, что sqlite поддерживает DB–API 2.0, подстановка параметров выполняется в стиле строки форматирования языка Python, а соединения нельзя совместно использовать из различных потоков управления (без блокировок).</p>
<p>Создание базы данных</p>
<p>Для создания базы данных нужно установить, какие таблицы (и другие объекты, например индексы) в ней будут храниться, а также определить структуры таблиц (имена и типы полей).</p>
<p>Задача — создание базы данных, в которой будет храниться телепрограмма. В этой базе будет таблица со следующими полями:</p>
<p>tvdate,</p>
<p>tvweekday,</p>
<p>tvchannel,</p>
<p>tvtime1,</p>
<p>tvtime2,</p>
<p>prname,</p>
<p>prgenre.</p>
<p>Здесь tvdate — дата, tvchannel — канал, tvtime1 и tvtime2 — время начала и конца передачи, prname — название, prgenre — жанр. Конечно, в этой таблице есть функциональная зависимость (tvweekday вычисляется на основе tvdate и tvtime1), но из практических соображений БД к нормальным формам приводиться не будет. Кроме того, таблица будет создана с названиями дней недели (устанавливает соответствие между номером дня и днем недели):</p>
<p>weekday,</p>
<p>wdname.</p>
<p>Следующий сценарий создаст таблицу в базе данных (в случае с SQLite заботиться о создании базы данных не нужно: файл создастся автоматически. Для других баз данных необходимо перед этим создать базу данных, например, SQL–инструкцией CREATE DATABASE):</p>
<p>Листинг</p>
<p>import sqlite as db</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>try:</p>
<p>cu.execute("""</p>
<p>CREATE TABLE tv (</p>
<p>tvdate DATE,</p>
<p>tvweekday INTEGER,</p>
<p>tvchannel VARCHAR(30),</p>
<p>tvtime1 TIME,</p>
<p>tvtime2 TIME,</p>
<p>prname VARCHAR(150),</p>
<p>prgenre VARCHAR(40)</p>
<p>);</p>
<p>«"")</p>
<p>except db.DatabaseError, x:</p>
<p>print «Ошибка: ", x</p>
<p>c.commit()</p>
<p>try:</p>
<p>cu.execute("""</p>
<p>CREATE TABLE wd (</p>
<p>weekday INTEGER,</p>
<p>wdname VARCHAR(11)</p>
<p>);</p>
<p>«"")</p>
<p>except db.DatabaseError, x:</p>
<p>print «Ошибка: ", x</p>
<p>c.commit()</p>
<p>c.close()</p>
<p>Здесь просто исполняются SQL–инструкции, и обрабатывается ошибка базы данных, если таковая случится (например, при попытке создать таблицу с уже существующим именем). Для того чтобы таблицы создавались независимо, используется commit().</p>
<p>Кстати, удалить таблицы из базы данных можно следующим образом:</p>
<p>Листинг</p>
<p>import sqlite as db</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>try:</p>
<p>cu.execute(""«DROP TABLE tv;""")</p>
<p>except db.DatabaseError, x:</p>
<p>print «Ошибка: ", x</p>
<p>c.commit()</p>
<p>try:</p>
<p>cu.execute(""«DROP TABLE wd;""")</p>
<p>except db.DatabaseError, x:</p>
<p>print «Ошибка: ", x</p>
<p>c.commit()</p>
<p>c.close()</p>
<p>Наполнение базы данных</p>
<p>Теперь можно наполнить таблицы значениями. Следует начать с расшифровки числовых значений для дней недели:</p>
<p>Листинг</p>
<p>weekdays = [«Воскресенье», «Понедельник», «Вторник», «Среда»,</p>
<p>«Четверг», «Пятница», «Суббота», «Воскресенье»]</p>
<p>import sqlite as db</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>cu.execute(""«DELETE FROM wd;""")</p>
<p>cu.executemany(""«INSERT INTO wd VALUES (%s, %s);""",</p>
<p>enumerate(weekdays))</p>
<p>c.commit()</p>
<p>c.close()</p>
<p>Стоит напомнить, что встроенная функция enumerate() создает список пар номер–значение, например:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print [i for i in enumerate(['a', 'b', 'c'])]</p>
<p>[(0, 'a'), (1, 'b'), (2, 'c')]</p>
<p>Из приведенного примера ясно, что метод executemany() объекта–курсора использует второй параметр — последовательность — для массового ввода данных с помощью SQL–инструкции INSERT.</p>
<p>Предположим, что телепрограмма задана в файле tv.csv в формате CSV (он уже обсуждался):</p>
<p>Листинг</p>
<p>10.02.2003 9.00|ОРТ|Новости|Новости|9.15</p>
<p>10.02.2003 9.15|ОРТ|«НЕЖНЫЙ ЯД»|Сериал|10.15</p>
<p>10.02.2003 10.15|ОРТ|«Маски–шоу»|Юмористическая программа|10.45</p>
<p>10.02.2003 10.45|ОРТ|«Человек и закон»||11.30</p>
<p>10.02.2003 11.30|ОРТ|«НОВЫЕ ПРИКЛЮЧЕНИЯ СИНДБАДА»|Сериал|12.00</p>
<p>Следующая программа разбирает CSV–файл и записывает данные в таблицу tv:</p>
<p>Листинг</p>
<p>import calendar, csv</p>
<p>import sqlite as db</p>
<p>from sqlite.main import Time, Date ## Только для</p>
<p>db.Date, db.Time = Date, Time ## sqlite</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>input_file = open(«tv.csv», «rb»)</p>
<p>rdr = csv.DictReader(input_file,</p>
<p>fieldnames=['begt', 'channel', 'prname', 'prgenre', 'endt'])</p>
<p>for rec in rdr:</p>
<p>bd, bt = rec['begt'].split()</p>
<p>bdd, bdm, bdy = map(int, bd.split('.'))</p>
<p>bth, btm = map(int, bt.split('.'))</p>
<p>eth, etm = map(int, rec['endt'].split('.'))</p>
<p>rec['wd'] = calendar.weekday(bdy, bdm, bdd)</p>
<p>rec['begd'] = db.Date(bdy, bdm, bdd)</p>
<p>rec['begt'] = db.Time(bth, btm, 0)</p>
<p>rec['endt'] = db.Time(eth, etm, 0)</p>
<p>cu.execute(""«INSERT INTO tv</p>
<p>(tvdate, tvweekday, tvchannel, tvtime1, tvtime2, prname, prgenre)</p>
<p>VALUES (</p>
<p>%(begd)s, %(wd)s, %(channel)s, %(begt)s, %(endt)s,</p>
<p>%(prname)s, %(prgenre)s);""", rec)</p>
<p>input_file.close()</p>
<p>c.commit()</p>
<p>Большая часть преобразований связана с получением дат и времен (приходится разбивать строки на части в соответствии с форматом даты и времени). День недели получен с помощью функции из модуля calendar.</p>
<p>Примечание:</p>
<p>Из–за небольшой ошибки в пакете sqlite конструкторы Date, Time и т.д. не попадают из модуля sqlite.main при импорте из sqlite, поэтому пришлось добавить две строки, специфичные для sqlite, в универсальный «модуль» с именем db.</p>
<p>В этом же примере было продемонстрировано использование словаря для вставки значений в таблицу базы данных. Следует заметить, что подстановка выполняется внутри вызова execute() в соответствии с типами переданных значений. SQL–инструкция INSERT была бы некорректной при попытке выполнить подстановку самостоятельно, например, операцией форматирования %.</p>
<p>Выборки из базы данных</p>
<p>Базы данных создаются для удобства хранения и извлечения больших объемов. Следующий нехитрый пример позволяет проверить, правильно ли были введены в таблицу дни недели:</p>
<p>Листинг</p>
<p>import sqlite as db</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>cu.execute(«SELECT weekday, wdname FROM wd ORDER BY weekday;")</p>
<p>for i, n in cu.fetchall():</p>
<p>print i, n</p>
<p>Если все было сделано правильно, получится:</p>
<p>Листинг</p>
<p>0 Воскресенье</p>
<p>1 Понедельник</p>
<p>2 Вторник</p>
<p>3 Среда</p>
<p>4 Четверг</p>
<p>5 Пятница</p>
<p>6 Суббота</p>
<p>7 Воскресенье</p>
<p>Несложно догадаться, как сделать выборку телепрограммы:</p>
<p>Листинг</p>
<p>import sqlite as db</p>
<p>c = db.connect(database=«tvprogram»)</p>
<p>cu = c.cursor()</p>
<p>cu.execute("""</p>
<p>SELECT tvdate, tvtime1, wd.wdname, tvchannel, prname, prgenre</p>
<p>FROM tv, wd</p>
<p>WHERE wd.weekday = tvweekday</p>
<p>ORDER BY tvdate, tvtime1;""")</p>
<p>for rec in cu.fetchall():</p>
<p>dt = rec[0] + rec[1]</p>
<p>weekday = rec[2]</p>
<p>channel = rec[3]</p>
<p>name = rec[4]</p>
<p>genre = rec[5]</p>
<p>print "%s, %02i.%02i.%04i %s %02i:%02i %s (%s)» % (</p>
<p>weekday, dt.day, dt.month, dt.year, channel,</p>
<p>dt.hour, dt.minute, name, genre)</p>
<p>В этом примере в качестве типа для даты и времени используется тип из mx.DateTime. Именно поэтому стало возможным получить год, месяц, день, час и минуту обращением к атрибуту. Кстати, datetime–объект стандартного модуля datetime имеет те же атрибуты. В общем случае для даты и времени может использоваться другой тип, поэтому если получаемые из базы даты будут проходить более глубокую обработку, их следует переводить во внутреннее представление сразу после получения по запросу. Тем самым тип даты из модуля DB–API не будет влиять на другие части программы.</p>
<p>Другие СУБД и Python</p>
<p>Модуль sqlite дает прекрасные возможности для построения небольших и быстрых баз данных, однако для полноты изложения предлагается обзор модулей расширения Python для других СУБД.</p>
<p>Выше везде импортировался модуль sqlite, с изменением его имени на db. Это было сделано не случайно. Дело в том, что подобные модули, поддерживающие DB–API 2.0, есть и для других СУБД, и даже не в единственном числе. Согласно информации на сайте www.python.org DB–API 2.0–совместимые модули для Python имеют следующие СУБД или протоколы доступа к БД:</p>
<p>zxJDBC Доступ по JDBC.</p>
<p>MySQL Для СУБД MySQL.</p>
<p>mxODBC Доступ по ODBC, продается фирмой eGenix (http://www.egenix.com).</p>
<p>DCOracle2, cx_Oracle Для СУБД Oracle.</p>
<p>PyGresQL, psycopg, pyPgSQL Для СУБД PostgreSQL.</p>
<p>Sybase Для Sybase.</p>
<p>sapdbapi Для СУБД SAP.</p>
<p>KInterbasDB Для СУБД Firebird (это потомок Interbase).</p>
<p>PyADO Адаптер к Microsoft ActiveX Data Objects (только под Windows).</p>
<p>Примечание:</p>
<p>Для СУБД PostgreSQL нужно взять не PyGreSQL, а psycopg, так как в первом есть небольшие проблемы с типом для даты и времени при вставке параметров в методе execute(). Кроме того, psycopg оптимизирован для скорости и многопоточности (psycopg.threadsafety=2).</p>
<p>Таким образом, в примерах, используемых в этой лекции, вместо sqlite можно применять, например, psycopg: результат должен быть тем же, если, конечно, соответствующий модуль был установлен.</p>
<p>Однако в общем случае при переходе с одной СУБД на другую могут возникать нестыковки, даже, несмотря на поддержку одной версии DB–API. Например, у модулей могут различаться paramstyle. В этом случае придется немного переделать параметры к вызову execute(). Могут быть и другие причины, поэтому переход на другую СУБД следует тщательно тестировать.</p>
<p>Иметь интерфейс DB–API могут не только базы данных. Например, разработчики проекта fssdb стремятся построить DB–API 2.0 интерфейс к… файловой системе.</p>
<p>Несмотря на достаточно хорошие теоретические основы и стабильные реализации, реляционная модель — не единственная из успешно используемых сегодня. К примеру, уже рассматривался язык XML и интерфейсы для работы с ним в Python. Древовидная модель данных XML для многих задач является более естественной, и в настоящее время идут исследования, результаты которых позволят работать с XML так же легко и стабильно, как с реляционными СУБД. Язык программирования Python — один из полигонов этих исследований.</p>
<p>Решая конкретную задачу, разработчик программного обеспечения должен сделать выбор средств, наиболее подходящих для решения задачи. Очень многие подходят к этому выбору с предвзятостью, выбирая неоптимальную (для данной задачи или подзадачи) модель данных. В результате данные, которые по своей природе легче представить другой моделью, приходится хранить и обрабатывать в выбранной модели, зачастую невольно моделируя более естественные структуры доступа и хранения. Так, XML можно хранить в реляционной БД, а табличные данные — в XML, однако это неестественно. Из–за этого сложность и подверженность ошибкам программного продукта возрастают, даже если использованные инструменты высокого качества.</p>
<p>Заключение</p>
<p>В рамках данной лекции были рассмотрены возможности связи Python с системами управления реляционными базами данных. Для Python разработан стандарт, называемый DB–API (версия 2.0), которого должны придерживаться все разработчики модулей сопряжения с реляционными базами данных. Благодаря этому API код прикладной программы становится менее зависимым от марки используемой базы данных, его могут понять разработчики, использующие другие базы данных. Фактически DB–API 2.0 описывает имена функций и классов, которые должен содержать модуль сопряжения с базой данных, и их семантику. Модуль сопряжения должен содержать класс объектов–соединений с базой данных и класс для курсоров — специальных объектов, через которые происходит коммуникация с СУБД на прикладном уровне.</p>
<p>Здесь была использована СУБД SQLite и соответствующий модуль расширения Python для сопряжения с этой СУБД — sqlite, так как он поддерживает DB–API 2.0 и достаточно прост в установке. С его помощью были продемонстрированы основные приемы работы с базой данных: создание и наполнение таблиц, выполнение выборок и анализ полученных данных.</p>
<p>В конце лекции дан список других пакетов и модулей, которые позволяют Python–программе работать со многими современными СУБД.</p>
<center><div align="center"></div></center>





