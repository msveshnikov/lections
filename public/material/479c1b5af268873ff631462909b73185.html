# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 5. Имена. Пакеты</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции рассматриваются две темы — система
именования эле­ментов языка в Java и пакеты (packages), которые являются аналогами библи­отек из других
языков. Почти все конструкции в Java имеют имя для обраще­ния к ним из других частей
программы. По ходу изложения вводятся важные понятия, в частности - область
видимости имени. При перекрытии таких об­ластей возникает конфликт имен. Для
того, чтобы минимизировать риск воз­никновения подобных ситуаций, описываются
соглашения по именованию, предложенные компанией Sun.

</p>
<p>Пакеты осуществляют физическую и логическую группировку
классов и становятся необходимыми при создании больших систем. Вводится важное
понятие модуля компиляции и описывается его структура.

</p>
<p> 

</p>
<p>Ключевые слова: простые имена, составные имена, элементы, тип, область видимости,
пакеты, модуль компиляции.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Имена (names) используются в программе для доступа к объяв­ленным (declared) ранее
"объектам", "элементам", "конструкциям" языка
(все эти слова-синонимы были использованы здесь в их общем смысле, а не как термины
ООП, например). Конкретнее, в Java имеют­ся имена:

</p>
<p>•   
пакеты;

</p>
<p>•   
классы;

</p>
<p>•   
интерфейсы;

</p>
<p>•   
элементы (member) ссылочных типов:

</p>
<p> 

</p>
<p>-   
поля;

</p>
<p>-   
методы;

</p>
<p>-   
внутренние классы и
интерфейсы;

</p>
<p>•  аргументы:

</p>
<p>-   
методов;

</p>
<p>-   
конструкторов;

</p>
<p>-   
обработчиков ошибок;

</p>
<p>•  локальные переменные.

</p>
<p>Соответственно, все они должны быть объявлены
специальным об­разом, что будет постепенно рассматриваться по ходу курса. Так
же объ­являются конструкторы, однако их имя совпадает с именем класса, по­этому
они не попали в этот список.








</p>
<p>Напомним, что пакеты (packages) в Java — это способ
логически груп­пировать классы, что необходимо, поскольку зачастую количество
классов в системе составляет несколько тысяч, или даже десятков тысяч. Кроме
классов и интерфейсов в пакетах, могут находиться вложенные пакеты. Синонимами
этого слова в других языках являются библиотека или модуль.

</p>
<p> 

</p>
<p>Имена

</p>
<p> 

</p>
<p>Простые
и составные имена. Элементы

</p>
<p>Имена бывают простыми (simple), состоящими из одного идентифика­тора (они определяются во время
объявления) и составными (qualified), со­стоящими из последовательности идентификаторов, разделенных
точкой. Для пояснения этих терминов необходимо рассмотреть еще одно понятие.

</p>
<p>У пакетов и ссылочных типов (классов, интерфейсов, массивов) есть
элементы (members)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Доступ к элементам осуществляется с помощью выра­жения, состоящего из
имен, например, пакета и класса, разделенных точкой.

</p>
<p>Далее классы и интерфейсы будут называться объединяющим тер­мином тип (type).

</p>
<p>Элементами пакета являются содержащиеся в нем классы и интер­фейсы, а
также вложенные пакеты. Чтобы получить составное имя паке­та, необходимо к
полному имени пакета, в котором он располагается, до­бавить точку, а затем его
собственное простое имя. Например, составное имя основного пакета языка Java - java.lang (то есть простое имя этого пакета lang, и он находится в
объемлющем пакете java). Внутри него есть вложенный пакет, предназначенный для типов технологии reflection, ко­торая упоминалась в предыдущих главах. Простое название пакета reflect, а значит,
составное - java.lang.reflect.

</p>
<p>Простое имя классов и интерфейсов дается при объявлении, напри­мер, Object, String, Point. Чтобы получить
составное имя таких типов, на­до к составному имени пакета, в котором находится
тип, через точку добавить простое имя типа. Например, java.lang.Object, java.lang.reflect.Method или com.myfirm.MainClass. Смысл последнего выражения таков: сначала идет обращение к пакету com, затем к его эле­менту
- вложенному пакету myfirm, а затем к элементу пакета myfirm -классу MainClass. Здесь com.myfirm - составное имя
пакета, где лежит класс MainClass, a MainClass — простое имя этого
класса. Составляем их и разделяем точкой - получается полное имя класса com.myfirm.MainClass.

</p>
<p>Для ссылочных типов элементами являются поля и методы, а также
внутренние типы (классы и интерфейсы). Элементы могут быть как непо­средственно
объявлены в классе, так и получены по наследству от роди-

</p>
<p>150

</p>
<p>тельских классов и
интерфейсов, если таковые имеются. Простое имя элементов также дается при
инициализации. Например, toString(),
PI, InnerClass. Составное имя получается
путем объединения простого или составного имени типа, или переменной объектного
типа с именем элемента. Например, ref.toStringO, java.lang.Math.PI, OuterClass. InnerClass. Другие обращения к элементам ссылочных типов уже неоднократно
применялись в предыдущих главах.

</p>
<p> 

</p>
<p>Имена
и идентификаторы

</p>
<p>Теперь, когда мы рассмотрели простые и составные имена, уточним раз­ницу
между идентификатором (напомним, что это вид лексемы) и именем
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Понятно, что
простое имя состоит из одного идентификатора, а составное -из нескольких.
Однако не всякий идентификатор входит в состав имени.

</p>
<p>Во-первых, в выражении объявления (declaration) идентификатор еще не является именем. Другими словами, он становится
именем после первого появления в коде в месте объявления.

</p>
<p>Во-вторых, существует возможность обращаться к полям и методам
объектного типа не через имя типа или объектной переменной, а через ссылку на
объект, полученную в результате выполнения выражения. При­мер такого случая уже
приводился в одной из предыдущих глав:

</p>
<p>country.getCity().getStreet();

</p>
<p>В данном примере getStreet является не именем,
а идентификато­ром, так как соответствующий метод вызывается у объекта,
полученного в результате вызова метода getCity(). Причем country.getCity как раз яв­ляется
составным именем метода.

</p>
<p>Наконец, идентификаторы также используются для названий меток (label). Эта конструкция
рассматривается позже, однако приведем при­мер, показывающий, что пространства
имен и названий меток полностью разделены.

</p>
<p>num:

</p>
<p>for (int num = 2; num &lt;= 100; num++) { int n = (int)Math.sqrt(num)+1 ; while (-n != 0) { if (num%n==0) { continue num;

</p>
<p>}

</p>
<p>}

</p>
<p>System.out.print(num+" ");

</p>
<p>}








</p>
<p>Результатом будут простые
числа меньше 100:

</p>
<p> 

</p>
<p>2357 11 13171923 2931 37
41 43 47 53 5961 6771 73 79 83 89 97

</p>
<p> 

</p>
<p>Мы видим, что здесь применяются одноименные переменная и метка num, причем последняя
используется для выхода из внутреннего цикла while на внешний for.

</p>
<p>Очевидно, что удобнее использовать простое имя, а не составное, т.к. оно
короче и его легче запомнить. Однако понятно, что если в системе есть очень
много классов со множеством переменных, можно столкнуться с ситуацией, когда в
разных классах есть одноименные переменные или методы. Для решения этой и
других подобных проблем вводится новое по­нятие — область видимости.

</p>
<p> 

</p>
<p>Область
видимости (введение)

</p>
<p>Чтобы не заставлять программистов, совместно работающих над различными
классами одной системы, координировать имена, которые они дают различным
конструкциям языка, у каждого имени есть область видимости (scope). Если обращение,
например, к полю, идет из части ко­да, попадающей в область видимости его
имени, то можно пользоваться простым именем, если нет - необходимо применять
составное.

</p>
<p>Например:

</p>
<p> 

</p>
<p>class Point { int х,у;

</p>
<p>int getX() {

</p>
<p>return x; // простое имя

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>}

</p>
<p>class Test { void main() {

</p>
<p>Point p = new
Point(); p.x=3; // составное имя

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Видно, что к полю х изнутри класса можно обращаться по простому имени. К
нему же из другого класса можно обратиться только по состав­ному имени. Оно
составляется из имени переменной, ссылающейся на объект, и имени ПОЛЯ.

</p>
<p>Теперь необходимо рассмотреть области видимости для всех элемен­тов
языка. Однако прежде выясним, что такое пакеты, как и для чего они
используются.

</p>
<p> 

</p>
<p>Пакеты

</p>
<p>Программа на Java представляет собой
набор пакетов (packages). Каждый пакет может включать вложенные пакеты, то есть они образуют
иерархическую систему.

</p>
<p>Кроме того, пакеты могут содержать классы и интерфейсы и таким образом
группируют типы. Это необходимо сразу для нескольких целей. Во-первых, чисто
физически невозможно работать с большим количест­вом классов, если они
"свалены в кучу". Во-вторых, модульная декомпо­зиция облегчает
проектирование системы. К тому же, как будет показано ниже, существует
специальный уровень доступа, позволяющий типам из одного пакета более тесно
взаимодействовать друг с другом, чем с класса­ми из других пакетов. Таким
образом, с помощью пакетов производится логическая группировка типов. Из ООП
известно, что большая связность системы, то есть среднее количество классов, с
которыми взаимодейству­ет каждый класс, заметно усложняет развитие и поддержку
такой систе­мы. Используя пакеты, гораздо проще организовать эффективное взаи­модействие
подсистем друг с другом.

</p>
<p>Наконец, каждый пакет имеет свое пространство имен, что позво­ляет
создавать одноименные классы в различных пакетах. Таким обра­зом, разработчикам
не приходится тратить время на разрешение кон­фликта имен.

</p>
<p> 

</p>
<p>Элементы
пакета

</p>
<p>Еще раз повторим, что элементами пакета являются вложенные пакеты и типы
(классы и интерфейсы). Одноименные элементы запре­щены, то есть не может быть одноименных
класса и интерфейса, или вложенного пакета и типа. В противном случае возникнет
ошибка Компиляции.

</p>
<p>Например, в JDK 1.0 пакет java содержал пакеты applet, awt, io, 'ang, net, util и не содержал ни
одного типа. В пакет java.awt входил вло­женный пакет
image и 46 классов и интерфейсов.

</p>
<p>Составное имя любого элемента пакета - это составное имя этого пакета
плюс простое имя элемента. Например, для класса Object в паке­те java.lang составным именем
будет java. lang.Object, а для пакета image в пакете java.awt - java.awt.image.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Иерархическая структура пакетов была введена для удобства органи­зации
связанных пакетов, однако вложенные пакеты, или соседние, то есть вложенные в
один и тот же пакет, не имеют никаких дополнительных связей между собой, кроме
ограничения на несовпадение имен. Напри­мер, пакеты space.sun, space.sun.ray, space.moon и factory.store со­вершенно
"равны" между собой и типы одного из этих пакетов не имеют никакого
особенного доступа к типам других пакетов.

</p>
<p> 

</p>
<p>Платформенная
поддержка пакетов

</p>
<p>Простейшим способом организации пакетов и типов является обыч­ная
файловая структура. Рассмотрим вырожденный пример, когда все па­кеты, исходный
и бинарный код располагаются в одном каталоге и его подкаталогах.

</p>
<p>В этом корневом каталоге должна быть папка java, соответствующая
основному пакету языка, а в ней, в свою очередь, вложенные папки applet, awt, io, lang, net, util.

</p>
<p>Предположим, разработчик работает над моделью солнечной систе­мы, для
чего создал классы Sun, Moon и Test и расположил их в пакете space.sunsystem. В таком случае в корневом каталоге должна быть пап­ка space, соответствующая
одноименному пакету, а в ней - папка sunsys­tem, в которой
хранятся классы этого разработчика.

</p>
<p>Как известно, исходный код располагается в файлах с расширением .java, а бинарный - с
расширением .class. Таким образом, содержимое папки sunsystem может выглядеть следующим образом:

</p>
<p>Moon.java Moon.class Su n. java Sun.class Test.java Test.class

</p>
<p> 

</p>
<p>Другими словами, исходный код классов

</p>
<p> 

</p>
<p>space.sunsystem.Moon space.sunsystem.Sun space.sunsystem.Test

</p>
<p> 

</p>
<p>хранится в файлах

</p>
<p> 

</p>
<p>space\sunsystem\Moon.java

</p>
<p>space\sunsystem\Sun.java

</p>
<p>space\sunsystem\Test.java а бинарный код — в соответствующих .class-файлах. Обратите
внимание, что преобразование имен пакетов в файловые пути потребовало замены разделителя
. (точки) на символ-разделитель файлов (для Windows это об­ратный слэш \). Такое преобразование может выполнить как
компилятор для поиска исходных текстов и бинарного кода, так и виртуальная маши­на
для загрузки классов и интерфейсов.

</p>
<p>Обратите внимание, что было бы ошибкой запускать Java прямо из папки space\sunsystem и пытаться
обращаться к классу Test, несмотря на то, что файл-описание лежит именно в ней. Необходимо
подняться на два уровня каталогов выше, чтобы Java, построив путь из
имени пакета, смогла обнаружить нужный файл.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Кроме того, немаловажно, что Java всегда различает регистр иденти­фикаторов, а значит, названия файлов и
каталогов должны точно отвечать запрограммированным именам. Хотя в некоторых
случаях операционная система может обеспечить доступ, невзирая на регистр, при
изменении обстоятельств расхождения могут привести к сбоям.

</p>
<p>Существует специальное выражение, объявляющее пакет (подробно
рассматривается ниже). Оно предшествует объявлению типа и обознача­ет, какому
пакету будет принадлежать этот тип. Таким образом, набор до­ступных пакетов
определяется набором доступных файлов, содержащих объявления типов и пакетов.
Например, если создать пустой каталог, или заполнить его посторонними файлами,
это отнюдь не приведет к появле­нию пакета в Java.

</p>
<p>Какие файлы доступны для утилит Java SDK (компилятора, интер­претатора и т.д.), устанавливается на уровне
операционной системы, ведь утилиты — это обычные программы, которые выполняются
под уп­равлением ОС и, конечно, следуют ее правилам. Например, если пакет
содержит один тип, но описывающий его файл недоступен текущему пользователю ОС
для чтения, для Java этот тип и этот
пакет не будут су­ществовать.

</p>
<p>Понятно, что далеко не всегда удобно хранить все файлы в одном каталоге.
Зачастую классы находятся в разных местах, а некоторые мо­гут даже
распространяться в виде архивов, для ускорения загрузки через сеть. Копировать
все такие файлы в одну папку было бы крайне затруд­нительно.

</p>
<p>Поэтому Java использует
специальную переменную окружения, кото-Рая называется classpath. Аналогично тому, как переменная path помогает системе находить и загружать динамические библиотеки, эта
переменная Помогает работать с Java-классами. Ее значение должно состоять из путей к каталогам или архивам,
разделенных точкой с запятой. С версии 1.1 поддер­живаются архивы типов ZIP и JAR (Java ARchive) - специальный формат, Разработанный на основе ZIP для Java.








</p>
<p>Например, переменная classpath может иметь такое
значение: .;c:\java\classes;d:\lib\3Dengine.zip;d:\lib\fire.jar

</p>
<p>В результате все указанные каталоги и содержимое всех архивов "до­бавляется"
к исходному корневому каталогу. Java в поисках класса
будет искать его по описанному выше правилу во всех указанных папках и ар­хивах
по порядку
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Обратите внимание, что первым в переменной указан текущий каталог
(представлен точкой). Это делается для того, чтобы по­иск всегда начинался с
исходного корневого каталога. Конечно, такая за­пись не является обязательной и
делается на усмотрение разработчика.

</p>
<p>Несмотря на явные удобства такой конструкции, она таит в себе и
опасности. Если разрабатываемые классы хранятся в некотором каталоге и он
указан в classpath позже, чем некий
другой каталог, в котором обнару­живаются одноименные типы, разобраться в такой
ситуации будет непро­сто. В классы будут вноситься изменения, которые никак не
проявляются при запуске из-за того, что Java на самом деле загружает одни и те же файлы из посторонней папки.

</p>
<p>Поэтому к данной переменной среды окружения необходимо отно­ситься с
особым вниманием. Полезно помнить, что необязательно уста­навливать ее значение
сразу для всей операционной системы. Его можно явно указывать при каждом
запуске компилятора или виртуальной маши­ны как опцию, что, во-первых, никогда
не повлияет на другие Java-про­граммы, а во-вторых, заметно упрощает поиск ошибок, связанных с не­корректным
значением classpath.

</p>
<p>Наконец, можно применять и альтернативные подходы к хранению пакетов и
файлов с исходным и бинарным кодом. Например, в качестве такого хранилища может
использоваться база данных. Более того, суще­ствует ограничение на размещение
объявлений классов в .java-файлах, которое рассматривается ниже, а при использовании БД любые
ограни­чения можно снять. Тем не менее, при таком подходе рекомендуется пре­доставлять
утилиты импорта/экспорта с учетом ограничения для преоб­разований из/в файлы.

</p>
<p> 

</p>
<p>Модуль
компиляции

</p>
<p>Модуль компиляции (complication unit) хранится в текстовом .java-файле и является единичной порцией входных данных для компилятора. Он
состоит из трех частей:

</p>
<p>•   
объявление пакета;

</p>
<p>•   
import-выражения;

</p>
<p>•   
объявления верхнего
уровня.

</p>
<p> 

</p>
<p>Объявление пакета одновременно указывает, какому пакету будут
принадлежать все объявляемые ниже типы. Если данное выражение от­сутствует,
значит, эти классы располагаются в безымянном пакете (другое название — пакет
по умолчанию).

</p>
<p>Import-выражения
позволяют обращаться к типам из других пакетов по их простым именам,
"импортировать" их. Эти выражения также необя­зательны.

</p>
<p>Наконец, объявления верхнего уровня содержат объявления од­ного или
нескольких типов
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Название "верхнего уровня" противопос­тавляет эти
классы и интерфейсы, располагающиеся в пакетах, внут­ренним типам, которые
являются элементами и располагаются внут­ри других типов. Как ни странно, эта
часть также является необяза­тельной, в том смысле, что в случае ее отсутствия
компилятор не вы­даст ошибки. Однако никаких .class-файлов
сгенерировано тоже не будет.

</p>
<p>Доступность модулей компиляции определяется поддержкой плат­формы, т.к.
утилиты Java являются обычными
программами, которые ис­полняются операционной системой по общим правилам.

</p>
<p>Рассмотрим все три части
более подробно.

</p>
<p> 

</p>
<p>Объявление пакета

</p>
<p>Первое выражение в модуле компиляции — объявление пакета. Оно
записывается с помощью ключевого слова package, после которого
ука­зывается полное имя пакета.

</p>
<p>Например, первой строкой (после комментариев) в файле java/lang/Object.java идет:

</p>
<p> 

</p>
<p>package java.lang;

</p>
<p>Это одновременно служит объявлением пакета lang, вложенного в пакет java, и указанием, что
объявляемый ниже класс Object находит­ся в данном
пакете. Так складывается полное имя класса java.lang.Object.

</p>
<p>Если это выражение отсутствует, то такой модуль компиляции принадлежит
безымянному пакету. Этот пакет по умолчанию обяза­тельно должен поддерживаться
реализацией Java-платформы. Обратите внимание, что он не может иметь вложенных пакетов,
так как состав­ное имя пакета должно обязательно начинаться с имени пакета
верхне­го уровня.

</p>
<p>Таким образом, самая простая программа может выглядеть следую­щим
образом:








</p>
<p>class Simple {

</p>
<p>public static void main(String s[]) { System.
out.printlnf'Hello!");

</p>
<p>}

</p>
<p>}

</p>
<p>Этот модуль компиляции
будет принадлежать безымянному пакету.

</p>
<p>Пакет по умолчанию был введен в Java для облегчения написания очень небольших или временных приложений, для
экспериментов. Если же программа будет распространяться для пользователей, то
рекоменду­ется расположить ее в пакете, который, в свою очередь, должен быть
пра­вильно назван. Соглашения по именованию рассматриваются ниже.

</p>
<p>Доступность пакета определяется по доступности модулей компиля­ции, в
которых он объявляется. Точнее, пакет доступен тогда и только тогда, когда
выполняется любое из следующих двух условий:

</p>
<p>•    
доступен модуль компиляции
с объявлением этого пакета;

</p>
<p>•    
доступен один из вложенных
пакетов этого пакета. Таким образом, для следующего кода:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>package
space.star;

</p>
<p>class Sun { }

</p>
<p>если файл, который хранит этот модуль компиляции, доступен Java-плат­форме, то
пакеты space и вложенный в него star (полное название space.star) также становятся доступны для Java.

</p>
<p>Если пакет доступен, то область видимости его объявления - все доступ­ные
модули компиляции. Проще говоря, все существующие пакеты доступ­ны для всех
классов, никаких ограничений на доступ к пакетам в Java нет.

</p>
<p>Требуется, чтобы пакеты java.lang и java.io, а значит, и java, всегда были доступны для Java-платформы, поскольку они содержат классы, не­обходимые для работы
любого приложения.

</p>
<p> 

</p>
<p>Импорт-выражения

</p>
<p>Как будет рассмотрено ниже, область видимости объявления типа -пакет, в
котором он располагается. Это означает, что внутри данного паке­та допускается
обращение к типу по его простому имени. Из всех других пакетов необходимо
обращаться по составному имени, то есть полное имя пакета плюс простое имя
типа, разделенные точкой. Поскольку пакеты могут иметь довольно длинные имена
(например, дополнительный пакет в составе JDK1.2 называется com.sun.image.codec.jpeg),
а тип может многократно
использоваться в модуле компиляции, такое ограничение может привести к
усложнению исходного кода и сложностям в разработке.

</p>
<p>Для решения этой проблемы вводятся import-выражения, позволя­ющие
импортировать типы в модуль компиляции и далее обращаться к ним по простым
именам. Существует два вида таких выражений:

</p>
<p>•     
импорт одного типа;

</p>
<p>•     
импорт пакета.

</p>
<p>Важно подчеркнуть, что импортирующие выражения являются, по сути,
подсказкой компилятора. Он пользуется ими, чтобы для каждого простого имени
типа из другого пакета получить его полное имя, которое и попадает в
компилированный код. Это означает, что импортирующих выражений может быть очень
много, включая и те, что импортируют не­используемые пакеты и типы, но это
никак не отразится ни на размере, ни на качестве бинарного кода. Также
безразлично, обращаться к типу по его полному имени, или включить его в
импортирующее выражение и об­ращаться по простому имени — результат будет один
и тот же.

</p>
<p>Импортирующие выражения имеют эффект только внутри модуля компиляции, в
котором они объявлены. Все объявления типов высшего уровня, находящиеся в этом
же модуле, могут одинаково пользоваться импортированными типами. К
импортированным типам возможен и обычный доступ по полному имени.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Выражение, импортирующее один тип, записываются с помощью ключевого
слова import и полного имени
типа. Например:

</p>
<p>import java.net.URL;

</p>
<p>Такое выражение означает, что в дальнейшем в этом модуле компиля­ции
простое имя URL будет обозначать одноименный класс из пакета java.net. Попытка импортировать тип, недоступный на момент компиля­ции, вызовет
ошибку. Если один и тот же тип импортируется несколько раз, то это не создает
ошибки, а дублированные выражения игнорируются. Если же импортируются типы с
одинаковыми простыми именами из раз­ных пакетов, то такая ситуация породит
ошибку компиляции.

</p>
<p>Выражение, импортирующее пакет, включает в себя полное имя па­кета
следующим образом.

</p>
<p>import java.awt.*;

</p>
<p>Это выражение делает доступными все типы, находящиеся в пакете java.awt, по их простому
имени. Попытка импортировать пакет, недоступ­ный на момент компиляции, вызовет
ошибку. Импортирование одного па­кета многократно не создает ошибки,
дублированные выражения игнори­руются. Обратите внимание, что импортировать
вложенный пакет нельзя.

</p>
<p>Например:

</p>
<p> 

</p>
<p>// пример вызовет ошибку
компиляции import java.awt.image;

</p>
<p>Создается впечатление, что теперь мы можем обращаться к типам па­кета java.awt.image по упрощенному имени, например, image.ImageFilter. На самом деле пример вызовет ошибку компиляции, так как данное вы­ражение
расценивается как импорт типа, а в пакете java.awt отсутствует тип image.

</p>
<p>Аналогично, выражение

</p>
<p> 

</p>
<p>import java.awt.*;

</p>
<p> 

</p>
<p>не делает более доступными классы пакета java.awt.image, их необходи­мо
импортировать отдельно.

</p>
<p>Поскольку пакет java.lang содержит типы, без
которых невоз­можно создать ни одну программу, он неявным образом импортирует­ся
в каждый модуль компиляции. Таким образом, все типы из этого пакета доступны по
их простым именам без каких-либо дополнитель­ных усилий. Попытка импортировать
данный пакет еще раз будет проигнорирована.

</p>
<p>Допускается одновременно импортировать пакет и какой-нибудь тип из него:

</p>
<p> 

</p>
<p>import java.awt.*; import java.awt.Point;

</p>
<p>Может возникнуть вопрос, как же лучше поступать — импортировать типы по
отдельности или весь пакет сразу? Есть ли какая-нибудь разница в этих подходах?

</p>
<p>Разница заключается в алгоритме работы компилятора, который приводит
каждое простое имя к полному. Он состоит из трех шагов:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
сначала просматриваются
выражения, импортирующие типы;

</p>
<p>•   
затем другие типы,
объявленные в текущем пакете, в том числе в текущем модуле компиляции;

</p>
<p>•   наконец, просматриваются
выражения, импортирующие пакеты.

</p>
<p>Таким образом, если тип явно импортирован, то невозможно ни объ­явление
нового типа с таким же именем, ни доступ по простому имени к одноименному типу
в текущем пакете.

</p>
<p>Например:

</p>
<p>II
пример вызовет ошибку компиляции package my_geom;

</p>
<p> 

</p>
<p>import java.awt.Point;

</p>
<p>class Point { }

</p>
<p>Этот модуль вызовет
ошибку компиляции, так как имя Point в объ­явлении
высшего типа будет рассматриваться как обращение к импор­тированному классу java.awt.Point, а его
переопределять, конечно, йнельзя.

</p>
<p>Если в пакете объявлен
тип:

</p>
<p> 

</p>
<p>package
my_geom;

</p>
<p>class Point { }

</p>
<p>то в другом модуле компиляции:

</p>
<p>package
my_geom;

</p>
<p>import
java.awt.Point;

</p>
<p>class Line { void main() {

</p>
<p>System.out.println(new Point());

</p>
<p>}

</p>
<p>}

</p>
<p>складывается неопределенная ситуация - какой из классов, my_geom. Point Или java.awt.Point, будет использоваться при создании объекта? Результа­том будет:

</p>
<p> 

</p>
<p>java.awt.Point[x=0,y=0]

</p>
<p>В соответствии с правилами, имя Point было трактовано на основе Импорта типа. К классу текущего пакета все еще
можно обращаться по •полному имени: my_geom.Point. Если бы
рассматривался безымянный Чакет, то обратиться к такому "перекрытому"
типу было бы уже невозмож-1,0&gt; что является дополнительным
аргументом к рекомендации распола-|*1ъ важные программы в
именованных пакетах.








</p>
<p>Теперь рассмотрим импорт пакета. Его еще называют "импорт по
требованию", подразумевая, что никакой "загрузки" всех типов
импорти­рованного пакета сразу при указании импортирующего выражения не
происходит, их полные имена подставляются по мере использования про­стых имен в
коде. Можно импортировать пакет и задействовать только один тип (или даже ни одного)
из него.

</p>
<p>Изменим рассмотренный выше
пример:

</p>
<p>package my_geom;

</p>
<p> 

</p>
<p>import
java.avvt.*;

</p>
<p> 

</p>
<p>class Line { void main() {

</p>
<p>System.out.println(new
PointO); System.out.println(new RectangleQ);

</p>
<p>}

</p>
<p>}

</p>
<p>Теперь результатом будет:

</p>
<p>my_geom.Point@92d342
java.awt.Rectangle[x=0,y=0,width=0,height=0]

</p>
<p>Тип Point нашелся в текущем
пакете, поэтому компилятору не при­шлось выполнять поиск по пакету java.awt. Второй объект
порождается от класса Rectangle, которого не существует в текущем пакете, зато он обнаруживается в java.awt.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Также корректен теперь
пример:

</p>
<p>package my_geom;

</p>
<p>import
java.awt.*;

</p>
<p>class Point { }

</p>
<p>Таким образом, импорт пакета не препятствует объявлению новы* типов или
обращению к существующим типам текущего пакета по про­стым именам. Если все же
нужно работать именно с внешними типами, то можно воспользоваться импортом
типа, или обращаться к ним по полным именам. Кроме того, считается, что импорт
конкретных типов помогает при прочтении кода сразу понять, какие внешние классы
и интерфейсы используются в этом модуле компиляции. Однако полностью полагаться
на такое соображение не стоит, так как возможны случаи, когда импорти­рованные
типы не используются и, напротив, в коде стоит обращение к другим типам по
полному имени.

</p>
<p> 

</p>
<p>Объявление верхнего уровня

</p>
<p>Далее модуль компиляции может содержать одно или несколько объявлений
классов и интерфейсов. Подробно формат такого объявления рассматривается в
следующих лекциях, однако приведем краткую инфор­мацию и здесь.

</p>
<p>Объявление класса начинается с ключевого слова class, интерфейса - interface. Далее указывается имя типа, а затем в фигурных скобках опи­сывается тело
типа. Например:

</p>
<p> 

</p>
<p>package first;

</p>
<p>class FirstClass { }

</p>
<p>interface
Mylnterface { }

</p>
<p>Область видимости типа - пакет, в котором он описан. Из других па­кетов
к типу можно обращаться либо по составному имени, либо с помо­щью импортирующих
выражений.

</p>
<p>Однако, кроме области видимости, в Java также есть средства
разгра­ничения доступа. По умолчанию тип объявляется доступным только для
Других типов своего пакета. Чтобы другие пакеты также могли использо­вать его,
можно указать ключевое слово public:

</p>
<p> 

</p>
<p>package second;

</p>
<p>public class
OpenClass { }

</p>
<p> 

</p>
<p>public interface
Publiclnterface {

</p>
<p>}

</p>
<p>Такие типы доступны для всех пакетов.

</p>
<p>Объявления верхнего
уровня описывают классы и интерфейсы, хра­нящиеся в пакетах. В версии Java 1.1 были введены внутренние (inner) ти-которые объявляются внутри других типов и являются их элементами

</p>
<p>163








</p>
<p>наряду с полями и методами. Данная возможность является вспомогатель­ной
и довольно запутанной, поэтому в курсе подробно не рассматривается, хотя
некоторые примеры и пояснения помогут в целом ее освоить.

</p>
<p>Если пакеты, исходный и бинарный код хранятся в файловой системе, то Java может накладывать ограничение на объявления классов в модулях
компиляции. Это ограничение
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>создает ошибку компиляции в случае, ес­ли описание
типа не обнаруживается в файле с названием, составленным из имени типа и
расширения (например, java), и при этом:

</p>
<p>•  тип объявлен как public и, значит, может
использоваться из других пакетов;

</p>
<p>•             тип используется из других модулей компиляции в своем пакете. Эти
условия означают, что в модуле компиляции может быть макси­мум один тип
отвечающий этим условиям.

</p>
<p>Другими словами, в модуле компиляции может быть максимум один public тип, и его имя и
имя файла должны совпадать. Если же в нем есть не-public типы, имена которых не совпадают с именем файла, то они должны
использоваться только внутри этого модуля компиляции.

</p>
<p>Если же для хранения пакетов применяется БД, то такое ограничение не
должно накладываться.

</p>
<p>На практике же программисты зачастую помещают в один модуль компиляции
только один тип, независимо от того, public он или нет. Это существенно упрощает работу с ними. Например, описание
класса space.sun.Size хранится в файле space\sun\Size.java, а бинарный код -в файле Size.class в том же каталоге.
Именно так устроены все стандарт­ные библиотеки Java.

</p>
<p>Обратите внимание, что при объявлении классов вполне допускают­ся
перекрестные обращения. В частности, следующий пример совершен­но корректен:

</p>
<p> 

</p>
<p>package test;

</p>
<p> 

</p>
<p>/*

</p>
<p>* Класс Human, описывающий человека

</p>
<p>7

</p>
<p>class Human { String name;

</p>
<p>Car car; // принадлежащая человеку машина

</p>
<p>}

</p>
<p> 

</p>
<p>Г

</p>
<p>* Класс Car, описывающий автомобиль

</p>
<p>7

</p>
<p>class Car { String model;

</p>
<p>Human driver; // водитель, управляющий машиной

</p>
<p>}

</p>
<p>Кроме того, класс Саг был использован раньше, чем был объявлен. Такое
перекрестное применение типов также допускается в случае, если они находятся в
разных пакетах. Компилятор должен поддерживать воз­можность транслировать их
одновременно.

</p>
<p> 

</p>
<p>Уникальность
имен пакетов

</p>
<p>Поскольку Java создавался как
язык, предназначенный для распро­странения приложений через Internet, а приложения
состоят из структу­ры пакетов, необходимо предпринять некоторые усилия, чтобы
не про­изошел конфликт имен. Имена двух используемых пакетов могут сов­пасть по
прошествии значительного времени после их создания. Испра­вить такое положение
обычному программисту будет крайне затрудни­тельно.

</p>
<p>Поэтому создатели Java предлагают
следующий способ уникального именования пакетов. Если программа создается
разработчиком, у которо­го есть
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>Internet-сайт, либо же он работает на организацию, у которой име­ется сайт, и
доменное имя такого сайта, например, company.com, то име­на пакетов должны начинаться с этих же слов, выписанных в
обратном порядке: com. company. Дальнейшие вложенные пакеты могут носить на­звания подразделений
компании, пакетов, фамилий разработчиков, име­на компьютеров и т.д.

</p>
<p>Таким образом, пакет верхнего уровня всегда записывается ASCII-буквами в нижнем
регистре и может иметь одно из следующих имен:

</p>
<p>•   
трехбуквенные com, edu, gov, mil, net, org, int (этот список рас­ширяется);

</p>
<p>•   
двухбуквенные,
обозначающие имена стран, такие как ru, su, de, uk и другие.

</p>
<p>Если имя сайта противоречит требованиям к идентификаторам Java, то можно
предпринять следующие шаги:

</p>
<p>•   
если в имени стоит
запрещенный символ, например, тире, то его можно заменить знаком подчеркивания;

</p>
<p>•   
если имя совпадает с
зарезервированным словом, можно в конце добавить знак подчеркивания;

</p>
<p>•   
если имя начинается с
цифры, можно в начале добавить знак под­черкивания.

</p>
<p>Примеры имен пакетов,
составленных по таким правилам: com. sun. image, codec.jpeg

</p>
<p>org.omg.CORBA.ORBPackage

</p>
<p>oracle.jdbc.driver.OracleDriver

</p>
<p>Однако, конечно, никто не требует, чтобы Java-пакеты были обяза­тельно
доступны на Internet-сайте, который дал им имя. Скорее была сделана попытка воспользоваться
существующей системой имен вместо того, чтобы создавать новую для именования
библиотек.

</p>
<p> 

</p>
<p>Область видимости имен

</p>
<p>Областью видимости объявления некоторого элемента языка назы­вается
часть программы, откуда допускается обращение к этому элементу по простому
имени.

</p>
<p>При рассмотрении каждого элемента языка будет указываться его область
видимости, однако имеет смысл собрать эту информацию в од­ном месте.

</p>
<p>Область видимости доступного пакета — вся программа, то есть лю­бой
класс может использовать доступный пакет. Однако необходимо по­мнить, что
обращаться к пакету можно только по его полному составно­му имени. К пакету java.lang ни из какого места нельзя обратиться как к просто lang.

</p>
<p>Областью видимости импортированного типа являются все объявле­ния
верхнего уровня в этом модуле компиляции.

</p>
<p>Областью видимости типа (класса или интерфейса) верхнего уров­ня
является пакет, в котором он объявлен. Из других пакетов доступ возможен либо
по составному имени, либо с помощью импортирующе­го выражения, которое помогает
компилятору воссоздать составное имя.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Область видимости элементов классов или интерфейсов — это все тело типа,
в котором они объявлены. Если обращение к этим эле­ментам происходит из другого
типа, необходимо воспользоваться со­ставным именем. Имя может быть составлено
из простого или состав­ного имени типа, имени объектной переменной или ключевых
слов super или this, после чего через точку указывается простое имя эле­мента.

</p>
<p>Аргументы метода, конструктора или обработчика ошибок видны только
внутри этих конструкций и не могут быть доступы извне.

</p>
<p>Область видимости локальных переменных начинается с момента их
инициализации и до конца блока, в котором они объявлены. В отличие от полей
типов, локальные переменные не имеют значений по умолчанию и должны
инициализироваться явно.

</p>
<p>int х;

</p>
<p>for (int i=0; К10; i++) { int t=5+i;

</p>
<p>}

</p>
<p>//
здесь переменная t уже
недоступна, // так как блок, в котором она была объявлена, // уже завершен, а
переменная х еще недоступна, // так как пока не была инициализирована

</p>
<p>Определенные проблемы возникают, когда происходит
перекрытие областей видимости и возникает конфликт имен различных конструкций
языка.

</p>
<p> 

</p>
<p>"Затеняющее"
объявление (Shadowing)

</p>
<p>Самыми распространенными случаями возникновения конфликта имен являются
выражение, импортирующее пакет, и объявление локальных переменных, или
параметров методов, конструкторов, обработчиков ошибок. Импорт пакета подробно
рассматривался в этой главе. Если им­портированный и текущий пакеты содержат
одноименные типы, то их об­ласти пересекаются. Как уже говорилось, предпочтение
отдается типу из текущего пакета. Также рассказывалось о том, как эту проблему
решать.

</p>
<p>Перейдем к проблеме перекрытия имен полей класса и локальных пе­ременных.
Пример:

</p>
<p>class Human { int age; //возраст int getAgeO { return age;

</p>
<p>}

</p>
<p>void setAge(int age) { age=age; // ???

</p>
<p>}

</p>
<p>}

</p>
<p>В классе Human (человек) объявлено поле age (возраст). Удобно оп­ределить
также метод setAge(), который должен устанавливать новое зна­чение возраста для человека.
Вполне логично сделать у метода setAge() °Дин входной аргумент, который также будет называть age (ведь в качест-Ве этого аргумента будет передаваться новое
значение возраста). Получа­ется, что в реализации метода setAge() нужно написать age=age, в пер­вом случае подразумевая поле класса, во втором - параметр метода
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>
По­нятно, что хотя с точки зрения компилятора это корректная конструкция,
попытка сослаться на две разные переменные через одно имя успехом не
увенчается. Надо заметить, что такие ошибки случаются порой даже у опытных
разработчиков.

</p>
<p>Во-первых, рассмотрим, из-за чего возникла конфликтная ситуа­ция. Есть
два элемента языка — аргумент метода и поле класса, области видимости которых
пересеклись. Область видимости поля класса больше, она охватывает все тело
класса, в то время как область видимости аргу­мента метода включает только сам
метод. В таком случае внутри области пересечения по простому имени доступен
именно аргумент метода, а по­ле класса "затеняется" (shadowing) объявлением параметра метода.

</p>
<p>Остается вопрос, как в такой ситуации все же обратиться к полю класса.
Если доступ по простому имени невозможен, надо воспользо­ваться составным.
Здесь удобнее всего применить специальное ключевое слово this (оно будет подробно рассматриваться в следующих главах). Слово this имеет значение ссылки на объект, внутри которого оно при­меняется. Если
вызвать метод setAge() у объекта класса Human и ис­пользовать в
этом методе слово this, то его значение будет ссылкой на данный объект.

</p>
<p>Исправленный вариант
примера:

</p>
<p> 

</p>
<p>class Human {

</p>
<p>int age;// возраст

</p>
<p> 

</p>
<p>void setAge(int age) {

</p>
<p>this.age=age; // верное
присвоение!

</p>
<p>}

</p>
<p>}

</p>
<p>Конфликт имен, возникающий из-за затеняющего
объявления, до­вольно легко исправить с помощью ключевого слова this или других кон­струкций языка, в зависимости от обстоятельств. Наибольшей
проблемой является то, что компилятор никак не сообщает о таких ситуациях, и са­мое
сложное — выявить ее с помощью тестирования или контрольного просмотра кода.

</p>
<p> 

</p>
<p>"Заслоняющее"
объявление (Obscuring)

</p>
<p>Может возникнуть ситуация, когда простое имя может быть одно­временно
рассмотрено как имя переменной, типа или пакета.

</p>
<p>Приведем пример, который
частично иллюстрирует такой случай:

</p>
<p>import
java.awt.*;

</p>
<p> 

</p>
<p>public class
Obscuring {

</p>
<p>static Point
Test = new Point(3,2); public static void main (String s[]) { print(Test.x);

</p>
<p>}

</p>
<p>}

</p>
<p>class Test {

</p>
<p>static int x = -5;

</p>
<p>}

</p>
<p>В методе main() простое имя Test одновременно
обозначает имя поля класса Obscruing и имя другого типа,
находящегося в том же пакете,-Test. С помощью этого имени происходит обращение к полю х, которое определено
и в классе java.awt.Point и Test.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Результатом этого примера станет 3, то есть переменная имеет более
высокий приоритет. В свою очередь, тип имеет более высокий приоритет, чем
пакет. Таким образом, обращение к доступному в обычных условиях типу или пакету
может оказаться невозможным, если есть объявление од­ноименной переменной или
типа, имеющее более высокий приоритет. Такое объявление называется
"заслоняющим" (obscuring).

</p>
<p>Эта проблема скорее всего не возникнет, если следовать соглашениям по
именованию элементов языка Java.

</p>
<p> 

</p>
<p>Соглашения по именованию

</p>
<p>Для того, чтобы код, написанный на Java, было легко читать
и по­нять не только его автору, но и другим разработчикам, а также для устра­нения
некоторых конфликтов имен, предлагаются следующие соглаше­ния по именованию
элементов языка Java. Стандартные библиотеки и классы Java также следуют им там, где это возможно.

</p>
<p>Соглашения регулируют
именование следующих конструкций:

</p>
<p>•     
пакеты;

</p>
<p>•     
типы (классы и
интерфейсы);

</p>
<p>•     
методы;

</p>
<p>•     
поля;

</p>
<p>•     
поля-константы;

</p>
<p>•     
локальные переменные и параметры
методов и др. Рассмотрим их последовательно.

</p>
<p>Правила построения имен пакетов уже подробно рассматривались в этой
главе. Имя каждого пакета начинается с маленькой буквы и пред­ставляет собой,
как правило, одно недлинное слово. Если требуется со­ставить название из
нескольких слов, можно воспользоваться знаком подчеркивания или начинать
следующее слово с большой буквы. Имя па­кета верхнего уровня обычно
соответствует доменному имени первого уровня. Названия java и javax (Java extension) зарезервированы компа­нией Sun для стандартных
пакетов Java.

</p>
<p>При возникновении ситуации "заслоняющего" объявления (obscur­ing) можно изменить
имя локальной переменной, что не повлечет за со­бой глобальных изменений в
коде. Случай же конфликта с именем типа не должен возникать, согласно правилам
именования типов.

</p>
<p>Имена типов начинаются с большой буквы и могут состоять из не­скольких
слов, каждое следующее слово также начинается с большой буквы. Конечно, надо
стремиться к тому, чтобы имена были описательными, "го­ворящими".

</p>
<p>Имена классов, как
правило, являются существительными: Human

</p>
<p>HighGreenOak

</p>
<p>ArraylndexOutOfBoundsException

</p>
<p> 

</p>
<p>(Последний пример - ошибка, возникающая при использовании индекса
массива, который выходит за границы допустимого.)

</p>
<p>Аналогично задаются имена интерфейсов, хотя они не обязательно должны
быть существительными. Часто используется английский суф­фикс "able:":

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Runnable

</p>
<p>Serializable

</p>
<p>Cloneable

</p>
<p> 

</p>
<p>Проблема "заслоняющего" объявления (obscuring) для типов встреча­ется редко, так как имена пакетов и локальных переменных
(параметров) начинаются с маленькой буквы, а типов — с большой.

</p>
<p>Имена методов должны быть глаголами и обозначать действия, которые
совершает данный метод. Имя должно начинаться с маленькой буквы, но мо­жет
состоять из нескольких слов, причем каждое следующее слово начинает­ся с
заглавной буквы. Существует ряд принятых названий для методов:

</p>
<p>•   
если методы предназначены
для чтения и изменения значения пе­ременной, то их имена начинаются,
соответственно, с get и set, например, для
переменной size это будут getSizeO и setSize();

</p>
<p>•    -метод, возвращающий длину, называется length(), например, в классе String;

</p>
<p> 

</p>
<p>•    
имя метода, который
проверяет булевское условие, начинается с is, например, isVisibleO у компонента
графического пользова­тельского интерфейса;

</p>
<p>•     метод, который преобразует величину в формат F, называется toF(), например, метод
toSting(), который приводит любой объект к строке.

</p>
<p>Вообще, рекомендуется везде, где возможно, называть методы похо­жим
образом, как в стандартных классах Java, чтобы они были
понятны всем разработчикам.

</p>
<p>Поля класса имеют имена, записываемые в том же стиле, что и для методов,
начинаются с маленькой буквы, могут состоять из нескольких слов, каждое
следующее слово начинается с заглавной буквы. Имена должны быть
существительными, например, поле name в классе Human, или size в классе Planet.

</p>
<p>Как для полей решается проблема "заслоняющего" объявления (obscuring), уже обсуждалось.

</p>
<p>Поля могут быть константами, если в их объявлении стоит ключевое слово final. Их имена состоят
из последовательности слов, сокращений, аббревиатур. Записываются они только
большими буквами, слова разде­ляются знаками подчеркивания:

</p>
<p> 

</p>
<p>PI

</p>
<p>MINVALUE MAXVALUE

</p>
<p>Иногда константы образуют группу, тогда рекомендуется использо­вать одно
или несколько одинаковых слов в начале имен:

</p>
<p> 

</p>
<p>COLOR_RED

</p>
<p>COLORJ3REEN

</p>
<p>COLOR_BLUE

</p>
<p>Наконец, рассмотрим имена локальных переменных и
параметров методов, конструкторов и обработчиков ошибок. Они, как правило, до­вольно
короткие, но, тем не менее, должны быть осмыслены. Например, можно использовать
аббревиатуру (имя ср для ссылки на экземпляр клас­са ColorPoint) или сокращение (buf для buffer).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Распространенные
однобуквенные сокращения:

</p>
<p> 

</p>
<p>byte b; char с; inti,j,k; long I;

</p>
<p>float f; double d; Object o; String s;

</p>
<p>Exception e; // объект, представляющий ошибку в Java

</p>
<p>Двух- и трехбуквенные имена не должны совпадать с принятыми до­менными
именами первого уровня Internet-сайтов.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой главе был рассмотрен механизм именования элементов языка. Для
того, чтобы различные части большой системы не зависели друг от дру­га,
вводится понятие "область видимости имени", вне которой необходимо
использовать не простое, а составное имя. Затем были изучены элементы (members), которые могут быть у пакетов и ссылочных типов. Также рас­сматривалась
связь терминов "идентификатор" (из темы "Лексика") и имя.

</p>
<p>Затем были рассмотрены пакеты, которые используются в Java для создания
физической и логической структуры классов, а также для более точного
разграничения области видимости. Пакет содержит вложенные пакеты и типы (классы
и интерфейсы). Вопрос о платформенной под­держке пакетов привел к рассмотрению
модулей компиляции как тексто­вых файлов, поскольку именно в виде файлов и
каталогов, как правило, хранятся и распространяются Java-приложения. Тогда
же впервые был рассмотрен вопрос разграничения доступа, так как доступ к
модулям компиляции определяется именно платформенной поддержкой, а точнее -
операционной системой.

</p>
<p>Модуль компиляции состоит из трех основных частей — объявление пакета,
импорт-выражения и объявления верхнего уровня. Важную роль иг­рает безымянный
пакет, или пакет по умолчанию, хотя он и не рекоменду­ется для применения при
создании больших систем. Были изучены детали применения двух видов
импорт-выражений - импорт класса и импорт па­кета. Наконец, было начато рассмотрение
объявлений верхнего уровня (эта тема будет продолжена в главе, описывающей
объявление классов). Паке­ты, как и другие элементы языка, имеют определенные
соглашения по име­нованию, призванные облегчить понимание кода и уменьшить
возмож­ность возникновения ошибок и двусмысленных ситуаций в программе.

</p>
<p>Описание области видимости для различных элементов языка приводит к
вопросу о возможных перекрытиях таких областей и, как следствие, о кон­фликтах
имен. Рассматриваются "затеняющие" и "заслоняющие" объявления.
Для устранения или уменьшения возможности возникновения таких ситуа­ций
описываются соглашения по именованию для всех элементов языка.

</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Что из перечисленных ниже слов является простым именем?

</p>
<p> 

</p>
<p>МуОазэ.пате

</p>
<p>МуС1а58.пате.т,о5тгтд()

</p>
<p>Муаазз.пате^оБтгтдО.пазпСоаеО

</p>
<p>&#9633;       
МуС^ээ

</p>
<p>&#9633;       
пате

</p>
<p>&#9633;          
1оБМпд

</p>
<p>&#9633;       
ЬаэпСос-е

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Могут ли пакет и вложенные пакеты содержать одноименные классы?

</p>
<p>&#9633;       
да

</p>
<p>&#9633;       
нет








</p>
<p>3.   Корректен
ли объявленный ниже класс? Если нет, то как его можно исправить? class Box {

</p>
<p>private int weight=0; public int getWeight() { return weight;

</p>
<p>}

</p>
<p>void setWieght(int weight) { weigh t=weigth;

</p>
<p>}

</p>
<p>}

</p>
<p>П   пример
корректен, ничего исправлять не нужно

</p>
<p>Г~1   пример
некорректен, конфликт имен в методе setWeight требует переименования поля или
аргумента

</p>
<p>П   пример
корректен, однако конфликт имен в методе setWeight требует переименования поля или
аргумента

</p>
<p>Г~1   пример корректен, однако конфликт имен
в методе setWeight требует
переименования поля или аргумента, либо использования выражения this

</p>
<p>&#9633;  
пример корректен, однако конфликт имен в методе setWeight требует переименования поля или
аргумента, либо использования выражений this или
super

</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Что из перечисленных ниже слов является составным именем? Му-ГЛавв
МуС1а88.пате
МуС1а88.пате.т.о51гтд()
МуС1а85.пате.т.о51ппд().»1а811(^е()

</p>
<p>&#9633;       
МуОаээ.пате

</p>
<p>&#9633;       
МуГЛазэ.пате.т-оЗтпд

</p>
<p>&#9633;       
МуФазз.патеЛобгппдО.пазгЮойе

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Программист располагает свою программу в каталоге c:\work.
Программа состоит из одного класса demo.Start.
Как нужно расположить файл .java и
как запускать компилятор javac?

</p>
<p>&#9633;       c:\work\Start.java, запустить
компилятор из каталога c:\work javac Start.java

</p>
<p>&#9633;       c:\work\demo\Start.java, запустить
компилятор из каталога c:\work\demo

</p>
<p>javac Start.java

</p>
<p>П   c:\work\demo\Start.java, запустить
компилятор из каталога c:\work

</p>
<p>javac demo\Start.java

</p>
<p>&#9633;       c:\work\demo\Start.java, запустить
компилятор из каталога c:\work

</p>
<p>javac demo.Start

</p>
<p>3.   Как в предыдущем вопросе следует расположить файл .class и как запускать виртуальную
машину java?

</p>
<p>П   c:\work\Start.class, запустить JVM из каталога c:\work java Start

</p>
<p>П   c:\work\demo\Start.class, запустить JVM из каталога c:\work\demo java Start

</p>
<p>&#9633;          
c:\work\demo\Start.class, запустить JVM из c:\work: java demo\Start.class

</p>
<p>&#9633;          
c:\work\demo\Start.class, запустить JVM из c:\work: Java demo.Start

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1.       Что
из перечисленных ниже слов является
идентификатором?

</p>
<p>MyClass

</p>
<p>MyClass.name

</p>
<p>MyClass.name.toStringO

</p>
<p>MyClass.name.toString().hashCode()

</p>
<p>&#9633;          
MyClass l~l   name

</p>
<p>&#9633;          
toString

</p>
<p>&#9633;          
hashCode

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Ниже
приведено несколько вариантов записи модуля
компиляции. Какие из них корректны, если предполагается
описать класс Point из пакета test.demo, причем класс
активно использует классы java.awt.Point и несколько
классов из пакета java.net?

</p>
<p>О   package test.demo;
import java.awt.Point; importjava.net.*;

</p>
<p>П import java.awt.*; importjava.net.*; package
test.demo;

</p>
<p>П   package test.demo; importjava.net.*; import
java.awt.*;

</p>
<p>П   package test.demo.* importjava.net.*; import
java.awt.*;








</p>
<p>3.   Какие формальные нарушения
соглашений по

</p>
<p>именованию
присутствуют в следующем примере: public class flat{

</p>
<p>private int floor_number; private int г; // количество комнат public int roomsO { retun r;

</p>
<p>}

</p>
<p>public int
GetFloorNumberO { return floor_number;

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;       
класс назван с прописной буквы,
должно быть Flat

</p>
<p>&#9633;       
имя поля floor_number содержит два слова, разделенных
знаком подчеркивания, должно быть FloorNumbe

</p>
<p>&#9633;       
имя поля г состоит из одной
буквы, а оно должно быть более понятным, например, rooms или roomsNumber

</p>
<p>&#9633;       
другие нарушения

</p>
<p>
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 5. Имена. Пакеты</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции рассматриваются две темы — система
именования эле­ментов языка в Java и пакеты (packages), которые являются аналогами библи­отек из других
языков. Почти все конструкции в Java имеют имя для обраще­ния к ним из других частей
программы. По ходу изложения вводятся важные понятия, в частности - область
видимости имени. При перекрытии таких об­ластей возникает конфликт имен. Для
того, чтобы минимизировать риск воз­никновения подобных ситуаций, описываются
соглашения по именованию, предложенные компанией Sun.

</p>
<p>Пакеты осуществляют физическую и логическую группировку
классов и становятся необходимыми при создании больших систем. Вводится важное
понятие модуля компиляции и описывается его структура.

</p>
<p> 

</p>
<p>Ключевые слова: простые имена, составные имена, элементы, тип, область видимости,
пакеты, модуль компиляции.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Имена (names) используются в программе для доступа к объяв­ленным (declared) ранее
"объектам", "элементам", "конструкциям" языка
(все эти слова-синонимы были использованы здесь в их общем смысле, а не как термины
ООП, например). Конкретнее, в Java имеют­ся имена:

</p>
<p>•   
пакеты;

</p>
<p>•   
классы;

</p>
<p>•   
интерфейсы;

</p>
<p>•   
элементы (member) ссылочных типов:

</p>
<p> 

</p>
<p>-   
поля;

</p>
<p>-   
методы;

</p>
<p>-   
внутренние классы и
интерфейсы;

</p>
<p>•  аргументы:

</p>
<p>-   
методов;

</p>
<p>-   
конструкторов;

</p>
<p>-   
обработчиков ошибок;

</p>
<p>•  локальные переменные.

</p>
<p>Соответственно, все они должны быть объявлены
специальным об­разом, что будет постепенно рассматриваться по ходу курса. Так
же объ­являются конструкторы, однако их имя совпадает с именем класса, по­этому
они не попали в этот список.








</p>
<p>Напомним, что пакеты (packages) в Java — это способ
логически груп­пировать классы, что необходимо, поскольку зачастую количество
классов в системе составляет несколько тысяч, или даже десятков тысяч. Кроме
классов и интерфейсов в пакетах, могут находиться вложенные пакеты. Синонимами
этого слова в других языках являются библиотека или модуль.

</p>
<p> 

</p>
<p>Имена

</p>
<p> 

</p>
<p>Простые
и составные имена. Элементы

</p>
<p>Имена бывают простыми (simple), состоящими из одного идентифика­тора (они определяются во время
объявления) и составными (qualified), со­стоящими из последовательности идентификаторов, разделенных
точкой. Для пояснения этих терминов необходимо рассмотреть еще одно понятие.

</p>
<p>У пакетов и ссылочных типов (классов, интерфейсов, массивов) есть
элементы (members)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Доступ к элементам осуществляется с помощью выра­жения, состоящего из
имен, например, пакета и класса, разделенных точкой.

</p>
<p>Далее классы и интерфейсы будут называться объединяющим тер­мином тип (type).

</p>
<p>Элементами пакета являются содержащиеся в нем классы и интер­фейсы, а
также вложенные пакеты. Чтобы получить составное имя паке­та, необходимо к
полному имени пакета, в котором он располагается, до­бавить точку, а затем его
собственное простое имя. Например, составное имя основного пакета языка Java - java.lang (то есть простое имя этого пакета lang, и он находится в
объемлющем пакете java). Внутри него есть вложенный пакет, предназначенный для типов технологии reflection, ко­торая упоминалась в предыдущих главах. Простое название пакета reflect, а значит,
составное - java.lang.reflect.

</p>
<p>Простое имя классов и интерфейсов дается при объявлении, напри­мер, Object, String, Point. Чтобы получить
составное имя таких типов, на­до к составному имени пакета, в котором находится
тип, через точку добавить простое имя типа. Например, java.lang.Object, java.lang.reflect.Method или com.myfirm.MainClass. Смысл последнего выражения таков: сначала идет обращение к пакету com, затем к его эле­менту
- вложенному пакету myfirm, а затем к элементу пакета myfirm -классу MainClass. Здесь com.myfirm - составное имя
пакета, где лежит класс MainClass, a MainClass — простое имя этого
класса. Составляем их и разделяем точкой - получается полное имя класса com.myfirm.MainClass.

</p>
<p>Для ссылочных типов элементами являются поля и методы, а также
внутренние типы (классы и интерфейсы). Элементы могут быть как непо­средственно
объявлены в классе, так и получены по наследству от роди-

</p>
<p>150

</p>
<p>тельских классов и
интерфейсов, если таковые имеются. Простое имя элементов также дается при
инициализации. Например, toString(),
PI, InnerClass. Составное имя получается
путем объединения простого или составного имени типа, или переменной объектного
типа с именем элемента. Например, ref.toStringO, java.lang.Math.PI, OuterClass. InnerClass. Другие обращения к элементам ссылочных типов уже неоднократно
применялись в предыдущих главах.

</p>
<p> 

</p>
<p>Имена
и идентификаторы

</p>
<p>Теперь, когда мы рассмотрели простые и составные имена, уточним раз­ницу
между идентификатором (напомним, что это вид лексемы) и именем
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Понятно, что
простое имя состоит из одного идентификатора, а составное -из нескольких.
Однако не всякий идентификатор входит в состав имени.

</p>
<p>Во-первых, в выражении объявления (declaration) идентификатор еще не является именем. Другими словами, он становится
именем после первого появления в коде в месте объявления.

</p>
<p>Во-вторых, существует возможность обращаться к полям и методам
объектного типа не через имя типа или объектной переменной, а через ссылку на
объект, полученную в результате выполнения выражения. При­мер такого случая уже
приводился в одной из предыдущих глав:

</p>
<p>country.getCity().getStreet();

</p>
<p>В данном примере getStreet является не именем,
а идентификато­ром, так как соответствующий метод вызывается у объекта,
полученного в результате вызова метода getCity(). Причем country.getCity как раз яв­ляется
составным именем метода.

</p>
<p>Наконец, идентификаторы также используются для названий меток (label). Эта конструкция
рассматривается позже, однако приведем при­мер, показывающий, что пространства
имен и названий меток полностью разделены.

</p>
<p>num:

</p>
<p>for (int num = 2; num &lt;= 100; num++) { int n = (int)Math.sqrt(num)+1 ; while (-n != 0) { if (num%n==0) { continue num;

</p>
<p>}

</p>
<p>}

</p>
<p>System.out.print(num+" ");

</p>
<p>}








</p>
<p>Результатом будут простые
числа меньше 100:

</p>
<p> 

</p>
<p>2357 11 13171923 2931 37
41 43 47 53 5961 6771 73 79 83 89 97

</p>
<p> 

</p>
<p>Мы видим, что здесь применяются одноименные переменная и метка num, причем последняя
используется для выхода из внутреннего цикла while на внешний for.

</p>
<p>Очевидно, что удобнее использовать простое имя, а не составное, т.к. оно
короче и его легче запомнить. Однако понятно, что если в системе есть очень
много классов со множеством переменных, можно столкнуться с ситуацией, когда в
разных классах есть одноименные переменные или методы. Для решения этой и
других подобных проблем вводится новое по­нятие — область видимости.

</p>
<p> 

</p>
<p>Область
видимости (введение)

</p>
<p>Чтобы не заставлять программистов, совместно работающих над различными
классами одной системы, координировать имена, которые они дают различным
конструкциям языка, у каждого имени есть область видимости (scope). Если обращение,
например, к полю, идет из части ко­да, попадающей в область видимости его
имени, то можно пользоваться простым именем, если нет - необходимо применять
составное.

</p>
<p>Например:

</p>
<p> 

</p>
<p>class Point { int х,у;

</p>
<p>int getX() {

</p>
<p>return x; // простое имя

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>}

</p>
<p>class Test { void main() {

</p>
<p>Point p = new
Point(); p.x=3; // составное имя

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Видно, что к полю х изнутри класса можно обращаться по простому имени. К
нему же из другого класса можно обратиться только по состав­ному имени. Оно
составляется из имени переменной, ссылающейся на объект, и имени ПОЛЯ.

</p>
<p>Теперь необходимо рассмотреть области видимости для всех элемен­тов
языка. Однако прежде выясним, что такое пакеты, как и для чего они
используются.

</p>
<p> 

</p>
<p>Пакеты

</p>
<p>Программа на Java представляет собой
набор пакетов (packages). Каждый пакет может включать вложенные пакеты, то есть они образуют
иерархическую систему.

</p>
<p>Кроме того, пакеты могут содержать классы и интерфейсы и таким образом
группируют типы. Это необходимо сразу для нескольких целей. Во-первых, чисто
физически невозможно работать с большим количест­вом классов, если они
"свалены в кучу". Во-вторых, модульная декомпо­зиция облегчает
проектирование системы. К тому же, как будет показано ниже, существует
специальный уровень доступа, позволяющий типам из одного пакета более тесно
взаимодействовать друг с другом, чем с класса­ми из других пакетов. Таким
образом, с помощью пакетов производится логическая группировка типов. Из ООП
известно, что большая связность системы, то есть среднее количество классов, с
которыми взаимодейству­ет каждый класс, заметно усложняет развитие и поддержку
такой систе­мы. Используя пакеты, гораздо проще организовать эффективное взаи­модействие
подсистем друг с другом.

</p>
<p>Наконец, каждый пакет имеет свое пространство имен, что позво­ляет
создавать одноименные классы в различных пакетах. Таким обра­зом, разработчикам
не приходится тратить время на разрешение кон­фликта имен.

</p>
<p> 

</p>
<p>Элементы
пакета

</p>
<p>Еще раз повторим, что элементами пакета являются вложенные пакеты и типы
(классы и интерфейсы). Одноименные элементы запре­щены, то есть не может быть одноименных
класса и интерфейса, или вложенного пакета и типа. В противном случае возникнет
ошибка Компиляции.

</p>
<p>Например, в JDK 1.0 пакет java содержал пакеты applet, awt, io, 'ang, net, util и не содержал ни
одного типа. В пакет java.awt входил вло­женный пакет
image и 46 классов и интерфейсов.

</p>
<p>Составное имя любого элемента пакета - это составное имя этого пакета
плюс простое имя элемента. Например, для класса Object в паке­те java.lang составным именем
будет java. lang.Object, а для пакета image в пакете java.awt - java.awt.image.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Иерархическая структура пакетов была введена для удобства органи­зации
связанных пакетов, однако вложенные пакеты, или соседние, то есть вложенные в
один и тот же пакет, не имеют никаких дополнительных связей между собой, кроме
ограничения на несовпадение имен. Напри­мер, пакеты space.sun, space.sun.ray, space.moon и factory.store со­вершенно
"равны" между собой и типы одного из этих пакетов не имеют никакого
особенного доступа к типам других пакетов.

</p>
<p> 

</p>
<p>Платформенная
поддержка пакетов

</p>
<p>Простейшим способом организации пакетов и типов является обыч­ная
файловая структура. Рассмотрим вырожденный пример, когда все па­кеты, исходный
и бинарный код располагаются в одном каталоге и его подкаталогах.

</p>
<p>В этом корневом каталоге должна быть папка java, соответствующая
основному пакету языка, а в ней, в свою очередь, вложенные папки applet, awt, io, lang, net, util.

</p>
<p>Предположим, разработчик работает над моделью солнечной систе­мы, для
чего создал классы Sun, Moon и Test и расположил их в пакете space.sunsystem. В таком случае в корневом каталоге должна быть пап­ка space, соответствующая
одноименному пакету, а в ней - папка sunsys­tem, в которой
хранятся классы этого разработчика.

</p>
<p>Как известно, исходный код располагается в файлах с расширением .java, а бинарный - с
расширением .class. Таким образом, содержимое папки sunsystem может выглядеть следующим образом:

</p>
<p>Moon.java Moon.class Su n. java Sun.class Test.java Test.class

</p>
<p> 

</p>
<p>Другими словами, исходный код классов

</p>
<p> 

</p>
<p>space.sunsystem.Moon space.sunsystem.Sun space.sunsystem.Test

</p>
<p> 

</p>
<p>хранится в файлах

</p>
<p> 

</p>
<p>space\sunsystem\Moon.java

</p>
<p>space\sunsystem\Sun.java

</p>
<p>space\sunsystem\Test.java а бинарный код — в соответствующих .class-файлах. Обратите
внимание, что преобразование имен пакетов в файловые пути потребовало замены разделителя
. (точки) на символ-разделитель файлов (для Windows это об­ратный слэш \). Такое преобразование может выполнить как
компилятор для поиска исходных текстов и бинарного кода, так и виртуальная маши­на
для загрузки классов и интерфейсов.

</p>
<p>Обратите внимание, что было бы ошибкой запускать Java прямо из папки space\sunsystem и пытаться
обращаться к классу Test, несмотря на то, что файл-описание лежит именно в ней. Необходимо
подняться на два уровня каталогов выше, чтобы Java, построив путь из
имени пакета, смогла обнаружить нужный файл.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Кроме того, немаловажно, что Java всегда различает регистр иденти­фикаторов, а значит, названия файлов и
каталогов должны точно отвечать запрограммированным именам. Хотя в некоторых
случаях операционная система может обеспечить доступ, невзирая на регистр, при
изменении обстоятельств расхождения могут привести к сбоям.

</p>
<p>Существует специальное выражение, объявляющее пакет (подробно
рассматривается ниже). Оно предшествует объявлению типа и обознача­ет, какому
пакету будет принадлежать этот тип. Таким образом, набор до­ступных пакетов
определяется набором доступных файлов, содержащих объявления типов и пакетов.
Например, если создать пустой каталог, или заполнить его посторонними файлами,
это отнюдь не приведет к появле­нию пакета в Java.

</p>
<p>Какие файлы доступны для утилит Java SDK (компилятора, интер­претатора и т.д.), устанавливается на уровне
операционной системы, ведь утилиты — это обычные программы, которые выполняются
под уп­равлением ОС и, конечно, следуют ее правилам. Например, если пакет
содержит один тип, но описывающий его файл недоступен текущему пользователю ОС
для чтения, для Java этот тип и этот
пакет не будут су­ществовать.

</p>
<p>Понятно, что далеко не всегда удобно хранить все файлы в одном каталоге.
Зачастую классы находятся в разных местах, а некоторые мо­гут даже
распространяться в виде архивов, для ускорения загрузки через сеть. Копировать
все такие файлы в одну папку было бы крайне затруд­нительно.

</p>
<p>Поэтому Java использует
специальную переменную окружения, кото-Рая называется classpath. Аналогично тому, как переменная path помогает системе находить и загружать динамические библиотеки, эта
переменная Помогает работать с Java-классами. Ее значение должно состоять из путей к каталогам или архивам,
разделенных точкой с запятой. С версии 1.1 поддер­живаются архивы типов ZIP и JAR (Java ARchive) - специальный формат, Разработанный на основе ZIP для Java.








</p>
<p>Например, переменная classpath может иметь такое
значение: .;c:\java\classes;d:\lib\3Dengine.zip;d:\lib\fire.jar

</p>
<p>В результате все указанные каталоги и содержимое всех архивов "до­бавляется"
к исходному корневому каталогу. Java в поисках класса
будет искать его по описанному выше правилу во всех указанных папках и ар­хивах
по порядку
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Обратите внимание, что первым в переменной указан текущий каталог
(представлен точкой). Это делается для того, чтобы по­иск всегда начинался с
исходного корневого каталога. Конечно, такая за­пись не является обязательной и
делается на усмотрение разработчика.

</p>
<p>Несмотря на явные удобства такой конструкции, она таит в себе и
опасности. Если разрабатываемые классы хранятся в некотором каталоге и он
указан в classpath позже, чем некий
другой каталог, в котором обнару­живаются одноименные типы, разобраться в такой
ситуации будет непро­сто. В классы будут вноситься изменения, которые никак не
проявляются при запуске из-за того, что Java на самом деле загружает одни и те же файлы из посторонней папки.

</p>
<p>Поэтому к данной переменной среды окружения необходимо отно­ситься с
особым вниманием. Полезно помнить, что необязательно уста­навливать ее значение
сразу для всей операционной системы. Его можно явно указывать при каждом
запуске компилятора или виртуальной маши­ны как опцию, что, во-первых, никогда
не повлияет на другие Java-про­граммы, а во-вторых, заметно упрощает поиск ошибок, связанных с не­корректным
значением classpath.

</p>
<p>Наконец, можно применять и альтернативные подходы к хранению пакетов и
файлов с исходным и бинарным кодом. Например, в качестве такого хранилища может
использоваться база данных. Более того, суще­ствует ограничение на размещение
объявлений классов в .java-файлах, которое рассматривается ниже, а при использовании БД любые
ограни­чения можно снять. Тем не менее, при таком подходе рекомендуется пре­доставлять
утилиты импорта/экспорта с учетом ограничения для преоб­разований из/в файлы.

</p>
<p> 

</p>
<p>Модуль
компиляции

</p>
<p>Модуль компиляции (complication unit) хранится в текстовом .java-файле и является единичной порцией входных данных для компилятора. Он
состоит из трех частей:

</p>
<p>•   
объявление пакета;

</p>
<p>•   
import-выражения;

</p>
<p>•   
объявления верхнего
уровня.

</p>
<p> 

</p>
<p>Объявление пакета одновременно указывает, какому пакету будут
принадлежать все объявляемые ниже типы. Если данное выражение от­сутствует,
значит, эти классы располагаются в безымянном пакете (другое название — пакет
по умолчанию).

</p>
<p>Import-выражения
позволяют обращаться к типам из других пакетов по их простым именам,
"импортировать" их. Эти выражения также необя­зательны.

</p>
<p>Наконец, объявления верхнего уровня содержат объявления од­ного или
нескольких типов
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Название "верхнего уровня" противопос­тавляет эти
классы и интерфейсы, располагающиеся в пакетах, внут­ренним типам, которые
являются элементами и располагаются внут­ри других типов. Как ни странно, эта
часть также является необяза­тельной, в том смысле, что в случае ее отсутствия
компилятор не вы­даст ошибки. Однако никаких .class-файлов
сгенерировано тоже не будет.

</p>
<p>Доступность модулей компиляции определяется поддержкой плат­формы, т.к.
утилиты Java являются обычными
программами, которые ис­полняются операционной системой по общим правилам.

</p>
<p>Рассмотрим все три части
более подробно.

</p>
<p> 

</p>
<p>Объявление пакета

</p>
<p>Первое выражение в модуле компиляции — объявление пакета. Оно
записывается с помощью ключевого слова package, после которого
ука­зывается полное имя пакета.

</p>
<p>Например, первой строкой (после комментариев) в файле java/lang/Object.java идет:

</p>
<p> 

</p>
<p>package java.lang;

</p>
<p>Это одновременно служит объявлением пакета lang, вложенного в пакет java, и указанием, что
объявляемый ниже класс Object находит­ся в данном
пакете. Так складывается полное имя класса java.lang.Object.

</p>
<p>Если это выражение отсутствует, то такой модуль компиляции принадлежит
безымянному пакету. Этот пакет по умолчанию обяза­тельно должен поддерживаться
реализацией Java-платформы. Обратите внимание, что он не может иметь вложенных пакетов,
так как состав­ное имя пакета должно обязательно начинаться с имени пакета
верхне­го уровня.

</p>
<p>Таким образом, самая простая программа может выглядеть следую­щим
образом:








</p>
<p>class Simple {

</p>
<p>public static void main(String s[]) { System.
out.printlnf'Hello!");

</p>
<p>}

</p>
<p>}

</p>
<p>Этот модуль компиляции
будет принадлежать безымянному пакету.

</p>
<p>Пакет по умолчанию был введен в Java для облегчения написания очень небольших или временных приложений, для
экспериментов. Если же программа будет распространяться для пользователей, то
рекоменду­ется расположить ее в пакете, который, в свою очередь, должен быть
пра­вильно назван. Соглашения по именованию рассматриваются ниже.

</p>
<p>Доступность пакета определяется по доступности модулей компиля­ции, в
которых он объявляется. Точнее, пакет доступен тогда и только тогда, когда
выполняется любое из следующих двух условий:

</p>
<p>•    
доступен модуль компиляции
с объявлением этого пакета;

</p>
<p>•    
доступен один из вложенных
пакетов этого пакета. Таким образом, для следующего кода:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>package
space.star;

</p>
<p>class Sun { }

</p>
<p>если файл, который хранит этот модуль компиляции, доступен Java-плат­форме, то
пакеты space и вложенный в него star (полное название space.star) также становятся доступны для Java.

</p>
<p>Если пакет доступен, то область видимости его объявления - все доступ­ные
модули компиляции. Проще говоря, все существующие пакеты доступ­ны для всех
классов, никаких ограничений на доступ к пакетам в Java нет.

</p>
<p>Требуется, чтобы пакеты java.lang и java.io, а значит, и java, всегда были доступны для Java-платформы, поскольку они содержат классы, не­обходимые для работы
любого приложения.

</p>
<p> 

</p>
<p>Импорт-выражения

</p>
<p>Как будет рассмотрено ниже, область видимости объявления типа -пакет, в
котором он располагается. Это означает, что внутри данного паке­та допускается
обращение к типу по его простому имени. Из всех других пакетов необходимо
обращаться по составному имени, то есть полное имя пакета плюс простое имя
типа, разделенные точкой. Поскольку пакеты могут иметь довольно длинные имена
(например, дополнительный пакет в составе JDK1.2 называется com.sun.image.codec.jpeg),
а тип может многократно
использоваться в модуле компиляции, такое ограничение может привести к
усложнению исходного кода и сложностям в разработке.

</p>
<p>Для решения этой проблемы вводятся import-выражения, позволя­ющие
импортировать типы в модуль компиляции и далее обращаться к ним по простым
именам. Существует два вида таких выражений:

</p>
<p>•     
импорт одного типа;

</p>
<p>•     
импорт пакета.

</p>
<p>Важно подчеркнуть, что импортирующие выражения являются, по сути,
подсказкой компилятора. Он пользуется ими, чтобы для каждого простого имени
типа из другого пакета получить его полное имя, которое и попадает в
компилированный код. Это означает, что импортирующих выражений может быть очень
много, включая и те, что импортируют не­используемые пакеты и типы, но это
никак не отразится ни на размере, ни на качестве бинарного кода. Также
безразлично, обращаться к типу по его полному имени, или включить его в
импортирующее выражение и об­ращаться по простому имени — результат будет один
и тот же.

</p>
<p>Импортирующие выражения имеют эффект только внутри модуля компиляции, в
котором они объявлены. Все объявления типов высшего уровня, находящиеся в этом
же модуле, могут одинаково пользоваться импортированными типами. К
импортированным типам возможен и обычный доступ по полному имени.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Выражение, импортирующее один тип, записываются с помощью ключевого
слова import и полного имени
типа. Например:

</p>
<p>import java.net.URL;

</p>
<p>Такое выражение означает, что в дальнейшем в этом модуле компиля­ции
простое имя URL будет обозначать одноименный класс из пакета java.net. Попытка импортировать тип, недоступный на момент компиля­ции, вызовет
ошибку. Если один и тот же тип импортируется несколько раз, то это не создает
ошибки, а дублированные выражения игнорируются. Если же импортируются типы с
одинаковыми простыми именами из раз­ных пакетов, то такая ситуация породит
ошибку компиляции.

</p>
<p>Выражение, импортирующее пакет, включает в себя полное имя па­кета
следующим образом.

</p>
<p>import java.awt.*;

</p>
<p>Это выражение делает доступными все типы, находящиеся в пакете java.awt, по их простому
имени. Попытка импортировать пакет, недоступ­ный на момент компиляции, вызовет
ошибку. Импортирование одного па­кета многократно не создает ошибки,
дублированные выражения игнори­руются. Обратите внимание, что импортировать
вложенный пакет нельзя.

</p>
<p>Например:

</p>
<p> 

</p>
<p>// пример вызовет ошибку
компиляции import java.awt.image;

</p>
<p>Создается впечатление, что теперь мы можем обращаться к типам па­кета java.awt.image по упрощенному имени, например, image.ImageFilter. На самом деле пример вызовет ошибку компиляции, так как данное вы­ражение
расценивается как импорт типа, а в пакете java.awt отсутствует тип image.

</p>
<p>Аналогично, выражение

</p>
<p> 

</p>
<p>import java.awt.*;

</p>
<p> 

</p>
<p>не делает более доступными классы пакета java.awt.image, их необходи­мо
импортировать отдельно.

</p>
<p>Поскольку пакет java.lang содержит типы, без
которых невоз­можно создать ни одну программу, он неявным образом импортирует­ся
в каждый модуль компиляции. Таким образом, все типы из этого пакета доступны по
их простым именам без каких-либо дополнитель­ных усилий. Попытка импортировать
данный пакет еще раз будет проигнорирована.

</p>
<p>Допускается одновременно импортировать пакет и какой-нибудь тип из него:

</p>
<p> 

</p>
<p>import java.awt.*; import java.awt.Point;

</p>
<p>Может возникнуть вопрос, как же лучше поступать — импортировать типы по
отдельности или весь пакет сразу? Есть ли какая-нибудь разница в этих подходах?

</p>
<p>Разница заключается в алгоритме работы компилятора, который приводит
каждое простое имя к полному. Он состоит из трех шагов:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
сначала просматриваются
выражения, импортирующие типы;

</p>
<p>•   
затем другие типы,
объявленные в текущем пакете, в том числе в текущем модуле компиляции;

</p>
<p>•   наконец, просматриваются
выражения, импортирующие пакеты.

</p>
<p>Таким образом, если тип явно импортирован, то невозможно ни объ­явление
нового типа с таким же именем, ни доступ по простому имени к одноименному типу
в текущем пакете.

</p>
<p>Например:

</p>
<p>II
пример вызовет ошибку компиляции package my_geom;

</p>
<p> 

</p>
<p>import java.awt.Point;

</p>
<p>class Point { }

</p>
<p>Этот модуль вызовет
ошибку компиляции, так как имя Point в объ­явлении
высшего типа будет рассматриваться как обращение к импор­тированному классу java.awt.Point, а его
переопределять, конечно, йнельзя.

</p>
<p>Если в пакете объявлен
тип:

</p>
<p> 

</p>
<p>package
my_geom;

</p>
<p>class Point { }

</p>
<p>то в другом модуле компиляции:

</p>
<p>package
my_geom;

</p>
<p>import
java.awt.Point;

</p>
<p>class Line { void main() {

</p>
<p>System.out.println(new Point());

</p>
<p>}

</p>
<p>}

</p>
<p>складывается неопределенная ситуация - какой из классов, my_geom. Point Или java.awt.Point, будет использоваться при создании объекта? Результа­том будет:

</p>
<p> 

</p>
<p>java.awt.Point[x=0,y=0]

</p>
<p>В соответствии с правилами, имя Point было трактовано на основе Импорта типа. К классу текущего пакета все еще
можно обращаться по •полному имени: my_geom.Point. Если бы
рассматривался безымянный Чакет, то обратиться к такому "перекрытому"
типу было бы уже невозмож-1,0&gt; что является дополнительным
аргументом к рекомендации распола-|*1ъ важные программы в
именованных пакетах.








</p>
<p>Теперь рассмотрим импорт пакета. Его еще называют "импорт по
требованию", подразумевая, что никакой "загрузки" всех типов
импорти­рованного пакета сразу при указании импортирующего выражения не
происходит, их полные имена подставляются по мере использования про­стых имен в
коде. Можно импортировать пакет и задействовать только один тип (или даже ни одного)
из него.

</p>
<p>Изменим рассмотренный выше
пример:

</p>
<p>package my_geom;

</p>
<p> 

</p>
<p>import
java.avvt.*;

</p>
<p> 

</p>
<p>class Line { void main() {

</p>
<p>System.out.println(new
PointO); System.out.println(new RectangleQ);

</p>
<p>}

</p>
<p>}

</p>
<p>Теперь результатом будет:

</p>
<p>my_geom.Point@92d342
java.awt.Rectangle[x=0,y=0,width=0,height=0]

</p>
<p>Тип Point нашелся в текущем
пакете, поэтому компилятору не при­шлось выполнять поиск по пакету java.awt. Второй объект
порождается от класса Rectangle, которого не существует в текущем пакете, зато он обнаруживается в java.awt.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Также корректен теперь
пример:

</p>
<p>package my_geom;

</p>
<p>import
java.awt.*;

</p>
<p>class Point { }

</p>
<p>Таким образом, импорт пакета не препятствует объявлению новы* типов или
обращению к существующим типам текущего пакета по про­стым именам. Если все же
нужно работать именно с внешними типами, то можно воспользоваться импортом
типа, или обращаться к ним по полным именам. Кроме того, считается, что импорт
конкретных типов помогает при прочтении кода сразу понять, какие внешние классы
и интерфейсы используются в этом модуле компиляции. Однако полностью полагаться
на такое соображение не стоит, так как возможны случаи, когда импорти­рованные
типы не используются и, напротив, в коде стоит обращение к другим типам по
полному имени.

</p>
<p> 

</p>
<p>Объявление верхнего уровня

</p>
<p>Далее модуль компиляции может содержать одно или несколько объявлений
классов и интерфейсов. Подробно формат такого объявления рассматривается в
следующих лекциях, однако приведем краткую инфор­мацию и здесь.

</p>
<p>Объявление класса начинается с ключевого слова class, интерфейса - interface. Далее указывается имя типа, а затем в фигурных скобках опи­сывается тело
типа. Например:

</p>
<p> 

</p>
<p>package first;

</p>
<p>class FirstClass { }

</p>
<p>interface
Mylnterface { }

</p>
<p>Область видимости типа - пакет, в котором он описан. Из других па­кетов
к типу можно обращаться либо по составному имени, либо с помо­щью импортирующих
выражений.

</p>
<p>Однако, кроме области видимости, в Java также есть средства
разгра­ничения доступа. По умолчанию тип объявляется доступным только для
Других типов своего пакета. Чтобы другие пакеты также могли использо­вать его,
можно указать ключевое слово public:

</p>
<p> 

</p>
<p>package second;

</p>
<p>public class
OpenClass { }

</p>
<p> 

</p>
<p>public interface
Publiclnterface {

</p>
<p>}

</p>
<p>Такие типы доступны для всех пакетов.

</p>
<p>Объявления верхнего
уровня описывают классы и интерфейсы, хра­нящиеся в пакетах. В версии Java 1.1 были введены внутренние (inner) ти-которые объявляются внутри других типов и являются их элементами

</p>
<p>163








</p>
<p>наряду с полями и методами. Данная возможность является вспомогатель­ной
и довольно запутанной, поэтому в курсе подробно не рассматривается, хотя
некоторые примеры и пояснения помогут в целом ее освоить.

</p>
<p>Если пакеты, исходный и бинарный код хранятся в файловой системе, то Java может накладывать ограничение на объявления классов в модулях
компиляции. Это ограничение
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>создает ошибку компиляции в случае, ес­ли описание
типа не обнаруживается в файле с названием, составленным из имени типа и
расширения (например, java), и при этом:

</p>
<p>•  тип объявлен как public и, значит, может
использоваться из других пакетов;

</p>
<p>•             тип используется из других модулей компиляции в своем пакете. Эти
условия означают, что в модуле компиляции может быть макси­мум один тип
отвечающий этим условиям.

</p>
<p>Другими словами, в модуле компиляции может быть максимум один public тип, и его имя и
имя файла должны совпадать. Если же в нем есть не-public типы, имена которых не совпадают с именем файла, то они должны
использоваться только внутри этого модуля компиляции.

</p>
<p>Если же для хранения пакетов применяется БД, то такое ограничение не
должно накладываться.

</p>
<p>На практике же программисты зачастую помещают в один модуль компиляции
только один тип, независимо от того, public он или нет. Это существенно упрощает работу с ними. Например, описание
класса space.sun.Size хранится в файле space\sun\Size.java, а бинарный код -в файле Size.class в том же каталоге.
Именно так устроены все стандарт­ные библиотеки Java.

</p>
<p>Обратите внимание, что при объявлении классов вполне допускают­ся
перекрестные обращения. В частности, следующий пример совершен­но корректен:

</p>
<p> 

</p>
<p>package test;

</p>
<p> 

</p>
<p>/*

</p>
<p>* Класс Human, описывающий человека

</p>
<p>7

</p>
<p>class Human { String name;

</p>
<p>Car car; // принадлежащая человеку машина

</p>
<p>}

</p>
<p> 

</p>
<p>Г

</p>
<p>* Класс Car, описывающий автомобиль

</p>
<p>7

</p>
<p>class Car { String model;

</p>
<p>Human driver; // водитель, управляющий машиной

</p>
<p>}

</p>
<p>Кроме того, класс Саг был использован раньше, чем был объявлен. Такое
перекрестное применение типов также допускается в случае, если они находятся в
разных пакетах. Компилятор должен поддерживать воз­можность транслировать их
одновременно.

</p>
<p> 

</p>
<p>Уникальность
имен пакетов

</p>
<p>Поскольку Java создавался как
язык, предназначенный для распро­странения приложений через Internet, а приложения
состоят из структу­ры пакетов, необходимо предпринять некоторые усилия, чтобы
не про­изошел конфликт имен. Имена двух используемых пакетов могут сов­пасть по
прошествии значительного времени после их создания. Испра­вить такое положение
обычному программисту будет крайне затрудни­тельно.

</p>
<p>Поэтому создатели Java предлагают
следующий способ уникального именования пакетов. Если программа создается
разработчиком, у которо­го есть
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>Internet-сайт, либо же он работает на организацию, у которой име­ется сайт, и
доменное имя такого сайта, например, company.com, то име­на пакетов должны начинаться с этих же слов, выписанных в
обратном порядке: com. company. Дальнейшие вложенные пакеты могут носить на­звания подразделений
компании, пакетов, фамилий разработчиков, име­на компьютеров и т.д.

</p>
<p>Таким образом, пакет верхнего уровня всегда записывается ASCII-буквами в нижнем
регистре и может иметь одно из следующих имен:

</p>
<p>•   
трехбуквенные com, edu, gov, mil, net, org, int (этот список рас­ширяется);

</p>
<p>•   
двухбуквенные,
обозначающие имена стран, такие как ru, su, de, uk и другие.

</p>
<p>Если имя сайта противоречит требованиям к идентификаторам Java, то можно
предпринять следующие шаги:

</p>
<p>•   
если в имени стоит
запрещенный символ, например, тире, то его можно заменить знаком подчеркивания;

</p>
<p>•   
если имя совпадает с
зарезервированным словом, можно в конце добавить знак подчеркивания;

</p>
<p>•   
если имя начинается с
цифры, можно в начале добавить знак под­черкивания.

</p>
<p>Примеры имен пакетов,
составленных по таким правилам: com. sun. image, codec.jpeg

</p>
<p>org.omg.CORBA.ORBPackage

</p>
<p>oracle.jdbc.driver.OracleDriver

</p>
<p>Однако, конечно, никто не требует, чтобы Java-пакеты были обяза­тельно
доступны на Internet-сайте, который дал им имя. Скорее была сделана попытка воспользоваться
существующей системой имен вместо того, чтобы создавать новую для именования
библиотек.

</p>
<p> 

</p>
<p>Область видимости имен

</p>
<p>Областью видимости объявления некоторого элемента языка назы­вается
часть программы, откуда допускается обращение к этому элементу по простому
имени.

</p>
<p>При рассмотрении каждого элемента языка будет указываться его область
видимости, однако имеет смысл собрать эту информацию в од­ном месте.

</p>
<p>Область видимости доступного пакета — вся программа, то есть лю­бой
класс может использовать доступный пакет. Однако необходимо по­мнить, что
обращаться к пакету можно только по его полному составно­му имени. К пакету java.lang ни из какого места нельзя обратиться как к просто lang.

</p>
<p>Областью видимости импортированного типа являются все объявле­ния
верхнего уровня в этом модуле компиляции.

</p>
<p>Областью видимости типа (класса или интерфейса) верхнего уров­ня
является пакет, в котором он объявлен. Из других пакетов доступ возможен либо
по составному имени, либо с помощью импортирующе­го выражения, которое помогает
компилятору воссоздать составное имя.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Область видимости элементов классов или интерфейсов — это все тело типа,
в котором они объявлены. Если обращение к этим эле­ментам происходит из другого
типа, необходимо воспользоваться со­ставным именем. Имя может быть составлено
из простого или состав­ного имени типа, имени объектной переменной или ключевых
слов super или this, после чего через точку указывается простое имя эле­мента.

</p>
<p>Аргументы метода, конструктора или обработчика ошибок видны только
внутри этих конструкций и не могут быть доступы извне.

</p>
<p>Область видимости локальных переменных начинается с момента их
инициализации и до конца блока, в котором они объявлены. В отличие от полей
типов, локальные переменные не имеют значений по умолчанию и должны
инициализироваться явно.

</p>
<p>int х;

</p>
<p>for (int i=0; К10; i++) { int t=5+i;

</p>
<p>}

</p>
<p>//
здесь переменная t уже
недоступна, // так как блок, в котором она была объявлена, // уже завершен, а
переменная х еще недоступна, // так как пока не была инициализирована

</p>
<p>Определенные проблемы возникают, когда происходит
перекрытие областей видимости и возникает конфликт имен различных конструкций
языка.

</p>
<p> 

</p>
<p>"Затеняющее"
объявление (Shadowing)

</p>
<p>Самыми распространенными случаями возникновения конфликта имен являются
выражение, импортирующее пакет, и объявление локальных переменных, или
параметров методов, конструкторов, обработчиков ошибок. Импорт пакета подробно
рассматривался в этой главе. Если им­портированный и текущий пакеты содержат
одноименные типы, то их об­ласти пересекаются. Как уже говорилось, предпочтение
отдается типу из текущего пакета. Также рассказывалось о том, как эту проблему
решать.

</p>
<p>Перейдем к проблеме перекрытия имен полей класса и локальных пе­ременных.
Пример:

</p>
<p>class Human { int age; //возраст int getAgeO { return age;

</p>
<p>}

</p>
<p>void setAge(int age) { age=age; // ???

</p>
<p>}

</p>
<p>}

</p>
<p>В классе Human (человек) объявлено поле age (возраст). Удобно оп­ределить
также метод setAge(), который должен устанавливать новое зна­чение возраста для человека.
Вполне логично сделать у метода setAge() °Дин входной аргумент, который также будет называть age (ведь в качест-Ве этого аргумента будет передаваться новое
значение возраста). Получа­ется, что в реализации метода setAge() нужно написать age=age, в пер­вом случае подразумевая поле класса, во втором - параметр метода
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>
По­нятно, что хотя с точки зрения компилятора это корректная конструкция,
попытка сослаться на две разные переменные через одно имя успехом не
увенчается. Надо заметить, что такие ошибки случаются порой даже у опытных
разработчиков.

</p>
<p>Во-первых, рассмотрим, из-за чего возникла конфликтная ситуа­ция. Есть
два элемента языка — аргумент метода и поле класса, области видимости которых
пересеклись. Область видимости поля класса больше, она охватывает все тело
класса, в то время как область видимости аргу­мента метода включает только сам
метод. В таком случае внутри области пересечения по простому имени доступен
именно аргумент метода, а по­ле класса "затеняется" (shadowing) объявлением параметра метода.

</p>
<p>Остается вопрос, как в такой ситуации все же обратиться к полю класса.
Если доступ по простому имени невозможен, надо воспользо­ваться составным.
Здесь удобнее всего применить специальное ключевое слово this (оно будет подробно рассматриваться в следующих главах). Слово this имеет значение ссылки на объект, внутри которого оно при­меняется. Если
вызвать метод setAge() у объекта класса Human и ис­пользовать в
этом методе слово this, то его значение будет ссылкой на данный объект.

</p>
<p>Исправленный вариант
примера:

</p>
<p> 

</p>
<p>class Human {

</p>
<p>int age;// возраст

</p>
<p> 

</p>
<p>void setAge(int age) {

</p>
<p>this.age=age; // верное
присвоение!

</p>
<p>}

</p>
<p>}

</p>
<p>Конфликт имен, возникающий из-за затеняющего
объявления, до­вольно легко исправить с помощью ключевого слова this или других кон­струкций языка, в зависимости от обстоятельств. Наибольшей
проблемой является то, что компилятор никак не сообщает о таких ситуациях, и са­мое
сложное — выявить ее с помощью тестирования или контрольного просмотра кода.

</p>
<p> 

</p>
<p>"Заслоняющее"
объявление (Obscuring)

</p>
<p>Может возникнуть ситуация, когда простое имя может быть одно­временно
рассмотрено как имя переменной, типа или пакета.

</p>
<p>Приведем пример, который
частично иллюстрирует такой случай:

</p>
<p>import
java.awt.*;

</p>
<p> 

</p>
<p>public class
Obscuring {

</p>
<p>static Point
Test = new Point(3,2); public static void main (String s[]) { print(Test.x);

</p>
<p>}

</p>
<p>}

</p>
<p>class Test {

</p>
<p>static int x = -5;

</p>
<p>}

</p>
<p>В методе main() простое имя Test одновременно
обозначает имя поля класса Obscruing и имя другого типа,
находящегося в том же пакете,-Test. С помощью этого имени происходит обращение к полю х, которое определено
и в классе java.awt.Point и Test.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Результатом этого примера станет 3, то есть переменная имеет более
высокий приоритет. В свою очередь, тип имеет более высокий приоритет, чем
пакет. Таким образом, обращение к доступному в обычных условиях типу или пакету
может оказаться невозможным, если есть объявление од­ноименной переменной или
типа, имеющее более высокий приоритет. Такое объявление называется
"заслоняющим" (obscuring).

</p>
<p>Эта проблема скорее всего не возникнет, если следовать соглашениям по
именованию элементов языка Java.

</p>
<p> 

</p>
<p>Соглашения по именованию

</p>
<p>Для того, чтобы код, написанный на Java, было легко читать
и по­нять не только его автору, но и другим разработчикам, а также для устра­нения
некоторых конфликтов имен, предлагаются следующие соглаше­ния по именованию
элементов языка Java. Стандартные библиотеки и классы Java также следуют им там, где это возможно.

</p>
<p>Соглашения регулируют
именование следующих конструкций:

</p>
<p>•     
пакеты;

</p>
<p>•     
типы (классы и
интерфейсы);

</p>
<p>•     
методы;

</p>
<p>•     
поля;

</p>
<p>•     
поля-константы;

</p>
<p>•     
локальные переменные и параметры
методов и др. Рассмотрим их последовательно.

</p>
<p>Правила построения имен пакетов уже подробно рассматривались в этой
главе. Имя каждого пакета начинается с маленькой буквы и пред­ставляет собой,
как правило, одно недлинное слово. Если требуется со­ставить название из
нескольких слов, можно воспользоваться знаком подчеркивания или начинать
следующее слово с большой буквы. Имя па­кета верхнего уровня обычно
соответствует доменному имени первого уровня. Названия java и javax (Java extension) зарезервированы компа­нией Sun для стандартных
пакетов Java.

</p>
<p>При возникновении ситуации "заслоняющего" объявления (obscur­ing) можно изменить
имя локальной переменной, что не повлечет за со­бой глобальных изменений в
коде. Случай же конфликта с именем типа не должен возникать, согласно правилам
именования типов.

</p>
<p>Имена типов начинаются с большой буквы и могут состоять из не­скольких
слов, каждое следующее слово также начинается с большой буквы. Конечно, надо
стремиться к тому, чтобы имена были описательными, "го­ворящими".

</p>
<p>Имена классов, как
правило, являются существительными: Human

</p>
<p>HighGreenOak

</p>
<p>ArraylndexOutOfBoundsException

</p>
<p> 

</p>
<p>(Последний пример - ошибка, возникающая при использовании индекса
массива, который выходит за границы допустимого.)

</p>
<p>Аналогично задаются имена интерфейсов, хотя они не обязательно должны
быть существительными. Часто используется английский суф­фикс "able:":

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Runnable

</p>
<p>Serializable

</p>
<p>Cloneable

</p>
<p> 

</p>
<p>Проблема "заслоняющего" объявления (obscuring) для типов встреча­ется редко, так как имена пакетов и локальных переменных
(параметров) начинаются с маленькой буквы, а типов — с большой.

</p>
<p>Имена методов должны быть глаголами и обозначать действия, которые
совершает данный метод. Имя должно начинаться с маленькой буквы, но мо­жет
состоять из нескольких слов, причем каждое следующее слово начинает­ся с
заглавной буквы. Существует ряд принятых названий для методов:

</p>
<p>•   
если методы предназначены
для чтения и изменения значения пе­ременной, то их имена начинаются,
соответственно, с get и set, например, для
переменной size это будут getSizeO и setSize();

</p>
<p>•    -метод, возвращающий длину, называется length(), например, в классе String;

</p>
<p> 

</p>
<p>•    
имя метода, который
проверяет булевское условие, начинается с is, например, isVisibleO у компонента
графического пользова­тельского интерфейса;

</p>
<p>•     метод, который преобразует величину в формат F, называется toF(), например, метод
toSting(), который приводит любой объект к строке.

</p>
<p>Вообще, рекомендуется везде, где возможно, называть методы похо­жим
образом, как в стандартных классах Java, чтобы они были
понятны всем разработчикам.

</p>
<p>Поля класса имеют имена, записываемые в том же стиле, что и для методов,
начинаются с маленькой буквы, могут состоять из нескольких слов, каждое
следующее слово начинается с заглавной буквы. Имена должны быть
существительными, например, поле name в классе Human, или size в классе Planet.

</p>
<p>Как для полей решается проблема "заслоняющего" объявления (obscuring), уже обсуждалось.

</p>
<p>Поля могут быть константами, если в их объявлении стоит ключевое слово final. Их имена состоят
из последовательности слов, сокращений, аббревиатур. Записываются они только
большими буквами, слова разде­ляются знаками подчеркивания:

</p>
<p> 

</p>
<p>PI

</p>
<p>MINVALUE MAXVALUE

</p>
<p>Иногда константы образуют группу, тогда рекомендуется использо­вать одно
или несколько одинаковых слов в начале имен:

</p>
<p> 

</p>
<p>COLOR_RED

</p>
<p>COLORJ3REEN

</p>
<p>COLOR_BLUE

</p>
<p>Наконец, рассмотрим имена локальных переменных и
параметров методов, конструкторов и обработчиков ошибок. Они, как правило, до­вольно
короткие, но, тем не менее, должны быть осмыслены. Например, можно использовать
аббревиатуру (имя ср для ссылки на экземпляр клас­са ColorPoint) или сокращение (buf для buffer).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Распространенные
однобуквенные сокращения:

</p>
<p> 

</p>
<p>byte b; char с; inti,j,k; long I;

</p>
<p>float f; double d; Object o; String s;

</p>
<p>Exception e; // объект, представляющий ошибку в Java

</p>
<p>Двух- и трехбуквенные имена не должны совпадать с принятыми до­менными
именами первого уровня Internet-сайтов.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой главе был рассмотрен механизм именования элементов языка. Для
того, чтобы различные части большой системы не зависели друг от дру­га,
вводится понятие "область видимости имени", вне которой необходимо
использовать не простое, а составное имя. Затем были изучены элементы (members), которые могут быть у пакетов и ссылочных типов. Также рас­сматривалась
связь терминов "идентификатор" (из темы "Лексика") и имя.

</p>
<p>Затем были рассмотрены пакеты, которые используются в Java для создания
физической и логической структуры классов, а также для более точного
разграничения области видимости. Пакет содержит вложенные пакеты и типы (классы
и интерфейсы). Вопрос о платформенной под­держке пакетов привел к рассмотрению
модулей компиляции как тексто­вых файлов, поскольку именно в виде файлов и
каталогов, как правило, хранятся и распространяются Java-приложения. Тогда
же впервые был рассмотрен вопрос разграничения доступа, так как доступ к
модулям компиляции определяется именно платформенной поддержкой, а точнее -
операционной системой.

</p>
<p>Модуль компиляции состоит из трех основных частей — объявление пакета,
импорт-выражения и объявления верхнего уровня. Важную роль иг­рает безымянный
пакет, или пакет по умолчанию, хотя он и не рекоменду­ется для применения при
создании больших систем. Были изучены детали применения двух видов
импорт-выражений - импорт класса и импорт па­кета. Наконец, было начато рассмотрение
объявлений верхнего уровня (эта тема будет продолжена в главе, описывающей
объявление классов). Паке­ты, как и другие элементы языка, имеют определенные
соглашения по име­нованию, призванные облегчить понимание кода и уменьшить
возмож­ность возникновения ошибок и двусмысленных ситуаций в программе.

</p>
<p>Описание области видимости для различных элементов языка приводит к
вопросу о возможных перекрытиях таких областей и, как следствие, о кон­фликтах
имен. Рассматриваются "затеняющие" и "заслоняющие" объявления.
Для устранения или уменьшения возможности возникновения таких ситуа­ций
описываются соглашения по именованию для всех элементов языка.

</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Что из перечисленных ниже слов является простым именем?

</p>
<p> 

</p>
<p>МуОазэ.пате

</p>
<p>МуС1а58.пате.т,о5тгтд()

</p>
<p>Муаазз.пате^оБтгтдО.пазпСоаеО

</p>
<p>&#9633;       
МуС^ээ

</p>
<p>&#9633;       
пате

</p>
<p>&#9633;          
1оБМпд

</p>
<p>&#9633;       
ЬаэпСос-е

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Могут ли пакет и вложенные пакеты содержать одноименные классы?

</p>
<p>&#9633;       
да

</p>
<p>&#9633;       
нет








</p>
<p>3.   Корректен
ли объявленный ниже класс? Если нет, то как его можно исправить? class Box {

</p>
<p>private int weight=0; public int getWeight() { return weight;

</p>
<p>}

</p>
<p>void setWieght(int weight) { weigh t=weigth;

</p>
<p>}

</p>
<p>}

</p>
<p>П   пример
корректен, ничего исправлять не нужно

</p>
<p>Г~1   пример
некорректен, конфликт имен в методе setWeight требует переименования поля или
аргумента

</p>
<p>П   пример
корректен, однако конфликт имен в методе setWeight требует переименования поля или
аргумента

</p>
<p>Г~1   пример корректен, однако конфликт имен
в методе setWeight требует
переименования поля или аргумента, либо использования выражения this

</p>
<p>&#9633;  
пример корректен, однако конфликт имен в методе setWeight требует переименования поля или
аргумента, либо использования выражений this или
super

</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Что из перечисленных ниже слов является составным именем? Му-ГЛавв
МуС1а88.пате
МуС1а88.пате.т.о51гтд()
МуС1а85.пате.т.о51ппд().»1а811(^е()

</p>
<p>&#9633;       
МуОаээ.пате

</p>
<p>&#9633;       
МуГЛазэ.пате.т-оЗтпд

</p>
<p>&#9633;       
МуФазз.патеЛобгппдО.пазгЮойе

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Программист располагает свою программу в каталоге c:\work.
Программа состоит из одного класса demo.Start.
Как нужно расположить файл .java и
как запускать компилятор javac?

</p>
<p>&#9633;       c:\work\Start.java, запустить
компилятор из каталога c:\work javac Start.java

</p>
<p>&#9633;       c:\work\demo\Start.java, запустить
компилятор из каталога c:\work\demo

</p>
<p>javac Start.java

</p>
<p>П   c:\work\demo\Start.java, запустить
компилятор из каталога c:\work

</p>
<p>javac demo\Start.java

</p>
<p>&#9633;       c:\work\demo\Start.java, запустить
компилятор из каталога c:\work

</p>
<p>javac demo.Start

</p>
<p>3.   Как в предыдущем вопросе следует расположить файл .class и как запускать виртуальную
машину java?

</p>
<p>П   c:\work\Start.class, запустить JVM из каталога c:\work java Start

</p>
<p>П   c:\work\demo\Start.class, запустить JVM из каталога c:\work\demo java Start

</p>
<p>&#9633;          
c:\work\demo\Start.class, запустить JVM из c:\work: java demo\Start.class

</p>
<p>&#9633;          
c:\work\demo\Start.class, запустить JVM из c:\work: Java demo.Start

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1.       Что
из перечисленных ниже слов является
идентификатором?

</p>
<p>MyClass

</p>
<p>MyClass.name

</p>
<p>MyClass.name.toStringO

</p>
<p>MyClass.name.toString().hashCode()

</p>
<p>&#9633;          
MyClass l~l   name

</p>
<p>&#9633;          
toString

</p>
<p>&#9633;          
hashCode

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Ниже
приведено несколько вариантов записи модуля
компиляции. Какие из них корректны, если предполагается
описать класс Point из пакета test.demo, причем класс
активно использует классы java.awt.Point и несколько
классов из пакета java.net?

</p>
<p>О   package test.demo;
import java.awt.Point; importjava.net.*;

</p>
<p>П import java.awt.*; importjava.net.*; package
test.demo;

</p>
<p>П   package test.demo; importjava.net.*; import
java.awt.*;

</p>
<p>П   package test.demo.* importjava.net.*; import
java.awt.*;








</p>
<p>3.   Какие формальные нарушения
соглашений по

</p>
<p>именованию
присутствуют в следующем примере: public class flat{

</p>
<p>private int floor_number; private int г; // количество комнат public int roomsO { retun r;

</p>
<p>}

</p>
<p>public int
GetFloorNumberO { return floor_number;

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;       
класс назван с прописной буквы,
должно быть Flat

</p>
<p>&#9633;       
имя поля floor_number содержит два слова, разделенных
знаком подчеркивания, должно быть FloorNumbe

</p>
<p>&#9633;       
имя поля г состоит из одной
буквы, а оно должно быть более понятным, например, rooms или roomsNumber

</p>
<p>&#9633;       
другие нарушения

</p>
<p>
</p>
<center> 
</center>
    </div>