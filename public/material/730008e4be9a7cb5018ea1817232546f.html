# encoding: windows-1251







<p>Лекция знакомит с наиболее важными модулями и пакетами стандартных библиотек Python в мере, достаточной для свободного ориентирования в них.</p>
<p>Одним из важных преимуществ языка Python является наличие большой библиотеки модулей и пакетов, входящих в стандартную поставку. Как говорят, к Python «приложены батарейки».</p>
<p>Понятие модуля</p>
<p>Перед тем как приступить к изучению модулей стандартной библиотеки, необходимо определить то, что в Python называется модулем.</p>
<p>В соответствии с модульным подходом к программированию большая задача разбивается на несколько более мелких, каждую из которых (в идеале) решает отдельный модуль. В разных методологиях даются различные ограничения на размер модулей, однако при построении модульной структуры программы важнее составить такую композицию модулей, которая позволила бы свести к минимуму связи между ними. Набор классов и функций, имеющий множество связей между своими элементами, было бы логично расположить в одном модуле. Есть и еще одно полезное замечание: модули должно быть легче использовать, чем написать заново. Это значит, что модуль должен иметь удобный интерфейс: набор функций, классов и констант, который он предлагает своим пользователям.</p>
<p>В языке Python набор модулей, посвященных одной проблеме, можно поместить в пакет. Хорошим примером такого пакета является пакет xml, в котором собраны модули для различных аспектов обработки XML.</p>
<p>В программе на Python модуль представлен объектом–модулем, атрибутами которого являются имена, определенные в модуле:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import datetime</p>
<p>&gt;&gt;&gt; d1 = datetime.date(2004, 11, 20)</p>
<p>В данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется объект с именем datetime.</p>
<p>Модули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, например, модули pickle и cPickle. Обычно модули на Python в чем–то гибче, чем модули расширения.</p>
<p>Модули в Python</p>
<p>Модуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти соответствующий интерпретатор языка. Пути к каталогам, в которых Python ищет модули, можно увидеть в значении переменной sys.path:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; sys.path</p>
<p>['', '/usr/local/lib/python23.zip', '/usr/local/lib/python2.3',</p>
<p>'/usr/local/lib/python2.3/plat–linux2', '/usr/local/lib/python2.3/lib–tk',</p>
<p>'/usr/local/lib/python2.3/lib–dynload',</p>
<p>'/usr/local/lib/python2.3/site–packages']</p>
<p>В последних версиях Python модули можно помещать и в zip–архивы для более компактного хранения (по аналогии с jar–архивами в Java).</p>
<p>При запуске программы поиск модулей также идет в текущем каталоге. (Нужно внимательно называть собственные модули, чтобы не было конфликта имен со стандартными или дополнительно установленными модулями.)</p>
<p>Подключение модуля к программе на Python осуществляется с помощью оператора import. У него есть две формы: import и from–import:</p>
<p>Листинг</p>
<p>import os</p>
<p>import pre as re</p>
<p>from sys import argv, environ</p>
<p>from string import *</p>
<p>С помощью первой формы с текущей областью видимости связывается только имя, ссылающееся на объект модуля, а при использовании второй — указанные имена (или все имена, если применена *) объектов модуля связываются с текущей областью видимости. При импорте можно изменить имя, с которым объект будет связан, с помощью as. В первом случае пространство имен модуля остается в отдельном имени и для доступа к конкретному имени из модуля нужно применять точку. Во втором случае имена используются так, как если бы они были определены в текущем модуле:</p>
<p>Листинг</p>
<p>os.system(«dir»)</p>
<p>digits = re.compile("\d+»)</p>
<p>print argv[0], environ</p>
<p>Повторный импорт модуля происходит гораздо быстрее, так как модули кэшируются интерпретатором. Загруженный модуль можно загрузить еще раз (например, если модуль изменился на диске) с помощью функции reload():</p>
<p>Листинг</p>
<p>import mymodule</p>
<p>…</p>
<p>reload(mymodule)</p>
<p>Однако в этом случае все объекты, являющиеся экземплярами классов из старого варианта модуля, не изменят своего поведения.</p>
<p>При работе с модулями есть и другие тонкости. Например, сам процесс импорта модуля можно переопределить. Подробнее об этом можно узнать в оригинальной документации.</p>
<p>Встроенные функции</p>
<p>В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. Для удобства функции условно разделены по категориям:</p>
<p>Функции преобразования типов и классы: coerce, str, repr, int, list, tuple, long, float, complex, dict, super, file, bool, object</p>
<p>Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode</p>
<p>Функции обработки данных: apply, map, filter, reduce, zip, range, xrange, max, min, iter, enumerate, sum</p>
<p>Функции определения свойств: hash, id, callable, issubclass, isinstance, type</p>
<p>Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir</p>
<p>Функции компиляции и исполнения: eval, execfile, reload, __import__, compile</p>
<p>Функции ввода–вывода: input, raw_input, open</p>
<p>Функции для работы с атрибутами: getattr, setattr, delattr, hasattr</p>
<p>Функции — «украшатели» методов классов: staticmethod, classmethod, property</p>
<p>Прочие функции: buffer, slice</p>
<p>Совет:</p>
<p>Уточнить назначение функции, ее аргументов и результата можно в интерактивной сессии интерпретатора Python:</p>
<p>&gt;&gt;&gt; help(len)</p>
<p>Help on built–in function len:</p>
<p>len(…)</p>
<p>len(object) -&gt; integer</p>
<p>Return the number of items of a sequence or mapping.Или так:</p>
<p>&gt;&gt;&gt; print len.__doc__</p>
<p>len(object) -&gt; integer</p>
<p>Return the number of items of a sequence or mapping.</p>
<p>Функции преобразования типов и классы</p>
<p>Функции и классы из этой категории служат для преобразования типов данных. В старых версиях Python для преобразования к нужному типу использовалась одноименная функция. В новых версиях Python роль таких функций играют имена встроенных классов (однако семантика не изменилась). Для понимания сути достаточно небольшого примера:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; int(23.5)</p>
<p>23</p>
<p>&gt;&gt;&gt; float('12.345')</p>
<p>12.345000000000001</p>
<p>&gt;&gt;&gt; dict([('a', 2), ('b', 3)])</p>
<p>{'a': 2, 'b': 3}</p>
<p>&gt;&gt;&gt; object</p>
<p>&lt;type 'object'&gt;</p>
<p>&gt;&gt;&gt; class MyObject(object):</p>
<p>… pass</p>
<p>…</p>
<p>Числовые и строковые функции</p>
<p>Функции работают с числовыми или строковыми аргументами. В следующей таблице даны описания этих функций.</p>
<p>abs(x) Модуль числа x. Результат: |x|.</p>
<p>divmod(x, y) Частное и остаток от деления. Результат: (частное, остаток).</p>
<p>pow(x, y[, m]) Возведение x в степень y по модулю m. Результат: x**y % m.</p>
<p>round(n[, z]) Округление чисел до заданного знака после (или до) точки.</p>
<p>ord(s) Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.</p>
<p>chr(n) Возвращает строку с символом с заданным кодом.</p>
<p>len(s) Возвращает число элементов последовательности или отображения.</p>
<p>oct(n), hex(n) Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.</p>
<p>cmp(x, y) Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата сравнения.</p>
<p>unichr(n) Возвращает односимвольную Unicode–строку с символом с кодом n.</p>
<p>unicode(s, [, encoding[, errors]]) Создает Unicode–объект, соответствующий строке s в заданной кодировке encoding. Ошибки кодирования обрабатываются в соответствии с errors, который может принимать значения: 'strict' (строгое преобразование), 'replace' (с заменой несуществующих символов) или 'ignore' (игнорировать несуществующие символы). По умолчанию: encoding='utf–8', errors='strict'.</p>
<p>Следующий пример строит таблицу кодировки кириллических букв в Unicode:</p>
<p>Листинг</p>
<p>print «Таблица Unicode (русские буквы)».center(18*4)</p>
<p>i = 0</p>
<p>for c in «АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ»\</p>
<p>«абвгдежзийклмнопрстуфхцчшщъыьэюя»:</p>
<p>u = unicode(c, 'koi8–r')</p>
<p>print "%3i: %1s %s» % (ord(u), c, `u`),</p>
<p>i += 1</p>
<p>if i % 4 == 0:</p>
<p>print</p>
<p>Функции обработки данных</p>
<p>Эти функции подробнее будут рассмотрены в лекции по функциональному программированию. Пример с функциями range() и enumerate():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; for i, c in enumerate(«ABC»):</p>
<p>… print i, c</p>
<p>…</p>
<p>0 A</p>
<p>1 B</p>
<p>2 C</p>
<p>&gt;&gt;&gt; print range(4, 20, 2)</p>
<p>[4, 6, 8, 10, 12, 14, 16, 18]</p>
<p>Функции определения свойств</p>
<p>Эти функции обеспечивают доступ к некоторым встроенным атрибутам объектов и другим свойствам. Следующий пример показывает некоторые из этих функций:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = «abcde»</p>
<p>&gt;&gt;&gt; s1 = «abcde»</p>
<p>&gt;&gt;&gt; s2 = «ab» + «cde»</p>
<p>&gt;&gt;&gt; print «hash:", hash(s), hash(s1), hash(s2)</p>
<p>hash: — 1332677140–1332677140–1332677140</p>
<p>&gt;&gt;&gt; print «id:", id(s), id(s1), id(s2)</p>
<p>id: 1076618592 1076618592 1076618656</p>
<p>Здесь, можно увидеть, что для одного и того же строкового литерала «abcde» получается один и тот же объект, тогда как для одинаковых по значению объектов вполне можно получить разные объекты.</p>
<p>Функции для доступа к внутренним структурам</p>
<p>В современной реализации языка Python глобальные и локальные переменные доступны в виде словаря благодаря функциям globals() и locals(). Правда, записывать что–либо в эти словари не рекомендуется.</p>
<p>Функция vars() возвращает таблицу локальных имен некоторого объекта (если параметр не задан, она возвращает то же, что и locals()). Обычно используется в качестве словаря для операции форматирования:</p>
<p>Листинг</p>
<p>a = 1</p>
<p>b = 2</p>
<p>c = 3</p>
<p>print "%(a)s + %(b)s = %(c)s» % vars()</p>
<p>Функции компиляции и исполнения</p>
<p>Функция reload() уже рассматривалась, а из остальных функций этой категории особого внимания заслуживает eval(). Как следует из названия, эта функция вычисляет переданное ей выражение. В примере ниже вычисляется выражение, которое строится динамически:</p>
<p>Листинг</p>
<p>a = 2</p>
<p>b = 3</p>
<p>for op in «+-*/%":</p>
<p>e = «a " + op + " b»</p>
<p>print e, «-&gt;", eval(e)</p>
<p>У функции eval() кроме подлежащего вычислению выражения есть еще два параметра — с их помощью можно задать глобальное и локальное пространства имен, из которых будут разрешаться имена выражения. Пример выше, переписанный для использования с собственным словарем имен в качестве глобального пространства имен:</p>
<p>Листинг</p>
<p>for op in «+-*/%":</p>
<p>e = «a " + op + " b»</p>
<p>print e, «-&gt;", eval(e, {'a': 2, 'b': 3})</p>
<p>Функцией eval() легко злоупотребить. Нужно стараться использовать ее только тогда, когда без нее не обойтись. Из соображений безопасности не следует применять eval() для аргумента, в котором присутствует непроверенный ввод от пользователя.</p>
<p>Функции ввода–вывода</p>
<p>Функции input() и raw_input() используются для ввода со стандартного ввода. В серьезных программах их лучше не применять. Функция open() служит для открытия файла по имени для чтения, записи или изменения. В следующем примере файл открывается для чтения:</p>
<p>Листинг</p>
<p>f = open(«file.txt», «r», 1)</p>
<p>for line in f:</p>
<p>…</p>
<p>f.close()</p>
<p>Функция принимает три аргумента: имя файла (путь к файлу), режим открытия («r» — чтение, «w» — запись, «a» — добавление или «w+», «a+», «r+» — изменение. Также может прибавляться «t», что обозначает текстовый файл. Это имеет значение только на платформе Windows). Третий аргумент указывает режим буферизации: 0 — без буферизации, 1 — построчная буферизация, больше 1 — буфер указанного размера в байтах.</p>
<p>В новых версиях Python функция open() является синонимом для file().</p>
<p>Функции для работы с атрибутами</p>
<p>У объектов в языке Python могут быть атрибуты (в терминологии языка C++ - члены–данные и члены–функции). Следующие две программы эквивалентны:</p>
<p>Листинг</p>
<p># первая программа:</p>
<p>class A:</p>
<p>pass</p>
<p>a = A()</p>
<p>a.attr = 1</p>
<p>try:</p>
<p>print a.attr</p>
<p>except:</p>
<p>print None</p>
<p>del a.attr</p>
<p># вторая программа:</p>
<p>class A:</p>
<p>pass</p>
<p>a = A()</p>
<p>setattr(a, 'attr', 1)</p>
<p>if hasattr(a, 'attr'):</p>
<p>print getattr(a, 'attr')</p>
<p>else:</p>
<p>print None</p>
<p>delattr(a, 'attr')</p>
<p>Функции — «украшатели» методов классов</p>
<p>Эти функции будут рассмотрены в лекции, посвященной ООП.</p>
<p>Обзор стандартной библиотеки</p>
<p>Модули стандартной библиотеки можно условно разбить на группы по тематике.</p>
<p>Сервисы периода выполнения. Модули: sys, atexit, copy, traceback, math, cmath, random, time, calendar, datetime, sets, array, struct, itertools, locale, gettext.</p>
<p>Поддержка цикла разработки. Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.</p>
<p>Взаимодействие с ОС (файлы, процессы). Модули: os, os.path, getopt, glob, popen2, shutil, select, signal, stat, tempfile.</p>
<p>Обработка текстов. Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. Пакет xml.</p>
<p>Многопоточные вычисления. Модули: threading, thread, Queue.</p>
<p>Хранение данных. Архивация. Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.</p>
<p>Платформо–зависимые модули. Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.</p>
<p>Поддержка сети. Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.</p>
<p>Поддержка Internet. Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет email.</p>
<p>Python о себе. Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.</p>
<p>Графический интерфейс. Модуль Tkinter.</p>
<p>Примечание:</p>
<p>Очень часто модули содержат один или несколько классов, с помощью которых создается объект нужного типа, а затем речь идет уже не об именах из модуля, а об атрибутах этого объекта. И наоборот, некоторые модули содержат лишь функции, слишком общие для того, чтобы работать над произвольными объектами (либо достаточно большой категорией объектов).</p>
<p>Сервисы периода выполнения</p>
<p>Модуль sys</p>
<p>Модуль sys содержит информацию о среде выполнения программы, об интерпретаторе Python. Далее будут представлены наиболее популярные объекты из этого модуля: остальное можно изучить по документации.</p>
<p>exit([c]) Выход из программы. Можно передать числовой код завершения: 0 в случае успешного завершения, другие числа при аварийном завершении программы.</p>
<p>argv Список аргументов командной строки. Обычно sys.argv[0] содержит имя запущенной программы, а остальные параметры передаются из командной строки.</p>
<p>platform Платформа, на которой работает интерпретатор.</p>
<p>stdin, stdout, stderr Стандартный ввод, вывод, вывод ошибок. Открытые файловые объекты.</p>
<p>version Версия интерпретатора.</p>
<p>setrecursionlimit(limit) Установка уровня максимальной вложенности рекурсивных вызовов.</p>
<p>exc_info() Информация об обрабатываемом исключении.</p>
<p>Модуль copy</p>
<p>Этот модуль содержит функции для копирования объектов. Вначале предлагается к рассмотрению «парадокс», который вводит в замешательство новичков в Python:</p>
<p>Листинг</p>
<p>lst1 = [0, 0, 0]</p>
<p>lst = [lst1] * 3</p>
<p>print lst</p>
<p>lst[0][1] = 1</p>
<p>print lst</p>
<p>В результате получается, возможно, не то, что ожидалось:</p>
<p>Листинг</p>
<p>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</p>
<p>[[0, 1, 0], [0, 1, 0], [0, 1, 0]]</p>
<p>Дело в том, что список lst содержит ссылки на один и тот же список! Для того чтобы действительно размножить список, необходимо применить функцию copy() из модуля copy:</p>
<p>Листинг</p>
<p>from copy import copy</p>
<p>lst1 = [0, 0, 0]</p>
<p>lst = [copy(lst1) for i in range(3)]</p>
<p>print lst</p>
<p>lst[0][1] = 1</p>
<p>print lst</p>
<p>Теперь результат тот, который ожидался:</p>
<p>Листинг</p>
<p>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</p>
<p>[[0, 1, 0], [0, 0, 0], [0, 0, 0]]</p>
<p>В модуле copy есть еще и функция deepcopy() для глубокого копирования, при которой объекты копируются на всю возможную глубину, рекурсивно.</p>
<p>Модули math и cmath</p>
<p>В этих модулях собраны математические функции для действительных и комплексных аргументов. Это те же функции, что используются в языке C. В таблице ниже даны функции модуля math. Там, где аргумент обозначен буквой z, аналогичная функция определена и в модуле cmath.</p>
<p>Функция или константа Описание</p>
<p>acos(z) арккосинус z</p>
<p>asin(z) арксинус z</p>
<p>atan(z) арктангенс z</p>
<p>atan2(y,x) atan(y/x)</p>
<p>ceil(x) наименьшее целое, большее или равное x</p>
<p>cos(z) косинус z</p>
<p>cosh(x) гиперболический косинус x</p>
<p>e константа e</p>
<p>exp(z) экспонента (то есть, e**z)</p>
<p>fabs(x) абсолютное значение x</p>
<p>floor(x) наибольшее целое, меньшее или равное x</p>
<p>fmod(x,y) остаток от деления x на y</p>
<p>frexp(x) возвращает мантиссу и порядок x как пару (m, i), где m — число с плавающей точкой, а i — целое, такое, что x = m * 2.**i. Если 0, возвращает (0,0), иначе 0.5 &lt;= abs(m) &lt; 1.0</p>
<p>hypot(x,y) sqrt(x*x + y*y)</p>
<p>ldexp(m,i) m * (2**i)</p>
<p>log(z) натуральный логарифм z</p>
<p>log10(z) десятичный логарифм z</p>
<p>modf(x) возвращает пару (y,q) - целую и дробную часть x. Обе части имеют знак исходного числа</p>
<p>pi константа пи</p>
<p>pow(x,y) x**y</p>
<p>sin(z) синус z</p>
<p>sinh(z) гиперболический синус z</p>
<p>sqrt(z) корень квадратный от z</p>
<p>tan(z) тангенс z</p>
<p>tanh(z) гиперболический тангенс z</p>
<p>Модуль random</p>
<p>Этот модуль генерирует псевдослучайные числа для нескольких различных распределений. Наиболее используемые функции:</p>
<p>random() Генерирует псевдослучайное число из полуоткрытого диапазона [0.0, 1.0).</p>
<p>choice(s) Выбирает случайный элемент из последовательности s.</p>
<p>shuffle(s) Размешивает элементы изменчивой последовательности s на месте.</p>
<p>randrange([start,] stop[, step]) Выдает случайное целое число из диапазона range(start, stop, step). Аналогично choice(range(start, stop, step)).</p>
<p>normalvariate(mu, sigma) Выдает число из последовательности нормально распределенных псевдослучайных чисел. Здесь mu — среднее, sigma — среднеквадратическое отклонение (sigma &gt; 0)</p>
<p>Остальные функции и их параметры можно уточнить по документации. Следует отметить, что в модуле есть функция seed(n), которая позволяет установить генератор случайных чисел в некоторое состояние. Например, если возникнет необходимость многократного использования одной и той же последовательности псевдослучайных чисел.</p>
<p>Модуль time</p>
<p>Этот модуль дает функции для получения текущего времени и преобразования форматов времени.</p>
<p>Модуль sets</p>
<p>Модуль реализует тип данных для множеств. Следующий пример показывает, как использовать этот модуль. Следует заметить, что в Python 2.4 и старше тип set стал встроенным, и вместо sets.Set можно использовать set:</p>
<p>Листинг</p>
<p>import sets</p>
<p>A = sets.Set([1, 2, 3])</p>
<p>B = sets.Set([2, 3, 4])</p>
<p>print A | B, A &amp; B, A — B, A ^ B</p>
<p>for i in A:</p>
<p>if i in B:</p>
<p>print i,</p>
<p>В результате будет выведено:</p>
<p>Листинг</p>
<p>Set([1, 2, 3, 4]) Set([2, 3]) Set([1]) Set([1, 4])</p>
<p>2 3</p>
<p>Модули array и struct</p>
<p>Эти модули реализуют низкоуровневый массив и структуру данных. Основное их назначение — разбор двоичных форматов данных.</p>
<p>Модуль itertools</p>
<p>Этот модуль содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как если бы они получались в цикле. Альтернативный подход — использование списков для хранения промежуточных результатов — требует подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они действительно требуются для дальнейших вычислений. Итераторы будут рассмотрены более подробно в лекции по функциональному программированию.</p>
<p>Модуль locale</p>
<p>Модуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для написания чисел, валют, времени и даты и т.п. Следующий пример выводит дату сначала в культурной среде «C», а затем на русском языке:</p>
<p>Листинг</p>
<p>import time, locale</p>
<p>locale.setlocale(locale.LC_ALL, None)</p>
<p>print time.strftime("%d %B %Y», time.localtime (time.time()))</p>
<p>locale.setlocale(locale.LC_ALL, «ru_RU.KOI8–R»)</p>
<p>print time.strftime("%d %B %Y», time.localtime (time.time()))</p>
<p>В результате:</p>
<p>Листинг</p>
<p>18 November 2004</p>
<p>18 Ноября 2004</p>
<p>Модуль gettext</p>
<p>При интернационализации программы важно не только предусмотреть возможность использования нескольких культурных сред, но и перевод сообщений и меню программы на соответствующий язык. Модуль gettext позволяет упростить этот процесс достаточно стандартным способом. Основные сообщения программы пишутся на английском языке. А переводы строк, отмеченных в программе специальным образом, даются в виде отдельных файлов, по одному на каждый язык (или культурную среду). Уточнить нюансы использования gettext можно по документации к Python.</p>
<p>Поддержка цикла разработки</p>
<p>Модули этого раздела помогают поддерживать документацию, производить регрессионное тестирование, отлаживать и профилировать программы на Python, а также обслуживают распространение готовых программ, создавая среду для конфигурирования и установки пакетов.</p>
<p>В качестве иллюстрации можно предположить, что создается модуль для вычисления простых чисел по алгоритму «решето Эратосфена». Модуль будет находиться в файле Sieve.py и состоять из одной функции primes(N), которая в результате своей работы дает все простые (не имеющие натуральных делителей кроме себя и единицы) числа от 2 до N:</p>
<p>Листинг</p>
<p>import sets</p>
<p>import math</p>
<p>""«Модуль для вычисления простых чисел от 2 до N """</p>
<p>def primes(N):</p>
<p>«"«Возвращает все простые от 2 до N»""</p>
<p>sieve = sets.Set(range(2, N))</p>
<p>for i in range(2, math.sqrt(N)):</p>
<p>if i in sieve:</p>
<p>sieve -= sets.Set(range(2*i, N, i))</p>
<p>return sieve</p>
<p>Модуль pdb</p>
<p>Модуль pdb предоставляет функции отладчика с интерфейсом — командной строкой. Сессия отладки вышеприведенного модуля могла бы быть такой:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import pdb</p>
<p>&gt;&gt;&gt; pdb.runcall(Sieve.primes, 100)</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(15)primes()</p>
<p>— &gt; sieve = sets.Set(range(2, N))</p>
<p>(Pdb) l</p>
<p>10 import sets</p>
<p>11 import math</p>
<p>12 ""«Модуль для вычисления простых чисел от 2 до N """</p>
<p>13 def primes(N):</p>
<p>14 ""«Возвращает все простые от 2 до N»""</p>
<p>15 -&gt; sieve = sets.Set(range(2, N))</p>
<p>16 for i in range(2, int(math.sqrt(N))):</p>
<p>17 if i in sieve:</p>
<p>18 sieve -= sets.Set(range(2*i, N, i))</p>
<p>19 return sieve</p>
<p>20</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(16)primes()</p>
<p>— &gt; for i in range(2, int(math.sqrt(N))):</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(17)primes()</p>
<p>— &gt; if i in sieve:</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(18)primes()</p>
<p>— &gt; sieve -= sets.Set(range(2*i, N, i))</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(16)primes()</p>
<p>— &gt; for i in range(2, int(math.sqrt(N))):</p>
<p>(Pdb) p sieve</p>
<p>Set([2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39,</p>
<p>41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79,</p>
<p>81, 83, 85, 87, 89, 91, 93, 95, 97, 99])</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(17)primes()</p>
<p>— &gt; if i in sieve:</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(18)primes()</p>
<p>— &gt; sieve -= sets.Set(range(2*i, N, i))</p>
<p>(Pdb) n</p>
<p>&gt; /home/rnd/workup/intuit–python/examples/Sieve.py(16)primes()</p>
<p>— &gt; for i in range(2, int(math.sqrt(N))):</p>
<p>(Pdb) p sieve</p>
<p>Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37, 41, 43, 47, 49,</p>
<p>53, 55, 59, 61, 65, 67, 71, 73, 77, 79, 83, 85, 89, 91, 95, 97])</p>
<p>Модуль profile</p>
<p>С помощью профайлера разработчики программного обеспечения могут узнать, сколько времени занимает исполнение различных функций и методов.</p>
<p>Продолжая пример с решетом Эратосфена, стоит посмотреть, как тратится процессорное время при вызове функции primes():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; profile.run(«Sieve.primes(100000)»)</p>
<p>709 function calls in 1.320 CPU seconds</p>
<p>Ordered by: standard name</p>
<p>ncalls tottime percall cumtime percall filename:lineno(function)</p>
<p>1 0.010 0.010 1.320 1.320 &lt;string&gt;:1(?)</p>
<p>1 0.140 0.140 1.310 1.310 Sieve.py:13(primes)</p>
<p>1 0.000 0.000 1.320 1.320 profile:0(Sieve.primes(100000))</p>
<p>0 0.000 0.000 profile:0(profiler)</p>
<p>65 0.000 0.000 0.000 0.000 sets.py:119(__iter__)</p>
<p>314 0.000 0.000 0.000 0.000 sets.py:292(__contains__)</p>
<p>65 0.000 0.000 0.000 0.000 sets.py:339(_binary_sanity_check)</p>
<p>66 0.630 0.010 0.630 0.010 sets.py:356(_update)</p>
<p>66 0.000 0.000 0.630 0.010 sets.py:425(__init__)</p>
<p>65 0.010 0.000 0.540 0.008 sets.py:489(__isub__)</p>
<p>65 0.530 0.008 0.530 0.008 sets.py:495(difference_update)</p>
<p>Здесь ncalls — количество вызовов функции или метода, tottime — полное время выполнения кода функции (без времени нахождения в вызываемых функциях), percall — тоже, в пересчете на один вызов, cumtime — аккумулированное время нахождения в функции, вместе со всеми вызываемыми функциями. В последнем столбце приведено имя файла, номер строки с функцией или методов и его имя.</p>
<p>Примечание:</p>
<p>«Странные» имена, например, __iter__, __contains__ и __isub__ - имена методов, реализующих итерацию по элементам, проверку принадлежности элемента (in) и операцию -=. Метод __init__ - конструктор объекта (в данном случае — множества).</p>
<p>Модуль unittest</p>
<p>При разработке программного обеспечения рекомендуется применять так называемые регрессионные испытания. Для каждого модуля составляется набор тестов, по возможности таким образом, чтобы проверялись не только типичные вычисления, но и «крайние», вырожденные случаи, чтобы испытания затронули каждую ветку алгоритма хотя бы один раз. Тест для данного модуля (написанный сразу после того, как определен интерфейс модуля) находится в файле test_Sieve.py:</p>
<p>Листинг</p>
<p># file: test_Sieve.py</p>
<p>import Sieve, sets</p>
<p>import unittest</p>
<p>class TestSieve(unittest.TestCase):</p>
<p>def setUp(self):</p>
<p>pass</p>
<p>def testone(self):</p>
<p>primes = Sieve.primes(1)</p>
<p>self.assertEqual(primes, sets.Set())</p>
<p>def test100(self):</p>
<p>primes = Sieve.primes(100)</p>
<p>self.assert_(primes == sets.Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,</p>
<p>53, 59, 61, 67, 71, 73, 79, 83, 89, 97]))</p>
<p>if __name__ == '__main__':</p>
<p>unittest.main()</p>
<p>Тестовый модуль состоит из определения класса, унаследованного от класса unittest.TestCase, в котором описывается подготовка к испытаниям (метод setUp) и сами испытания — методы, начинающиеся на test. В данном случае таких испытаний всего два: в первом испытывается случай N=1, а во втором — N=100.</p>
<p>Запуск тестов производится выполнением функции unittest.main(). Вот как выглядят успешные испытания:</p>
<p>Листинг</p>
<p>$ python test_Sieve.py</p>
<p>..</p>
<p>— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p>
<p>Ran 2 tests in 0.002s</p>
<p>OK</p>
<p>В процессе разработки перед каждым выпуском все модули прогоняются через регрессионные испытания, чтобы обнаружить, не были ли внесены ошибки. Однако никакие тесты в общем случае не могут гарантировать безошибочности сложной программы. При дополнении модулей тесты также могут быть дополнены, чтобы отразить изменения в проекте.</p>
<p>Кстати, сам Python и его стандартная библиотека имеют тесты для каждого модуля — они находятся в каталоге test в месте, где развернуты файлы поставки Python, и являются частью пакета test.</p>
<p>Модуль pydoc</p>
<p>Успех проекта зависит не только от обеспечения эффективного и качественного кода, но и от качества документации. Утилита pydoc аналогична команде man в Unix:</p>
<p>Листинг</p>
<p>$ pydoc Sieve</p>
<p>Help on module Sieve:</p>
<p>NAME</p>
<p>Sieve — Модуль для вычисления простых чисел от 2 до N</p>
<p>FILE</p>
<p>Sieve.py</p>
<p>FUNCTIONS</p>
<p>primes(N)</p>
<p>Возвращает все простые от 2 до N</p>
<p>Эта страница помощи появилась благодаря тому, что были написаны строки документации — как ко всему модулю, так и к функции primes(N).</p>
<p>Стоит попробовать запустить pydoc следующей командой:</p>
<p>Листинг</p>
<p>pydoc–p 8088</p>
<p>И направить браузер на URL http://127.0.0.1:8088/ - можно получить документацию по модулям Python в виде красивого web–сайта.</p>
<p>Узнать другие возможности pydoc можно, подав команду pydoc pydoc.</p>
<p>Пакет docutils</p>
<p>Этот пакет и набор утилит пока что не входит в стандартную поставку Python, однако о нем нужно знать тем, кто хочет быстро готовить документацию (руководства пользователя и т.п.) для своих модулей. Этот пакет использует специальный язык разметки (ReStructuredText), из которого потом легко получается документация в виде HTML, LaTeX и в других форматах. Текст в формате RST легко читать и в исходном виде. С этим инструментом можно познакомиться на http://docutils.sourceforge.net</p>
<p>Пакет distutils</p>
<p>Данный пакет предоставляет стандартный путь для распространения собственных Python–пакетов. Достаточно написать небольшой конфигурационный файл setup.py, использующий distutils, и файл с перечислением файлов проекта MANIFEST.in, чтобы пользователи пакета смогли его установить командой</p>
<p>Листинг</p>
<p>python setup.py install</p>
<p>Тонкости работы с distutils можно изучить по документации.</p>
<p>Взаимодействие с операционной системой</p>
<p>Различные операционные системы имеют свои особенности. Здесь рассматривается основной модуль этой категории, функции которого работают на многих операционных системах.</p>
<p>Модуль os</p>
<p>Разделители каталогов и другие связанные с этим обозначения доступны в виде констант.</p>
<p>Константа Что обозначает</p>
<p>os.curdir Текущий каталог</p>
<p>os.pardir Родительский каталог</p>
<p>os.sep Разделитель элементов пути</p>
<p>os.altsep Другой разделитель элементов пути</p>
<p>os.pathsep Разделитель путей в списке путей</p>
<p>os.defpath Список путей по умолчанию</p>
<p>os.linesep Признак окончания строки</p>
<p>Программа на Python работает в операционной системе в виде отдельного процесса. Функции модуля os дают доступ к различным значениям, относящимся к процессу и к среде, в которой он исполняется. Одним из важных объектов, доступных из модуля os, является словарь переменных окружения environ. Например, с помощью переменных окружения web–сервер передает некоторые параметры в CGI–сценарий. В следующем примере можно получить переменную окружения PATH:</p>
<p>Листинг</p>
<p>import os</p>
<p>PATH = os.environ['PATH']</p>
<p>Большая группа функций посвящена работе с файлами и каталогами. Ниже приводятся только те, которые доступны как в Unix, так и в Windows.</p>
<p>access(path, flags) Проверка доступности файла или каталога с именем path. Режим запрашиваемого доступа указывается значением flags, составленных комбинацией (побитовым ИЛИ) флагов os.F_OK (файл существует), os.R_OK (из файла можно читать), os.W_OK (в файл можно писать) и os.X_OK (файл можно исполнять, каталог можно просматривать).</p>
<p>chdir(path) Делает path текущим рабочим каталогом.</p>
<p>getcwd() Текущий рабочий каталог.</p>
<p>chmod(path, mode) Устанавливает режим доступа к path в значение mode. Режим доступа можно получить, скомбинировав флаги (см. ниже). Следует заметить, что chmod() не дополняет действующий режим, а устанавливает его заново.</p>
<p>listdir(dir) Возвращает список файлов в каталоге dir. В список не входят специальные значения ".» и "..».</p>
<p>mkdir(path[, mode]) Создает каталог path. По умолчанию режим mode равен 0777, то есть: S_IRWXU|S_IRWXG|S_IRWXO, если пользоваться константами модуля stat.</p>
<p>makedirs(path[, mode]) Аналог mkdir(), создающий все необходимые каталоги, если они не существуют. Возбуждает исключение, когда последний каталог уже существует.</p>
<p>remove(path), unlink(path) Удаляет файл path. Для удаления каталогов используются rmdir() и removedirs().</p>
<p>rmdir(path) Удаляет пустой каталог path.</p>
<p>removedirs(path) Удаляет path до первого непустого каталога. В случае если самый последний вложенный подкаталог в указанном пути — не пустой, возбуждается исключение OSError.</p>
<p>rename(src, dst) Переименовывает файл или каталог src в dst.</p>
<p>renames(src, dst) Аналог rename(), создающий все необходимые каталоги для пути dst и удаляющий пустые каталоги пути src.</p>
<p>stat(path) Возвращает информацию о path в виде не менее чем десятиэлементного кортежа. Для доступа к элементам кортежа можно использовать константы из модуля stat, например stat.ST_MTIME (время последней модификации файла).</p>
<p>utime(path, times) Устанавливает значения времен последней модификации (mtime) и доступа к файлу (atime). Если times равен None, в качестве времен берется текущее время. В других случаях times рассматривается как двухэлементный кортеж (atime, mtime). Для получения atime и mtime некоторого файла можно использовать stat() совместно с константами модуля stat.</p>
<p>Для работы с процессами модуль os предлагает следующие функции (здесь упомянуты только некоторые, доступные как в Unix, так и в Windows):</p>
<p>abort() Вызывает для текущего процесса сигнал SIGABRT.</p>
<p>system(cmd) Выполняет командную строку cmd в отдельной оболочке, аналогично вызову system библиотеки языка C. Возвращаемое значение зависит от используемой платформы.</p>
<p>times() Возвращает кортеж из пяти элементов, содержащий время в секундах работы процесса, ОС (по обслуживанию процесса), дочерних процессов, ОС для дочерних процессов, а также время от фиксированного момента в прошлом (например, от момента запуска системы).</p>
<p>getloadavg() Возвращает кортеж из трех значений, соответствующих занятости процессора за последние 1, 5 и 15 минут.</p>
<p>Модуль stat</p>
<p>В этом модуле описаны константы, которые можно использовать как индексы к кортежам, применяемым функциями os.stat() и os.chmod() (а также некоторыми другими). Их можно уточнить в документации по Python.</p>
<p>Модуль tempfile</p>
<p>Программе иногда требуется создать временный файл, который после выполнения некоторых действий больше не нужен. Для этих целей можно использовать функцию TemporaryFile, которая возвращает файловый объект, готовый к записи и чтению.</p>
<p>В следующем примере создается временный файл, куда записываются данные и затем читаются:</p>
<p>Листинг</p>
<p>import tempfile</p>
<p>f = tempfile.TemporaryFile()</p>
<p>f.write(«0»*100) # записывается сто символов 0</p>
<p>f.seek(0) # уст. указатель на начало файла</p>
<p>print len(f.read()) # читается до конца файла и вычисляется длина</p>
<p>Как и следовало ожидать, в результате будет выведено 100. Временный файл будет удален, как только будут удалены все ссылки на его объект.</p>
<p>Обработка текстов</p>
<p>Модули этой категории будут подробно рассмотрены в отдельной лекции.</p>
<p>Многопоточные вычисления</p>
<p>Модули этой категории станут предметом рассмотрения отдельной лекции.</p>
<p>Хранение данных. Архивация</p>
<p>К этой категории отнесены модули, которые работают с внешними хранилищами данных.</p>
<p>Модуль pickle</p>
<p>Процесс записи объекта в виде последовательности байтов называется сериализацией. Для того чтобы сохранить объект во внешней памяти или передать его по каналам связи, его нужно вначале сериализовать.</p>
<p>Модуль pickle позволяет сериализовывать объекты и сохранять их в строке или файле. Следующие объекты могут быть сериализованы:</p>
<p>встроенные типы: None, числа, строки (обычные и Unicode).</p>
<p>списки, кортежи и словари, содержащие только сериализуемые объекты.</p>
<p>функции, определенные на уровне модуля (сохраняется имя, но не реализация!).</p>
<p>встроенные функции.</p>
<p>классы, определенные на уровне модуля.</p>
<p>объекты классов, __dict__ или __setstate__() которых являются сериализуемыми.</p>
<p>Типичный вариант использования модуля приведен ниже.</p>
<p>Сохранение:</p>
<p>Листинг</p>
<p>import pickle, time</p>
<p>mydata = («abc», 12, [1, 2, 3])</p>
<p>output_file = open(«mydata.dat», «w»)</p>
<p>p = pickle.Pickler(output_file)</p>
<p>p.dump(mydata)</p>
<p>output_file.close()</p>
<p>Восстановление:</p>
<p>Листинг</p>
<p>import pickle</p>
<p>input_file = open(«mydata.dat», «r»)</p>
<p>mydata = pickle.load(input_file)</p>
<p>print mydata</p>
<p>input_file.close()</p>
<p>Модуль shelve</p>
<p>Для хранения объектов в родном для Python формате можно применять полку (shelve). По своему интерфейсу полка ничем не отличается от словаря. Следующий пример показывает, как использовать полку:</p>
<p>Листинг</p>
<p>import shelve</p>
<p>data = («abc», 12) # - данные (объект)</p>
<p>key = «key» # - ключ (строка)</p>
<p>filename = «polka.dat» # - имя файла для хранения полки</p>
<p>d = shelve.open(filename) # открытие полки</p>
<p>d[key] = data # сохранить данные под ключом key</p>
<p># (удаляет старое значение, если оно было)</p>
<p>data = d[key] # загрузить значение по ключу</p>
<p>len(d) # получить количество объектов на полке</p>
<p>d.sync() # запись изменений в БД на диске</p>
<p>del d[key] # удалить ключ и значение</p>
<p>flag = d.has_key(key) # проверка наличия ключа</p>
<p>lst = d.keys() # список ключей</p>
<p>d.close() # закрытие полки</p>
<p>Модули anydbm и gdbm</p>
<p>Для внешнего хранения данных можно использовать примитивные базы данных, содержащие пары ключ–значение. В Python имеется несколько модулей для работы с такими базами: bsddb, gdbm, dbhash и т.п. Модуль anydbm выбирает один из имеющихся хэшей, поэтому его можно применять для чтения ряда форматов (any — любой).</p>
<p>Доступ к хэшу из Python мало отличается от доступа к словарю. Разница лишь в том, что хэш еще нужно открыть для создания, чтения или записи, а затем закрыть. Кроме того, при записи хэш блокируется, чтобы не испортить данные.</p>
<p>Модуль csv</p>
<p>Формат CSV (comma separated values — значения, разделенные запятыми) достаточно популярен для обмена данными между электронными таблицами и базами данных. Следующий ниже пример посвящен записи в CSV–файл и чтению из него:</p>
<p>Листинг</p>
<p>mydata = [(1, 2, 3), (1, 3, 4)]</p>
<p>import csv</p>
<p># Запись в файл:</p>
<p>f = file(«my.csv», «w»)</p>
<p>writer = csv.writer(f)</p>
<p>for row in mydata:</p>
<p>writer.writerow(row)</p>
<p>f.close()</p>
<p># Чтение из файла:</p>
<p>reader = csv.reader(file(«my.csv»))</p>
<p>for row in reader:</p>
<p>print row</p>
<p>Платформо–зависимые модули</p>
<p>Эта категория модулей имеет применение только для конкретных операционных систем и семейств операционных систем. Довольно большое число модулей в стандартной поставке Python посвящено трем платформам: Unix, Windows и Macintosh.</p>
<p>При создании переносимых приложений использовать платформо–зависимые модули можно только при условии реализации альтернативных веток алгоритма, либо с отказом от свойств, которые доступны не на всех платформах. Так, под Windows не работает достаточно обычная для Unix функция os.fork(), поэтому при создании переносимых приложений нужно использовать другие средства для распараллеленных вычислений, например, многопоточность.</p>
<p>В документации по языку обычно отмечено, для каких платформ доступен тот или иной модуль или даже отдельная функция.</p>
<p>Поддержка сети. Протоколы Интернет</p>
<p>Почти все модули из этой категории, обслуживающие клиентскую часть протокола, построены по одному и тому же принципу: из модуля необходим только класс, объект которого содержит информацию о соединении с сервером, а методы реализуют взаимодействие с сервером по соответствующему протоколу. Таким образом, чем сложнее протокол, тем больше методов и других деталей требуется для реализации клиента.</p>
<p>Примеры серверов используются по другому принципу. В модуле с реализацией сервера описан базовый класс, из которого пользователь модуля должен наследовать свой класс, реализующий требуемую функциональность. Правда, иногда замещать нужно всего один или два метода.</p>
<p>Этому вопросу будет посвящена отдельная лекция.</p>
<p>Поддержка Internet. Форматы данных</p>
<p>В стандартной библиотеке Python имеются разноуровневые модули для работы с различными форматами, применяющимися для кодирования данных в сети Интернет и тому подобных приложениях.</p>
<p>Сегодня наиболее мощным инструментом для обработки сообщений в формате RFC 2822 является пакет email. С его помощью можно как разбирать сообщения в удобном для программной обработки виде, так и формировать сообщение на основе данных о полях и основном содержимом (включая вложения).</p>
<p>Python о себе</p>
<p>Язык Python является рефлективным языком, в котором можно «заглянуть» глубоко в собственные внутренние структуры кода и данных. Модули этой категории дают возможность прикоснуться к внутреннему устройству Python. Более подробно об этом рассказывается в отдельной лекции.</p>
<p>Графический интерфейс</p>
<p>Почти все современные приложения имеют графический интерфейс пользователя. Такие приложения можно создавать и на языке Python. В стандартной поставке имеется модуль Tkinter, который есть не что иное, как интерфейс к языку Tcl/Tk, на котором можно описывать графический интерфейс.</p>
<p>Следует отметить, что существуют и другие пакеты для программирования графического интерфейса: wxPython (основан на wxWindows), PyGTK и т.д. Среди этих пакетов в основном такие, которые работают на одной платформе (реже — на двух).</p>
<p>Помимо возможностей программного описания графического интерфейса, для Python есть несколько коммерческих и некоммерческих построителей графического интерфейса (GUI builders), однако в данном курсе они не рассматриваются.</p>
<p>Заключение</p>
<p>В этой лекции говорилось о встроенных функциях языка Python и модулях его стандартной библиотеки. Некоторые направления будут рассмотрены более подробно в следующих лекциях. Python имеет настолько обширную стандартную библиотеку, что в рамках одной лекции можно только сделать ее краткий обзор, подкрепив небольшими примерами наиболее типичные идиомы при использовании модулей.</p>
<center><div align="center"></div></center>





