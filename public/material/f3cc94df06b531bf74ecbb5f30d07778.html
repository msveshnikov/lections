# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 14. Пакет java.util</h2></center>

<p> 

</p>
<p> 

</p>
<p>Эта лекция посвящена пакету java.util, в котором содержится множество вспомогательных классов
и интерфейсов. Они настолько удобны, что прак­тически любая программа
использует эту библиотеку. Центральную часть в изложении занимает тема
контейнеров, или коллекций,— классов,
хранящих упорядоченные ссылки на ряд объектов. Они были существенно
переработаны в ходе создания версии Java2. Также рассматриваются классы для работы с датой, для
генерации случайных чисел, обеспечения поддержки многих наци­ональных языков в
приложении и др.

</p>
<p>Работа
с датами и временем Класс Date

</p>
<p>Класс Date изначально предоставлял набор функций для работы с датой — для получения
текущего года, месяца и т.д. Однако сейчас все пе­речисленные методы не
рекомендованы к использованию и практически всю функциональность для этого
предоставляет класс Calendar.

</p>
<p>Существует несколько конструкторов класса Date, однако рекомен­довано
к использованию два:

</p>
<p> 

</p>
<p>Date() и Date(long
date)

</p>
<p> 

</p>
<p>Второй конструктор принимает в качестве параметра значение типа long, указывающее на
количество миллисекунд, прошедших с I января 1970 г., 00:00:00 по Гринвичу.
Первый конструктор создает экземпляр, со­ответствующий текущему моменту.
Фактически это эквивалентно второму варианту new Date(System.currentTimeMillis()). Можно уже после созда­ния экземпляра класса Date использовать метод setTime(long time) для того, чтобы
задать нужное время.

</p>
<p>Для сравнения дат служат методы after(Date date) и before(Date date), которые
возвращают булевское значение, в зависимости от того, выпол­нено условие или
нет. Метод compareTo(Date anotherDate) возвращает значение типа int, которое равно -1,
если дата меньше сравниваемой, 1 — если больше и 0 - если даты равны. Метод toString() возвращает строко­вое описание даты. Однако для более понятного и
удобного преобразова­ния даты в текст рекомендуется пользоваться классом SimpleDateFormat, определенным в пакете java.text.













</p>
<p>Классы Calendar и GregorianCalendar

</p>
<p>Более развитые средства для работы с датами представляет класс Calendar. Calendar является абстрактным классом. Для различных плат­форм реализуются
конкретные подклассы календаря. На данный момент существует реализация
Григорианского календаря - GregorianCalendar. Экземпляр этого класса получается путем вызова статического метода getlnstance(), который возвращает экземпляр класса GregorianCalendar
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Подклассы класса Calendar должны
интерпретировать объект Date по-разному. В
будущем предполагается реализовать также лунный календарь, используемый в
некоторых странах.

</p>
<p>Calendar обеспечивает набор методов, позволяющих манипулировать различными
"частями" даты, т.е. получать и устанавливать дни, месяцы, недели и
т.д.

</p>
<p>Если при задании параметров календаря некоторые параметры упущены, то
для них будут использованы значения по умолчанию для начала отсчета, т.е.

</p>
<p> 

</p>
<p>YEAR = 1970, MONTH
= JANUARY DATE = 1 и т.д.

</p>
<p> 

</p>
<p>Для считывания и установки различных "частей" даты используются методы get(int
filed), set(int filed, int value), add(int field, int amount), roll(int field, inr
amount), переменная типа int с именем filed указывает на номер поля, с которым нужно произвести операцию. Для удобства все эти поля определены в Calendar как статические константы типа int.

</p>
<p>Рассмотрим подробнее порядок выполнения перечисленных методов.

</p>
<p> 

</p>
<p> 

</p>
<p>Метод setfint field,int value).

</p>
<p>Как уже говорилось, данный метод производит установку какого-либо поля
даты. На самом деле после вызова этого метода немедленного пересчета даты не
производится. Пересчет даты будет осуществлен толь­ко после вызова методов get(), getTime() или getTimelnMillis(). Таким об­разом, последовательная установка нескольких полей не
вызовет ненуж­ных вычислений. Помимо этого, появляется еще один интересный
эффект. Рассмотрим следующий пример. Предположим, что дата установлена на
последний день августа. Необходимо перевести ее на последний день сен­тября.
Если бы внутреннее представление даты изменялось после вызова метода set, то при
последовательной установке полей мы получили бы вот такой эффект:

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) {

</p>
<p>SimpleDateFormat sdf = new SimpleDateFormat("yyyy

</p>
<p>MMMM dd
HH:mm:ss"); Calendar cal = Calendar.getlnstance();
cal.set(Calendar.YEAR,2002); cal.set(Calendar.MONTH,Calendar.AUGUST); cal.set(Calendar.DAY_OF_MONTH,31);
System.out.printlnf Initialy set date:  " +

</p>
<p>sdf.format(cal.getTime()));
cal.set(Calendar.MONTH,Calendar.SEPTEMBER); System.out.println(" Date with
month changed : " +

</p>
<p>sdf.format(cal.getTime())); cal. set( Calendar.
DAY_OF_MONTH, 30); System.out.println(" Date with day changed : " +

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>sdf.format(cal.getTime()));

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>Initialy set
date:   2002 August 31 22:57:47

</p>
<p>Date with month
changed : 2002 October 01 22:57:47

</p>
<p>Date with day
changed : 2002 October 30 22:57:47

</p>
<p>Как мы видим, в данном примере при изменении месяца
день меся­ца остался неизменным и было унаследовано его предыдущее значение. Но
поскольку в сентябре 30 дней, дата автоматически была переведена на 1 октября,
и когда было бы установлено 30 число, оно относилось бы уже к октябрю. В
следующем примере считывание даты не производится, со­ответственно, ее
вычисление не выполняется до тех пор, пока все поля не Установлены:

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) {

</p>
<p>SimpleDateFormat sdf = new
SimpleDateFormat("yyyy MMMM dd HH:mm:ss");








</p>
<p>Calendar cai = Calendar.getlnstance();

</p>
<p>cai.set(Calendar.YEAR,2002);

</p>
<p>cai. set(Calendar. MONTH, Calendar. AUGUST);

</p>
<p>cal.set(Calendar.DAY_OF_MONTH,31);

</p>
<p>System.out.println(" Initialy set date:      " +

</p>
<p>sdf.format(cal.getTime()));
cal.set(Calendar.MONTH,Calendar.SEPTEMBER); cal.set(Calendar.DAY_OF_MONTH,30);
System.out.println(" Date with day and
month changed :

</p>
<p>+ sdf.format(cal.getTime()));

</p>
<p>}

</p>
<p>}



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="191" height="38">
 <tr>
  <td valign="top" align="left" height="38">
  <p>2002 August 31 23:03:51 2002 September 30 23:03:51
  </p>
</td>
 </tr>
</table>



<p>Результатом будет: Initialy set date:

</p>
<p>Date with day
and month changed:

</p>
<p> 

</p>
<p>Метод add (int field, int delta).

</p>
<p>Добавляет некоторое смещение к существующей величине поля. В принципе,
то же самое можно сделать с помощью set(f, get(f) + delta).

</p>
<p>В случае использования метода add следует помнить о двух правилах:

</p>
<p>1.  Если величина поля изменения выходит за диапазон возможных значений
данного поля, то производится деление по модулю дан­ной величины, частное
суммируется со следующим по старшинст­ву полем.

</p>
<p>2. 
Если изменяется одно из
полей, причем, после изменения млад­шее по отношению к изменяемому полю
принимает некоррект­ное значение, то оно изменяется на то, которое максимально
близко к "старому".

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public Testo { }

</p>
<p>public static void main(String[] args) {

</p>
<p>SimpleDateFormat sdf = new SimpleDateFormat("yyyy

</p>
<p>MMMMdd HH:mm:ss"); Calendar cal = Calendar.getlnstance();

</p>
<p>cal.set(Calendar.YEAR,2002);

</p>
<p>cal.set(Calendar.MONTH.Calendar.AUGUST);

</p>
<p>cal.set(Calendar.DAY_OF_MONTH,31);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>cal.set(Calendar.HOUR_OF_DAY19);

</p>
<p>cal.set(Calendar.MINUTE,30);

</p>
<p>cal.set(Calendar.SECOND,00);

</p>
<p>System.out.printlnfCurrent date:" + sdf.format(cal.getTime()));
cal.add(Calendar.SECOND,75);

</p>
<p>System. out.printlnfCurrent date:" + sdf.format(cal.getTime()));
cal.add(Calendar.MONTH, 1);

</p>
<p>System.
out.printlnfCurrent date:" + sdf.format(cal.getTime()));

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>Current date: 2002 August 31 19:30:00 Rule 1: 2002 August
31 19:31:15 Rule 2: 2002 September 30 19:31:15

</p>
<p> 

</p>
<p>Метод rollfint field,int delta).

</p>
<p>Добавляет некоторое смещение к существующей величине поля и не
производит изменения старших полей. Рассмотрим приведенный ранее пример, но с
использованием метода roll.

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) {

</p>
<p>SimpleDateFormat
sdf = new SimpleDateFormatfyyyy

</p>
<p>MMMM dd HH:mm:ss"); Calendar cal = Calendar.getlnstance();
cal.set(Calendar.YEAR,2002); cal.set(Calendar.MONTH,Calendar.AUGUST);
cal.set(Calendar.DAY_OF_MONTH,31); cal.set(Calendar.HOUR_OF_DAY19);
cal.set(Calendar.MINUTE,30); cal.set(Calendar.SECOND,00);

</p>
<p>System.out.printlnfCurrent date:" + sdf.format(cal.getTime()));
cal.roll(Calendar.SECOND,75);

</p>
<p>System.out.println("Rule 1: " + sdf.format(cal.getTЎme())); cal. roll(Calendar. MONTH, 1 );

</p>
<p>System, out. printlnfRule 2: " + sdf.format(cal.getTime()));

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>Current date: 2002 August 31 19:30:00 Rule 1: 2002 August
31 19:30:15 Rule 2: 2002 September 30 19:30:15

</p>
<p> 

</p>
<p>Как видно из результатов работы приведенного выше кода, действие пра­вила
1 изменилось по сравнению с методом add, а правило 2
действует так же.

</p>
<p> 

</p>
<p>Класс TimeZone

</p>
<p>Класс TimeZone предназначен для
совместного использования с классами Calendar и DateFormat. Класс абстрактный, поэтому от него порождать объекты нельзя. Вместо
этого определен статический метод getDefault(). который возвращает экземпляр наследника TimeZone с на­стройками, взятыми из операционной системы, под управлением кото­рой
работает JVM. Для того, чтобы указать произвольные параметры, можно воспользоваться
статическим методом getTimeZone(String ID), в качестве параметра которому передается наименование конкретного вре­менного
пояса, для которого необходимо получить объект TimeZone. На­бор полей,
определяющих возможный набор параметров для getTimeZone, нигде явно не описывается
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Вместо этого определен стати­ческий метод Stringf] getAvailablelds(), который возвращает возможные значения для параметра getTimeZone. Так можно определить набор воз­можных параметров для конкретного
временного пояса (рассчитывается относительно Гринвича) Stringf] getAvailablelds(int offset).

</p>
<p>Рассмотрим пример, в котором на консоль последовательно выводятся:

</p>
<p>•   
временная зона по
умолчанию;

</p>
<p>•   
список всех возможных
временных зон;

</p>
<p>•   
список временных зон,
которые совпадают с текущей временной зоной.

</p>
<p>public class Test { public Test() { }

</p>
<p>public static
void main(String[] args) {

</p>
<p>Test test = new
Test() ;

</p>
<p>TimeZone tz = TimeZone.getDefault();

</p>
<p>int rawOffset = tz.getRawOffset();

</p>
<p>System.out.println("Current
TimeZone" + tz.getDisplayNameO + tz.getlD()
+ "\n\n");

</p>
<p>// Dispaly
all available TimeZones

</p>
<p>System.out.println("AII Available TimeZones
\n");

</p>
<p>String[] idArr = tz.getAvailablelDs();

</p>
<p>for(int cnt=0;cnt &lt; idArr.length;cnt++){

</p>
<p>tz = TimeZone.getTimeZone(idArr[cnt]);

</p>
<p>System.out.println(test.padr(tz.getDisplayName()
+ tz.getlD(),64) + " raw offset=" + tz.getRawOffset()
+ ";hour offset=(" + tz.getRawOffset()/
(1000 * 60 * 60 )
+ ")");

</p>
<p>}

</p>
<p>// Dispaly all available TimeZones same as for Moscow System.out.println("\n\n TimeZones same as for Moscow \n"); idArr = tz.getAvailablelDs(rawOffset); for(int cnt=0;cnt &lt; idArr.length;cnt++){ tz = TimeZone.getTimeZone(idArr[cnt]); System.out.println(test.padr(tz.getDisplayName()+ tz.getlD(),64) + " raw offsets" + tz.getRawOffset() + ";hour offset=(" + tz.getRawOffset()/ (1000 * 60 * 60 ) + ")");

</p>
<p>}

</p>
<p>}

</p>
<p>String padr(String str,int len){ if(len - str.lengthO
&gt; 0){

</p>
<p>char[] buf = new
char[len - str.length()];

</p>
<p>Arrays.fill(buf,' ');

</p>
<p>return str + new
String(buf); }else{

</p>
<p>return str.substring(0,len);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>Current TimeZone Moscow Standard TimeEurope/Moscow
TimeZones same as for Moscow

</p>
<p>Eastern
African TimeAfrica/Addis_Aba raw offset=10800000;hour offset=(3) Eastern
African TimeAfrica/Asmera raw offset=10800000;hour offset=(3)

</p>
<p>Eastern African TimeAfrica/Dar_es_Sa raw offset^ 10800000;hour
offset=(3) Eastern African TimeAfnca/Djibouti raw offset=10800000
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>hour
offset=(3) Eastern African TimeAfrica/Kampala raw offset=10800000;hour
offset=(3) Eastern African TimeAfrica/Khartoum raw offset=10800000;hour
offset=(3) Eastern African TimeAfrica/Mogadishu raw offset=10800000;hour
offset=(3) Eastern African TimeAfrica/Nairobi raw offset=10800000;hour
offset=(3) Arabia Standard TimeAsia/Aden raw offset=10800000;hour offset=(3)
Arabia Standard TimeAsia/Baghdad raw offset=10800000;hour offset=(3) Arabia
Standard TimeAsia/Bahrain raw offset=10800000;hour offset=(3) Arabia Standard
TimeAsia/Kuwait raw offset=10800000;hour offset=(3) Arabia Standard
TimeAsia/Qatar raw offset=10800000;hour offset=(3) Arabia Standard
TimeAsia/Riyadh raw offset= 10800000;hour offset=(3) Eastern African TimeEAT
raw offset=10800000;hour offset=(3) Moscow Standard TimeEurope/Moscow raw
offset=10800000;hour offset=(3) Eastern African Timelndian/Antananar raw
offset=10800000;hour offset=(3) Eastern African Timelndian/Comoro raw
offset=10800000;hour offset=(3) Eastern African Timelndian/Mayotte raw
offset=10800000;hour offset=(3)

</p>
<p> 

</p>
<p>Класс SimpleTimeZone

</p>
<p>Класс SimpleTimeZone, как потомок TimeZone, реализует его абст­рактные методы и предназначен для применения в
настройках, использу­ющих Григорианский календарь. В большинстве случаев нет
необходимо­сти создавать экземпляр данного класса с помощью конструктора. Вмес­то
этого лучше использовать статические методы, которые возвращают тип TimeZone, рассмотренные в
предыдущем параграфе. Единственная, пожалуй, причина для использования
конструктора - необходимость за­дания нестандартных правил перехода на зимнее и
летнее время.

</p>
<p>В классе SimpleTimeZone определено три
конструктора. Рассмотрим наиболее полный с точки зрения функциональности
вариант, который, помимо временной зоны, задает летнее и зимнее время.

</p>
<p>public SimpleTimeZone(int rawOffset, String
ID, int startMonth, int startDay, int startDayOfWeek, int startTime, int
endMonth, int endDay, int endDayOfWeek, int endTime)

</p>
<p>rawOffset -
временное смещение относительно гринвича; Ю — идентификатор временной зоны (см.
пред.параграф); 8Тх111Мопт.г) - месяц перехода на
летнее время; 51аг10ау - день месяца перехода на летнее время*; 51агЮауОг\Л/еек - день недели перехода на летнее время*; этагШте - время перехода
на летнее время (указывается в милли­секундах);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>endMonth - месяц
окончания действия летнего времени; endDay - день окончания действия летнего
времени*; endDayGtWeek - день недели окончания действия летнего времени*;
endTime - время окончания действия летнего времени (указывается в
миллисекундах).

</p>
<p>Перевод часов на зимний и летний вариант исчисления времени оп­ределяется
специальным правительственным указом. Обычно переход на летнее время происходит
в 2 часа в последнее воскресенье марта, а переход на зимнее время - в 3 часа в
последнее воскресенье октября.

</p>
<p>Алгоритм расчета
таков:

</p>
<p>•    если з1агЮау=1 и установлен день недели, то будет вычисляться первый
день недели ЭТ^ОауОАЛ/еек месяца зт.а11МопМ (например, первое воскресенье);

</p>
<p>•    если 8т.аг10ау=-1 и установлен день недели, то будет вычисляться
последний день недели этагЮауОАЛ/еек месяца этагНМопШ (напри­мер, последнее
воскресенье);

</p>
<p>•    если день недели зт.аг10ауОг\Л/еек установлен в 0, то будет вычис­ляться
число эт^Оау конкретного месяца startMonth;

</p>
<p>•    для того, чтобы установить день недели после конкретного числа,
специфицируется отрицательное значение дня недели. Например, чтобы указать
первый понедельник после 23 февраля, использует­ся вот такой набор:

</p>
<p>startDayOfWeek=-MONDAY, зт.агт.Моп^РЕВЯиАРгт', эт.агЮау=23

</p>
<p>•   для того, чтобы указать последний день недели перед каким-либо числом,
указывается отрицательное значение этого числа и отри­цательное значение дня
недели. Например, для того, чтобы ука­зать последнюю субботу перед 23 февраля,
необходимо задать та­кой набор параметров:

</p>
<p>э1аг10ауОАЛ/еек=-5АТ№ОАт; startMonth=FEBRUARY йагтОау=-23;

</p>
<p>•   все вышеперечисленное относится также и к окончанию действия летнего
времени.

</p>
<p>Рассмотрим пример
получения текущей временной зоны с заданием Перехода на зимнее и летнее время
для России по умолчанию.








</p>
<p>public class Test { public Test()
{ }

</p>
<p>public static ve-id main(String[] args) { Test
test = new Test() ;

</p>
<p>SimpleTimeZone stz = new
SimpleTimeZone( TimeZone.getDefault().getRawOffset()
,TimeZone.getDefault().getlD() .Calendar.MARCH ,-1

</p>
<p>.Calendar.SUNDAY ,test.getTime(2,0,0,0) .Calendar.OCTOBER
,-1

</p>
<p>,Calendar.SUNDAY ,test.getTime(3,0,0,0)

</p>
<p>);

</p>
<p>System.out.println(stz.toString()); }

</p>
<p>int getTime(int hour.int minjnt secjnt ms){

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>return hour * 3600000 + min * 60000
+ sec * 1000 + ms;

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>java.util.SimpleTimeZone[id=Europe/Moscow,offset=10800000,dst
Savings=3600000,useDaylight=true,startYear=0,startMode=2,start
Month=2,startDay=-1 ,startDayOfWeek=1 ,startTime=7200000,
startTimeMode=0,endMode=2,endMonth=9,endDay=-1, endDayOfWeek=1,endTime=10800000, endTimeMode=0]

</p>
<p> 

</p>
<p>Интерфейс Observer и класс Observable

</p>
<p>Интерфейс Observable определяет всего один метол-update (Observable о, Object arg), который вызывается, когда обозрева­емый объект изменяется.

</p>
<p>Класс Observer предназначен для поддержки обозреваемого объекта в парадигме MVC (model-view-controller), которая, как и другие проектные решения и шаблоны, описана в специальной
литературе. Этот класс до-1" жен быть унаследован, если
возникает необходимость в том, чтобы отеле живать состояние какого-либо
объекта. Обозреваемый объект моЖеТ цметь несколько обозревателей.
Соответственно, они должны реализовать интерфейс Observable.

</p>
<p>После того, как в состоянии обозреваемого объекта что-то меняется, необходимо
вызвать метод notifyObservers, который, в свою очередь, вы­зывает методы update у каждого обозревателя.

</p>
<p>Порядок, в котором вызываются методы update обозревателей, за­ранее не определен. Реализация по умолчанию
подразумевает их вызов в порядке регистрации. Регистрация осуществляется с
помощью метода addObserver(Observer о). Удаление
обозревателя из списка выполняется с помощью deleteObserver(Observer о). Перед вызовом notifyObservers необходимо вызвать
метод setChanged, который устанавливает признак того, что обозреваемый объект был
изменен.

</p>
<p>Рассмотрим пример организации взаимодействия классов:

</p>
<p> 

</p>
<p>public class TestObservable extends java.util.Observable
{ private String name = ""; public TestObservable(String name) { this.name
= name;

</p>
<p>}

</p>
<p>public void modifyO { setChanged();

</p>
<p>}

</p>
<p>public String getName() { return name;

</p>
<p>}

</p>
<p>}

</p>
<p>public class TestObserver implements java.util.Observer
{ private String name = "";

</p>
<p>public TestObserver(String name) { this.name
= name;

</p>
<p>}

</p>
<p>public void updateQava.util.Observable
o,Object arg) { String str = "Called update of" + name; str += "
from " + ((TestObservable)o).getName(); str += " with argument"
+ (String)arg; System.out.println(str);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}








</p>
<p>Курс




</p>
<p>секция




</p>
<p>14                                                                                                            Пакет
java.util








</p>
<p> 








</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test
test = new Test();

</p>
<p>TestObservable to = newTestObservable("Observable");

</p>
<p>TestObserver o1 = newTestObserver("Observer 1");

</p>
<p>TestObserver o2 = newTestObserver("Observer 2");

</p>
<p>to.addObserver(o1);

</p>
<p>to.addObserver(o2);

</p>
<p>to.modify();

</p>
<p>to.notifyObservers("Notify argument");

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В результате работы на консоль будет выведено:

</p>
<p> 

</p>
<p>Called update of Observer 2 from Observable with argument
Notify argument

</p>
<p>Called update of Observer 1 from Observable with
argument Notify argument

</p>
<p> 

</p>
<p>На практике использовать Observer не всегда удобно,
так как в Java отсутствует
множественное наследование и Observer необходимо насле­довать
в самом начале построения иерархии классов. Как вариант, можно предложить
определить интерфейс, задающий функциональность, сход­ную с Observer, и реализовать его
в подходящем классе.

</p>
<p> 

</p>
<p> 

</p>
<p>Коллекции

</p>
<p>Зачастую в программе работа идет не с одним объектом, а с целой группой
более или менее однотипных экземпляров (например, автопарк организации). Проще
всего сделать это с помощью массивов. Однако, не­смотря на то, что это
достаточно эффективное решение для многих случа­ев, оно имеет некоторые
ограничения. Так, обращаться к элементу массива можно только по его номеру
(индексу). Также необходимо заранее задать длину массива и больше ее не менять.

</p>
<p>Массивы существовали в Java изначально. Кроме
того, было опредс лено два класса для организации более эффективной работы с
наборам11 объектов: Hashtable и Vector. В JDK 1.2 набор классов, поддерживаюши* работу с коллекциями, был существенно
расширен.

</p>
<p>Существует несколько различных типов классов-коллекций. Все 0ни
разрабатывались, по возможности, в соответствии с единой логикой Л
определенными интерфейсами и там, где это возможно, работа с ними
унифицирована. Однако все коллекции отличаются внутренними меха­низмами
хранения, скоростью доступа к элементам, потребляемой памя­тью и другими
деталями. Например, в некоторых коллекциях объекты (также называемые элементами
коллекций), могут быть упорядочены, в некоторых - нет. В некоторых типах
коллекций допускается дублирова­ние ссылок на объект, в некоторых — нет. Далее
мы рассмотрим каждый из классов-коллекций

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Классы, обеспечивающие манипулирование коллекциями объектов, объявлены в
пакете java.util.

</p>
<p> 

</p>
<p>Интерфейсы

</p>
<p> 

</p>
<p>Интерфейс Collection

</p>
<p>Данный интерфейс является корнем всей иерархии классов-коллек­ций. Он
определяет базовую функциональность любой коллекции — на­бор методов, которые
позволяют добавлять, удалять, выбирать элементы коллекции. Классы, которые
реализуют интерфейс Collection, могут со­держать дубликаты и пустые (null) значения.

</p>
<p>AbstractCollection, как абстрактный класс, служит основой для со­здания конкретных классов
коллекций и содержит реализацию некото­рых методов, определенных в интерфейсе Collection.

</p>
<p> 

</p>
<p>Интерфейс Set

</p>
<p>Классы, которые реализуют этот интерфейс, не допускают наличия
Дубликатов. В коллекции этого типа разрешено наличие только одной ссылки типа null. Интерфейс Set расширяет интерфейс Collection, та­ким образом, любой класс, имплементирующий Set, реализует все ме­тоды,
определенные в Collection. Любой объект, добавляемый в Set, Должен
реализовать метод equals, чтобы его можно было сравнить с Другими.

</p>
<p>AbstractSet, являясь абстрактным классом, представляет собой ос­нову для реализации
различных вариантов интерфейса Set.

</p>
<p> 

</p>
<p>Интерфейс List

</p>
<p>Классы, реализующие этот интерфейс, содержат упорядоченную
по-^едовательность объектов (объекты хранятся в том порядке, в котором








</p>
<p></p>
<center><img width="456" height="506" src="http://kufas.ru/java.files/image042.png"></center>
они были добавлены). D JDK 1.2 был переделан класс Vector, так, что оц теперь реализует интерфейс List. Интерфейс List расширяет интерфе^с Collection, и любой класс, имплементирующий List, реализует все мето-ды, определенные в Collection, и в то же время вводятся новые методы которые позволяют добавлять и
удалять элементы из списка. List также обеспечивает Listlterator, который позволяет перемещаться как вперед так и назад по элементам
списка.

<p>AbstractList, как абстрактный класс, представляет собой основу ддя реализации
различных вариантов интерфейса List.

</p>
<p>Интерфейс Map

</p>
<p>Классы, которые реализуют этот интерфейс, хранят
неупорядочен­ный набор объектов парами ключ/значение. Каждый ключ должен быть
уникальным. Hashtable после модификации в JDK 1.2 реализует интер­фейс Map. Порядок следования пар ключ/значение не определен.

</p>
<p>Интерфейс Map не расширяет интерфейс Collection.
AbstractMap, будучи абстрактным
классом, представляет собой основу для реализации различных вариантов
интерфейса Map.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Интерфейс SortedSet

</p>
<p>Этот интерфейс расширяет Set, требуя, чтобы содержимое набора было упорядочено. Такие коллекции могут
содержать объекты, которые реализуют интерфейс Comparable, либо могут сравниваться с использо­ванием внешнего Comparator.

</p>
<p> 

</p>
<p>Интерфейс SortedMap

</p>
<p>Этот интерфейс расширяет Map, требуя, чтобы содержимое коллек­ции было упорядочено по значениям
ключей.

</p>
<p> 

</p>
<p>Интерфейс Iterator

</p>
<p>В Java 1 для перебора элементов коллекции использовался интерфейс Enumeration. В Java 2 для этих целей должны применяться объекты, кото­рые реализуют
интерфейс Iterator. Все классы, которые реализуют интер­фейс Collection, должны реализовать метод iterator, который возвращает объект, реализующий интерфейс Iterator. Iterator весьма похож на Enumeration,
с тем лишь отличием, что в
.нем определен метод remove, который позволяет удалить объект из коллекции, для которой Iterator был создан.

</p>
<p>Таким образом, подводя итог, перечислим интерфейсы, используе­мые при
работе с коллекциями:

</p>
<p> 

</p>
<p>java.util.Collection java. util. Set java.util.List java. util.
M ар java.util.SortedSet java.util.SortedMap java. util. Iterator

</p>
<p>Абстрактные
классы, используемые при работе с коллекциями

</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="20" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="420" height="495" src="http://kufas.ru/java.files/image043.png"></center></td>
 </tr>
</table>


java.util.AbstratctCollection - данный класс
реализует все методы, определенные в интерфейсе Collection, за исключением iterator и size, так что для того,
чтобы создать немодифицируемую коллекцию, нужно переопределить эти методы. Для
реализации модифицируемой коллек­ции необходимо еще переопределить метод public void add(Object о) (в противном случае при его вызове будет возбуждено
исключение UnsupportedOperationException).

<p>Необходимо также определить два конструктора без аргументов и с
аргументом Collection. Первый должен создавать пустую коллекцию, вто-

</p>
<p>- коллекцию на основе существующей. Данный класс расширяется кассами AbstractList и AbstractSet.

</p>
<p>java.util.AbstratctList - этот класс
расширяет AbstractCollection и реализует
интерфейс List. Для создания немодифицируемого списка не­обходимо имплементировать
методы public Object get(int index) и public int size(). Для реализации
модифицируемого списка необходимо также реализовать метод public void set(int index.Object element) (в противном
случае при его вызове будет возбуждено исключение UnsupportedOperationException).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>В отличие от AbstractCollection, в этом случае нет необходимости реализовывать метод iterator, так как он уже
реализован поверх методов доступа к элементам списка get, set, add, remove.

</p>
<p>java.util.AbstratctSet - данный класс
расширяет AbstractCollection и реализует
основную функциональность, определенную в интерфейсе Set. Следует отметить,
что этот класс не переопределяет функциональность, реализованную в классе AbstractCollection.

</p>
<p>java.util.AbstratctMap - этот класс
расширяет основную функцио­нальность, определенную в интерфейсе Map. Для реализации
немодифи­цируемого класса, унаследованного от AbstractMap, достаточно опреде­лить метод entrySet, который должен
возвращать объект, приводимый к типу AbstractSet. Этот набор (Set) не должен обеспечивать методов для добавления и удаления элементов из
набора. Для реализации модифици­руемого класса Map необходимо также переопределить метод put и доба­вить в итератор, возвращаемый entrySet().iterator(), поддержку
метода remove.

</p>
<p>java.util.AbstratctSequentialList - этот класс
расширяет AbstractList и является основой
для класса LinkedList. Основное отличие от AbstractList заключается в том,
что этот класс обеспечивает не только по­следовательный, но и произвольный
доступ к элементам списка, с помо­щью методов get(int index), set(int index, Object element), set(int index, Object element), add(int index, Object element) и remove(int index). Для того, чтобы
реализовать данный класс, необходимо переопределить мето­ды listlterator и size. Причем, если
реализуется немодифицируемый спи-с°к, для итератора достаточно
реализовать методы hasNext, next, hasPrevious, previous и index. Для модифицируемого
списка необходимо Дополнительно реализовать метод set, а для списков
переменной длины е1Чеи add, и remove.








</p>
<p>Конкретные классы коллекций

</p>
<p>java.util.ArrayList - этот класс
расширяет AbstractList и весьма похож на
класс Vector. Он также динамически расширяется, как Vector, однако его методы
не являются синхронизированными, вследствие чего операции с ним выполняются
быстрее. Для того, чтобы воспользоваться синхрони­зированной версией ArrayList, можно применить вот такую конструкцию:

</p>
<p> 

</p>
<p>List I = Collections.synchronizedList(new
ArrayList(...)); public class Test {

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Testt
= newTest(); ArrayList al = new ArrayList(); al.addf'First element");
al.addf'Second element"); al.addf'Third element"); Iterator it = al.iterator();
while(it.hasNext()) {

</p>
<p>System.out.println((String)it.next());

</p>
<p>}

</p>
<p>System.out.println("\n");
al.add(2,"Insertion"); it = al.iterator(); while(it.hasNext()){

</p>
<p>System, out. println((String)it.next());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>First element Second element Third element

</p>
<p>Firts element Second element Insertion Third element

</p>
<p>java.util.LinkedList — представляет
собой реализацию интерфейса List. Он реализует все методы интерфейса List, помимо этого
добавляются еще новые методы, которые позволяют добавлять, удалять и
получать элементы в конце и начале списка. LinkedList является
двухсвязным списком и позволяет перемещаться как от начала в конец списка, так
и наоборот. LinkedList удобно использовать
для организации стека.

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test
test = new Test(); LinkedList II = new LinkedList();
ll.add("Element1"); H.addFirst("Element2");
H.addFirst("Element3"); H.addLast("Element4");
test.dumpList(ll); ll.remove(2); test.dumpList(ll);

</p>
<p>String element = (String)ll.getLast();

</p>
<p>ll.remove(element);

</p>
<p>test.dumpList(ll);

</p>
<p>}

</p>
<p>private void dumpList(List list){ Iterator
it = list.iterator(); System.out.println(); while(it.hasNext()){

</p>
<p>System.out.println((String)it.next());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>Element3 Element2 Elementl Elements

</p>
<p>Element3 Element2

</p>
<p>Element4

</p>
<p> 

</p>
<p>Element3 Element2

</p>
<p> 

</p>
<p>Классы LinkedList
и ArrayList имеют схожую функциональность. Однако с точки зрения производительности он отличаются. Так. в ArrayList заметно быстрей
(примерно на порядок) осуществляются опе­рации прохода по всему списку
(итерации) и получения данных. LinkedList почти на порядок
быстрее выполняет операции удаления и до­бавления новых элементов.

</p>
<p>Java.util.Hastable — расширяет абстрактный класс Dictionary. В JDK 1.2 класс Hashtable также реализует
интерфейс Map. Hashtable предназначен для
хранения объектов в виде пар ключ/значение. Из самого названия сле­дует, что Hashtable использует алгоритм
хэширования для увеличения ско­рости доступа к данным
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Для того, чтобы выяснить
принципы работы дан­ного алгоритма, рассмотрим несколько примеров.

</p>
<p>Предположим, имеется массив строк, содержащий названия городов. Для
того, чтобы найти элемент массива, содержащий название города, в общем случае требуется
просмотреть весь массив, а если необходимо най­ти все элементы массива, то для
поиска каждого, в среднем, потребуется просматривать половину массива. Такой
подход может оказаться приемле­мым только для небольших массивов.

</p>
<p>Как уже отмечалось ранее, для того, чтобы увеличить скорость поис­ка,
используется алгоритм хэширования. Каждый объект в Java унаследо­ван от Object. Как уже отмечалось ранее. Object определено целое число, которое уникально идентифицирует экземпляр
класса Object и, соответст­венно,
все экземпляры классов, унаследованных от Object. Это число воз­вращает
метод hashCode(). Именно оно используется при сохранении ключа в Hashtable следующим образом:
разделив длину массива, предназ­наченного для хранения ключей, на код, получаем
некое целое число, ко­торое служит индексом для хранения ключа в массиве array.length % hashCode().

</p>
<p>Далее, если необходимо добавить новую пару ключ/значение, вычис­ляется
новый индекс, и если этот индекс совпадает с уже имеющимся, то создается список
ключей, на который указывает элемент массива ключей-Таким образом, при обратном
извлечении ключа необходимо вычислить индекс массива по тому же алгоритму и
получить его. Если ключ в массиве единственный, то используется значение
элемента массива, если хранится несколько ключей, то необходимо обойти список и
выбрать нужный.

</p>
<p>Есть несколько соображений, относящихся к производительности классов,
использующих для хранения данных алгоритм хэширования. В частности, размер
массива. Если массив окажется слишком мал, то свя­занные списки будут слишком
длинными и скорость поиска станет су­щественно снижаться, так как просмотр
элементов списка будет такой #е, как в обычном массиве. Чтобы этого избежать,
задается некий коэф­фициент заполнения. При заполнении элементов массива, в
котором хранятся ключи (или списки ключей) на эту величину, происходит уве­личение
массива и производится повторное реиндексирование. Таким образом, если массив
окажется слишком мал, то он будет быстро запол­няться и будет производиться
операция повторного индексирования, ко­торая отнимает достаточно много ресурсов
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>
С другой стороны, если мас­сив сделать большим, то при необходимости
просмотреть последова­тельно все элементы коллекции, использующей алгоритм
хэширования, придется обрабатывать большое количество пустых элементов массива
ключей.

</p>
<p>Начальный размер массива и коэффициент загрузки коллекции задаются при
конструировании. Например:

</p>
<p>Hashtable ht = new Hashtable( 1000,0.60)

</p>
<p>Существует также конструктор без параметров, который
использует значения по умолчанию 101 для размера массива (в последней версии
значение уменьшено до 11) и 0.75 для коэффициента загрузки.

</p>
<p>Использование алгоритма хэширования позволяет гарантировать, что
скорость доступа к элементам коллекции такого типа будет увеличи­ваться не
линейно, а логарифмически. Таким образом, при частом поиске каких-либо значений
по ключу имеет смысл задействовать коллекции, применяющие алгоритм хэштрования.

</p>
<p>java.util.HashMap - этот класс расширяет AbstractMap и весьма по­хож на
класс Hashtable. HashMap предназначен для
хранения пар объек­тов ключ/значение. Как для ключей, так и для элементов
допускаются значения типа null. Порядок хранения элементов в этой коллекции не совпадает с порядком их
добавления. Порядок элементов в коллекции также может меняться во времени. HashMap обеспечивает постоянное время доступа для операций get и put.

</p>
<p>Итерация по всем элементам коллекции пропорциональна ее емкос­ти.
Поэтому имеет смысл не делать размер коллекций чрезмерно большим, если
достаточно часто придется осуществлять итерацию по элементам.

</p>
<p>Методы HashMap не являются
синхронизированными. Для того, чтобы обеспечить нормальную работу в
многопоточном варианте, следует использовать либо внешнюю синхронизацию
потоков, либо синхронизи­рованный вариант коллекции.








</p>
<p>public
class Test {

</p>
<p>private class TestObject{ String text = ""; public TestObject(String
text){ this.text = text;

</p>
<p>};

</p>
<p>public String getText(){
return this.text;

</p>
<p>}

</p>
<p>public void setText(String text){ this, text = text;

</p>
<p>}

</p>
<p>}

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) { Testt
= new Test() ; TestObject to = null; HashMap hm = new HashMapO;
hm.put("Key1",t.newTestObject("Value 1")); hm.put("Key2",t.
new TestObject(&amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>Value 2")); hm.put("Key3",t.newTestObject("Value
3")); to = (TestObject)hm.get("Key1");
System.out.println("Object value for Key1 = " +

</p>
<p>to.getText() + "\n"); System.out.println("lteration
over entrySet"); Map.Entry entry = null; Iterator it = hm.entrySet().iterator();
// Итератор для перебора всех точек входа в Map while(it.hasNext()){

</p>
<p>entry = (Map.Entry)it.next();

</p>
<p>System.out.println("For key = " + entry.
getKey() +

</p>
<p>" value =
" + ((TestObject)entry.getValue()).getText());

</p>
<p>}

</p>
<p>System.out.println();

</p>
<p>System.out.println("lteration over keySet");
String key = "";

</p>
<p>// Итератор для перебора всех ключей в Map it = hm.keySet().iterator(); while(it.hasNext()){
key = (String)it.next();

</p>
<p>System.out.println( "For key = " + key +
" value = " +

</p>
<p>((TestObject)hm.get(key)).getText());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>Object value for Key1 = Value 1

</p>
<p>Iteration over entrySet For key = КеуЗ value = Value
3 For key = Key2 value = Value 2 For key = Key1 value = Value 1

</p>
<p>Iteration over keySet For key = КеуЗ value = Value
3 For key = Key2 value = Value 2 For key = Key1 value = Value 1

</p>
<p>java.util.TreeMap - расширяет класс AbstractMap
и реализует ин­терфейс SortedMap. TreeMap содержит ключи в порядке возрастания.
Используется либо натуральное сравнение ключей, либо должен быть реализован
интерфейс Comparable. Реализация алгоритма поиска обеспечивает логарифмическую зависимость
времени выполнения ос­новных операций (containsKey, get, put и remove). Запрещено приме­нение
null значений для
ключей. При использовании дубликатов клю­чей ссылка на объект, сохраненный с
таким же ключом, будет утеряна. Например:

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) { Testt
= new Test(); TreeMap tm = new TreeMap(); tm.putfkey","String Г); System. out.
p ri ntl n (tm. g et(" key")); tm.putfkey","String2");
System, out. println(tm.get("key"));

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>Stringi String2

</p>
<p> 

</p>
<p> 

</p>
<p>Класс Collections

</p>
<p>Класс Collections является
классом-утилитой и содержит несколько вспомогательных методов для работы с
классами, обеспечивающими раз­личные интерфейсы коллекций. Например, для
сортировки элементов списков, для поиска элементов в упорядоченных коллекциях и
Т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>Д. Но, пожалуй, наиболее важным свойством этого класса является возмож­ность
получения синхронизированных вариантов классов-коллекций Например, для
получения синхронизированного варианта Map можно использовать следующий подход:

</p>
<p> 

</p>
<p>HashMap hm = new
HashMap();

</p>
<p> 

</p>
<p>Map syncMap = Collections.synchronizedMap(hm);

</p>
<p>Как уже отмечалось ранее, начиная с JDK 1.2, класс Vector реализует интерфейс
List. Рассмотрим пример сортировки элементов, содержащихся в классе Vector.

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>private class TestObject { private String
name = ""; public TestObject(String name) { this.name = name;

</p>
<p>}

</p>
<p>}

</p>
<p>private class MyComparator implements Comparator {
public int compare(Object I,Object r) { String left = (String)l; String right =
(String)r; return -1 * left.compareTo(right);

</p>
<p>}

</p>
<p>}

</p>
<p>public Test() {
}

</p>
<p>public static void main(String[] args) { Test
test = new Test(); Vector v = new Vector(); v.addfbbbbb");
v.add("aaaaa"); v.addf'ccccc");

</p>
<p>System.out.printlnf'Default
elements order");

</p>
<p>test.dumpList(v);

</p>
<p>Collections.sort(v);

</p>
<p>System.out.println("
Default sorting order"); test.dumpList(v);

</p>
<p>System.out.printlnf'Reverse
sorting order with providing

</p>
<p>imlicit comparator"); Collections.sort(v,test.new
MyComparatorO); test.dumpList(v);

</p>
<p>}

</p>
<p>private void dumpList(List I) { Iterator it = l.iterator(); while(it.hasNext()) {

</p>
<p>System. out.println(it.next());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Класс Properties

</p>
<p>Класс Properties предназначен для хранения набора свойств (пара­метров). Методы

</p>
<p>String
getProperty(String key)

</p>
<p>String
getProperty(String key,String defaultValue)

</p>
<p> 

</p>
<p>Позволяют получить свойство из набора.

</p>
<p>С помощью метода setProperty(String key, String value) это свойство Можцо установить.

</p>
<p>Метод load(lnputStream inStream) позволяет загрузить набор свойств из входного потока (потоки данных подробно рассматриваются в Лекции 15). Как правило, это текстовый файл, в котором хранятся пара­метры. Параметры — это строки, которые представляют собой пары Ключ/значение.
Предполагается, что по умолчанию используется коди­ровка ISO 8859-1. Каждая строка должна оканчиваться символами \г,\п *ли \г\п.
Строки из файла будут считываться до тех пор, пока не будет до-








</p>
<p>Курс




</p>
<p>Программирование на Java




</p>
<p>пекиияЛ




</p>
<p>Пакет
java.util








</p>
<p>стигнут его конец. Строки, состоящие из одних пробелов, или начинаю­щиеся
со знаков 
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> или #, игнорируются, т.е. их можно трактовать как ком­ментарии.
Если строка оканчивается символом /, то следующая строк;, считается ее
продолжением. Первый символ с начала строки, отличный от пробела, считается
началом ключа. Первый встретившийся пробел двоеточие или знак равенства
считается окончанием ключа. Все символы окончания ключа при необходимости могут
быть включены в название ключа, но при этом перед ними должен стоять символ \.
После того, как встретился символ окончания ключа, все аналогичные символы
будут проигнорированы до начала значения. Оставшаяся часть строки интер­претируется
как значение. В строке, состоящей только из символов \t, \п, V&gt; \\. \"&gt; \'Л и \uxxxx, они все распознаются и интерпретируются как оди­ночные символы. Если
встретится сочетание \ и символа конца строки, то следующая строка будет считаться
продолжением текущей, также будут проигнорированы все пробелы до начала
строки-продолжения.

</p>
<p>Метод save(OutputStream inStream,String header) сохраняет набор свойств в выходной поток в виде, пригодном для
вторичной загрузки с помощью метода load. Символы,
считающиеся служебными, кодируются так, чтобы их можно было считать при
вторичной загрузке. Символы в национатьной кодировке будут приведены к виду \uxxxx. При сохране­нии используется кодировка ISO 8859-1. Если указан header, то он будет помещен в начало потока в виде комментария (т.е. с
символом # в нача­ле), далее будет следовать комментарий, в котором будет
указано время и дата сохранения свойств в потоке.

</p>
<p>В классе Properties определен еще метод
list(PrintWriter out), который практически идентичен save. Отличается лишь
заголовок, который изме­нить нельзя. Кроме того, строки усекаются по ширине.
Поэтому данный метод для сохранения Properties не годится.

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test
test = new Test(); Properties props = new PropertiesO; StringWriter sw - new
StringWriter(); sw.write("Key1 =Vlaue1 \n"); sw.write(" Key2 : Vlaue2
\r\n"); sw.write(" КеуЗ Vlaue3 \n "); InputStream is =

</p>
<p>new ByteArraylnputStream(sw.toString().getBytesO);

</p>
<p>try{

</p>
<p>props.load(is);

</p>
<p>}

</p>
<p>catch (lOException ex) { ex.printStackTrace();

</p>
<p>}

</p>
<p>props. I ist (Syste m. о ut);

</p>
<p>props. setProperty("Key1 "."Modified
Valuer); props.setProperty("Key4","Added Value4");
props.list(System.out);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>-- listing properties --Key3=Vlaue3 Key2=Vlaue2
Key1=Vlaue1

</p>
<p>-- listing properties --Key4=Added Value4 Key3=Vlaue3
Key2=Vlaue2 Key1=Modified Valuel

</p>
<p>Интерфейс Comparator

</p>
<p>В коллекциях многие методы сортировки или сравнения требуют передачи в
качестве одного из параметров объекта, который реализует интерфейс Comparator. Этот интерфейс определяет единственный метод compare(Object objl .Object obj2), который на
основании определенного пользователем алгоритма сравнивает объекты, переданные
в качестве параметров. Метод compare должен вернуть:

</p>
<p>-1 если objl &lt; obj2

</p>
<p>0      
если obj 1 = obj2

</p>
<p>1      
если obj 1 &gt; obj2

</p>
<p>Класс Arrays

</p>
<p>Статический класс Arrays обеспечивает набор
методов для выполне­ния операций над массивами, таких, как поиск, сортировка,
сравнение. В








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0" align="left">
 <tr>
  <td width="469" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="55" height="26" src="http://kufas.ru/java.files/image044.png" alt="Подпись:  "></center></td>
 </tr>
</table>




<p>Arrays также определен статический метод public List aList(a[] arr), коцк рый
возвращает список фиксированного размера, основанный на массив^ Изменения в List можно внести, изменив данные в массиве.

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test
test = new Test();

</p>
<p>String[] arr = {"String 1","String 4","String
2","String 3"}; test. dumpArray( arr); Arrays, sort(arr);
test.dumpArray(arr);

</p>
<p>int ind = Arrays.binarySearch(arr,"String 4");
System.out.println("\nlndex of \"String 4\" = " + ind);

</p>
<p>}

</p>
<p>void dumpArray(String arr[]){ System.out. println();
for(int cnt=0;cnt &lt; arr.length;cnt++) { System.out.println(arr[cnt]);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Класс StringTokenizer

</p>
<p>Этот класс предназначен для разбора строки по лексемам (tokens). Строка, которую
необходимо разобрать, передается в качестве параметра конструктору StringTokenizer(String str). Определено еще два перегружен­ных конструктора, которым дополнительно
можно передать строку-разде­литель лексем StringTokenizer(String str, String delim) и признак возврата разделителя лексем StringTokenizer(String str, String delim, Boolean returnDelims).

</p>
<p>Разделителем лексем по
умолчанию служит пробел.

</p>
<p>public class
Test {

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) { Test test = new
Test();

</p>
<p>String toParse = "wordl ;word2;word3;word4";
StringTokenizer st = new StringTokenizer(toParse,";");

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>while(st.hasMoreTokens()){

</p>
<p>System.out.println(st.nextToken());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>wordl word 2 word3 word4

</p>
<p> 

</p>
<p> 

</p>
<p>Класс BitSet

</p>
<p>Класс BitSet предназначен для
работы с последовательностями битов. Каждый компонент этой коллекции может
принимать булево значение, которое обозначает, установлен бит или нет.
Содержимое BitSet может быть
модифицировано содержимым другого BitSet с использованием опе­раций AND, OR или XOR (исключающее или).

</p>
<p>BitSet имеет текущий размер (количество установленных битов), может динамически
изменяться. По умолчанию все биты в наборе уста­навливаются в 0 (false). Установка и очистка битов в BitSet осуществля­ется методами set(int index) и clear(int index).

</p>
<p>Метод int length() возвращает "логический" размер набора битов, int Size() возвращает количество памяти, занимаемой битовой последова­тельностью BitSet.

</p>
<p> 

</p>
<p>public class
Test {

</p>
<p>public Test() {
}

</p>
<p>public static void main(String[] args) { Test
test = new Test(); BitSet bs1 =newBitSet(); BitSet bs2 = newBitSet();
bsl.set(O); bs1.set(2); bs1.set(4);

</p>
<p>System.out.println("Length = " + bs1
.length() + " size = "

</p>
<p>+ bs1 .sizeQ); System.out.println(bs1);








</p>
<p>bs2.set(1);

</p>
<p>bs2.set(2);

</p>
<p>bs1.and(bs2);

</p>
<p>System.out.println(bs1);

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>Length = 5 size = 64

</p>
<p>{0, 2, 4}

</p>
<p>{2}

</p>
<p> 

</p>
<p>Проанализировав первую строку вывода на консоль, можно сделать вывод,
что для внутреннего представления BitSet использует значения типа long.

</p>
<p> 

</p>
<p>Класс Random

</p>
<p>Класс Random используется для
получения последовательности псевдослучайных чисел. В качестве
"зерна" применяется 48-битовое число. Если для инициализации Random задействовать одно и то же число, будет получена та же самая последовательность псевдослучайных
чисел.

</p>
<p>В классе Random определено также
несколько методов, которые воз­вращают псевдослучайные величины для примитивных
типов Java.

</p>
<p>Дополнительно следует отметить наличие двух методов: double nextGaussian() - возвращает случайное число в диапазоне от 0.0 до 1.0 распределенное
по нормальному закону, и void nextBytes(byte[] arr) - за­полняет массив arr случайными
величинами типа byte.

</p>
<p>Пример использования Random:

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test
test = new Test(); Random r = new Random(100); // Generating the same sequence
numbers for(int cnt=0;cnt&lt;9;cnt++){

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>System.out.print(r.nextlnt() + "");

</p>
<p>System.out.println(); r = new Random(100);
for(int cnt=0;cnt&lt;9;cnt++) {

</p>
<p>System.out.print(r.nextlnt() + " ");

</p>
<p>}

</p>
<p>System.out.println();

</p>
<p>// Generating sequence of bytes

</p>
<p>byte[] randArray = new byte[8];

</p>
<p>r.nextBytes(randArray);

</p>
<p>test.dumpArray(randArray);

</p>
<p>}

</p>
<p>void dumpArray(byte[] arr) {

</p>
<p>for(int cnt=0;cnt&lt; arr.length;cnt++) { System.out.print(arr[cnt]);

</p>
<p>}

</p>
<p>System.out.println();

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>-1193959466 -1139614796
837415749 -1220615319 -

</p>
<p>1429538713 118249332 -951589224 -1193959466 -1139614796

</p>
<p>837415749 -1220615319
-1429538713 118249332 -951589224

</p>
<p>81;-6;-107;77;118;17;93;-98;

</p>
<p> 

</p>
<p>Локализация

</p>
<p> 

</p>
<p>Класс Locale

</p>
<p>Класс Locale предназначен для
отображения определенного региона. Под регионом принято понимать не только
географическое положение, но также языковую и культурную среду. Например, помимо того, что ука­зывается страна
Швейцария, можно указать также и язык - французский Или немецкий.

</p>
<p>Определено два варианта
конструкторов в классе Locale:

</p>
<p> 

</p>
<p>Locale(String language, String country) Locale(String
language, String country, String variant)

</p>
<p>Первые два параметра в обоих конструкторах определяют язык и стра-
НУ&gt; Для которой определяется локаль, согласно кодировке ISO. Список под-
31— 3440                                                     481








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0" align="left">
 <tr>
  <td width="470" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="54" height="27" src="http://kufas.ru/java.files/image045.png" alt="Подпись:  "></center></td>
 </tr>
</table>




<p>держиваемых стран и языков можно получить и с помощью вызова статиче
ских методов Locale.getlSOLanguages() Locale.getlSOCountries(), coot. ветственно. Во втором варианте конструктора указан также строковый па­раметр
variant, в котором кодируется информация о платформе. Если здеСь необходимо
указать дополнительные параметры, то их требуется разделить символом
подчеркивания, причем, более важный параметр должен следо­вать первым.

</p>
<p>Пример использования:

</p>
<p> 

</p>
<p>Locale I = new
Locale("ru","RU");

</p>
<p>Locale I = new
Localefen","US","WINDOWS");

</p>
<p> 

</p>
<p>Статический метод getDefault() возвращает текущую локаль, скон­струированную на основе настроек
операционной системы, под управле­нием которой функционирует JVM.

</p>
<p>Для наиболее часто использующихся локалей заданы константы. Например, Locale.US или Locale.GERMAN.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>После того как экземпляр класса Locale создан, с помощью различ­ных методов можно получить дополнительную
информацию о локали.

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Test test = new
Test(); Locale I = Locale.getDefault(); System.out.printing.getCountry() +
"" +

</p>
<p>l.getDisplayCountry() + "" + l.getlS03Country());
System.out.printing.getLanguage() + "" +

</p>
<p>l.getDisplayLanguage() + "" + l.getlS03Language());
System.out.println(l.getVariant() + "" + l.getDisplayVariant()); I = new
Locale("ru","RU","WINDOWS");
System.out.printing.getCountry() + "" +

</p>
<p>l.getDisplayCountry() + "" + l.getlS03Country());
System.out.println(l.getLanguage() + "" +

</p>
<p>l.getDisplayLanguage() + "" + l.getlS03Language());
System.out.printing.getvariant() + "" + l.getDisplayVariantO);

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>US United States USA en English eng

</p>
<p> 

</p>
<p>RU Russia RUS ru Russian rus WINDOWS WINDOWS

</p>
<p> 

</p>
<p> 

</p>
<p>Класс ResourceBundle

</p>
<p>Абстрактный класс ResourceBundle предназначен для
хранения объектов, специфичных для локали. Например, когда необходимо полу­чить набор строк, зависящих от локали, используют ResourceBundle.

</p>
<p>Применение ResourceBundle настоятельно
рекомендуется, если предполагается использовать программу в многоязыковой
среде. С помо­щью этого класса легко манипулировать наборами ресурсов, зависящих от локалей, их можно
менять, добавлять новые и т.д.

</p>
<p>Набор ресурсов — это фактически набор классов, имеющих одно ба­зовое имя. Далее наименование класса дополняется наименованием ло­кали, с которой связывается
этот класс. Например, если имя базового класса будет MyResources, то для английской локали имя класса будет Myfмesources_en, для русской - MyResources_ru.
Помимо этого, может
добавляться идентификатор языка, если для данного региона определено несколько
языков. Например, MyResources_de_CH - так будет выгля­деть швейцарский вариант немецкого языка. Кроме того, можно указать
дополнительный признак variant (см. описание Locale). Так, описанный раннее пример для платформы UNIX будет выглядеть следующим обра­зом: MyResources_de_CH_UNIX.

</p>
<p>Загрузка объекта для нужной локали производится с помощью ста­тического
метода getBundle.:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>ResourceBundle myResources =

</p>
<p>ResourceBundle.getBundlef'MyResources",
someLocale);

</p>
<p>На основе указанного базового имени (первый параметр), указанной Локали (второй параметр) и локали по умолчанию (задается настройками ОС или JVM) генерируется
список возможных имен ресура. Причем, ука­занная локаль имеет более высокий приоритет, чем локаль по умолчанию. Если
обозначить составляющие указанной локали (язык, страна, вариант) как 1, а локали по
умолчанию — 2, то список примет следующий вид:

</p>
<p> 

</p>
<p>baseclass +
"_" + languagel + "_" + countryl + "_" + varianti








</p>
<p>baseclass +
"_" + language 1 + "_" + country 1 + "_" + variantl
+

</p>
<p>".properties" baseclass +
"_" + languagel + "_" + countryl baseclass + "_"
+ languagel + "_" + countryl + ".properties" baseclass +
"_" + languagel baseclass + "_" + languagel + ".properties"
baseclass + "_" + Ianguage2 + "_" + country2 +
"_" + variant2 baseclass + "_" + Ianguage2 + "_" +
country2 + "_" + variant2 +

</p>
<p>".properties" baseclass + "_" + Ianguage2
+ "_" + country2 baseclass + "_" + Ianguage2 +
"_" + country2 + ".properties" baseclass + "_" + Ianguage2
baseclass + "_" + Ianguage2 + ".properties" baseclass

</p>
<p>baseclass + ".properties"

</p>
<p> 

</p>
<p>Например, если необходимо найти ResourceBundle
для локали fr_CH (Швейцарский французский), а локаль по умолчанию en_US, при этом название базового класса ResourceBundle
MyResources, то порядок поиска подходящего ResourceBundle будет таков.

</p>
<p>MyResources_fr_CH

</p>
<p>MyResources_fr

</p>
<p>MyResources_en_US

</p>
<p>MyResourcesen

</p>
<p>MyResources

</p>
<p> 

</p>
<p>Результатом работы getBundle будет загрузка
необходимого класса ресурсов в память, однако данные этого класса могут быть
сохранены на диске. Таким образом, если нужный класс не будет найден, то к требуемому
имени класса будет добавлено расширение ".properties" и будет предпри­нята попытка найти файл с данными на диске.

</p>
<p>Следует помнить, что необходимо указывать полностью квалифици­рованное
имя класса ресурсов, т.е. имя пакета, имя класса. Кроме того, класс ресурсов
должен быть доступен в контексте его вызова (там, где вы­зывается getResourceBundle), то есть не быть private и т.д.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Всегда должен создаваться базовый класс без суффиксов, т.е. если вы
создаете ресурсы с именем MyResource, должен быть в наличии класс MyResource. class.

</p>
<p>ResourceBundle хранит объекты в
виде пар ключ/значение. Как уже отмечалось ранее, класс ResourceBundle абстрактный,
поэтому при его наследовании необходимо переопределить методы:

</p>
<p>Enumeration
getKeys()

</p>
<p>protected
Object handleGetObject(String key)

</p>
<p>Первый метод должен возвращать список всех ключей, которые опре­делены в
ResourceBundle, второй должен возвращать объект, связанный с конкретным ключом.

</p>
<p>Рассмотрим пример использования ResourceBundle:

</p>
<p>public class
MyResource extends ResourceBundle {

</p>
<p>private Hashtable res = null; public MyResource() {

</p>
<p>res = new Hashtable();

</p>
<p>res. putfTestKey", "English Variant");

</p>
<p>}

</p>
<p>public Enumeration getKeys() { return res.keys();

</p>
<p>}

</p>
<p>protected Object handleGetObject(String key) throws
java.util.MissingResourceException { return res.get(key); }

</p>
<p>}

</p>
<p>public class MyResource_ru_RU extends
ResourceBundle { private Hashtable res = null; pub/ic MyResource_ru_RU() { res =
new Hashtable(); res.put("TestKey","Русский варинат");

</p>
<p>}

</p>
<p>public Enumeration getKeys() { return res.keys();

</p>
<p>}

</p>
<p>protected Object handleGetObject(String key) throws
java.util.MissingResourceException { return res.get(key);

</p>
<p>}

</p>
<p>}

</p>
<p>public class Test { public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Test test = new
Test();

</p>
<p>ResourceBundle rb = ResourceBundle.getBundle
("experiment. MyResource",Locale.getDefault());

</p>
<p>System.out.println(rb.getString("TestKey"));

</p>
<p>rb = ResourceBundle.getBundle("experiment.MyResource",
new Locale("ru","RU"));
System.out.println(rb.getString("TestKey"));

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p>English Variant Русский Вариант

</p>
<p>Кроме того, следует обратить внимание, что ResourceBundle может хранить не
только строковые значения. В нем можно хранить также дво­ичные данные, или
просто методы, реализующие нужную функциональ­ность, в зависимости от локали.

</p>
<p>public interface Behavior { public String
getBehavior(); public String getCapital(); }

</p>
<p>public class EnglishBehavior implements Behavior{
public EnglishBehavior() { }

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public String getBehavior(){ return "English
behavior";

</p>
<p>}

</p>
<p>public String getCapital(){ return "London";

</p>
<p>}

</p>
<p>}

</p>
<p>public class RussianBehavior implements Behavior { public
RussianBehavior() { }

</p>
<p>public String
getBehavior(){

</p>
<p>return "Русский вариант поведения";

</p>
<p>}

</p>
<p>public String getCapital(){ return "Москва";

</p>
<p>public class MyResourceBundle_ru_RU extends
ResourceBundle { Hashtable bundle = null; public MyResourceBundle_ru_RU() { bundle
= new Hashtable();

</p>
<p>bundle.put("Bundle
description","Набор ресурсов для

</p>
<p>русской локали"); bundle.putf'Behavior",new
RussianBehavior());

</p>
<p>}

</p>
<p>public Enumeration getKeys() { return
bundle.keys();

</p>
<p>}

</p>
<p>protected Object handleGetObject(String key)
throws java.util.MissingResourceException { return
bundle.getf'key");

</p>
<p>}

</p>
<p> 

</p>
<p>public class MyResourceBundle_en_EN { Hashtable
bundle = null; public MyResourceBundle_en_EN() { bundle = new
HashtableO;

</p>
<p>bundle.putf'Bundle
descnption'V'English resource set"); bundle.putf'Behavior",new
EnglishBehavior());

</p>
<p>}

</p>
<p>public Enumeration getKeys() { return
bundle.keys();

</p>
<p>}

</p>
<p>protected Object handleGetObject(String key)
throws java.util.MissingResourceException { return
bundle.getf'key");

</p>
<p>}

</p>
<p>public class MyResourceBundle extends
ResourceBundle { Hashtable bundle = null;
public MyResourceBundleO { bundle = new Hashtable();

</p>
<p>bundle.putf'Bundle description","Default
resource bundle") bundle.putf'Behavior",new EnglishBehaviorO);

</p>
<p>}

</p>
<p>public Enumeration getKeys() { return
bundle.keys();

</p>
<p>}

</p>
<p>protected Object handleGetObject(String key)
throws java.util.MissingResourceException { return bundle.get(key);

</p>
<p>}

</p>
<p>}

</p>
<p>public class Using { public Using() { }

</p>
<p>public static void main(String[] args) { Using
u - new Using(); ResourceBundle rb =

</p>
<p>ResourceBundle.getBundle("lecture.MyResourceBundle",
Locale.getDefaultO);

</p>
<p>System.out.println((String)rb.getObject("Bundle
description")); Behavior be = (Behavior)rb.getObject("Behavior");
System.out.println(be.getBehavior()); System.out.println(be.getCapital());

</p>
<p>rb = ResourceBundle.getBundle("lecture.MyResourceBundle",
new Locale("en","EN"));

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>System.out.println((String)rb.getObject("Bundle
description")); Behavior be = (Behavior)rb.getObject("Behavior");
System.out.println(be.getBehavior()); System, out. println(be.getCapital());

</p>
<p>}

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>Русский
набор ресурсов Русский вариант поведения Москва

</p>
<p>English resource bundle English behavior London

</p>
<p> 

</p>
<p> 

</p>
<p>Классы и81Не8оигсеВипй1е и РгорегиевНеБоигсеВиг^е

</p>
<p>У класса ResourceBundle
определено два прямых потомка ListResourceBundle и
PropertiesResourceBundle. PropertiesResourceBundie
хранит набор ресурсов в файле, который представляет собой набор строк.

</p>
<p>Алгоритм конструирования объекта, содержащего набор ресурсов, был описан
в предыдущем параграфе. Во всех случаях, когда в качестве последнего элемента
используется .properties, например, baseclass + "_" +
language 1 + "_" +
country 1 + ".properties", речь идет о создании flesourceBundle из файла с
наименованием baseclass + "_" + language 1 + "_" + country 1 и расширением properties. Обычно класс peSOurceBundle помещают в пакет resources, а файл свойств - в каталог ^sources. Тогда для того,
чтобы инстанциировать нужный класс, необ­ходимо указать полный путь к этому
классу (файлу):

</p>
<p>getBundlef'resources.MyResource", Locale. getDefaultO);

</p>
<p>ListResourceBundle хранит набор
ресурсов в виде коллекции и являет­ся абстрактным классом. Классы, которые
наследуют ListResourceBundle, должны обеспечить:

</p>
<p>•   переопределение метода Object[][] getContents(), который воз­вращает массив ресурсов;

</p>
<p>•   собственно двумерный массив, содержащий ресурсы. Рассмотрим пример:

</p>
<p>public class MyResource extends ListResourceBundle { Vector
v = new Vector(); Object[][] resources = { {"StringKey","String"},
{"DoubleKey",new Double(O.O)}, {"VectorKey",v},

</p>
<p>};

</p>
<p>public MyResource() { super();

</p>
<p>v.addf'Element 1"); v.addf'Element 2"); v.addfElement
3");

</p>
<p>}

</p>
<p>protected Object[][] getContents() { return
resources;

</p>
<p>}

</p>
<p>}

</p>
<p>public class Test { public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Test
test = new Test();

</p>
<p>ResourceBundle rb = ResourceBundle.getBundle
("experiment.MyResource",Locale.getDefaultO);








</p>
<p>Vector v = (Vector)rb.getObject("VectorKey");
Iterator it = v.iterator(); while(it.hasNext()) {

</p>
<p>System.out.println(it.next());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p>Element 1 Element
2 Element 3

</p>
<p> 

</p>
<p>Создание ресурсов для локалей, отличных от локали по умолчанию,
осуществляется так же, как было показано для ResourceBundle.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены вспомогательные классы пакета java.util. Как можно было
заметить, они относятся к самым разным зада­чам, а потому редкая программа
обходится без использования хотя бы од­ного класса этого пакета.

</p>
<p>Напомним кратко все основные классы и их особенности:

</p>
<p>•   
Для работы с датой и
временем должны использоваться классы Date, Calendar. Класс Calendar абстрактный, существует кон­кретная реализация этого класса GregorianCalendar.

</p>
<p>•   
Класс Observer и интерфейс Observable реализуют парадигму
MVC и предназначены для
уведомления одного объекта об изме­нении состояния другого.

</p>
<p>•   
Коллекции (Collections) не накладывают ограничений на порядок следования и дублирование
элементов.

</p>
<p>•   
Списки (List) поддерживают
порядок элементов (управляются либо самими данными, либо внешними алгоритмами).

</p>
<p>•   
Наборы (Set) не допускают
дублированных элементов.

</p>
<p>•   
Карты (Maps) используют
уникальные ключи для поиска содер­жимого.

</p>
<p>•   
Применение массивов делает
добавление, удаление и увеличение количества элементов затруднительным.

</p>
<p>•   
Использование связанных
списков (LinkedList) обеспечивает хо­рошую производительность при вставке, удалении
элементов, но снижает скорость индексированного доступа к ним.

</p>
<p>•  Использование деревьев (Tree) облегчает вставку, удаление и уве­личение размера хранилища, снижает
скорость индексированного доступа, но увеличивает скорость поиска.

</p>
<p>•  Применение хэширования облегчает вставку, удаление и увеличение размера
хранилища, снижает скорость индексированного доступа, но увеличивает скорость
поиска. Однако хэширование требует нали­чия уникальных ключей для запоминания
элементов данных.

</p>
<p>•  Класс Properties удобен для хранения
наборов параметров в виде пар ключ/значение. Параметры могут сохраняться в
потоки (файлы) и загружаться из них.

</p>
<p>• Реализация классом интерфейса Comparator позволяет
сравнивать экземпляры класса друг с другом и, соответственно, сортировать их,
например, в коллекциях.

</p>
<p>• Arrays является классом-утилитой и обеспечивает набор методов, реализующих
различные приемы работы с массивами. Не имеет конструктора.

</p>
<p>•   StringTokenizer - вспомогательный
класс, предназначенный для разбора строк на лексемы.

</p>
<p>•  При необходимости работать с сущностями, представленными в виде битовых
последовательностей, удобно использовать класс BitSet.

</p>
<p>•  Манипулировать ресурсами, которые различаются в зависимости от
локализации, удобно с помощью классов ResourceBundle, ListResourceBundle, PropertiesResourceBundle. Собственно ло-каль задается с помощью класса Locale.








</p>
<p>КУРС___________ _______________________________ п

</p>
<p>11рограммирование на ja

</p>
<p> 

</p>
<p> 

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>Необходимо
написать метод, который возвращает случайное число в диапазоне от О до 100,
кратное 5. Из перечисленных вариантов выберите правильный.

</p>
<p>&#9633;       public int getRandom5()
{

</p>
<p>return (int)(Math.random()*20)
* 5;

</p>
<p>}

</p>
<p>&#9633;       public int getRandom5() {

</p>
<p>Math m = new Math()

</p>
<p>return (int)(m.random()*20) * 5;

</p>
<p>}

</p>
<p>&#9633;       public int getRandom5() {

</p>
<p>return (Math.random()*20)
* 5;

</p>
<p>}

</p>
<p> 

</p>
<p>2.  
В JDK 1.2 введены новые классы и
интерфейсы, которые позволяют работать с наборами объектов. Отметьте те из них,
которые являются интерфейсами.

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="23">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java.util.List
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java.util.TreeMap
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java.
  util .AbstractList
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java.util.SortedMap
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java. util. Iterator
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="119" valign="top">
  <p>java.util.Collections
  </p>
</td>
 </tr>
</table>

<p> 

</p>
<p> 

</p>
<p>3.   Какое значение будет выведено на консоль в
представленном фрагменте кода?

</p>
<p>String strl = "abc";
String str2 = "abc"; System.out.println(str1 == str2);

</p>
<p>&#9633;       
true

</p>
<p>&#9633;       
false








</p>
<p>КуРС                                                                                               Программирование
Haj^

</p>
<p>Вариант 2




</p>
<p>

</p>
<p>Вариант 3








</p>
<p> 








</p>
<p>1.  
Какое из выражений относительно класса java.lang.Runtime является корректным?

</p>
<p>&#9633;          
объект Runtime создается при помощи следующего кода. Runtime г = Runtime.getRuntimeO;

</p>
<p>&#9633;          
метод дс(), определенный в
RuntimeQ, вызывает начало сборки мусора виртуальной машиной Java

</p>
<p>&#9633;          
метод freeMemoryO, определенный в классе Runtime, освобождает неиспользуемую память

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Какие высказывания относительно java.util. Vector и java.util.Hashtable можно считать корректными?

</p>
<p>|~1   в Vector могут сохраняться ссылки как на объекты, так и на примитивные типы

</p>
<p>&#9633;       ссылки на объекты в Vector хранятся в порядке
их добавления

</p>
<p>[~|   в качестве
ключей для Hashtable должны передаваться
объекты типа String

</p>
<p>&#9633;          
ссылки на объекты в Hashtable хранятся в порядке
их добавления

</p>
<p>&#9633;          
и Hashtable, и Vector являются
синхронизированными, чтобы избежать ситуации, когда несколько потоков пытаются
получить доступ к одной и той же коллекции

</p>
<p> 

</p>
<p> 

</p>
<p>3.  
Будет ли переменная sb после выполнения кода в строке
2 указывать на тот же самый объект?

</p>
<p>1.    StringBuffer sb = new StringBuffer("abc");

</p>
<p>2.   
sb.appendf'x");

</p>
<p> 

</p>
<p>&#9633;          
да

</p>
<p>&#9633;          
нет

</p>
<p>Необходимо
написать метод, который получает в качестве

</p>
<p>параметра
значение угла в градусах типа double

</p>
<p>и
вычисляет его косинус.

</p>
<p>Какой из приведенных вариантов
верен?

</p>
<p>Q   double getCos(double angle) { return Math.cos(angle);

</p>
<p>|"1   double
getCos(double angle) {

</p>
<p>return Math.cos(angle * Math.PI / 180);

</p>
<p>}

</p>
<p>&#9633;   double getCos(double angle) {

</p>
<p>return Math.cos(angle * PI / 180);

</p>
<p>}

</p>
<p> 

</p>
<p>Приведенный
ниже пример кода вызывает ошибку компи­ляции

</p>
<p>double getCos(double angle) { return Math.cos(angle);

</p>
<p>}

</p>
<p> 

</p>
<p>public static void showStatus(Boolean flag) {

</p>
<p>if(flag) { System.out.println( "FIRED")

</p>
<p>} else {

</p>
<p>System.out.println("NOT READY");

</p>
<p>}

</p>
<p>}

</p>
<p>Какое из перечисленных исправлений
решит проблему?

</p>
<p>&#9633;          
заменить if(flag) { на if(flag.equals(true)

</p>
<p>&#9633;          
заменить public static void showStatus(Boolean flag) { на public
static void showStatus(boolean flag) {

</p>
<p>&#9633;          
заменить if(flag) { на if(flag.booleanValue())
{








</p>
<p>Какой из перечисленных ниже
классов имеет наибольшее сходство с классом Vector?

</p>
<p>&#9633;       
AbstractCollection D   ArrayList

</p>
<p>&#9633;       
Hashtable

</p>
<p>
</p>
<center> 
</center>
    </div>