# encoding: windows-1251







<p>Python проектировался как объектно–ориентированный язык программирования. Это означает (по Алану Кэю, автору объектно–ориентированного языка Smalltalk), что он построен с учетом следующих принципов:</p>
<p>Все данные в нем представляются объектами.</p>
<p>Программу можно составить как набор взаимодействующих объектов, посылающих друг другу сообщения.</p>
<p>Каждый объект имеет собственную часть памяти и может состоять из других объектов.</p>
<p>Каждый объект имеет тип.</p>
<p>Все объекты одного типа могут принимать одни и те же сообщения (и выполнять одни и те же действия).</p>
<p>Язык Python имеет достаточно мощную, но, вместе с тем, самобытную поддержку объектно–ориентированного программирования. В этой лекции ООП представляется без лишних формальностей. Работа с Python убеждает, что писать программы в объектно–ориентированном стиле не только просто, но и приятно.</p>
<p>Примечание:</p>
<p>К сожалению, большинство введений в ООП (даже именитых авторов) изобилует значительным числом терминов, зачастую затемняющих суть вопроса. В данном изложении будут употребляться только те термины, которые необходимы на практике для взаимопонимания разработчиков или для расширения кругозора. Так как в разных языках программирования ООП имеет свои нюансы, в скобках иногда будут даваться синонимы или аналоги того или иного термина.</p>
<p>Примечание:</p>
<p>ОО программирование — это методология написания кода. Здесь не будет подробно рассматриваться объектно–ориентированный анализ и объектно–ориентированное проектирование, которые не менее важны как стадии создания программного обеспечения.</p>
<p>Основные понятия</p>
<p>При процедурном программировании программа разбивается на части в соответствии с алгоритмом: каждая часть (подпрограмма, функция, процедура) является составной частью алгоритма.</p>
<p>При объектно–ориентированном программировании программа строится как совокупность взаимодействующих объектов.</p>
<p>С точки зрения объектно–ориентированного подхода, объект — это нечто, обладающее значением (состоянием), типом (поведением) и индивидуальностью. Когда программист выделяет объекты в предметной области, он обычно абстрагируется (отвлекается) от большинства их свойств, концентрируясь на существенных для задачи свойствах. Над объектами можно производить операции (посылая им сообщения). В языке Python все данные представлены в виде объектов.</p>
<p>Взаимодействие объектов заключается в вызове методов одних объектов другими. Иногда говорят, что объекты посылают друг другу сообщения. Сообщения — это запросы к объекту выполнить некоторые действия. (Сообщения, методы, операции, функции–члены являются синонимами).</p>
<p>Каждый объект хранит свое состояние (для этого у него есть атрибуты) и имеет определенный набор методов. (Синонимы: атрибут, поле, слот, объект–член, переменная экземпляра). Методы определяют поведение объекта. Объекты класса имеют общее поведение.</p>
<p>Объекты описываются не индивидуально, а с помощью классов. Класс — объект, являющийся шаблоном объекта. Объект, созданный на основе некоторого класса, называется экземпляром класса. Все объекты определенных пользователем классов являются экземплярами класса. Тем не менее, объекты даже с одним и тем же состоянием могут быть разными объектами. Говорят, что они имеют разную индивидуальность.</p>
<p>В языке Python для определения класса используется оператор class:</p>
<p>Листинг</p>
<p>class имя_класса(класс1, класс2, …):</p>
<p># определения методов</p>
<p>Класс определяет тип объекта, то есть его возможные состояния и набор операций.</p>
<p>Абстракция и декомпозиция</p>
<p>Абстракция в ООП позволяет составить из данных и алгоритмов обработки этих данных объекты, отвлекаясь от несущественных (на некотором уровне) с точки зрения составленной информационной модели деталей. Таким образом, программа подвергается декомпозиции на части «дозированной» сложности. Отдельный объект, даже вместе с совокупностью его связей с другими объектами, человеком воспринимается легче (именно так он привык оперировать в реальном мире), чем что–то неструктурированное и монотонное.</p>
<p>Перед тем как начать написание даже самой простенькой объектно–ориентированной программы, необходимо провести анализ предметной области, для того чтобы выявить в ней классы объектов.</p>
<p>При выделении объектов необходимо абстрагироваться (отвлечься) от большинства присущих им свойств и сконцентрироваться на свойствах, значимых для задачи..</p>
<p>Выделяемые объекты необязательно должны походить на физические объекты — ведь это абстракции, за которыми скрываются процессы, взаимодействия, отношения.</p>
<p>Удачная декомпозиция стоит многого. От нее зависят не только количественные характеристики кода (быстродействие, занимаемая память), но и трудоемкость дальнейшего развития и сопровождения. При отсутствии соответствующего опыта лучше не загадывать будущих путей развития программы, а делать ее как можно проще, под конкретную задачу.</p>
<p>Даже если просто перечислить все существительные, встретившиеся в описании задачи (явно или неявно), получится неплохой список кандидатов в классы.</p>
<p>При процедурном подходе тоже используется декомпозиция, но при объектно–ориентированном подходе производится декомпозиция не самого алгоритма на более мелкие части, а предметной области на классы объектов.</p>
<p>Объекты</p>
<p>До этой лекции объекты Python встречались много раз: ведь каждое число, строка, функция, модуль и т.п. — это объекты. Некоторые встроенные объекты имеют в Python синтаксическую поддержку (для задания литералов). Таковы числа, строки, списки, кортежи и некоторые другие типы.</p>
<p>Теперь следует посмотреть на них в свете только что приведенных определений. Пример:</p>
<p>Листинг</p>
<p>a = 3</p>
<p>b = 4.0</p>
<p>c = a + b</p>
<p>Здесь происходит следующее. Сначала имя «a» связывается в локальном пространстве имен с объектом–числом 3 (целое число). Затем «b» связывается с объектом–числом 4.0 (число с плавающей точкой). После этого над объектами 3 и 4.0 выполняется операция сложения, и имя «c» связывается с получившимся объектом. Кстати, операциями, в основном, будут называться методы, которые имеют в Python синтаксическую поддержку, в данном случае — инфиксную запись. То же самое можно записать как:</p>
<p>Листинг</p>
<p>c = a.__add__(b)</p>
<p>Здесь __add__() - метод объекта a, который реализует операцию + между этим объектом и другим объектом.</p>
<p>Узнать набор методов некоторого объекта можно с помощью встроенной функции dir():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; dir(a)</p>
<p>['__abs__', '__add__', '__and__', '__class__', '__cmp__', '__coerce__',</p>
<p>'__delattr__', '__div__', '__divmod__', '__doc__', '__float__',</p>
<p>'__floordiv__', '__getattribute__', '__getnewargs__', '__hash__',</p>
<p>'__hex__', '__init__', '__int__', '__invert__', '__long__',</p>
<p>'__lshift__', '__mod__', '__mul__', '__neg__', '__new__',</p>
<p>'__nonzero__', '__oct__', '__or__', '__pos__', '__pow__',</p>
<p>'__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__',</p>
<p>'__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__',</p>
<p>'__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__',</p>
<p>'__rshift__', '__rsub__', '__rtruediv__', '__rxor__',</p>
<p>'__setattr__', '__str__', '__sub__', '__truediv__', '__xor__']</p>
<p>Здесь стоит указать на еще одну особенность Python. Не только инфиксные операции, но и встроенные функции ожидают наличия некоторых методов у объекта. Например, можно записать:</p>
<p>Листинг</p>
<p>abs(c)</p>
<p>А функция abs() на самом деле использует метод переданного ей объекта:</p>
<p>Листинг</p>
<p>c.__abs__()</p>
<p>Объекты появляются в результате вызова функций–фабрик или конструкторов классов (об этом ниже), а заканчивают свое существование при удалении последней ссылки на объект. Оператор del удаляет имя (а значит, и одну ссылку на объект) из пространства имен:</p>
<p>Листинг</p>
<p>a = 1</p>
<p># …</p>
<p>del a</p>
<p># имени a больше нет</p>
<p>Типы и классы</p>
<p>Тип определяет область допустимых значений объекта и набор операций над ним. В ООП тип тесно связан с поведением — действиями объекта, состоящими в изменении внутреннего состояния и вызовами методов других объектов.</p>
<p>Ранее в языке Python встроенные типы данных не являлись экземплярами класса, поэтому считалось, что это были просто объекты определенного типа. Теперь ситуация изменилась, и объекты встроенных типов имеют классы, к которым они принадлежат. Таким образом, тип и класс в Python становятся синонимами.</p>
<p>Интерпретатор языка Python всегда может сказать, к какому типу относится объект. Однако с точки зрения применимости объекта в операции его принадлежность к классу не играет решающей роли: гораздо важнее, какие методы поддерживает объект.</p>
<p>Примечание:</p>
<p>Пока что в Python есть «классические» и «новые» классы. Первые классы определяются сами по себе, а вторые обязательно ведут свою родословную от класса object. Для целей данного изложения разница между этими видами классов не имеет значения.</p>
<p>Экземпляры классов могут появляться в программе не только из литералов или в результате операций. Обычно для получения объекта класса достаточно вызвать конструктор этого класса с некоторыми параметрами. Объект–класс, как и объект–функция, может быть вызван. Это и будет вызовом конструктора:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import sets</p>
<p>&gt;&gt;&gt; s = sets.Set([1, 2, 3])</p>
<p>В этом примере модуль sets содержит определение класса Set. Вызывается конструктор этого класса с параметром [1, 2, 3]. В результате с именем s будет связан объект–множество из трех элементов 1, 2, 3.</p>
<p>Следует заметить, что, кроме конструктора, определенные классы имеют и деструктор — метод, который вызывается при уничтожении объекта. В языке Python объект уничтожается в случае удаления последней ссылки на него либо в результате сборки мусора, если объект оказался в неиспользуемом цикле ссылок. Так как Python сам управляет распределением памяти, деструкторы в нем нужны очень редко. Обычно в том случае, когда объект управляет ресурсом, который нужно корректно вернуть в определенное состояние.</p>
<p>Еще один способ получить объект некоторого типа — использование функций–фабрик. По синтаксису вызов функции–фабрики не отличается от вызова конструктора класса.</p>
<p>Определение класса</p>
<p>Пусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф — это множество вершин и набор ребер, попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия ребра в графе и т.п. На языке Python определение класса может выглядеть так:</p>
<p>Листинг</p>
<p>from sets import Set as set # тип для множества</p>
<p>class G:</p>
<p>def __init__(self, V, E):</p>
<p>self.vertices = set(V)</p>
<p>self.edges = set(E)</p>
<p>def add_vertex(self, v):</p>
<p>self.vertices.add(v)</p>
<p>def add_edge(self, (v1, v2)):</p>
<p>self.vertices.add(v1)</p>
<p>self.vertices.add(v2)</p>
<p>self.edges.add((v1, v2))</p>
<p>def has_edge(self, (v1, v2)):</p>
<p>return (v1, v2) in self.edges</p>
<p>def __str__(self):</p>
<p>return "%s; %s» % (self.vertices, self.edges)</p>
<p>Использовать класс можно следующим образом:</p>
<p>Листинг</p>
<p>g = G([1, 2, 3, 4], [(1, 2), (2, 3), (2, 4)])</p>
<p>print g</p>
<p>g.add_vertex(5)</p>
<p>g.add_edge((5,6))</p>
<p>print g.has_edge((1,6))</p>
<p>print g</p>
<p>что даст в результате</p>
<p>Листинг</p>
<p>Set([1, 2, 3, 4]); Set([(2, 4), (1, 2), (2, 3)])</p>
<p>False</p>
<p>Set([1, 2, 3, 4, 5, 6]); Set([(2, 4), (1, 2), (5, 6), (2, 3)])</p>
<p>Как видно из предыдущего примера, определить класс не так уж сложно. Конструктор класса имеет специальное имя __init__. (Деструктор здесь не нужен, но он бы имел имя __del__.) Методы класса определяются в пространстве имен класса. В качестве первого формального аргумента метода принято использовать self. Кроме методов в объекте класса имеются два атрибута: vertices (вершины) и edges (ребра). Для представления объекта G в виде строки используется специальный метод __str__().</p>
<p>Принадлежность классу можно выяснить с помощью встроенной функции isinstance():</p>
<p>Листинг</p>
<p>print isinstance(g, G)</p>
<p>Инкапсуляция</p>
<p>Обычно считается, что без инкапсуляции невозможно представить себе ООП, что это ключевое понятие. История развития методологий программирования движима борьбой со сложностью разработки программного обеспечения. Сложность больших программных систем, в создании которых участвует сразу большое количество разработчиков, уменьшается, если на верхнем уровне не видно деталей реализации нижних уровней. Собственно, процедурный подход был первым шагом на этом пути. Под инкапсуляцией (incapsulation, что можно перевести по–разному, но на нужные ассоциации хорошо наводит слово «обволакивание») понимается сокрытие информации о внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный (public) интерфейс. Таким образом, другие объекты не должны вмешиваться в «дела» объекта, кроме как используя вызовы методов.</p>
<p>В языке Python инкапсуляции не придается принципиального значения: ее соблюдение зависит от дисциплинированности программиста. В других языках программирования имеются определенные градации доступности методов объекта.</p>
<p>Доступ к свойствам</p>
<p>В языке Python не считается зазорным получить доступ к некоторому атрибуту (не методу) напрямую, если, конечно, этот атрибут описан в документации как часть интерфейса класса. Такие атрибуты называются свойствами (properties). В других языках программирования принято для доступа к свойствам создавать специальные методы (вместо того чтобы напрямую обращаться к общедоступным членам–данным). В Python достаточно использовать ссылку на атрибут, если свойство ни на что в объекте не влияет (то есть другие объекты могут его произвольно менять). Если же свойство менее тривиально и требует каких–то действий в самом объекте, его можно описать как свойство (пример взят из документации к Python):</p>
<p>Листинг</p>
<p>class C(object):</p>
<p>def getx(self): return self.__x</p>
<p>def setx(self, value): self.__x = value</p>
<p>def delx(self): del self.__x</p>
<p>x = property(getx, setx, delx, «I'm the 'x' property.»)</p>
<p>Синтаксически доступ к свойству x будет обычной ссылкой на атрибут:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; c = C()</p>
<p>&gt;&gt;&gt; c.x = 1</p>
<p>&gt;&gt;&gt; print c.x</p>
<p>1</p>
<p>&gt;&gt;&gt; del c.x</p>
<p>А на самом деле будут вызываться соответствующие методы: setx(), getx(), delx().</p>
<p>Следует отметить, что в экземпляре класса в Python можно организовать доступ к любым (даже несуществующим) атрибутам, обрабатывая запрос на доступ к атрибуту группой специальных методов:</p>
<p>__getattr__(self, name) Этот метод объекта вызывается в том случае, если атрибут не найден другим способом (его нет в данном экземпляре или в дереве классов). Здесь name — имя атрибута. Метод должен вычислить значение атрибута либо возбудить исключение AttributeError. Для получения полного контроля над атрибутами в «новых» классах (то есть потомках object) используйте метод __getattribute__().</p>
<p>__setattr__(self, name, value) Этот метод вызывается при присваивании значения некоторому атрибуту. В отличие от __getattr__(), метод всегда вызывается, а не только тогда, когда атрибут может быть найден в экземпляре класса, поэтому нужно с осторожностью присваивать значения атрибутам внутри этого метода: это может вызвать рекурсию. Для присваивания значений атрибутов предпочтительнее присваивать словарю __dict__: self.__dict__[name] = value или (для «новых» классов) - обращение к __setattr__() базового класса: object.__setattr__(self, name, value).</p>
<p>__delattr__(self, name) Как можно догадаться из названия, этот метод служит для удаления атрибута.</p>
<p>Следующий небольшой пример демонстрирует все перечисленные моменты. В этом примере из словаря создается объект, именами атрибутов которого будут ключи словаря, а значениями — значения из словаря по заданным ключам:</p>
<p>Листинг</p>
<p>class AttDict(object):</p>
<p>def __init__(self, dict=None):</p>
<p>object.__setattr__(self, '_selfdict', dict or {})</p>
<p>def __getattr__(self, name):</p>
<p>if self._selfdict.has_key(name):</p>
<p>return self._selfdict[name]</p>
<p>else:</p>
<p>raise AttributeError</p>
<p>def __setattr__(self, name, value):</p>
<p>if name[0] != '_':</p>
<p>self._selfdict[name] = value</p>
<p>else:</p>
<p>raise AttributeError</p>
<p>def __delattr__(self, name):</p>
<p>if name[0] != '_' and self._selfdict.has_key(name):</p>
<p>del self._selfdict[name]</p>
<p>ad = AttDict({'a': 1, 'b': 10, 'c': '123'})</p>
<p>print ad.a, ad.b, ad.c</p>
<p>ad.d = 512</p>
<p>print ad.d</p>
<p>Сокрытие данных</p>
<p>Подчеркивание ("_") в начале имени атрибута указывает на то, что он не входит в общедоступный интерфейс. Обычно применяется одиночное подчеркивание, которое в языке не играет особой роли, но как бы говорит программисту: «этот метод только для внутреннего использования». Двойное подчеркивание работает как указание на то, что атрибут — приватный. При этом атрибут все же доступен, но уже под другим именем, что и иллюстрируется ниже:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; class X:</p>
<p>… x = 0</p>
<p>… _x = 0</p>
<p>… __x = 0</p>
<p>…</p>
<p>&gt;&gt;&gt; dir(X)</p>
<p>['_X__x', '__doc__', '__module__', '_x', 'x']</p>
<p>Полиморфизм</p>
<p>В переводе с греческого полиморфизм означает «многоформие». Так в информатике называют возможность использования одного имени для выполнения различных действий.</p>
<p>Можно встретить множество определений полиморфизма (также есть несколько видов полиморфизма) в зависимости от языка программирования. Как правило, в качестве примера проявления полиморфизма приводят переопределение методов в подклассах. При этом можно создать функцию, требующую формального аргумента — экземпляра базового класса, а в качестве фактического аргумента давать экземпляр подкласса. Функция будет вызывать метод объекта с именем, а за именем будут скрываться различные действия. В связи с этим полиморфизм обычно связывают с иерархией наследования.</p>
<p>В Python полиморфизм связан не с наследованием, а с набором и смыслом доступных методов в экземпляре класса. Ниже будет показано, что, имея определенные методы, можно воссоздать класс для строки или любого другого встроенного типа. Для этого необходимо определить свойственный типу набор методов. Конечно, нужный набор методов можно получить и с помощью наследования, но в Python это не только не обязательно, но иногда и противоречит здравому смыслу.</p>
<p>При написании функции в Python обычно не проверяется, к какому типу (классу) относится тот или иной аргумент: некоторые методы просто применяются к переданному объекту. Тем самым функции получаются максимально обобщенными: они не требуют от объектов–параметров большего, чем наличие методов с определенным именем, набором аргументов и семантикой.</p>
<p>Следующий пример показывает полиморфизм в том виде, в котором он свойственен Python:</p>
<p>Листинг</p>
<p>def get_last(x):</p>
<p>return x[-1]</p>
<p>print get_last([1, 2, 3])</p>
<p>print get_last(«abcd»)</p>
<p>Описанной функции будет подходить в качестве аргумента все, от чего можно взять индекс–1 (последний элемент). Однако семантика «взятие последнего элемента» выполняется только для последовательностей. Функция будет работать и для словарей, но смысл при этом будет немного другой.</p>
<p>Имитация типов</p>
<p>Для иллюстрации понятия полиморфизма можно построить собственный тип, похожий на встроенный тип «функция». Построить класс, объекты которого вызываются подобно методам или функциям, можно так:</p>
<p>Листинг</p>
<p>class CountArgs(object):</p>
<p>def __call__(self, *args, **kwargs):</p>
<p>return len(args) + len(kwargs)</p>
<p>cc = CountArgs()</p>
<p>print cc(1, 3, 4)</p>
<p>Как видно из этого примера, экземпляры класса CountArgs можно вызывать подобно функциям (в результате будет возвращено количество переданных параметров). При попытке вызова экземпляра на самом деле будет вызван метод __call__() со всеми аргументами.</p>
<p>Следующий пример показывает, что сравнением экземпляров класса тоже можно управлять:</p>
<p>Листинг</p>
<p>class Point:</p>
<p>def __init__(self, x, y):</p>
<p>self.coord = (x, y)</p>
<p>def __nonzero__(self):</p>
<p>return self.coord[0] != 0 or self.coord[1] != 0</p>
<p>def __cmp__(self, p):</p>
<p>return cmp(self.coord, p.coord)</p>
<p>for x in range(-3, 4):</p>
<p>for y in range(-3, 4):</p>
<p>if Point(x, y) &lt; Point(y, x):</p>
<p>print "*",</p>
<p>elif Point(x, y):</p>
<p>print ".»,</p>
<p>else:</p>
<p>print «o»,</p>
<p>print</p>
<p>Программа выведет:</p>
<p>Листинг</p>
<p>. * * * * * *</p>
<p>. . * * * * *</p>
<p>… * * * *</p>
<p>… o * * *</p>
<p>… . . * *</p>
<p>… … *</p>
<p>… … .</p>
<p>В данной программе класс Point (Точка) имеет метод __nonzero__(), который определяет истинностное значение объекта класса. Истину будут давать только точки, отличные от (0, 0). Другой метод - __cmp__() - вызывается при необходимости сравнить точку и другой объект (имеющий как и точка атрибут coord, который содержит кортеж как минимум из двух элементов). Нужно заметить, что вместо __cmp__ можно определить отдельные методы для операций сравнения: __lt__, __le__, __ne__, __eq__, __ge__, __gt__ (для &lt;, &lt;=, !=, ==, &gt;=, &gt; соответственно).</p>
<p>Достаточно легко имитировать и числовые типы. Класс, который пользуется удобством синтаксиса инфиксного +, можно определить так:</p>
<p>Листинг</p>
<p>class Plussable:</p>
<p>def __add__(self, x):</p>
<p>…</p>
<p>def __radd__(self, x):</p>
<p>…</p>
<p>def __iadd__(self, x):</p>
<p>…</p>
<p>Здесь метод __add__() вызывается, когда экземпляр класса Plussable стоит слева от сложения, __radd__() - если справа от сложения и метод слева от него не имеет метода __add__(). Метод __iadd__() нужен для реализации +=.</p>
<p>Отношения между классами</p>
<p>Наследование</p>
<p>На практике часто возникает ситуация, когда в предметной области выделены очень близкие, но вместе с тем неодинаковые классы. Одним из способов сокращения описания классов за счет использования их сходства является выстраивание классов в иерархию. В корне этой иерархии стоит базовый класс, от которого нижележащие классы иерархии наследуют свои атрибуты, уточняя и расширяя поведение вышележащего класса. Обычно принципом построения классификации является отношение «IS–A» («ЕСТЬ»). Например, класс Окружность в программе — графическом редакторе может быть унаследован от класса Геометрическая Фигура. При этом Окружность будет являться подклассом (или субклассом) для класса Геометрическая Фигура, а Геометрическая Фигура — надклассом (или суперклассом) для класса Окружность.</p>
<p>В языке Python во главе иерархии («новых») классов стоит класс object. Для ориентации в иерархии существуют некоторые встроенные функции, которые будут рассмотрены ниже. Функция issubclass(x, y) может сказать, является ли класс x подклассом класса y:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; class A(object): pass</p>
<p>…</p>
<p>&gt;&gt;&gt; class B(A): pass</p>
<p>…</p>
<p>&gt;&gt;&gt; issubclass(A, object)</p>
<p>True</p>
<p>&gt;&gt;&gt; issubclass(B, A)</p>
<p>True</p>
<p>&gt;&gt;&gt; issubclass(B, object)</p>
<p>True</p>
<p>&gt;&gt;&gt; issubclass(A, str)</p>
<p>False</p>
<p>&gt;&gt;&gt; issubclass(A, A) # класс является подклассом самого себя</p>
<p>True</p>
<p>В основе построения классификации всегда стоит принцип, играющий наиболее важную роль в анализируемой и моделируемой системе. Следует заметить, что одним из «перегибов» при использовании ОО методологии является искусственное выстраивание иерархии классов. Например, не стоит наследовать класс Машина от класса Колесо (внимательные заметят, что здесь отношение другое: колесо является частью машины).</p>
<p>Класс называется абстрактным, если он предназначен только для наследования. Экземпляры абстрактного класса обычно не имеют большого смысла. Классы с рабочими экземплярами называются конкретными.</p>
<p>В Python примером абстрактного класса является встроенный тип basestring, у которого есть конкретные подклассы str и unicode.</p>
<p>Множественное наследование</p>
<p>В отличие, например, от Java, в языке Python можно наследовать класс от нескольких классов. Такая ситуация называется множественным наследованием (multiple inheritance).</p>
<p>Класс, получаемый при множественном наследовании, объединяет поведение своих надклассов, комбинируя стоящие за ними абстракции.</p>
<p>Использовать множественное наследование следует очень осторожно, а необходимость в нем возникает реже одиночного.</p>
<p>Множественное наследование можно применить для получения класса с заданными общедоступными методами, причем методы задает один родительский класс, а реализуются они на основе методов второго класса. Первый класс может быть полностью абстрактным.</p>
<p>Множественное наследование применяется для добавления примесей (mixins). Примесь — специально сконструированный класс, добавляющий в некоторый класс какую–либо черту поведения (привнесением атрибутов). Примеси обычно являются абстрактными классами.</p>
<p>Изредка множественное наследование применяется в своем основном смысле, когда объекты класса, получающегося в результате множественного наследования, предназначаются для использования в качестве объектов всех родительских классов.</p>
<p>В случае с Python наследование можно считать одним из способов собрать нужные комбинации методов в серии классов:</p>
<p>Листинг</p>
<p>class A:</p>
<p>def a(self): return 'a'</p>
<p>class B:</p>
<p>def b(self): return 'b'</p>
<p>class C:</p>
<p>def c(self): return 'c'</p>
<p>class AB(A, B):</p>
<p>pass</p>
<p>class BC(B, C):</p>
<p>pass</p>
<p>class ABC(A, B, C):</p>
<p>pass</p>
<p>Впрочем, собрать нужные методы можно и по–другому, без использования наследования:</p>
<p>Листинг</p>
<p>def ma(self): return 'a'</p>
<p>def mb(self): return 'b'</p>
<p>def mc(self): return 'c'</p>
<p>class AB:</p>
<p>a = ma</p>
<p>b = mb</p>
<p>class BC:</p>
<p>b = mb</p>
<p>c = mc</p>
<p>class ABC:</p>
<p>a = ma</p>
<p>b = mb</p>
<p>c = mc</p>
<p>Порядок разрешения методов</p>
<p>В случае, когда надклассы имеют одинаковые методы, использование того или иного метода определяется порядком разрешения методов (method resolution order). Для «новых» классов узнать этот порядок очень просто с помощью атрибута __mro__:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; str.__mro__</p>
<p>(&lt;type 'str'&gt;, &lt;type 'basestring'&gt;, &lt;type 'object'&gt;)</p>
<p>Это означает, что сначала методы ищутся в классе str, затем в basestring, а уже потом — в object.</p>
<p>Для «классических» классов порядок несколько отличается от порядка разрешения методов в «новых» классах. Нужно стараться избегать множественного наследования или применять его очень аккуратно.</p>
<p>Агрегация</p>
<p>Контейнеры</p>
<p>Под контейнером обычно понимают объект, основным назначением которого является хранение и обеспечение доступа к другим объектам. Контейнеры реализуют отношение «HAS–A» («ИМЕЕТ») между объектами. Встроенные типы, список и словарь — яркие примеры контейнеров. Можно построить собственные типы контейнеров, которые будут иметь свою логику доступа к хранимым объектам. В контейнере хранятся не сами объекты, а ссылки на них.</p>
<p>Для практических нужд в Python обычно хватает встроенных контейнеров (словаря и списка), но если это необходимо, можно создать и другие. Ниже приведен класс Стек, реализованный на базе списка:</p>
<p>Листинг</p>
<p>class Stack:</p>
<p>def __init__(self):</p>
<p>«"«Инициализация стека»""</p>
<p>self._stack = []</p>
<p>def top(self):</p>
<p>«"«Возвратить вершину стека (не снимая)»""</p>
<p>return self._stack[-1]</p>
<p>def pop(self):</p>
<p>«"«Снять со стека элемент»""</p>
<p>return self._stack.pop()</p>
<p>def push(self, x):</p>
<p>«"«Поместить элемент на стек»""</p>
<p>self._stack.append(x)</p>
<p>def __len__(self):</p>
<p>«"«Количество элементов в стеке»""</p>
<p>return len(self._stack)</p>
<p>def __str__(self):</p>
<p>«"«Представление в виде строки»""</p>
<p>return " : ".join(["%s» % e for e in self._stack])</p>
<p>Использование:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = Stack()</p>
<p>&gt;&gt;&gt; s.push(1)</p>
<p>&gt;&gt;&gt; s.push(2)</p>
<p>&gt;&gt;&gt; s.push(«abc»)</p>
<p>&gt;&gt;&gt; print s.pop()</p>
<p>abc</p>
<p>&gt;&gt;&gt; print len(s)</p>
<p>2</p>
<p>&gt;&gt;&gt; print s</p>
<p>1 : 2</p>
<p>Таким образом, контейнеры позволяют управлять набором (любых) других объектов в соответствии со структурой их хранения, не вмешиваясь во внутренние дела объектов. Узнав интерфейс класса Stack, можно и не догадаться, что он реализован на основе списка, и каким именно образом он реализован с помощью него. Но для использования стека это не важно.</p>
<p>Примечание:</p>
<p>В данном примере для краткости изложения не учтено, что в результате некоторых действий могут возбуждаться исключения. Например, при попытке снять элемент с вершины пустого стека.</p>
<p>Итераторы</p>
<p>Итераторы — это объекты, которые предоставляют последовательный доступ к элементам контейнера (или генерируемым «на лету» объектам). Итератор позволяет перебирать элементы, абстрагируясь от реализации того контейнера, откуда он их берет (если этот контейнер вообще есть).</p>
<p>В следующем примере приведен итератор, выдающий значения из списка по принципу «считалочки» по N:</p>
<p>Листинг</p>
<p>class Zahlreim:</p>
<p>def __init__(self, lst, n):</p>
<p>self.n = n</p>
<p>self.lst = lst</p>
<p>self.current = 0</p>
<p>def __iter__(self):</p>
<p>return self</p>
<p>def next(self):</p>
<p>if self.lst:</p>
<p>self.current = (self.current + self.n — 1) % len(self.lst)</p>
<p>return self.lst.pop(self.current)</p>
<p>else:</p>
<p>raise StopIteration</p>
<p>print range(1, 11)</p>
<p>for i in Zahlreim(range(1, 11), 5):</p>
<p>print i,</p>
<p>Программа выдаст</p>
<p>Листинг</p>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>5 10 6 2 9 8 1 4 7 3</p>
<p>В этой программе делегировано управление доступом к элементам списка (или любого другого контейнера, имеющего метод pop(n) для взятия и удаления n–го элемента) классу–итератору. Итератор должен иметь метод next() и возбуждать исключение StopIteration по завершении итераций. Кроме того, метод __iter__() должен выдавать итератор по экземпляру класса (в данном случае итератор — он сам (self)).</p>
<p>В настоящее время итераторы приобретают все большее значение, и о них много говорилось в лекции по функциональному программированию.</p>
<p>Ассоциация</p>
<p>Если в случае агрегации имеется довольно четкое отношение «ИМЕЕТ» (HAS–A) или «СОДЕРЖИТСЯ–В», которое даже отражено в синтаксисе Python:</p>
<p>Листинг</p>
<p>lst = [1, 2, 3]</p>
<p>if 1 in lst:</p>
<p>…</p>
<p>то в случае ассоциации ссылка на экземпляр другого класса используется без отношения включения одного в другой или принадлежности. О таком отношении между классами говорят как об отношении USE–A («ИСПОЛЬЗУЕТ»). Это достаточно общее отношение зависимости между классами.</p>
<p>В языке Python границы между агрегацией и ассоциацией несколько размыты, так как объекты при агрегации обычно не хранятся в области памяти, выделенной под контейнер (хранятся только ссылки).</p>
<p>Объекты могут также ссылаться друг на друга. В этом случае возникают циклические ссылки, которые при неаккуратном использовании могут привести (в старых версиях Python) к утечкам памяти. В новых версиях Python для циклических ссылок работает сборщик мусора.</p>
<p>Разумеется, при «чистой» агрегации циклических ссылок не возникает.</p>
<p>Например, при представлении дерева ссылки могут идти от родителей к детям и обратно от каждого дочернего узла к родительскому.</p>
<p>Слабые ссылки</p>
<p>Для обеспечения ассоциаций объектов без свойственных ссылкам проблем с возможностью образования циклических ссылок, в Python для сложных структур данных и других видов использования, при которых ссылки не должны мешать удалению объекта, предлагается механизм слабых ссылок. Такая ссылка не учитывается при подсчете ссылок на объект, а значит, объект удаляется с исчезновением последней «сильной» ссылки.</p>
<p>Для работы со слабыми ссылками применяется модуль weakref. Основные принципы его работы станут понятны из следующего примера:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import weakref</p>
<p>&gt;&gt;&gt;</p>
<p>&gt;&gt;&gt; class MyClass(object):</p>
<p>… def __str__(self):</p>
<p>… return «MyClass»</p>
<p>…</p>
<p>&gt;&gt;&gt;</p>
<p>&gt;&gt;&gt; s = MyClass() # создается экземпляр класса</p>
<p>&gt;&gt;&gt; print s</p>
<p>MyClass</p>
<p>&gt;&gt;&gt; s1 = weakref.proxy(s) # создается прокси–объект</p>
<p>&gt;&gt;&gt; print s1 # прокси–объект работает как исходный</p>
<p>MyClass</p>
<p>&gt;&gt;&gt; ss = weakref.ref(s) # создается слабая ссылка на него</p>
<p>&gt;&gt;&gt; print ss() # вызовом ссылки получается исходный объект</p>
<p>MyClass</p>
<p>&gt;&gt;&gt; del s # удаляется единственная сильная ссылка на объект</p>
<p>&gt;&gt;&gt; print ss() # теперь исходного объекта не существует</p>
<p>None</p>
<p>&gt;&gt;&gt; print s1</p>
<p>Traceback (most recent call last):</p>
<p>File "&lt;stdin&gt;", line 1, in ?</p>
<p>ReferenceError: weakly–referenced object no longer exists</p>
<p>К сожалению, поведение прокси–объекта не совсем такое, как у исходного: он не может быть ключом словаря, так как является нехэшируемым.</p>
<p>Статический метод</p>
<p>Иногда необходимо использовать метод, принадлежащий классу, а не его экземпляру. В этом случае можно описать статический метод. До появления декораторов (до Python 2.4) определять статический метод приходилось следующим образом:</p>
<p>Листинг</p>
<p>class A(object):</p>
<p>def name():</p>
<p>return A.__name__</p>
<p>name = staticmethod(name)</p>
<p>print A.name()</p>
<p>a = A()</p>
<p>print a.name()</p>
<p>Статическому методу не передается параметр с экземпляром класса. Он ему попросту не нужен.</p>
<p>В Python 2.4 для применения описателей (descriptors) был придуман новый синтаксис — декораторы:</p>
<p>Листинг</p>
<p>class A(object):</p>
<p>@staticmethod</p>
<p>def name():</p>
<p>return A.__name__</p>
<p>Смысл декоратора в том, что он «пропускает» определяемую функцию (или метод) через заданную в нем функцию. Теперь писать name три раза не потребовалось. Декораторов может быть несколько, и применяются они в обратном порядке.</p>
<p>Метод класса</p>
<p>Если статический метод имеет свои аналоги в C++ и Java, то метод класса основан на том, что в Python классы являются объектами. В отличие от статического метода, в метод класса первым параметром передается объект–класс. Вместо self для подчеркивания принадлежности метода к методам класса принято использовать cls.</p>
<p>Пример использования метода класса можно найти в модуле tree пакета nltk (Natural Language ToolKit, набор инструментов для естественного языка). Ниже приведен лишь фрагмент определения класса Tree (базового класса для других подклассов). Метод convert класса Tree определяет процедуру преобразования дерева одного типа в дерево другого типа. Эта процедура абстрагируется от деталей реализации конкретных типов, описывая обобщенный алгоритм преобразования:</p>
<p>Листинг</p>
<p>class Tree:</p>
<p># …</p>
<p>def convert(cls, val):</p>
<p>if isinstance(val, Tree):</p>
<p>children = [cls.convert(child) for child in val]</p>
<p>return cls(val.node, children)</p>
<p>else:</p>
<p>return val</p>
<p>convert = classmethod(convert)</p>
<p>Пример использования (взят из строки документации метода convert()):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; # Преобразовать tree в экземпляр класса Tree</p>
<p>&gt;&gt;&gt; tree = Tree.convert(tree)</p>
<p>&gt;&gt;&gt; # " " " " " ParentedTree</p>
<p>&gt;&gt;&gt; tree = ParentedTree.convert(tree)</p>
<p>&gt;&gt;&gt; # " " " " " MultiParentedTree</p>
<p>&gt;&gt;&gt; tree = MultiParentedTree.convert(tree)</p>
<p>Метод класса позволяет более естественно описывать действия, которые связаны в основном с классами, а не с методами экземпляра класса.</p>
<p>Метаклассы</p>
<p>Еще одним отношением между классами является отношение класс–метакласс. Метакласс можно считать «высшим пилотажем» объектно–ориентированного программирования, но, к счастью, в Python можно создавать собственные метаклассы.</p>
<p>В Python класс тоже является объектом, поэтому ничего не мешает написать класс, назначением которого будет создание других классов динамически, во время выполнения программы.</p>
<p>Пример, в котором класс порождается динамически в функции–фабрике классов:</p>
<p>Листинг</p>
<p>def cls_factory_f(func):</p>
<p>class X(object):</p>
<p>pass</p>
<p>setattr(X, func.__name__, func)</p>
<p>return X</p>
<p>Использование будет выглядеть так:</p>
<p>Листинг</p>
<p>def my_method(self):</p>
<p>print «self:", self</p>
<p>My_Class = cls_factory_f(my_method)</p>
<p>my_object = My_Class()</p>
<p>my_object.my_method()</p>
<p>В этом примере функция cls_factory_f() возвращает класс с единственным методом, в качестве которого используется функция, переданная ей как аргумент. От этого класса можно получить экземпляры, а затем у экземпляров — вызвать метод my_method.</p>
<p>Теперь можно задаться целью построить класс, экземплярами которого будут классы. Такой класс, от которого порождаются классы, и называется метаклассом.</p>
<p>В Python имеется класс type, который на деле является метаклассом. Вот как с помощью его конструктора можно создать класс:</p>
<p>Листинг</p>
<p>def my_method(self):</p>
<p>print «self:", self</p>
<p>My_Class = type('My_Class', (object,), {'my_method': my_method})</p>
<p>В качестве первого параметра type передается имя класса, второй параметр — базовые классы для данного класса, третий — атрибуты.</p>
<p>В результате получится класс, эквивалентный следующему:</p>
<p>Листинг</p>
<p>class My_Class(object):</p>
<p>def my_method(self):</p>
<p>print «self:", self</p>
<p>Но самое интересное начинается при попытке составить собственный метакласс. Проще всего наследовать метакласс от метакласса type (пример взят из статьи Дэвида Мертца):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; class My_Type(type):</p>
<p>… def __new__(cls, name, bases, dict):</p>
<p>… print «Выделение памяти под класс», name</p>
<p>… return type.__new__(cls, name, bases, dict)</p>
<p>… def __init__(cls, name, bases, dict):</p>
<p>… print «Инициализация класса», name</p>
<p>… return super(My_Type, cls).__init__(cls, name, bases, dict)</p>
<p>…</p>
<p>&gt;&gt;&gt; my = My_Type(«X», (), {})</p>
<p>Выделение памяти под класс X</p>
<p>Инициализация класса X</p>
<p>В этом примере не происходит вмешательство в создание класса. Но в __new__() и __init__() имеется полный программный контроль над создаваемым классом в период выполнения.</p>
<p>Примечание:</p>
<p>Следует заметить, что в метаклассах принято называть первый аргумент методов не self, а cls, чтобы напомнить, что экземпляр, над которым работает программист, является не просто объектом, а классом.</p>
<p>Мультиметоды</p>
<p>Некоторые объектно–ориентированные «штучки» не входят в стандартный Python или стандартную библиотеку. Ниже будут рассмотрены мультиметоды — методы, сочетающие объекты сразу нескольких различных классов. Например, сложение двух чисел различных типов фактически требует использования мультиметода. Если «одиночный» метод достаточно задать для каждого класса, то мультиметод требует задания для каждого сочетания классов, которые он обслуживает:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import operator</p>
<p>&gt;&gt;&gt; operator.add(1, 2)</p>
<p>3</p>
<p>&gt;&gt;&gt; operator.add(1.0, 2)</p>
<p>3.0</p>
<p>&gt;&gt;&gt; operator.add(1, 2.0)</p>
<p>3.0</p>
<p>&gt;&gt;&gt; operator.add(1, 1+2j)</p>
<p>(2+2j)</p>
<p>&gt;&gt;&gt; operator.add(1+2j, 1)</p>
<p>(2+2j)</p>
<p>В этом примере operator.add ведет себя как мультиметод, выполняя разные действия для различных комбинаций параметров.</p>
<p>Для организации собственных мультиметодов можно воспользоваться модулем Multimethod (автор Neel Krishnaswami), который легко найти в Интернете. Следующий пример, адаптированный из документации модуля, показывает построение собственного мультиметода:</p>
<p>Листинг</p>
<p>from Multimethod import Method, Generic, AmbiguousMethodError</p>
<p># классы, для которых будет определен мультиметод</p>
<p>class A: pass</p>
<p>class B(A): pass</p>
<p># функции мультиметода</p>
<p>def m1(a, b): return 'AA'</p>
<p>def m2(a, b): return 'AB'</p>
<p>def m3(a, b): return 'BA'</p>
<p># определение мультиметода (без одной функции)</p>
<p>g = Generic()</p>
<p>g.add_method(Method((A, A), m1))</p>
<p>g.add_method(Method((A, B), m2))</p>
<p>g.add_method(Method((B, A), m3))</p>
<p># применение мультиметода</p>
<p>try:</p>
<p>print 'Типы аргументов:', 'Результат'</p>
<p>print 'A, A:', g(A(), A())</p>
<p>print 'A, B:', g(A(), B())</p>
<p>print 'B, A:', g(B(), A())</p>
<p>print 'B, B:', g(B(), B())</p>
<p>except AmbiguousMethodError:</p>
<p>print 'Неоднозначный выбор метода'</p>
<p>Устойчивые объекты</p>
<p>Для того чтобы объекты жили дольше, чем создавшая их программа, необходим механизм их представления в виде последовательности байтов. Во второй лекции уже рассматривался модуль pickle, который позволяет сериализовать объекты.</p>
<p>Здесь же будет показано, как класс может способствовать более качественному консервированию объекта. Следующие методы, если их определить в классе, позволяют управлять работой модуля pickle и рассмотренной ранее функции глубокого копирования. Другими словами, правильно составленные методы дают возможность воссоздать объект, передав самую суть — состояние объекта.</p>
<p>__getinitargs__() Должен возвращать кортеж из аргументов, который будет передаваться на вход метода __init__() при создании объекта.</p>
<p>__getstate__() Должен возвращать словарь, в котором выражено состояние объекта. Если этот метод в классе определен, то используется атрибут __dict__, который есть у каждого объекта.</p>
<p>__setstate__(state) Должен восстанавливать объекту ранее сохраненное состояние state.</p>
<p>В следующем примере класс CC управляет своим копированием (точно так же экземпляры этого класса смогут консервироваться и расконсервироваться при помощи модуля pickle):</p>
<p>Листинг</p>
<p>from time import time, gmtime</p>
<p>import copy</p>
<p>class CC:</p>
<p>def __init__(self, created=time()):</p>
<p>self.created = created</p>
<p>self.created_gmtime = gmtime(created)</p>
<p>self._copied = 1</p>
<p>print id(self), «init», created</p>
<p>def __getinitargs__(self):</p>
<p>print id(self), «getinitargs», self.created</p>
<p>return (self.created,)</p>
<p>def __getstate__(self):</p>
<p>print id(self), «getstate», self.created</p>
<p>return {'_copied': self._copied}</p>
<p>def __setstate__(self, dict):</p>
<p>print id(self), «setstate», dict</p>
<p>self._copied = dict['_copied'] + 1</p>
<p>def __repr__(self):</p>
<p>return "%s obj: %s %s %s» % (id(self), self._copied,</p>
<p>self.created, self.created_gmtime)</p>
<p>a = CC()</p>
<p>print a</p>
<p>b = copy.deepcopy(a)</p>
<p>print b</p>
<p>В результате будет получено</p>
<p>Листинг</p>
<p>1075715052 init 1102751640.91</p>
<p>1075715052 obj: 1 1102751640.91 (2004, 12, 11, 7, 54, 0, 5, 346, 0)</p>
<p>1075715052 getinitargs 1102751640.91</p>
<p>1075729452 init 1102751640.91</p>
<p>1075715052 getstate 1102751640.91</p>
<p>1075729452 setstate {'copied': 1}</p>
<p>1075729452 obj: 2 1102751640.91 (2004, 12, 11, 7, 54, 0, 5, 346, 0)</p>
<p>Состояние объекта состоит из трех атрибутов: created, created_gmtime, copied. Первый из этих атрибутов может быть восстановлен передачей параметра конструктору. Второй — вычислен в конструкторе на основе первого. А вот третий не входит в интерфейс класса и может быть передан только через механизм getstate/setstate. Причем, по смыслу этого атрибута при каждом копировании он должен увеличиваться на единицу (хотя в разных случаях атрибут может требовать других действий или не требовать их вообще). Следует включить отладочные операторы вывода, чтобы отследить последовательность вызовов методов при копировании.</p>
<p>Механизм getstate/setstate позволяет передавать при копировании только то, что нужно для воссоздания объекта, тогда как атрибут __dict__ может содержать много лишнего. Более того, __dict__ может содержать объекты, которые просто так сериализации не поддаются, и поэтому getstate/setstate — единственная возможность обойти подобные ограничения.</p>
<p>Примечание:</p>
<p>Следует заметить, что сериализация функций и классов — лишь кажущаяся: на принимающей стороне должны быть определения функций и классов, передаются же только их имена и принадлежность модулям.</p>
<p>Для хранения объектов используются не только простейшие механизмы хранения вроде pickle.dump/pickle.load или полки shelve. Сериализованные объекты Python можно хранить в специализированных хранилищах объектов (например, ZODB) или реляционных базах данных.</p>
<p>Это также касается передачи объектов по сетям передачи данных. Если простейшие объекты (вроде строк или чисел) можно передавать напрямую через HTTP, XML–RPC, SOAP и т.д., где они имеют собственный тип, то произвольные объекты необходимо консервировать на передающей стороне и расконсервировать на принимающей.</p>
<p>Критика ООП</p>
<p>Объектно–ориентированный подход сегодня считается «самым передовым». Однако не следует слепо верить в его всемогущество. Отдача (в виде скорости разработки) от объектного проектирования чувствуется только в больших проектах и в проектах, которые родственны объектному подходу: построение графического интерфейса, моделирование систем и т.п.</p>
<p>Также спорна большая гибкость объектных программ к изменениям. Она зависит от того, вносится ли новый метод (для серии объектов) или новый тип объекта. При процедурном подходе при появлении нового метода пишется отдельная процедура, в которой в каждой ветке алгоритма обрабатывается свой тип данных (то есть такое изменение требует редактирования одного места в коде). При ООП изменять придется каждый класс, внося в него новый метод (то есть изменения в нескольких местах). Зато ООП выигрывает при внесении нового типа данных: ведь изменения происходят только в одном месте, где описываются все методы для данного типа. При процедурном подходе приходится изменять несколько процедур. Сказанное иллюстрируется ниже. Пусть имеются классы A, B, C и методы a, b, c:</p>
<p>Листинг</p>
<p># ООП</p>
<p>class A:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p>class B:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p>class C:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p># процедурный подход</p>
<p>def a(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>def b(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>def c(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>При внесении нового типа объекта изменения в ОО–программе затрагивают только один модуль, а в процедурной — все процедуры:</p>
<p>Листинг</p>
<p># ООП</p>
<p>class D:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p># процедурный подход</p>
<p>def a(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>if type(x) is D: …</p>
<p>def b(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>if type(x) is D: …</p>
<p>def c(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p>if type(x) is D: …</p>
<p>И наоборот, теперь нужно добавить новый метод обработки. При процедурном подходе просто пишется новая процедура, а вот для объектного приходится изменять все классы:</p>
<p>Листинг</p>
<p># процедурный подход</p>
<p>def d(x):</p>
<p>if type(x) is A: …</p>
<p>if type(x) is B: …</p>
<p>if type(x) is C: …</p>
<p># ООП</p>
<p>class A:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p>def d(): …</p>
<p>class B:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p>def d(): …</p>
<p>class C:</p>
<p>def a(): …</p>
<p>def b(): …</p>
<p>def c(): …</p>
<p>def d(): …</p>
<p>Язык программирования Python изначально был ориентирован на практические нужды. Приведенное выше выражается в стандартной библиотеке Python, то есть в том, что там применяются и функции (обычно сильно обобщенные на довольно широкий круг входных данных), и классы (когда операции достаточно специфичны). Обобщенная природа функций Python и полиморфизм, не завязанный целиком на наследовании — вот свойства языка Python, позволяющие иметь большую гибкость в комбинации процедурного и объектно–ориентированного подходов.</p>
<p>Заключение</p>
<p>Даже достаточно неформальное введение в ООП потребовало определения большого количества терминов. В лекции была сделана попытка с помощью примеров передать не столько букву, сколько дух терминологии ООП. Были рассмотрены все базовые понятия: объект, тип, класс и виды отношений между объектами (IS–A, HAS–A, USE–A). Слушатели получили представление о том, что такое инкапсуляция и полиморфизм в стиле ООП, а также наследование — продление времени жизни объекта за рамками исполняющейся программы, известное как устойчивость объекта (object persistence). Были указаны недостатки ООП, но при этом весь предыдущий материал объективно свидетельствовал о достоинствах этого подхода.</p>
<p>Возможно, что именно эта лекция приведет слушателей к пониманию ООП, пригодному и удобному для практической работы.</p>
<center><div align="center"></div></center>





