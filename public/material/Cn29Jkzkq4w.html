<p style="text-align:justify"><span style="font-size:20px">Описание метода внутри объектного типа соответствует опережающему описанию метода (forward). Таким образом, где-нибудь после описания объектного типа, но внутри той же самой области действия, что и область действия описания объектного типа, метод должен реализоваться путем определения его описания.</span></p><p style="text-align:justify"><span style="font-size:20px">Для процедурных и функциональных методов определяющее описание имеет форму обычного описания процедуры или функции с тем исключением, что в этом случае идентификатор процедуры или функции рассматривается как идентификатор метода.</span></p><p style="text-align:justify"><span style="font-size:20px">В определяющем описании метода всегда присутствует неявный параметр с идентификатором Self, соответствующий формальному параметру-переменной, обладающему объектным типом. Внутри блока метода Self представляет экземпляр, компонент метода которого был указан для активизации метода. Таким образом, любые изменения значений полей Self отражаются на экземпляре.</span></p><p style="text-align:justify"><span style="font-size:20px">Виртуальные методы</span></p><p style="text-align:justify"><span style="font-size:20px">По умолчанию методы являются статическими, однако они могут, за исключением конструкторов, быть виртуальными (посредством включения директивы virtual в описание метода). Компилятор разрешает ссылки на вызовы статических методов во время процесса компиляции, тогда как вызовы виртуальных методов разрешаются во время выполнения. Это иногда называют поздним связыванием.</span></p><p style="text-align:justify"><span style="font-size:20px">Переопределение статического метода не зависит от изменения заголовка метода. В противоположность этому, переопределение виртуального метода должно сохранять порядок, типы и имена параметров, а также типы результатов функций, если таковые имеются. Более того, переопределение опять же должно включать директиву virtual.</span></p><p style="text-align:justify"><span style="font-size:20px">Динамические методы</span></p><p style="text-align:justify"><span style="font-size:20px">Borland Pascal поддерживает дополнительные методы с поздним связыванием, которые называются динамическими методами. Динамические методы отличаются от виртуальных только характером их диспетчеризации на этапе выполнения. Во всех других отношениях динамические методы считаются эквивалентными виртуальным.</span></p><p style="text-align:justify"><span style="font-size:20px">Описание динамического метода эквивалентно описанию виртуального метода, но описание динамического метода должно включать в себя индекс динамического метода, который указывается непосредственно за ключевым словом virtual. Индекс динамического метода должен быть целочисленной константой в диапазоне от 1 до 656535 и должен быть уникальным среди индексов других динамических методов, содержащихся в объектном типе или его предках. Например:</span></p><div class="fb2-empty-line" style="font-family: Arial; color: rgb(0, 0, 0); text-align: justify; font-size: 18px; height: 10px; line-height: 27px;">&nbsp;</div><p style="text-align:justify"><span style="font-size:20px">procedure FileOpen(var Msg: TMessage); virtual 100;</span></p><div class="fb2-empty-line" style="font-family: Arial; color: rgb(0, 0, 0); text-align: justify; font-size: 18px; height: 10px; line-height: 27px;">&nbsp;</div><p style="text-align:justify"><span style="font-size:20px">Переопределение динамического метода должно соответствовать порядку, типам и именам параметров и точно соответствовать типу результата функции порождающего метода. Переопределение также должно включать в себя директиву virtual, за которой следует тот же индекс динамического метода, который был задан в объектном типе предка.</span></p>