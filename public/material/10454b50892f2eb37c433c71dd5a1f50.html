# encoding: windows-1251







<p>В этой лекции сделана попытка пролить свет на внутреннее устройство интерпретатора Python. Для иллюстрации работы интерпретатора рассматриваются отладчик, профайлер и «дизассемблер».</p>
<p>Лексический анализ</p>
<p>Лексический анализатор языка программирования разбивает исходный текст программы (состоящий из одиночных символов) на лексемы — неделимые «слова» языка.</p>
<p>Основные категории лексем Python: идентификаторы и ключевые слова (NAME), литералы (STRING, NUMBER и т.п.), операции (OP), разделители, специальные лексемы для обозначения (изменения) отступов (INDENT, DEDENT) и концов строк (NEWLINE), а также комментарии (COMMENT). Лексический анализатор доступен через модуль tokenize, а определения кодов лексем содержатся в модуле token стандартной библиотеки Python. Следующий пример показывает лексический анализатор в действии:</p>
<p>Листинг</p>
<p>import StringIO, token, tokenize</p>
<p>prog_example = """</p>
<p>for i in range(100): # comment</p>
<p>if i % 1 == 0: \</p>
<p>print ":", t**2</p>
<p>«"".strip()</p>
<p>rl = StringIO.StringIO(prog_example).readline</p>
<p>for t_type, t_str, (br,bc), (er,ec), logl in tokenize.generate_tokens(rl):</p>
<p>print "%3i %10s : %20r» % (t_type, token.tok_name[t_type], t_str)</p>
<p>А вот что выведет эта программа, разбив на лексемы исходный код примера:</p>
<p>Листинг</p>
<table>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
<tr><td></td></tr>
</table>
<p>Фактически получен поток лексем, который может использоваться для различных целей. Например, для синтаксического «окрашивания» кода на языке Python. Словарь token.tok_name позволяет получить мнемонические имена для типа лексемы по номеру.</p>
<p>Синтаксический анализ</p>
<p>Вторая стадия преобразования исходного текста программы в байт–код интерпретатора состоит в синтаксическом анализе исходного текста. Модуль parser содержит функции suite() и expr() для построения деревьев синтаксического разбора соответственно для кода программ и выражений Python. Модуль symbol содержит номера символов грамматики Python, словарь для получения названия символа из грамматики Python.</p>
<p>Следующая программа анализирует достаточно простой код Python (prg) и порождает дерево синтаксического разбора (AST–объект), который тут же можно превращать в кортеж и красиво выводить функцией pprint.pprint(). Далее определяется функция для превращения номеров символов в их мнемонические обозначения (имена) в грамматике:</p>
<p>Листинг</p>
<p>import pprint, token, parser, symbol</p>
<p>prg = ""«print 2*2»""</p>
<p>pprint.pprint(parser.suite(prg).totuple())</p>
<p>def pprint_ast(ast, level=0):</p>
<p>if type(ast) == type(()):</p>
<p>for a in ast:</p>
<p>pprint_ast(a, level+1)</p>
<p>elif type(ast) == type(""):</p>
<p>print repr(ast)</p>
<p>else:</p>
<p>print " "*level,</p>
<p>try:</p>
<p>print symbol.sym_name[ast]</p>
<p>except:</p>
<p>print «token.»+token.tok_name[ast],</p>
<p>print</p>
<p>pprint_ast(parser.suite(prg).totuple())</p>
<p>Эта программа выведет следующее (структура дерева отражена отступами):</p>
<p>Листинг</p>
<p>(257,</p>
<p>(264,</p>
<p>(265,</p>
<p>(266,</p>
<p>(269,</p>
<p>(1, 'print'),</p>
<p>(292,</p>
<p>(293,</p>
<p>(294,</p>
<p>(295,</p>
<p>(297,</p>
<p>(298,</p>
<p>(299,</p>
<p>(300,</p>
<p>(301,</p>
<p>(302,</p>
<p>(303, (304, (305, (2, '2')))),</p>
<p>(16, '*'),</p>
<p>(303, (304, (305, (2, '2')))))))))))))))),</p>
<p>(4, ''))),</p>
<p>(0, ''))</p>
<p>file_input</p>
<p>stmt</p>
<p>simple_stmt</p>
<p>small_stmt</p>
<p>print_stmt</p>
<p>token.NAME 'print'</p>
<p>test</p>
<p>and_test</p>
<p>not_test</p>
<p>comparison</p>
<p>expr</p>
<p>xor_expr</p>
<p>and_expr</p>
<p>shift_expr</p>
<p>arith_expr</p>
<p>term</p>
<p>factor</p>
<p>power</p>
<p>atom</p>
<p>token.NUMBER '2'</p>
<p>token.STAR '*'</p>
<p>factor</p>
<p>power</p>
<p>atom</p>
<p>token.NUMBER '2'</p>
<p>token.NEWLINE ''</p>
<p>token.ENDMARKER ''</p>
<p>Получение байт–кода</p>
<p>После того как получено дерево синтаксического разбора, компилятор должен превратить его в байт–код, подходящий для исполнения интерпретатором. В следующей программе проводятся отдельно синтаксический анализ, компиляция и выполнение (вычисление) кода (и выражения) в языке Python:</p>
<p>Листинг</p>
<p>import parser</p>
<p>prg = ""«print 2*2»""</p>
<p>ast = parser.suite(prg)</p>
<p>code = ast.compile('filename.py')</p>
<p>exec code</p>
<p>prg = ""«2*2»""</p>
<p>ast = parser.expr(prg)</p>
<p>code = ast.compile('filename1.py')</p>
<p>print eval(code)</p>
<p>Функция parser.suite() (или parser.expr()) возвращает AST–объект (дерево синтаксического анализа), которое методом compile() компилируется в Python байт–код и сохраняется в кодовом объекте code. Теперь этот код можно выполнить (или, в случае выражения — вычислить) с помощью оператора exec (или функции eval()).</p>
<p>Здесь необходимо заметить, что недавно в Python появился пакет compiler, который объединяет модули для работы анализа исходного кода на Python и генерации кода. В данной лекции он не рассматривается, но те, кто хочет глубже изучить эти процессы, может обратиться к документации по Python.</p>
<p>Изучение байт–кода</p>
<p>Для изучения байт–кода Python–программы можно использовать модуль dis (сокращение от «дизассемблер»), который содержит функции, позволяющие увидеть байт–код в мнемоническом виде. Следующий пример иллюстрирует эту возможность:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; def f():</p>
<p>… print 2*2</p>
<p>…</p>
<p>&gt;&gt;&gt; dis.dis(f)</p>
<p>2 0 LOAD_CONST 1 (2)</p>
<p>3 LOAD_CONST 1 (2)</p>
<p>6 BINARY_MULTIPLY</p>
<p>7 PRINT_ITEM</p>
<p>8 PRINT_NEWLINE</p>
<p>9 LOAD_CONST 0 (None)</p>
<p>12 RETURN_VALUE</p>
<p>Определяется функция f(), которая должна вычислить и напечатать значение выражения 2*2. Функция dis() модуля dis выводит код функции f() в виде некого «ассемблера», в котором байт–код Python представлен мнемоническими именами. Следует заметить, что при интерпретации используется стек, поэтому LOAD_CONST кладет значение на вершину стека, а BINARY_MULTIPLY берет со стека два значения и помещает на стек результат их перемножения. Функция без оператора return возвращает значение None. Как и в случае с кодами для микропроцессора, некоторые байт–коды принимают параметры.</p>
<p>Мнемонические имена можно увидеть в списке dis.opname (ниже печатаются только задействованные имена):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import dis</p>
<p>&gt;&gt;&gt; [n for n in dis.opname if n[0] != "&lt;"]</p>
<p>['STOP_CODE', 'POP_TOP', 'ROT_TWO', 'ROT_THREE', 'DUP_TOP', 'ROT_FOUR',</p>
<p>'NOP', 'UNARY_POSITIVE', 'UNARY_NEGATIVE', 'UNARY_NOT', 'UNARY_CONVERT',</p>
<p>'UNARY_INVERT', 'LIST_APPEND', 'BINARY_POWER', 'BINARY_MULTIPLY',</p>
<p>'BINARY_DIVIDE', 'BINARY_MODULO', 'BINARY_ADD', 'BINARY_SUBTRACT',</p>
<p>'BINARY_SUBSCR', 'BINARY_FLOOR_DIVIDE', 'BINARY_TRUE_DIVIDE',</p>
<p>'INPLACE_FLOOR_DIVIDE', 'INPLACE_TRUE_DIVIDE', 'SLICE+0', 'SLICE+1',</p>
<p>'SLICE+2', 'SLICE+3', 'STORE_SLICE+0', 'STORE_SLICE+1', 'STORE_SLICE+2',</p>
<p>'STORE_SLICE+3', 'DELETE_SLICE+0', 'DELETE_SLICE+1', 'DELETE_SLICE+2',</p>
<p>'DELETE_SLICE+3', 'INPLACE_ADD', 'INPLACE_SUBTRACT', 'INPLACE_MULTIPLY',</p>
<p>'INPLACE_DIVIDE', 'INPLACE_MODULO', 'STORE_SUBSCR', 'DELETE_SUBSCR',</p>
<p>'BINARY_LSHIFT', 'BINARY_RSHIFT', 'BINARY_AND', 'BINARY_XOR', 'BINARY_OR',</p>
<p>'INPLACE_POWER', 'GET_ITER', 'PRINT_EXPR', 'PRINT_ITEM', 'PRINT_NEWLINE',</p>
<p>'PRINT_ITEM_TO', 'PRINT_NEWLINE_TO', 'INPLACE_LSHIFT', 'INPLACE_RSHIFT',</p>
<p>'INPLACE_AND', 'INPLACE_XOR', 'INPLACE_OR', 'BREAK_LOOP', 'LOAD_LOCALS',</p>
<p>'RETURN_VALUE', 'IMPORT_STAR', 'EXEC_STMT', 'YIELD_VALUE', 'POP_BLOCK',</p>
<p>'END_FINALLY', 'BUILD_CLASS', 'STORE_NAME', 'DELETE_NAME',</p>
<p>'UNPACK_SEQUENCE', 'FOR_ITER', 'STORE_ATTR', 'DELETE_ATTR', 'STORE_GLOBAL',</p>
<p>'DELETE_GLOBAL', 'DUP_TOPX', 'LOAD_CONST', 'LOAD_NAME', 'BUILD_TUPLE',</p>
<p>'BUILD_LIST', 'BUILD_MAP', 'LOAD_ATTR', 'COMPARE_OP', 'IMPORT_NAME',</p>
<p>'IMPORT_FROM', 'JUMP_FORWARD', 'JUMP_IF_FALSE', 'JUMP_IF_TRUE',</p>
<p>'JUMP_ABSOLUTE', 'LOAD_GLOBAL', 'CONTINUE_LOOP', 'SETUP_LOOP',</p>
<p>'SETUP_EXCEPT', 'SETUP_FINALLY', 'LOAD_FAST', 'STORE_FAST', 'DELETE_FAST',</p>
<p>'RAISE_VARARGS', 'CALL_FUNCTION', 'MAKE_FUNCTION', 'BUILD_SLICE',</p>
<p>'MAKE_CLOSURE', 'LOAD_CLOSURE', 'LOAD_DEREF', 'STORE_DEREF',</p>
<p>'CALL_FUNCTION_VAR', 'CALL_FUNCTION_KW', 'CALL_FUNCTION_VAR_KW',</p>
<p>'EXTENDED_ARG']</p>
<p>Легко догадаться, что LOAD означает загрузку значения в стек, STORE — выгрузку, PRINT — печать, BINARY — бинарную операцию и т.п.</p>
<p>Отладка</p>
<p>В интерпретаторе языка Python заложены возможности отладки программ, а в стандартной поставке имеется простейший отладчик — pdb. Следующий пример показывает программу, которая подвергается отладке, и типичную сессию отладки:</p>
<p>Листинг</p>
<p># File myfun.py</p>
<p>def fun(s):</p>
<p>lst = []</p>
<p>for i in s:</p>
<p>lst.append(ord(i))</p>
<p>return lst</p>
<p>Так может выглядеть типичный процесс отладки:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import pdb, myfun</p>
<p>&gt;&gt;&gt; pdb.runcall(myfun.fun, «ABCDE»)</p>
<p>&gt; /examples/myfun.py(4)fun()</p>
<p>— &gt; lst = []</p>
<p>(Pdb) n</p>
<p>&gt; /examples/myfun.py(5)fun()</p>
<p>— &gt; for i in s:</p>
<p>(Pdb) n</p>
<p>&gt; /examples/myfun.py(6)fun()</p>
<p>— &gt; lst.append(ord(i))</p>
<p>(Pdb) l</p>
<p>1 #!/usr/bin/python</p>
<p>2 # File myfun.py</p>
<p>3 def fun(s):</p>
<p>4 lst = []</p>
<p>5 for i in s:</p>
<p>6 -&gt; lst.append(ord(i))</p>
<p>7 return lst</p>
<p>[EOF]</p>
<p>(Pdb) p lst</p>
<p>[]</p>
<p>(Pdb) p vars()</p>
<p>{'i': 'A', 's': 'ABCDE', 'lst': []}</p>
<p>(Pdb) n</p>
<p>&gt; /examples/myfun.py(5)fun()</p>
<p>— &gt; for i in s:</p>
<p>(Pdb) p vars()</p>
<p>{'i': 'A', 's': 'ABCDE', 'lst': [65]}</p>
<p>(Pdb) n</p>
<p>&gt; /examples/myfun.py(6)fun()</p>
<p>— &gt; lst.append(ord(i))</p>
<p>(Pdb) n</p>
<p>&gt; /examples/myfun.py(5)fun()</p>
<p>— &gt; for i in s:</p>
<p>(Pdb) p vars()</p>
<p>{'i': 'B', 's': 'ABCDE', 'lst': [65, 66]}</p>
<p>(Pdb) r</p>
<p>— Return - &gt; /examples/myfun.py(7)fun() — &gt;[65, 66, 67, 68, 69]</p>
<p>— &gt; return lst</p>
<p>(Pdb) n</p>
<p>[65, 66, 67, 68, 69]</p>
<p>&gt;&gt;&gt;</p>
<p>Интерактивный отладчик вызывается функцией pdb.runcall() и на его приглашение (Pdb) следует вводить команды. В данном примере сессии отладки были использованы некоторые из следующих команд: l (печать фрагмент трассируемого кода), n (выполнить все до следующей строки), s (сделать следующий шаг, возможно, углубившись в вызов метода или функции), p (печать значения), r (выполнить все до возврата из текущей функции).</p>
<p>Разумеется, некоторые интерактивные оболочки разработчика для Python предоставляют функции отладчика. Кроме того, отладку достаточно легко организовать, поставив в ключевых местах программы, операторы print для вывода интересующих параметров. Обычно этого достаточно, чтобы локализовать проблему. В CGI–сценариях можно использовать модуль cgitb, о котором говорилось в одной из предыдущих лекций.</p>
<p>Профайлер</p>
<p>Для определения мест в программе, на выполнение которых уходит значительная часть времени, обычно применяется профайлер.</p>
<p>Модуль profile</p>
<p>Этот модуль позволяет проанализировать работу функции и выдать статистику использования процессорного времени на выполнение той или иной части алгоритма.</p>
<p>В качестве примера можно рассмотреть профилирование функции для поиска строк из списка, наиболее похожих на данную. Для того чтобы качественно профилировать функцию difflib.get_close_matches(), нужен большой объем данных. В файле russian.txt собрано 160 тысяч слов русского языка. Следующая программа поможет профилировать функцию difflib.get_close_matches():</p>
<p>Листинг</p>
<p>import difflib, profile</p>
<p>def print_close_matches(word):</p>
<p>print "\n».join(difflib.get_close_matches(word + "\n», open(«russian.txt»)))</p>
<p>profile.run(r'print_close_matches(«профайлер»)')</p>
<p>При запуске этой программы будет выдано примерно следующее:</p>
<p>Листинг</p>
<p>провайдер</p>
<p>трайлер</p>
<p>бройлер</p>
<p>899769 function calls (877642 primitive calls) in 23.620 CPU seconds</p>
<p>Ordered by: standard name</p>
<p>ncalls tottime percall cumtime percall filename:lineno(function)</p>
<p>1 0.000 0.000 23.610 23.610 &lt;string&gt;:1(?)</p>
<p>1 0.000 0.000 23.610 23.610 T.py:6(print_close_matches)</p>
<p>1 0.000 0.000 0.000 0.000 difflib.py:147(__init__)</p>
<p>1 0.000 0.000 0.000 0.000 difflib.py:210(set_seqs)</p>
<p>159443 1.420 0.000 1.420 0.000 difflib.py:222(set_seq1)</p>
<p>2 0.000 0.000 0.000 0.000 difflib.py:248(set_seq2)</p>
<p>2 0.000 0.000 0.000 0.000 difflib.py:293(__chain_b)</p>
<p>324261 2.240 0.000 2.240 0.000 difflib.py:32(_calculate_ratio)</p>
<p>28317 1.590 0.000 1.590 0.000 difflib.py:344(find_longest_match)</p>
<p>6474 0.100 0.000 2.690 0.000 difflib.py:454(get_matching_blocks)</p>
<p>28317/6190 1.000 0.000 2.590 0.000 difflib.py:480(__helper)</p>
<p>6474 0.450 0.000 3.480 0.001 difflib.py:595(ratio)</p>
<p>28686 0.240 0.000 0.240 0.000 difflib.py:617(&lt;lambda&gt;)</p>
<p>158345 8.690 0.000 9.760 0.000 difflib.py:621(quick_ratio)</p>
<p>159442 2.950 0.000 4.020 0.000 difflib.py:650(real_quick_ratio)</p>
<p>1 4.930 4.930 23.610 23.610 difflib.py:662(get_close_matches)</p>
<p>1 0.010 0.010 23.620 23.620 profile:0(print_close_matches(«профайлер»))</p>
<p>0 0.000 0.000 profile:0(profiler)</p>
<p>Здесь колонки таблицы показывают следующие значения: ncalls — количество вызовов (функции), tottime — время выполнения кода функции (не включая времени выполнения вызываемых из нее функций), percall — то же время, в пересчете на один вызов, cumtime — суммарное время выполнения функции (и всех вызываемых из нее функций), filename — имя файла, lineno — номер строки в файле, function — имя функции (если эти параметры известны).</p>
<p>Из приведенной статистики следует, что наибольшие усилия по оптимизации кода необходимо приложить в функциях quick_ratio() (на нее потрачено 8,69 секунд), get_close_matches() (4,93 секунд), затем можно заняться real_quick_ratio() (2,95 секунд) и _calculate_ratio() (секунд).</p>
<p>Это лишь самый простой вариант использования профайлера: модуль profile (и связанный с ним pstats) позволяет получать и обрабатывать статистику: их применение описано в документации.</p>
<p>Модуль timeit</p>
<p>Предположим, что проводится оптимизация небольшого участка кода. Необходимо определить, какой из вариантов кода является наиболее быстрым. Это можно сделать с помощью модуля timeit.</p>
<p>В следующей программе используется метод timeit() для измерения времени, необходимого для вычисления небольшого фрагмента кода. Измерения проводятся для трех вариантов кода, делающих одно и то же: конкатенирующих десять тысяч строк в одну строку. В первом случае используется наиболее естественный, «лобовой» прием инкрементной конкатенации, во втором — накопление строк в списке с последующим объединением в одну строку, в третьем применяется списковое включение, а затем объединение элементов списка в одну строку:</p>
<p>Листинг</p>
<p>from timeit import Timer</p>
<p>t = Timer("""</p>
<p>res = ""</p>
<p>for k in range(1000000,1010000):</p>
<p>res += str(k)</p>
<p>«"")</p>
<p>print t.timeit(200)</p>
<p>t = Timer("""</p>
<p>res = []</p>
<p>for k in range(1000000,1010000):</p>
<p>res.append(str(k))</p>
<p>res = ",".join(res)</p>
<p>«"")</p>
<p>print t.timeit(200)</p>
<p>t = Timer("""</p>
<p>res = ",".join([str(k) for k in range(1000000,1010000)])</p>
<p>«"")</p>
<p>print t.timeit(200)</p>
<p>Разные версии Python дадут различные результаты прогонов:</p>
<p>Листинг</p>
<p># Python 2.3</p>
<p>77.6665899754</p>
<p>10.1372740269</p>
<p>9.07727599144</p>
<p># Python 2.4</p>
<p>9.26631307602</p>
<p>9.8416929245</p>
<p>7.36629199982</p>
<p>В старых версиях Python рекомендуемым способом конкатенации большого количества строк являлось накопление их в списке с последующим применением функции join() (кстати, инкрементная конкатенация почти в восемь раз медленнее этого приема). Начиная с версии 2.4, инкрементная конкатенация была оптимизирована и теперь имеет даже лучший результат, чем версия со списками (которая вдобавок требует больше памяти). Но чемпионом все–таки является работа со списковым включением, поэтому свертывание циклов в списковое включение позволяет повысить эффективность кода.</p>
<p>Если требуются более точные результаты, рекомендуется использовать метод repeat(n, k) - он позволяет вызывать timeit(k) n раз, возвращая список из n значений. Необходимо отметить, что на результаты может влиять загруженность компьютера, на котором проводятся испытания.</p>
<p>Оптимизация</p>
<p>Основная реализация языка Python пока что не имеет оптимизирующего компилятора, поэтому разговор об оптимизации касается только оптимизации кода самим программистом. В любом языке программирования имеются свои характерные приемы оптимизации кода. Оптимизация (улучшение) кода может происходить в двух (зачастую конкурирующих) направлениях: скорость и занимаемая память. В условиях достатка оперативной памяти приложения обычно оптимизируют по скорости. При оптимизации по времени программы для одноразового вычисления следует иметь в виду, что в общее время решения задачи входит не только выполнение программы, но и время ее написания. Не стоит тратить усилия на оптимизацию программы, если она будет использоваться очень редко.</p>
<p>Следует учитывать, что программа, реализующая некоторый алгоритм, не может быть оптимизирована до бесконечно малого времени вычисления: используемый алгоритм имеет определенную временную сложность и программу, основанную на слишком сложном алгоритме, существенно оптимизировать не удастся. Можно попытаться сменить алгоритм (хотя многие задачи этого сделать не позволяют) или ослабить требования к решениям. Иногда помогает упрощение алгоритма. К сожалению, оптимизация кода, как и программирование — задача неформальная, поэтому умение оптимизировать код приходит с опытом.</p>
<p>Если скорость работы программы при большой длине данных не устраивает, следует поискать более эффективный алгоритм. Если же более эффективный алгоритм практически нецелесообразен, можно попытаться провести оптимизацию кода.</p>
<p>Собственно, в данном примере для модуля timeit уже показан практический способ нахождения оптимального кода. Стоит также отметить, что с помощью профайлера нужно определить места кода, отнимающие наибольшую часть времени. Обычно это действия, выполняемые в самом вложенном цикле. Можно попытаться вынести из цикла все, что можно вычислить в более внешнем цикле или вообще вне цикла.</p>
<p>В языке Python вызов функции является относительно дорогостоящей операцией, поэтому на критичных по скорости участках кода следует избегать вызова большого числа функций.</p>
<p>В некоторых случаях работу программы на Python можно ускорить в несколько раз с помощью специального оптимизатора (он не входит в стандартную поставку Python, но свободно распространяется): psyco. Для ускорения программы достаточно добавить следующие строки в начале главного модуля программы:</p>
<p>Листинг</p>
<p>import psyco</p>
<p>psyco.full()</p>
<p>Правда, некоторые функции не поддаются «компиляции» с помощью psyco. В этих случаях будут выданы предупреждения. Посмотрите документацию по psyco с тем, чтобы узнать ограничения в его использовании и способы их преодоления.</p>
<p>Еще одним вариантом ускорения работы приложения является переписывание критических участков алгоритма на языках более низкого уровня (С/С++) и использование модулей расширения из Python. Однако эта крайняя мера обычно не требуется или модули для задач, требующих большей эффективности, уже написаны. Например, для работы с растровыми изображениями имеется прекрасная библиотека модулей PIL (Python Imaging Library). Численные расчеты можно выполнять с помощью пакета Numeric и т.д.</p>
<p>Pychecker</p>
<p>Одним из наиболее интересных инструментов для анализа исходного кода Python программы является Pychecker. Как и lint для языка C, Pychecker позволяет выявлять слабости в исходном коде на языке Python. Можно рассмотреть следующий пример с использованием Pychecker:</p>
<p>Листинг</p>
<p>import re, string</p>
<p>import re</p>
<p>a = «a b c»</p>
<p>def test(x, y):</p>
<p>from string import split</p>
<p>a = «x y z»</p>
<p>print split(a) + x</p>
<p>test(['d'], 'e')</p>
<p>Pychecker выдаст следующие предупреждения:</p>
<p>Листинг</p>
<p>badcode.py:1: Imported module (string) not used</p>
<p>badcode.py:2: Imported module (re) not used</p>
<p>badcode.py:2: Module (re) re–imported</p>
<p>badcode.py:5: Parameter (y) not used</p>
<p>badcode.py:6: Using import and from … import for (string)</p>
<p>badcode.py:7: Local variable (a) shadows global defined on line 3</p>
<p>badcode.py:8: Local variable (a) shadows global defined on line 3</p>
<p>В первой строке импортирован модуль, который далее не применяется, то же самое с модулем re. Кроме того, модуль re импортирован повторно. Другие проблемы с кодом: параметр y не использован; модуль string применен как в операторе import, так и во from–import; локальная переменная a затеняет глобальную, которая определена в третьей строке.</p>
<p>Можно переписать этот пример так, чтобы Pychecker выдавал меньше предупреждений:</p>
<p>Листинг</p>
<p>import string</p>
<p>a = «a b c»</p>
<p>def test(x, y):</p>
<p>a1 = «x y z»</p>
<p>print string.split(a1) + x</p>
<p>test(['d'], 'e')</p>
<p>Теперь имеется лишь одно предупреждение:</p>
<p>Листинг</p>
<p>goodcode.py:4: Parameter (y) not used</p>
<p>Такое тоже бывает. Программист должен лишь убедиться, что он не сделал ошибки.</p>
<p>Исследование объекта</p>
<p>Даже самые примитивные объекты в языке программирования Python имеют возможности, общие для всех объектов: можно получить их уникальный идентификатор (с помощью функции id()), представление в виде строки — даже в двух вариантах (функции str() и repr()); можно узнать атрибуты объекта с помощью встроенной функции dir() и во многих случаях пользоваться атрибутом __dict__ для доступа к словарю имен объекта. Также можно узнать, сколько других объектов ссылается на данный с помощью функции sys.getrefcount(). Есть еще сборка мусора, которая применяется для освобождения памяти от объектов, которые более не используются, но имеют ссылки друг на друга (циклические ссылки). Сборкой мусора (garbage collection) можно управлять из модуля gc.</p>
<p>Все это подчеркивает тот факт, что объекты в Python существуют не сами по себе, а являются частью системы: они и их отношения строго учитываются интерпретатором.</p>
<p>Сразу же следует оговориться, что Python имеет две стороны интроспекции: «официальную», которую поддерживает описание языка и многие его реализации, и «неофициальную», которая использует особенности той или иной реализации. С помощью «официальных» средств интроспекции можно получить информацию о принадлежности объекта тому или иному классу (функция type()), проверить принадлежность экземпляра классу (isinstance()), отношение наследования между классами (issubclass()), а также получить информацию, о которой говорилось чуть выше. Это как бы приборная доска машины. С помощью «неофициальной» интроспекции (это то, что под капотом) можно получить доступ к чему угодно: к текущему фрейму исполнения и стеку, к байт–коду функции, к некоторым механизмам интерпретатора (от загрузки модулей до полного контроля над внутренней средой исполнения). Сразу же стоит сказать, что этот механизм следует рассматривать (и тем более вносить изменения) очень деликатно: разработчики языка не гарантируют постоянство этих механизмов от версии к версии, а некоторые полезные модули используют эти механизмы для своих целей. Например, упомянутый ранее ускоритель выполнения Python–кода psyco очень серьезно вмешивается во фреймы исполнения, заменяя их своими объектами. Кроме того, разные реализации Python могут иметь совсем другие внутренние механизмы.</p>
<p>Сказанное стоит подкрепить примерами.</p>
<p>В первом примере исследуется объект с помощью «официальных» средств. В качестве объекта выбрана обычная строка:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = «abcd»</p>
<p>&gt;&gt;&gt; dir(s)</p>
<p>['__add__', '__class__', '__contains__', '__delattr__', '__doc__',</p>
<p>'__eq__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',</p>
<p>'__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__',</p>
<p>'__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',</p>
<p>'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__',</p>
<p>'__str__', 'capitalize', 'center', 'count', 'decode',</p>
<p>'encode', 'endswith', 'expandtabs', 'find', 'index', 'isalnum', 'isalpha',</p>
<p>'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust',</p>
<p>'lower', 'lstrip', 'replace', 'rfind', 'rindex', 'rjust', 'rstrip',</p>
<p>'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title',</p>
<p>'translate', 'upper', 'zfill']</p>
<p>&gt;&gt;&gt; id(s)</p>
<p>1075718400</p>
<p>&gt;&gt;&gt; print str(s)</p>
<p>abcd</p>
<p>&gt;&gt;&gt; print repr(s)</p>
<p>'abcd'</p>
<p>&gt;&gt;&gt; type(s)</p>
<p>&lt;type 'str'&gt;</p>
<p>&gt;&gt;&gt; isinstance(s, basestring)</p>
<p>True</p>
<p>&gt;&gt;&gt; isinstance(s, int)</p>
<p>False</p>
<p>&gt;&gt;&gt; issubclass(str, basestring)</p>
<p>True</p>
<p>«Неофициальные» средства интроспекции в основном работают в области представления объектов в среде интерпретатора. Ниже будет рассмотрено, как главная (на настоящий момент) реализация Python может дать информацию об определенной пользователем функции:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; def f(x, y=0):</p>
<p>… ""«Function f(x, y)»""</p>
<p>… global s</p>
<p>… return t + x + y</p>
<p>…</p>
<p>&gt;&gt;&gt; f.secure = 1 # присваивается дополнительный атрибут</p>
<p>&gt;&gt;&gt; f.func_name # имя</p>
<p>'f'</p>
<p>&gt;&gt;&gt; f.func_doc # строка документации</p>
<p>'Function f(x, y)'</p>
<p>&gt;&gt;&gt; f.func_defaults # значения по умолчанию</p>
<p>(0,)</p>
<p>&gt;&gt;&gt; f.func_dict # словарь атрибутов функции</p>
<p>{'secure': 1}</p>
<p>&gt;&gt;&gt; co = f.func_code # кодовый объект</p>
<p>&gt;&gt;&gt; co</p>
<p>&lt;code object f at 0x401ec7e0, file "&lt;stdin&gt;", line 1&gt;</p>
<p>Кодовые объекты имеют свои атрибуты:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; co.co_code # байт–код</p>
<p>'t\x00\x00|\x00\x00\x17|\x01\x00\x17Sd\x01\x00S'</p>
<p>&gt;&gt;&gt; co.co_argcount # число аргументов</p>
<p>2</p>
<p>&gt;&gt;&gt; co.co_varnames # имена переменных</p>
<p>('x', 'y')</p>
<p>&gt;&gt;&gt; co.co_consts # константы</p>
<p>(None,)</p>
<p>&gt;&gt;&gt; co.co_names # локальные имена</p>
<p>('t', 'x', 'y')</p>
<p>&gt;&gt;&gt; co.co_name # имя блока кода (в нашем случае — имя функции)</p>
<p>'f'</p>
<p>и так далее. Более правильно использовать для получения всех этих сведений модуль inspect.</p>
<p>Модуль inspect</p>
<p>Основное назначение модуля inspect — давать приложению информацию о модулях, классах, функциях, трассировочных объектах, фреймах исполнения и кодовых объектах. Именно модуль inspect позволяет заглянуть «на кухню» интерпретатора Python.</p>
<p>Модуль имеет функции для проверки принадлежности объектов различным типам, с которыми он работает:</p>
<p>Функция Проверяемый тип</p>
<p>inspect.isbuiltin Встроенная функция</p>
<p>inspect.isclass Класс</p>
<p>inspect.iscode Код</p>
<p>inspect.isdatadescriptor Описатель данных</p>
<p>inspect.isframe Фрейм</p>
<p>inspect.isfunction Функция</p>
<p>inspect.ismethod Метод</p>
<p>inspect.ismethoddescriptor Описатель метода</p>
<p>inspect.ismodule Модуль</p>
<p>inspect.isroutine Функция или метод</p>
<p>inspect.istraceback Трассировочный объект</p>
<p>Пример:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import inspect</p>
<p>&gt;&gt;&gt; inspect.isbuiltin(len)</p>
<p>True</p>
<p>&gt;&gt;&gt; inspect.isroutine(lambda x: x+1)</p>
<p>True</p>
<p>&gt;&gt;&gt; inspect.ismethod(''.split)</p>
<p>False</p>
<p>&gt;&gt;&gt; inspect.isroutine(''.split)</p>
<p>True</p>
<p>&gt;&gt;&gt; inspect.isbuiltin(''.split)</p>
<p>True</p>
<p>Объект типа модуль появляется в Python–программе благодаря операции импорта. Для получения информации о модуле имеются некоторые функции, а объект–модуль обладает определенными атрибутами, как продемонстрировано ниже:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import inspect</p>
<p>&gt;&gt;&gt; inspect.ismodule(inspect)</p>
<p>True</p>
<p>&gt;&gt;&gt; inspect.getmoduleinfo('/usr/local/lib/python2.3/inspect.pyc')</p>
<p>('inspect', '.pyc', 'rb', 2)</p>
<p>&gt;&gt;&gt; inspect.getmodulename('/usr/local/lib/python2.3/inspect.pyc')</p>
<p>'inspect'</p>
<p>&gt;&gt;&gt; inspect.__name__</p>
<p>'inspect'</p>
<p>&gt;&gt;&gt; inspect.__dict__</p>
<p>…</p>
<p>&gt;&gt;&gt; inspect.__doc__</p>
<p>«Get useful information from live Python objects.\n\nThis module encapsulates</p>
<p>.…</p>
<p>Интересны некоторые функции, которые предоставляют информацию об исходном коде объектов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import inspect</p>
<p>&gt;&gt;&gt; inspect.getsourcefile(inspect) # имя файла исходного кода</p>
<p>'/usr/local/lib/python2.3/inspect.py'</p>
<p>&gt;&gt;&gt; inspect.getabsfile(inspect) # абсолютный путь к файлу</p>
<p>'/usr/local/lib/python2.3/inspect.py'</p>
<p>&gt;&gt;&gt; print inspect.getfile(inspect) # файл кода модуля</p>
<p>/usr/local/lib/python2.3/inspect.pyc</p>
<p>&gt;&gt;&gt; print inspect.getsource(inspect) # исходный текст модуля (в виде строки)</p>
<p># -*- coding: iso–8859–1 -*- ""«Get useful information from live Python objects.</p>
<p>…</p>
<p>&gt;&gt;&gt; import smtplib</p>
<p>&gt;&gt;&gt; # Комментарий непосредственно перед определением объекта:</p>
<p>&gt;&gt;&gt; inspect.getcomments(smtplib.SMTPException)</p>
<p>'# Exception classes used by this module.\n'</p>
<p>&gt;&gt;&gt; # Теперь берем строку документирования:</p>
<p>&gt;&gt;&gt; inspect.getdoc(smtplib.SMTPException)</p>
<p>'Base class for all exceptions raised by this module.'</p>
<p>С помощью модуля inspect можно узнать состав аргументов некоторой функции с помощью функции inspect.getargspec():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import inspect</p>
<p>&gt;&gt;&gt; def f(x, y=1, z=2):</p>
<p>… return x + y + z</p>
<p>…</p>
<p>&gt;&gt;&gt; def g(x, *v, **z):</p>
<p>… return x</p>
<p>…</p>
<p>&gt;&gt;&gt; print inspect.getargspec(f)</p>
<p>(['x', 'y', 'z'], None, None, (1, 2))</p>
<p>&gt;&gt;&gt; print inspect.getargspec(g)</p>
<p>(['x'], 'v', 'z', None)</p>
<p>Возвращаемый кортеж содержит список аргументов (кроме специальных), затем следуют имена аргументов для списка позиционных аргументов (*) и списка именованных аргументов (**), после чего — список значений по умолчанию для последних позиционных аргументов. Первый аргумент–список может содержать вложенные списки, отражая структуру аргументов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; def f((x1,y1), (x2,y2)):</p>
<p>… return 1</p>
<p>…</p>
<p>&gt;&gt;&gt; print inspect.getargspec(f)</p>
<p>([['x1', 'y1'], ['x2', 'y2']], None, None, None)</p>
<p>Классы (как вы помните) - тоже объекты, и о них можно кое–что узнать:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import smtplib</p>
<p>&gt;&gt;&gt; s = smtplib.SMTP</p>
<p>&gt;&gt;&gt; s.__module__ # модуль, в котором был определен объект</p>
<p>'smtplib'</p>
<p>&gt;&gt;&gt; inspect.getmodule(s) # можно догадаться о происхождении объекта</p>
<p>&lt;module 'smtplib' from '/usr/local/lib/python2.3/smtplib.pyc'&gt;</p>
<p>Для визуализации дерева классов может быть полезна функция inspect.getclasstree(). Она возвращает иерархически выстроенный в соответствии с наследованием список вложенных списков классов, указанных в списке–параметре. В следующем примере на основе списка всех встроенных классов–исключений создается дерево их зависимостей по наследованию:</p>
<p>Листинг</p>
<p>import inspect, exceptions</p>
<p>def formattree(tree, level=0):</p>
<p>«"«Вывод дерева наследований.</p>
<p>tree — дерево, подготовленное с помощью inspect.getclasstree(),</p>
<p>которое представлено списком вложенных списков и кортежей.</p>
<p>В кортеже entry первый элемент — класс, а второй — кортеж с его</p>
<p>базовыми классами. Иначе entry — вложенный список.</p>
<p>level — уровень отступов</p>
<p>«""</p>
<p>for entry in tree:</p>
<p>if type(entry) is type(()):</p>
<p>c, bases = entry</p>
<p>print level * " ", c.__name__, \</p>
<p>«(" + ", ".join([b.__name__ for b in bases]) + ")»</p>
<p>elif type(entry) is type([]):</p>
<p>formattree(entry, level+1)</p>
<p>v = exceptions.__dict__.values()</p>
<p>exc_list = [e for e in v</p>
<p>if inspect.isclass(e) and issubclass(e, Exception)]</p>
<p>formattree(inspect.getclasstree(exc_list))</p>
<p>С помощью функции inspect.currentframe() можно получить текущий фрейм исполнения. Атрибуты фрейма исполнения дают информацию о блоке кода, исполняющегося в точке вызова метода. При вызове функции (и в некоторых других ситуациях) на стек кладется соответствующий этому фрейму блок кода. При возврате из функции текущим становится фрейм, хранившийся в стеке. Фрейм содержит контекст выполнения кода: пространства имен и некоторые другие данные. Получить эти данные можно через атрибуты фреймового объекта:</p>
<p>Листинг</p>
<p>import inspect</p>
<p>def f():</p>
<p>fr = inspect.currentframe()</p>
<p>for a in dir(fr):</p>
<p>if a[:2] != "__":</p>
<p>print a, ":", str(getattr(fr, a))[:70]</p>
<p>f()</p>
<p>В результате получается</p>
<p>Листинг</p>
<p>f_back : &lt;frame object at 0x812383c&gt;</p>
<p>f_builtins : {'help': Type help() for interactive help, or help(object) for help ab</p>
<p>f_code : &lt;code object f at 0x401d83a0, file "&lt;stdin&gt;", line 11&gt;</p>
<p>f_exc_traceback : None</p>
<p>f_exc_type : None</p>
<p>f_exc_value : None</p>
<p>f_globals : {'f': &lt;function f at 0x401e0454&gt;, '__builtins__': &lt;module '__builtin__</p>
<p>f_lasti : 68</p>
<p>f_lineno : 16</p>
<p>f_locals : {'a': 'f_locals', 'fr': &lt;frame object at 0x813c34c&gt;}</p>
<p>f_restricted : 0</p>
<p>f_trace : None</p>
<p>Здесь f_back — предыдущий фрейм исполнения (вызвавший данный фрейм), f_builtins — пространство встроенных имен, как его видно из данного фрейма, f_globals — пространство глобальных имен, f_locals — пространство локальных имен, f_code — кодовый объект (в данном случае — байт–код функции f()), f_lasti — индекс последней выполнявшейся инструкции байт–кода, f_trace — функция трассировки для данного фрейма (или None), f_lineno — текущая строка исходного кода, f_restricted — признак выполнения в ограничительном режиме.</p>
<p>Получить информацию о стеке интерпретатора можно с помощью функции inspect.stack(). Она возвращает список кортежей, в которых есть следующие элементы:</p>
<p>Листинг</p>
<p>(фрейм–объект, имя_файла, строка_в_файле, имя_функции,</p>
<p>список_строк_исходного_кода, номер_строки_в_коде)</p>
<p>Трассировочные объекты также играют важную роль в интроспективных возможностях языка Python: с их помощью можно отследить место возбуждения исключения и обработать его требуемым образом. Для работы с трассировками предусмотрен даже специальный модуль — traceback.</p>
<p>Трассировочный объект представляет содержимое стека исполнения от места возбуждения исключения до места его обработки. В обработчике исключений связанный с исключением трассировочный объект доступен посредством функции sys.exc_info() (это третий элемент возвращаемого данной функцией кортежа).</p>
<p>Трассировочный объект имеет следующие атрибуты:</p>
<p>tb_frame Фрейм исполнения текущего уровня.</p>
<p>tb_lineno и tb_lasti Номер строки и инструкции, где было возбуждено исключение.</p>
<p>tb_next Следующий уровень стека (другой трассировочный объект).</p>
<p>Одно из наиболее частых применений модуля traceback — «мягкая» обработка исключений с выводом отладочной информации в удобном виде (в лог, на стандартный вывод ошибок и т.п.):</p>
<p>Листинг</p>
<p>#!/usr/bin/python</p>
<p>def dbg_except():</p>
<p>«"«Функция для отладки операторов try–except»""</p>
<p>import traceback, sys, string</p>
<p>print sys.exc_info()</p>
<p>print " ".join(traceback.format_exception(*sys.exc_info()))</p>
<p>def bad_func2():</p>
<p>raise StandardError</p>
<p>def bad_func():</p>
<p>bad_func2()</p>
<p>try:</p>
<p>bad_func()</p>
<p>except:</p>
<p>dbg_except()</p>
<p>В результате получается примерно следующее:</p>
<p>Листинг</p>
<p>(&lt;class exceptions.StandardError at 0x4019729c&gt;,</p>
<p>&lt;exceptions.StandardError instance at 0x401df2cc&gt;,</p>
<p>&lt;traceback object at 0x401dcb1c&gt;)</p>
<p>Traceback (most recent call last):</p>
<p>File «pr143.py», line 17, in ?</p>
<p>bad_func()</p>
<p>File «pr143.py», line 14, in bad_func</p>
<p>bad_func2()</p>
<p>File «pr143.py», line 11, in bad_func2</p>
<p>raise StandardError</p>
<p>StandardError</p>
<p>Функция sys.exc_info() дает кортеж с информацией о возбужденном исключении (класс исключения, объект исключения и трассировочный объект). Элементы этого кортежа передаются как параметры функции traceback.format_exception(), которая и печатает информацию об исключении в уже знакомой форме. Модуль traceback содержит и другие функции (о них можно узнать из документации), которые помогают форматировать те или иные части информации об исключении.</p>
<p>Разумеется, это еще не все возможности модуля inspect и свойств интроспекции в Python, а лишь наиболее интересные функции и атрибуты. Подробнее можно прочитать в документации или даже в исходном коде модулей стандартной библиотеки Python.</p>
<p>Заключение</p>
<p>С помощью возможностей интроспекции удается рассмотреть фазы работы транслятора Python: лексический анализ, синтаксический разбор и генерации кода для интерпретатора, саму работу интерпретатора можно видеть при помощи отладчика.</p>
<p>Вместе с тем, в этой лекции было дано представление об использовании профайлера для исследования того, на что больше всего тратится процессорное время в программе, а также затронуты некоторые аспекты оптимизации Python–программ и варианты оптимизации кода на Python по скорости.</p>
<p>Наконец, интроспекция позволяет исследовать не только строение программы, но и объектов, с которыми работает эта программа. Были рассмотрены возможности Python по получению информации об объектах — этом основном строительном материале, из которого складываются данные любой Python–программы.</p>
<center><div align="center"></div></center>





