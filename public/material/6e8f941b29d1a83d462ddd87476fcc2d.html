# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция
10. Операторы и структура кода. Исключения</h2></center>

<p> 

</p>
<p> 

</p>
<p>После ознакомления с типами данных в Java, правилами
объявления ^пассов и интерфейсов, а также с массивами, из базовых свойств языка
оста-доя рассмотреть лишь управление ходом выполнения программы. В этой лек-щд!
вводятся важные понятия, связанные с данной темой, описываются мет­ки,
операторы условного перехода, циклы, операторы break и continue и другие.

</p>
<p>Следующая тема посвящена более концептуальным
механизмам Java, а именно работе с ошибками или исключительными
ситуациями. Рассматрива­ются причины возникновения сбоев, способы их обработки,
объявление соб­ственных типов исключительных ситуаций. Описывается разделение
всех ошибок на проверяемые и непроверяемые компилятором, а также ошибки времени
исполнения.

</p>
<p> 

</p>
<p>Ключевые слова: метка, проверяемые исключения, непроверяемые исключения

</p>
<p> 

</p>
<p>Управление ходом программы

</p>
<p>Управление потоком вычислений является фундаментальной осно­вой всего
языка программирования. В данной лекции будут рассмотрены основные языковые
конструкции и способы их применения.

</p>
<p>Синтаксис выражений весьма схож с синтаксисом языка С, что об­легчает
его понимание для программистов, знакомых с этим языком, и вместе с тем имеется
ряд отличий, которые будут рассмотрены позднее и на которые следует обратить
внимание.

</p>
<p>Порядок выполнения программы определяется операторами. Опе­раторы могут
содержать другие операторы или выражения.

</p>
<p> 

</p>
<p>Нормальное
и прерванное выполнение операторов

</p>
<p>Последовательность
выполнения операторов может быть непрерыв­ки, а может и прерываться (при возникновении определенных условий). Ьпіолнение оператора может быть прервано, если в потоке вычислений ЭДУт обнаружены
операторы

</p>
<p> 

</p>
<p>break

</p>
<p>continue

</p>
<p>return








</p>
<p>Курс               ______________________________________________ Программирование
Ha^i^

</p>
<p>Тогда управление будет передано в другое место (в соответствии правилами обработки этих операторов, которые мы рассмотрим поз*С|~

</p>
<p>Нормальное выполнение оператора может быть прервано также nPll возникновении
исключительных ситуаций, которые тоже будут расемот

</p>
<p>реНЫ ПОЗДКее. ЯвНОе Возбуждение ИСКЛЮЧИТеЛЬНОЙ СИТуацИИ С ПОМОЩц

</p>
<p>оператора throw также прерывает нормальное выполнение оператора „ передает управление
выполнением программы (далее просто управление, в другое место.

</p>
<p>Прерывание нормального исполнения всегда вызывается опреде. ленной причиной. Приведем список таких причин:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
break (без указания метки);

</p>
<p>•   
break (с указанием метки);

</p>
<p>•   
continue (без указания метки);

</p>
<p>•   
continue (с указанием метки);

</p>
<p>•   
return (с возвратом значения);

</p>
<p>•   
return (без возврата значения;)

</p>
<p>•   
throw с указанием объекта
Throwable, а также все исключения, вызываемые
виртуальной машиной Java.

</p>
<p>Выражения могут завершаться нормально и преждевременно (ава­рийно). В данном случае термин "аварийно" вполне применим, т.к. при­чиной необычной последовательности выполнения выражения может быть только возникновение исключительной ситуации.

</p>
<p>Если в операторе содержится выражение, то в случае его аварийного завершения выполнение
оператора тоже будет завершено преждевременно (т.е. нормальный ход выполнения оператора будет нарушен).

</p>
<p>В том случае, если в операторе имеется вложенный оператор и его завершение
происходит ненормально, то так же ненормально завершает­ся оператор, содержащий вложенный (в некоторых случаях это не так. что будет оговариваться особо).

</p>
<p>Блоки и локальные переменные

</p>
<p>Блок — это последовательность операторов, объявлений локальных классов
или локальных переменных, заключенных в скобки. Область ви­димости локальных
переменных и классов ограничена блоком, в которое они определены.

</p>
<p>Операторы в блоке выполняются слева направо, сверху вниз. Если все операторы
(выражения) в блоке выполняются нормально, то и весь блок выполняется
нормально. Если какой-либо оператор (выражение' завершается ненормально, то и
весь блок завершается ненормально.

</p>
<p>Нельзя объявлять несколько локальных переменных с одинаковым" именами
в пределах видимости блока. Приведенный ниже код вызове1 ошибку
времени компиляции.

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) { Test t = new
Test() ; intx; 1Ы: {

</p>
<p>int x = 0;

</p>
<p>System, out. printlnfx = " + x);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>В то же время не следует забывать, что локальные переменные пере­крывают
видимость переменных-членов. Так, следующий пример отрабо­тает нормально.

</p>
<p>public class Test { static int x = 5; public Test() {}

</p>
<p>public static void main(String[] args) { Test t = new
Test() ; ntx = 1;

</p>
<p>System, out. printlnfx = " + x);

</p>
<p>}

</p>
<p>}

</p>
<p>На консоль будет выведено x = 1.

</p>
<p>To же самое правило применимо к параметрам методов.

</p>
<p> 

</p>
<p>public class Test { static int x; public Test() { }

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public static void main(String[] args) { Test t = new
Test() ; t.test(5);

</p>
<p>System.out.printlnf'Member value x = " + x);

</p>
<p>}

</p>
<p>private void test(int x){ this.x = x + 5;








</p>
<p>Курс_______________________________________________________ Программирование
Haja^

</p>
<p>System.out.println("Local value x = " + x);

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В результате работы этого примера на консоль будет выведено:

</p>
<p>Local value х = 5 Member
value х = 10

</p>
<p> 

</p>
<p>На следующем примере продемонстрируем, что область видимости локальной
переменной ограничена областью видимости блока, или one-ратора, в пределах
которого данная переменная объявлена.

</p>
<p>public class Test { static intx = 5; public
Test() { }

</p>
<p>public static void main(String[] args) { Testt =
newTest(); {

</p>
<p>int x = 1;

</p>
<p>System,
out. printlnfFirst block x = " + x);

</p>
<p>} {

</p>
<p>intx = 2;

</p>
<p>System.out.printlnfSecond
blockx =" + x);

</p>
<p>}

</p>
<p>System.out.print("For
cycle x = "); for(intx=0;x&lt;5;x++) { System.out.print("" + x);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Данный пример откомпилируется без ошибок и на консоль буДеТ выведен
следующий результат:

</p>
<p>First block х = 1 Second
block х =2 For cycle x = 0 1 2 3 4

</p>
<p>^я -|0                                                             Операторы
и структура кода. Исключения

</p>
<p>Следует помнить, что определение локальной переменной есть испол-мый
оператор. Если задана инициализация переменой, то выражение сдолняется слева
направо и его результат присваивается локальной пере-11 иной.
Использование неинициализированных локальных переменных лрешено и вызывает
ошибку компиляции. Следующий пример кода

</p>
<p> 

</p>
<p>public class Test { static int x = 5; public
Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Testt = new
Test() ; intx; inty = 5; if( y &gt; 3) x = 1 ; System.out.println(x);

</p>
<p>}

</p>
<p> 

</p>
<p>вызовет ошибку времени компиляции, т.к. возможны условия, при кото­рых
переменная х может быть не инициализирована до ее использования (несмотря на
то, что в данном случае оператор гї(у &gt; 3) и следующее
за ним выражение х = 1; будут выполняться всегда).

</p>
<p> 

</p>
<p>Пустой оператор

</p>
<p>Точка с запятой (;) является пустым оператором. Данная конструк­ция
вполне применима там, где не предполагается выполнение никаких Действий.
Преждевременное завершение пустого оператора невозможно.

</p>
<p> 

</p>
<p>Метки

</p>
<p>Любой оператор, или блок, может иметь метку. Метку можно указы-^ть в
качестве параметра для операторов break и continue. Область види­мости метки ограничивается оператором, или блоком, к
которому она от­носится. Так, в следующем примере мы получим ошибку компиляции:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Public class Test { static int x = 5; static { }








</p>
<p></p>
<center><img width="445" height="24" src="http://kufas.ru/java.files/image017.png" align="left" hspace="3" alt="Подпись: оправданно, но, конечно, их применение следует ограничивать лишь са-"></center>public Test() { }

<p>public static void main(String[] args) { Test t = newTest();
int x = 1; Lbl1: {

</p>
<p>if(x ==0) break Lbl1;

</p>
<p>}

</p>
<p>Lbl2:{

</p>
<p>if(x &gt;0) break Lbl1;

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>В случае, если имеется несколько вложенных блоков и операторов
допускается обращение из внутренних блоков к меткам, относящимся к внешним.

</p>
<p>Этот пример является вполне корректным:

</p>
<p>public class Test { static int x = 5; static {

</p>
<p> 

</p>
<p>}

</p>
<p>public Test() { }

</p>
<p>public static void main(String[] args) { Testt =
newTest(); int L2 - 0;

</p>
<p>Test: for(int i = 0; i&lt; 10;i++) { test:
for(int j = 0; j&lt; 10;j++) { if( i*j &gt; 50) break Test;

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>private void test() { }

</p>
<p>}

</p>
<p>В этом же примере можно увидеть, что метки используют пространств0 имен,
отличное от пространства имен переменных, методов и классов.

</p>
<p>Традиционно использование меток не рекомендуется, особенно в
л^ктно-ориентированных языках, поскольку серьезно усложняет пони-порядка
выполнения кода, а значит, и его тестирование и отладку, rfitil Java этот запРет можно считать не столь строгим, поскольку
самый дзсньш оператор goto отсутствует. В
некоторых ситуациях (как в рассмо­тренном примере с вложенными циклами)
использование меток вполне

</p>
<p>ft0Oi необходимыми
случаями.

</p>
<p>Оператор if

</p>
<p>Пожалуй, наиболее распространенной конструкцией в Java, как и в любом
другом структурном языке программирования, является оператор условного перехода.

</p>
<p>В общем случае
конструкция выглядит так:

</p>
<p>if (логическое
выражение) выражение или блок 1 else выражение или блок 2

</p>
<p>Логическое выражение может быть любой языковой конструкцией, которая
возвращает булевский результат. Отметим отличие от языка С, в котором в
качестве логического выражения могут использоваться различные типы данных, где
отличное от нуля выражение трактуется как истинное значение, а ноль - как
ложное. В Java возможно
использование только логических выражений.

</p>
<p>Если логическое выражение принимает значение "истина", то вы­полняется
выражение или блок 1, в противном случае - выражение или блок 2. Вторая часть
оператора (else) не является обязательной и может быть опущена. Т.е. конструкция if(х = 5) System.out.printlnf'Five") вполне
допустима.

</p>
<p>Операторы if-else могут
каскадироваться.

</p>
<p> 

</p>
<p>String test = "smb";

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>if(
test.equals("value1") {

</p>
<p>} else if
(test.equals("value2") {

</p>
<p>} else if
(test.equals("value3") {

</p>
<p>} else {

</p>
<p>Следует помнить, что оператор else относится к ближайшему к не\и оператору if. В данном случае
последнее условие else будет выполняться
только если не выполнено предыдущее. Заключительная конструкцИ(| else относится к самому последнему условию if и будет выполнена тольк0 в том случае, если ни одно из
вышеперечисленных условий не б\'Дег истинным. Если хотя
бы одно из условий выполнено, то все последующИе выполняться не
будут.

</p>
<p>Например:

</p>
<p> 

</p>
<p> 

</p>
<p>int x
=
5; if( x
&lt;
4) {

</p>
<p>System.out.println("MeHbLue 4"); } else if (x &gt; 4) {

</p>
<p>System.out.ргіпіІп("Больше 4"); }else if (x ==
5){

</p>
<p>System.out.printlnf'PaBHo 4"); } else{

</p>
<p>System.out.printlnf'flpyroe значение");

</p>
<p>}

</p>
<p> 

</p>
<p>Предложение "Равно 4" в данном случае напечатано не будет.

</p>
<p> 

</p>
<p>Оператор switch

</p>
<p>Оператор switch() удобно использовать в случае необходимости множественного выбора.
Выбор осуществляется на основе целочислен­ного значения.

</p>
<p>Структура оператора:

</p>
<p>switch(int value) { case consti :

</p>
<p>выражение или блок case
const2:

</p>
<p>выражение или блок case
constn:

</p>
<p>выражение или блок default:

</p>
<p>выражение или блок

</p>
<p>}

</p>
<p> 

</p>
<p>Причем, фраза default не является
обязательной.

</p>
<p>В качестве параметра switch может
использоваться переменная типа byte, short, int, char или выражение. Выражение должно в конечном итоге возвращать параметр
одного из указанных ранее типов. В операторе gase не могут
применяться значения примитивного типа long и ссылоч­ных типов Long, String, Integer, Byte и т.д.

</p>
<p>При выполнении оператора switch производится
последовательное сравнение значения х с константами, указанными после case, и в случае
совпадения выполняется выражение следующего за этим условием. Если выражение
выполнено нормально и нет преждевременного его заверше­ния, то производится
сравнение для последующих case. Если же выраже­ние, следующее за case, завершилось
ненормально, то будет прекращено выполнение всего оператора switch.

</p>
<p>Если не выполнен ни один оператор case, то выполнится
оператор default, если он имеется в данном switch. Если оператора default нет и ни одно из условий case не выполнено, то ни
одно из выражений switch так­же выполнено не
будет.

</p>
<p>Следует обратить внимание, что, в отличие от многозвенного if-else, если
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>какое-либо
условие case выполнено, то
выполнение switch не прекра­тится, а
будут проверяться следующие за ним условия. Если этого необходи­мо избежать, то
после кода следующего за оператором case используется оператор break, прерывающий дальнейшее выполнение оператора switch.

</p>
<p>После оператора case должен следовать
литерал, который может быть интерпретирован как 32-битовое целое значение.
Здесь не могут применяться выражения и переменные, если они не являются final static.

</p>
<p>Рассмотрим пример:

</p>
<p> 

</p>
<p>intx = 2; switch(x) {

</p>
<p>case 1 :

</p>
<p>case 2:

</p>
<p>System.out.printlnf'PaBHo 1 или 2");

</p>
<p>break; case 3: case 4:

</p>
<p>System.out.printlnf'PaBHo 3 или 4"); break;
default:

</p>
<p>System.out.ргіпііп("3начение не определено");

</p>
<p>}

</p>
<p> 

</p>
<p>»,    В данном случае на консоль будет выведен результат "Равно 1
или 2". Же убрать операторы break, то будут выведены
все три строки.

</p>
<p>Вот такая конструкция вызовет ошибку времени компиляции.

</p>
<p>intx = 5; switch (х) {

</p>
<p>case у: // только константы!

</p>
<p> 

</p>
<p>break;

</p>
<p>}

</p>
<p> 

</p>
<p>В операторе switch не может быть двух case с одинаковыми значе­ниями.

</p>
<p>Т.е. конструкция

</p>
<p>switch(x) { case 1:

</p>
<p>System,
out. printlnfOne");

</p>
<p>break;

</p>
<p>case 1:

</p>
<p>System.out.println("Two");

</p>
<p>break;

</p>
<p>case 3:

</p>
<p>System.out.println("Tree or other value");

</p>
<p>}

</p>
<p>недопустима.

</p>
<p>Также в конструкции switch может быть применен
только один оператор default.

</p>
<p> 

</p>
<p>Управление циклами

</p>
<p>В языке Java имеется три
основных конструкции управления циклами:

</p>
<p>•   
цикл while;

</p>
<p>•   
цикл do;

</p>
<p>•   
цикл for.

</p>
<p> 

</p>
<p>Цикл
while

</p>
<p>Основная форма цикла while может быть
представлена так:

</p>
<p> 

</p>
<p>while(norM4ecKoe выражение)

</p>
<p>повторяющееся выражение, или блок;

</p>
<p>В данной языковой конструкции повторяющееся выражение, или gjjoK будет исполняться до тех пор, пока логическое выражение будет ^fftb истинное значение. Этот многократно исполняемый блок называ­ет телом
цикла

</p>
<p>Операторы continue и break могут изменять нормальное исполне-^5 тела цикла. Так, если в теле цикла
встретился оператор continue, то оЯбраторы, следующие за ним, будут пропущены и
выполнение цикла начнется сначала. Если continue используется с меткой и метка принадле-jgjr к данному while, то выполнение его будет аналогичным. Если метка не относится к данному
while, его выполнение будет прекращено и управле­ние будет передано на
оператор, или блок, к которому относится метка.

</p>
<p>Если встретился оператор break, то выполнение цикла будет прекра­щено.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Если выполнение блока было прекращено по какой-то другой причи­не (возникла
исключительная ситуация), то выполнение всего цикла будет прекращено по той же
причине.

</p>
<p>Рассмотрим несколько примеров:

</p>
<p>public class Test { static int x = 5; public
Test() { }

</p>
<p>public static void main(String[] args) { Testt =
newTest(); intx = 0; while(x&lt; 5) { x++;

</p>
<p>if(x % 2
==0) continue; System.out.printf " + x); }

</p>
<p>}

</p>
<p> 

</p>
<p>На консоль будет выведено

</p>
<p> 

</p>
<p>135

</p>
<p>т,е. вывод на печать всех четных чисел будет пропущен.

</p>
<p> 

</p>
<p>Public class Test { static int x = 5; public Test() {








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0" align="left">
 <tr>
  <td width="466" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="53" height="28" src="http://kufas.ru/java.files/image018.png" alt="Подпись:  "></center></td>
 </tr>
</table>




<p>public static void main(String[] args) { Testt = new Test() ; intx
= 0; inty = 0;

</p>
<p>Ibi: while(y &lt;
3) {

</p>
<p>y++;

</p>
<p>while(x &lt;
5) { x++;

</p>
<p>if(x%2==0)
continue Ibi;

</p>
<p>System.
out.println("x=" + x + " y="+y);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>На консоль будет выведено

</p>
<p>x=1 y=1 x=3 y=2 x=5 y=3

</p>
<p>т.е. при выполнении
условия if(x % 2 == 0) continue Ibi; цикл по перемен­ной
x будет прерван, а
цикл по переменной у начнет новую итерацию. Типичный вариант использования выражения while():

</p>
<p> 

</p>
<p>int i = 0;

</p>
<p>while( i++ &lt; 5) {

</p>
<p>System.out.printlnf'Counter is " + i);

</p>
<p>}

</p>
<p>Следует помнить, что цикл whileO будет выполнен
только в том слу­чае, если на момент начала его выполнения логическое выражение
будет истинным. Таким образом, при выполнении программы может иметь
ме­сто ситуация, когда цикл while()
не будет выполнен ни разу.

</p>
<p>boolean b = false;
while(b) {

</p>
<p>System.out.println("Executed");

</p>
<p>}

</p>
<p>В данном случае строка System.out.printlnf'Executed");
выполнен3 не будет.

</p>
<p>Цикл
do

</p>
<p>Основная форма цикла do имеет следующий
вид: do

</p>
<p>повторяющееся выражение
или блок; while(norn4ecKoe выражение)

</p>
<p>Цикл do будет выполняться
до тех пор, пока логическое выражение будет истинным. В отличие от цикла while, этот цикл будет
выполнен, как минимум, один раз.

</p>
<p>Типичная конструкция цикла do:

</p>
<p> 

</p>
<p>int counter = 0; do{

</p>
<p>counter ++;

</p>
<p>System.out.printlnf'Counter
is " + counter); } while(counter &gt; 5);

</p>
<p> 

</p>
<p>В остальном выполнение цикла do аналогично выполнению цикла while, включая
использование операторов break и continue.

</p>
<p> 

</p>
<p>Цикл
for

</p>
<p>Довольно часто бывает необходимо изменять значение какой-либо П|ременной
в заданном диапазоне и выполнять повторяющуюся последо-щгельность операторов с
использованием этой переменной. Для выпол­нения такой последовательности
действий как нельзя лучше подходит Конструкция цикла for.

</p>
<p>Основная форма цикла for выглядит следующим образом:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>^(выражение инициализации; условие; выражение обновления) повторяющееся
выражение или блок;

</p>
<p> 

</p>
<p>Ключевыми элементами данной языковой конструкции являются •Федложения,
заключенные в круглые скобки и разделенные точкой с запятой.

</p>
<p>Выражение инициализации выполняется до начала выполнения тела 1*Икла.
Чаще всего используется как некое стартовое условие (инициализа-^я» или
объявление переменной).

</p>
<p>\ Условие должно
быть логическим выражением и трактуется точно ^же, как логическое выражение в
цикле while(). Тело цикла выполня­ли До тех пор, пока логическое выражение истинно. Как и в случае с








</p>
<p>циклом \л/Ы1е(), тело цикла может не исполниться ни разу. Это происхо.
дит, если логическое выражение принимает значение "ложь" до начала
выполнения цикла.

</p>
<p>Выражение обновления выполняется сразу после исполнения тела цикла
и до того, как проверено условие продолжения выполнения цикла Обычно здесь
используется выражение инкрементации, но может быть применено и любое другое
выражение.

</p>
<p>Пример использования цикла тог()

</p>
<p> 

</p>
<p>for(counter=0;counter&lt;
10;counter++) {

</p>
<p>System.out.println("Counter
is " + counter);

</p>
<p>}

</p>
<p>В данном примере предполагается, что переменная counter была объявлена ранее. Цикл будет выполнен 10 раз и будут напечатаны
значе­ния счетчика от 0 до 9.

</p>
<p>Разрешается определять
переменную прямо в предложении:

</p>
<p>for(int cnt = 0;cnt &lt; 10; cnt++) {

</p>
<p>System.out.printlnfCounter is " + cnt);

</p>
<p>}

</p>
<p>Результат выполнения этой конструкции будет аналогичен предыду­щему.
Однако нужно обратить внимание, что область видимости пере­менной cnt будет ограничена телом цикла.

</p>
<p>Любая часть конструкции for() может быть опущена. В вырожден­ном случае мы получим оператор for с пустыми значениями

</p>
<p>for(;;){ }

</p>
<p>В данном случае цикл
будет выполняться бесконечно. Эта конструк­ция аналогична конструкции while(true){}. Условия, в которых
она может быть применена, мы рассмотрим позже.

</p>
<p>Возможно также расширенное использование синтаксиса оператора for(). Предложение и
выражение могут состоять из нескольких частей, разделенных запятыми.

</p>
<p>for(i = 0,j = 0;i&lt;5;i++,j+=2){ }

</p>
<p>Использование такой
конструкции вполне правомерно.

</p>
<p>Операторы break и continue

</p>
<p>В некоторых случаях требуется изменить ход выполнения программы, а традиционных языках
программирования для этих целей применяется оператор goto, однако в Java он не поддерживается. Для этих целей приме-tfOffTcn операторы break и continue.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Оператор
continue

</p>
<p>Оператор continue может
использоваться только в циклах while, do, for. Если в потоке вычислений встречается оператор continue, то выпол­нение
текущей последовательности операторов (выражений) должно быть прекращено и
управление будет передано на начало блока, содержащего этот оператор.

</p>
<p> 

</p>
<p>intx = (int)(Math.random()*lO); intarr[l0] ={....} for(int
cnt=0;cnt&lt;10;cnt++) { if(arr[cnt] == x) continue;

</p>
<p> 

</p>
<p>}

</p>
<p>В данном случае, если в массиве агг встретится значение, равное х,
то выполнится оператор continue и все операторы до конца блока будут пропущены, а управление будет
передано на начало цикла.

</p>
<p>Если оператор continue будет применен вне
контекста оператора Цикла, то будет выдана ошибка времени компиляции. В случае
использо­вания вложенных циклов оператору continue, в качестве адреса
перехода, может быть указана метка, относящаяся к одному из этих операторов.

</p>
<p>Рассмотрим пример:

</p>
<p>public class Test { public Test() { }

</p>
<p>public static void main(String[] args) { Testt
= newTest(); for(intj=0;j&lt; 10;j++){

</p>
<p>if(i* % 2== 0) continue;

</p>
<p>System. out.print("i=" + i);

</p>
<p>}








</p>
<p>Программирование на ja,,.




</p>
<p>tuna 10




</p>
<p>Операторы
и структура кода. Исключения








</p>
<p>В результате работы на консоль будет выведено: 1 3579

</p>
<p>При выполнении условия в строке 7 нормальная последовательное,
выполнения операторов будет прервана и управление будет передано н начало
цикла. Таким образом, на консоль будут выводиться только нече1 ные
значения.

</p>
<p> 

</p>
<p>Оператор
break

</p>
<p>Этот оператор, как и оператор continue, изменяет последователь­ность
выполнения, но не возвращает исполнение к началу цикла, а преры-

</p>
<p>вает его.

</p>
<p> 

</p>
<p>public class
Test { public Test() { }

</p>
<p>public static void main( String [] args) { Testt =
new Test() ; int []x = {1,2,4,0,8}; inty =8;

</p>
<p>for(int cnt=0;cnt &lt; x.length;cnt++)
{ if(0 == x[cnt]) break; System, out. printlnfy/x = " + y/x[cnt]);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>На консоль будет
выведено:

</p>
<p>y/x = 8 y/x = 4 y/x = 2

</p>
<p> 

</p>
<p>При этом ошибки, связанной с делением на ноль, не произойдет, т.к. если
значение элемента массива будет равно 0,
то будет выполнено усло­вие
в строке 9 и выполнение цикла for будет прервано.

</p>
<p>В качестве аргумента break может быть указана
метка. Как и в случае с continue, нельзя указывать в качестве аргумента метки блоков, в которЫ* оператор
break не содержится.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Именованные блоки

</p>
<p>В реальной практике достаточно часто используются вложенные даслы.
Соответственно, может возникнуть ситуация, когда из вложенно-Ф цикла нужно прервать внешний. Простое использование break или O^ritinue не решает этой
задачи, однако в Java можно именовать блок
кода дивно указать операторам, к какому из них относится выполняемое дей­ствие. Делается это путем присвоения метки операторам do, while, for.

</p>
<p>Метка — это любая допустимая в данном контексте лексема, оканчи­вавшаяся
двоеточием.

</p>
<p>Рассмотрим следующий пример:

</p>
<p> 

</p>
<p> 

</p>
<p>int array[][] = {....}; for(int
i=0;i&lt;5;i++) { for(j=0;j&lt;4;      {

</p>
<p> 

</p>
<p>if(array[i][j] == caseValue)
break;

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В данном случае при выполнении условия будет прервано выполне­ние цикла по
j, цикл по i продолжится со следующего значения. Для того, чтобы прервать выполнение
обоих циклов, используется метка:

</p>
<p> 

</p>
<p> 

</p>
<p>int array[][] = {....}; outerLoop: for(int
i=0;i&lt;5;i++) { for(j=0;j&lt;4; j++){

</p>
<p> 

</p>
<p>if(array[i][j] == caseValue)
break outerLoop;

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Оператор continue также может
использоваться с именованными боками.

</p>
<p>Между  операторами   break  и  continue  есть  еще  одно
существенное отличие. Оператор break может
использоваться с








</p>
<p>любым именованным
блоком, в этом случае его действие в чем-т0 похоже на действие goto. Оператор continue (как и отмечалось ранее) может быть использован только в теле цикла. То
есть такая конструк. ция будет вполне приемлемой:

</p>
<p> 

</p>
<p>1ы:{

</p>
<p> 

</p>
<p>if( val &gt; maxVal) break Ibi;

</p>
<p> 

</p>
<p>}

</p>
<p>В то время как оператор continue здесь применять нельзя. В данном слу­чае при выполнении условия if выполнение блока с меткой Ibi будет пре­рвано, то
есть управление будет передано на оператор (выражение), сле­дующий
непосредственно за закрывающей фигурной скобкой.

</p>
<p>Метки используют пространство имен, отличное от пространства имен
классов и методов.

</p>
<p>Так, следующий пример кода
будет вполне работоспособным:

</p>
<p>public class Test { public
Test() { }

</p>
<p>public static void main(String[] args) { Testt = new Test();
t.test();

</p>
<p>}

</p>
<p>void test() { Test: {

</p>
<p>test: for(int i =0;true;i++)
{ if(i % 2 ==
0) continue test;
if(i &gt; 10) break Test; System.out.print(i + " ");

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Для составления меток применяются те же синтаксические правила, что и
для переменных, за тем исключением, что метки всегда оканчива­ются двоеточием.
Метки всегда должны быть привязаны к какому-либо блоку кода
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Допускается
использование меток с одинаковыми именами, но нельзя применять одинаковые имена
в пределах видимости блока. Т.е-такая конструкция допустима:

</p>
<p>Ibi: {

</p>
<p>System, out. printlnf'Block 1");

</p>
<p> 

</p>
<p>}

</p>
<p>Ibi: {

</p>
<p>System.out.println("Block 2");

</p>
<p> 

</p>
<p>}

</p>
<p>A такая нет: Ibi: {

</p>
<p>Ibi: {

</p>
<p>}

</p>
<p>}

</p>
<p>Оператор return

</p>
<p>Этот оператор предназначен для возврата управления из вызываемо­го
метода в вызывающий. Если в последовательности операторов выпол­няется return, то управление
немедленно (если это не оговорено особо) Передается в вызывающий метод.
Оператор return может иметь, а может и не иметь аргументов. Если метод не возвращает
значений (объявлен как void),
то в этом и только этом
случае выражение return применяется без
аргументов. Если возвращаемое значение есть, то return обязательно дол-Щн применяться с аргументом, чье значение и будет возвращено.

</p>
<p>В качестве аргумента return может использоваться выражение

</p>
<p> 

</p>
<p>return (х*у +10) /11 ;

</p>
<p> 

</p>
<p>В этом случае сначала будет выполнено выражение, а затем результат Ґw
выполнения будет передан в
вызывающий метод. Если выражение будет Свершено ненормально, то и оператор return будет завершен ненормально, например, если во время выполнения выражения
в операторе return воз-i*j*HeT исключение, то никакого значения метод не вернет, будет обрабаты­вая ошибка.

</p>
<p>В методе может быть более
одного оператора return.

</p>
<p> 

</p>
<p>Оператор
synchronized

</p>
<p>Этот оператор применяется для исключения взаимного влияния не-скольких
потоков при выполнении кода, он будет подробно рассмотрен в лекции 12,
посвященной потокам исполнения.

</p>
<p> 

</p>
<p>Ошибки
при работе программы. Исключения (Exceptions)

</p>
<p>При выполнении программы могут возникать ошибки. В одних случа­ях это
вызвано ошибками программиста, в других — внешними причинами. Например, может
возникнуть ошибка ввода/вывода при работе с файлом или сетевым соединением. В
классических языках программирования, на­пример, в С, требовалось проверять
некое условие, которое указывало на наличие ошибки, и в зависимости от этого
предпринимать те или иные действия.

</p>
<p>Например:

</p>
<p> 

</p>
<p> 

</p>
<p>int statusCode = someAction();
if
(statusCode){

</p>
<p>... обработка ошибки } else {

</p>
<p>statusCode = anotherAction(); if(statusCode) {

</p>
<p>... обработка ошибки ...

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В Java появилось более
простое и элегантное решение — обработка исключительных ситуаций.

</p>
<p>try{

</p>
<p>someAction();
anotherAction() } catch(Exception e) {

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>... обработка
исключительной ситуации

</p>
<p>}

</p>
<p>Легко заметить, что такой подход является не только изящным, но и более
надежным и простым для понимания.

</p>
<p>jj&amp;e"—

</p>
<p>Причины
возникновения ошибок

</p>
<p>Существует три причины
возникновения исключительных ситуаций.

</p>
<p>•  Попытка выполнить
некорректное выражение.

</p>
<p>Например, деление на ноль, или обращение к объекту по ссылке, равной null, попытка
использовать класс, описание которого (class-файл) отсутствует,
и т.д.

</p>
<p>В таких случаях всегда можно точно указать, в каком месте про­изошла
ошибка, - именно в некорректном выражении.

</p>
<p>•  Выполнение оператора throw.

</p>
<p>Этот оператор применяется для явного порождения ошибки. Оче­видно, что и
здесь можно указать место возникновения исключи­тельной ситуации.

</p>
<p>•  Асинхронные ошибки во
время исполнения программы. Причиной таких ошибок могут быть сбои внутри самой
виртуальной

</p>
<p>машины (ведь она
также является программой), или вызов метода stop() у потока выполнения Thread.

</p>
<p>В этом случае невозможно указать точное место программы, где про­исходит
исключительная ситуация. Если мы попытаемся остановить поток выполнения (вызвав
метод stop()), нам не удастся предсказать, при выпол­нении какого именно выражения
этот поток остановится.

</p>
<p>Таким образом, все ошибки в Java делятся на синхронные и асинхрон­ные. С первыми сравнительно проще
работать, так как принципиально возможно найти точное место в коде, которое
является причиной возникно­вения исключительной ситуации. Конечно, Java является строгим языком в том смысле, что все выражения до точки сбоя
обязательно будут выполнены, и в то же время ни одно последующее выражение
никогда выполнено не будет. Важно помнить, что ошибки могут возникать как по
причине недостаточной внимательности программиста (отсутствует нужный класс,
или индекс мас­сива вышел за допустимые границы), так и по независящим от него причинам
(произошел разрыв сетевого соединения, сбой аппаратного обеспечения, Например,
жесткого диска и др.).

</p>
<p>Асинхронные ошибки гораздо сложнее в обнаружении и исправле­нии.
Обычному разработчику очень трудно выявить причины сбоев в Виртуальной машине.
Это могут быть ошибки создателей JVM, несовме­стимость
с операционной системой, аппаратный сбой и многое другое. Все же современные
виртуальные машины реализованы довольно хоро­шо и подобные сбои происходят
крайне редко (при условии использова­ния качественных комплектующих).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Аналогичная ситуация наблюдается и в случае с принудительной Остановкой
потоков исполнения. Поскольку это действие выполняет -Ся
операционной системой, никогда нельзя предсказать, в каком ^енно месте
остановится поток. Это означает, что программа может








</p>
<p>многократно отработать корректно, а потом неожиданно дать сбой просто
из-за того, что поток остановился в каком-то другом месте. По этой причине
принудительная остановка не рекомендуется. В лекции 12 рассматриваются примеры
корректного управления жизненным циклом потока.

</p>
<p>При возникновении исключительной ситуации управление переда­ется от
кода, вызвавшего исключительную ситуацию, на ближайший блок catch (или вверх по
стеку) и создается объект, унаследованный от класса Throwable, или его потомков (см. диаграмму иерархии классов-исключе­ний), который
содержит информацию об исключительной ситуации и ис­пользуется при ее
обработке. Собственно, в блоке catch указывается именно класс обрабатываемой ситуации. Подробно обработка
ошибок рассматривается ниже.

</p>
<p>Иерархия, по которой передается информация об исключительной ситуации,
зависит от того, где эта исключительная ситуация возникла. Если это

</p>
<p>•   
метод, то управление будет
передаваться в то место, где данный метод был вызван;

</p>
<p>•   
конструктор, то управление
будет передаваться туда, где попыта­лись создать объект (как правило, применяя
оператор new);

</p>
<p>•   
статический инициализатор,
то управление будет передано туда, где произошло первое обращение к классу,
потребовавшее его инициа­лизации.

</p>
<p>Допускается создание собственных классов исключительных ситуаций.
Осуществляется это с помощью механизма наследования, то есть класс
пользовательской исключительной ситуации должен быть унаследован от класса Throwable, или его потомков.

</p>
<p> 

</p>
<p>Обработка
исключительных ситуаций

</p>
<p> 

</p>
<p>Конструкция try-catch

</p>
<p>В общем случае конструкция
выглядит так:

</p>
<p> 

</p>
<p>try {

</p>
<p>} catch(SomeExceptionClass
e) { } catch(AnotherExceptionClass e) {

</p>
<p>Работает она следующим образом. Сначала выполняется код, заклю­ченный в
фигурные скобки оператора try. Если во время его выполнения не происходит никаких нештатных ситуаций,
то далее управление пере­дается за закрывающую фигурную скобку последнего
оператора catch, ассоциированного с данным оператором try.

</p>
<p>Если в пределах try возникает
исключительная ситуация, то далее вы­полнение кода производится по одному из
перечисленных ниже сценариев.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Возникла исключительная ситуация, класс которой указан в качест­ве
параметра одного из блоков catch. В этом случае производится выпол­нение блока кода, ассоциированного с
данным catch (заключенного в фигурные скобки). Далее, если код в этом блоке
завершается нормально, то и весть оператор try завершается нормально и управление передается на оператор (выражение),
следующий за закрывающей фигурной скобкой последнего catch. Если код в catch завершается не
штатно, то и весь try завершается
нештатно по той же причине.

</p>
<p>Если возникла исключительная ситуация, класс которой не указан в
качестве аргумента ни в одном catch, то выполнение всего try завершается
нештатно.

</p>
<p> 

</p>
<p>Конструкция try-catch-finally

</p>
<p>Оператор finally предназначен для
того, чтобы обеспечить гарантиро­ванное выполнение какого-либо фрагмента кода.
Вне зависимости от того, возникла ли исключительная ситуация в блоке try, задан ли
подходящий блок catch, не возникла ли ошибка в самом блоке catch,- все равно блок finally будет в конце концов исполнен.

</p>
<p>Последовательность выполнения такой конструкции следующая: если оператор
try выполнен нормально,
то будет выполнен блок finally. В свою очередь, если оператор finally выполняется нормально, то и весь оператор try выполняется нормально.

</p>
<p>Если во время выполнения блока try возникает исключение и суще­ствует оператор catch, который
перехватывает данный тип исключения, Происходит выполнение связанного с catch блока. Если блок catch вы­полняется
нормально, либо ненормально, все равно затем выполняется блок finally. Если блок finally завершается нормально, то оператор try за­вершается так же, как завершился блок catch.

</p>
<p>Если в списке операторов catch не находится такого, который обра­ботал бы возникшее исключение, то все
равно выполняется блок finally. В Этом случае, если finally завершится
нормально, весь try завершится не­формально
по той же причине, по которой было нарушено исполнение try.

</p>
<p>Во всех случаях, если блок finally завершается ненормально, то весь fry завершится ненормально по той же причине.

</p>
<p>Рассмотрим пример применения конструкции try-catch-finally, try {

</p>
<p>byte f] buffer = new byte[128];
FilelnputStream fis = new FilelnputStream("file.txt");
while(fis.read(buffer) &gt; 0)
{ ... обработка данных

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>} catch(IOExceptмon
es) {

</p>
<p>... обработка исключения ... } finally {

</p>
<p>fis.flushO;

</p>
<p>fis.closeO;

</p>
<p>}

</p>
<p>Если в данном примере поместить операторы очистки буфера и за­крытия
файла сразу после окончания обработки данных, то при возникно­вении ошибки
ввода/вывода корректного закрытия файла не произойдет. Еще раз отметим, что
блок finally будет выполнен в
любом случае, вне за­висимости от того, произошла обработка исключения или нет,
возникло это исключение или нет.

</p>
<p>В конструкции try-catch-finally обязательным
является использование одной из частей оператора catch или finally. То есть
конструкция

</p>
<p> 

</p>
<p>try {

</p>
<p>} finally { }

</p>
<p>является вполне допустимой. В этом случае блок finally при возникнове­нии исключительной ситуации должен быть выполнен, хотя
сама исклю­чительная ситуация обработана не будет и будет передана для
обработки на более высокий уровень иерархии.

</p>
<p>Если обработка исключительной ситуации в коде не предусмотре­на, то при
ее возникновении выполнение метода будет прекращено и исключительная ситуация
будет передана для обработки коду более вы­сокого уровня. Таким образом, если
исключительная ситуация произой­дет в вызываемом методе, то управление будет
передано вызывающему методу и обработку исключительной ситуации должен
произвести он. Если исключительная ситуация возникла в коде самого высокого
уроп~ ня (например, методе main()), то управление будет передано исполняю­цдей системе Java и выполнение программы будет прекращено (более цочно — будет остановлен
поток исполнения, в котором произошла та-^ая ошибка).

</p>
<p> 

</p>
<p>Использование
оператора throw

</p>
<p>Помимо того, что предопределенная исключительная ситуация может быть
возбуждена исполняющей системой Java, программист сам может дано породить ошибку. Делается это с помощью
оператора throw.

</p>
<p>Например:

</p>
<p> 

</p>
<p>public int calculate(int theValue) { if( theValue &lt; 0) {

</p>
<p>throw new Ехсерпоп("Параметр для вычисления не должен быть
отрицательным");

</p>
<p>}

</p>
<p> 

</p>
<p> 

</p>
<p>В данном случае предполагается, что в качестве параметра методу может
быть передано только положительное значение; если это условие не выполнено, то
с помощью оператора throw порождается исключи­тельная ситуация. (Для успешной компиляции также
требуется в заго­ловке метода указать throws Exception — это выражение рассматривает­ся ниже.)

</p>
<p>Метод должен делегировать обработку исключительной ситуации вызвавшему
его коду
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Для этого в сигнатуре метода применяется ключе­вое слово throws, после которого
должны быть перечислены через запя­тую все исключительные ситуации, которые
может вызывать данный ме­тод. То есть приведенный выше пример должен быть
приведен к следую­щему виду:

</p>
<p>public int
calculate(int theValue) throws Exception { if(
theValue &lt; 0) {

</p>
<p>throw new Exceptionf'Some descriptive info");

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Таким образом, создание исключительной ситуации в программе ВьШолняется
с помощью оператора throw с аргументом,
значение которого ^°Жет быть приведено к типу Throwable.








</p>
<p>В некоторых случаях после обработки исключительной ситуации может
возникнуть необходимость передать информацию о ней в вызыва­ющий код.

</p>
<p>В этом случае
ошибка появляется вторично. Например:

</p>
<p> 

</p>
<p> 

</p>
<p>try{

</p>
<p>} catch(IOException ex) {

</p>
<p> 

</p>
<p>// Обработка исключительной ситуации

</p>
<p>// Повторное
возбуждение исключительной ситуации throw ex;

</p>
<p>}

</p>
<p>Рассмотрим еще один
случай.

</p>
<p>Предположим, что оператор throw применяется внутри
конструк­ции try-catch.

</p>
<p> 

</p>
<p>try{

</p>
<p>throw new IOException(); } catch(Exception
e) { }

</p>
<p>В этом случае исключение, возбужденное в блоке try, не будет пере­дано
для обработки на более высокий уровень иерархии, а обработается в пределах
блока try-catch, так как здесь содержится оператор, который может это исключение
перехватить. То есть произойдет неявная передача управления на соответствующий
блок cacth.

</p>
<p> 

</p>
<p>Проверяемые
и непроверяемые исключения

</p>
<p>Все исключительные ситуации можно разделить на две категории проверяемые
(checked) и непроверяемые (unchecked).

</p>
<p>Все исключения, порождаемые OTThrowable, можно разбить на
три группы. Они определяются тремя базовыми типами: наследникам11 Throwable - классами Error и Exception, а также наследником Excepti°n - RuntimeException.

</p>
<p>Ошибки, порожденные от Exception (и не являющиеся наследниками puntimeException), являются проверяемыми. Т.е. во время компиляции Проверяется,
предусмотрена ли обработка
возможных исключительных си­туаций. Как правило, это ошибки, связанные с
окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости
от того, корректно написан код или нет. Например, открытие сетевого соединения
или файла может привести к возникновению ошибки Л компилятор требует от программиста предусмотреть некие действия для обработки
возможных проблем
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Таким
образом повышается надежность Программы, ее устойчивость при возможных сбоях.

</p>
<p>Исключения, порожденные от RuntimeException, являются непро­веряемыми и компилятор не требует обязательной их
обработки.

</p>
<p>Как правило, это ошибки программы, которые при правильном ко­дировании
возникать не должны
(например, IndexOfBoundException
-выход за границы массива,
java.lang.ArifmeticException
- деление на ноль).
Поэтому, чтобы не загромождать программу, компилятор оставляет &#9632;а
усмотрение программиста обработку таких исключений с помощью |йоков
try-catch.

</p>
<p>&#9632; Исключения,
порожденные от Error, также не являются проверяе­мыми. Они предназначены для того, чтобы
уведомить приложение о воз­никновении фатальной ситуации, которую программным
способом уст­ранить практически невозможно (хотя формально обработчик
допускает-сд). Они могут свидетельствовать об ошибках программы, но, как прави-



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0">
 <tr>
  <td valign="top" align="left">
  <p>{
  </p>
</td>
 </tr>
</table>



<p>|,
это неустранимые проблемы на
уровне JVM. В качестве примера мож-| привести StackOverflowError (переполнение стека), OutOfMemoryError
ехватка памяти).

</p>
<p>Если в конструкции обработки исключений используется несколько
^итераторов catch, классы исключений нужно перечислять в них последо-Щтельно, от менее
общих к более общим. Рассмотрим два примера:

</p>
<p> 

</p>
<p> 

</p>
<p> 

</p>
<p>}

</p>
<p>catch (Exception e) { }

</p>
<p>catch(lOException ioe) { }

</p>
<p>catch(UserExcetion ue) {








</p>
<p></p>
<center><img width="443" height="440" src="http://kufas.ru/java.files/image019.png"></center>
В данном примере при возникновении исключительной
ситуации (класс, порожденный от Exception) будет выполняться всегда только пер­вый блок catch. Остальные не
будут выполнены ни при каких условиях. Эта ситуация отслеживается компилятором,
который сообщает об UnreachableCodeException (ошибка -
недостижимый код). Правильно данная конструкция будет выглядеть так:

<p> 

</p>
<p>try {

</p>
<p> 

</p>
<p>}

</p>
<p>catch(UserExcetion ue) { catch(IOException
ioe) { }

</p>
<p>catch(Exception е) { }

</p>
<p>В этом случае будет выполняться последовательная обработка ис­ключений.
И в случае, если не предусмотрена обработка того типа исклю­чения, которое
возникло (например, AnotherUserException),
будет вы­полнен блок catch(Exception е){...}

</p>
<p>Если срабатывает один из блоков catch, то остальные блоки
в данной конструкции try-catch выполняться не будут.

</p>
<p> 

</p>
<p>Создание
пользовательских классов исключений

</p>
<p>Как уже отмечалось, допускается создание собственных классов ис-
-ключений
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Для этого достаточно создать свой класс, унаследовав его от любого
наследника java.lang.Throwable
(или от самого Throwable).

</p>
<p>Пример:

</p>
<p>public class UserException extends Exception { public
UserExceptionQ { super();

</p>
<p>}

</p>
<p>public
UserException(String descry) { super(descr);

</p>
<p>}

</p>
<p>}

</p>
<p>Соответственно, данное исключение будет создаваться
следующим образом:

</p>
<p> 

</p>
<p>throw new ивегЕхсерпопС'Дополнительное описание");

</p>
<p> 

</p>
<p> 

</p>
<p>Переопределение
методов и исключения

</p>
<p>При переопределении методов следует помнить, что если переопре­деляемый
метод объявляет список возможных исключений, то переопре­деляющий метод не
может расширять этот список, но может его сужать. Усмотрим пример:








</p>
<p>public class BaseClass{

</p>
<p>public void method () throws lOException {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>public
class LegalOne extends BaseClass { public void method () throws lOException {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>public class LegalTwo extends BaseClass { public void
method () {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>public class LegalTree extends BaseClass { public void
method ()

</p>
<p>throws EOFException.MalformedURLException {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>public class IllegalOne extends BaseClass { public void
method ()

</p>
<p>throws lOException,INegalAccessException {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>public class lllegalTwo extends BaseClass { public void
method () {

</p>
<p> 

</p>
<p>throw new Exception();

</p>
<p>}

</p>
<p>}

</p>
<p>В данном случае:

</p>
<p>• определение класса LegalOne будет корректным, так как переопре­деление метода method() верное (список
ошибок не изменился);

</p>
<p>•    определение класса LegalTwo будет корректным,
так как пере­определение метода method() верное (новый метод не может вы­брасывать ошибок, а значит, не
расширяет список возможных ошибок старого метода);

</p>
<p>•   
определение класса LegalTree будет корректным,
так как пере­определение метода method() будет верным (новый метод может создавать исключения, которые
являются подклассами исключения, возбуждаемого в старом методе, то есть список
сузился);

</p>
<p>•   
определение класса IlegalOne будет некорректным, так как пере­определение метода method() неверно (lllegalAccessException не является
подклассом lOException, список расширился);

</p>
<p>•   
определение класса IlegalTwo будет некорректным: хотя заголовок method() объявлен верно
(список не расширился), в теле метода бросается исключение, не указанное в throws.

</p>
<p> 

</p>
<p>Особые
случаи

</p>
<p>Во время исполнения кода могут возникать ситуации, которые почти не
описаны в литературе.

</p>
<p>Рассмотрим такую ситуацию:

</p>
<p>import java.io.*; public class Test {

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public Test() { }

</p>
<p>public static
void main(String[]
args) { Test test = new Test();
try{

</p>
<p>test. doFilelnputfbogus. file");

</p>
<p>}

</p>
<p>catch (lOException ex) {

</p>
<p>System.out.printlnfSecond exception hadle starck trace"); ex. printStackTrace( ) ;

</p>
<p>}

</p>
<p>}

</p>
<p>private String doFilelnput(String fileName)

</p>
<p>throws FileNotFoundException,lOException
{ String retStr =
""; java.io.FilelnputStream
fis = null; try{

</p>
<p>f is = new java.io.FilelnputStream(fileName);

</p>
<p>}

</p>
<p>catch (FileNotFoundException ex) {

</p>
<p>System.out.printlnf'First exception hadle starck
trace");

</p>
<p>ex.printStackTrace();

</p>
<p>throw ex;

</p>
<p>}

</p>
<p>return retStr;

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Результат работы будет выглядеть следующим образом:

</p>
<p> 

</p>
<p>Java.io.FileNotFoundException: bogus.file (The system
cannot find the file specified)

</p>
<p>at java.io.FilelnputStream.open(Native Method)

</p>
<p>at
java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)

</p>
<p>at experiment.Test.doFilelnput(Test.java:33)

</p>
<p>at experiment.Test.main(Test.java:21) First exception
hadle starck trace

</p>
<p>Java.io.FileNotFoundException: bogus.file (The system
cannot find the file specified)

</p>
<p>at java.io.FilelnputStream.open(Native Method)

</p>
<p>at java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)

</p>
<p>at experiment.Test.doFilelnput(Test.java:33)

</p>
<p>at
experiment.Test.main(Test.java:21) Second exception hadle starck trace

</p>
<p> 

</p>
<p>Так как при вторичном возбуждении используется один и тот же объект Exception, стек в обоих случаях будет содержать одну и ту же последователь­ность
вызовов. То есть при повторном возбуждении исключения, если мы используем тот же объект,
изменения его параметров не происходит.

</p>
<p>Рассмотрим другой пример:

</p>
<p>import Java.io.*;

</p>
<p>public class Test {

</p>
<p>public Test() {
}

</p>
<p>public static void main(String[] args) { Test test = new
Test();

</p>
<p>try {

</p>
<p>test.doFilelnput();

</p>
<p>}

</p>
<p>catch (lOException ex) {

</p>
<p>System.out.printlnf'Exception hash code" +
ex.hashCode()); ex. pri ntStackTrace();

</p>
<p>}

</p>
<p>}

</p>
<p>private String doFilelnput()

</p>
<p>throws FileNotFoundException,IOException{
String retStr =""; java.io.FilelnputStream fis = null; try {

</p>
<p>fis = new
Java.io.FilelnputStreamf'bogus.file");

</p>
<p>}

</p>
<p>catch (FileNotFoundException ex) {

</p>
<p>System, out. printlnfException hash code" +
ex.hashCode()); ex. pri ntStackTrace();

</p>
<p>fis = new
java.io.FilelnputStream("anotherBogus.file"); throw ex;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>return retStr;

</p>
<p>}

</p>
<p>}

</p>
<p>java.io.FileNotFoundException: bogus.file (The system
cannot find the file specified)

</p>
<p>at java.io.FilelnputStream.open(Native Method)

</p>
<p>at
java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)

</p>
<p>at experiment.Test.doFilelnput(Test.java:33)

</p>
<p>at experiment.Test.main(Test.java:21)
Exception hash code 3214658

</p>
<p>java.io.FileNotFoundException: (The system cannot find
the path specified)

</p>
<p>at
java.io.FilelnputStream.open(Native Method) at java.io.FilelnputStream.&lt;init&gt;(FilelnputStream.java:64)
at experiment.Test.doFilelnput(Test.java:38) at
experiment.Test.main(Test.java:21) Exception hash code 6129586








</p>
<p>Несложно заметить, что, хотя последовательность вызовов одна и ту же, в вызываемом и
вызывающем методах обрабатываются разные объек­ты исключений.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В данной лекции
рассмотрены основные языковые конструкции.

</p>
<p>Для организации циклов в Java предназначены три
основных конст­рукции: while, do, for. Для изменения порядка выполнения операторов применяются continue и break (с меткой или без).
Также существуют два оператора ветвления: if и switch.

</p>
<p>Важной темой является обработка ошибок, поскольку без нее не об­ходится
ни одна программа, ведь причиной сбоев может служить не только ошибка
программиста, но и внешние события, например, разрыв сетевого соединения.
Основной конструкцией обработки исключительных ситуа­ций является try-catch-finally. Для явной
инициализации исключительной ситуации служит ключевое слово throw.

</p>
<p>Ошибки делятся на проверяемые и непроверяемые. Чтобы повысить надежность
программы, компилятор требует обработки исключений, классы которых наследуются
от Exception, кроме классов-наследников RuntimeException. Предполагается, что такие ошибки могут возникать не столько по ошибке
разработчика, сколько по внешним неконтролиру­емым причинам.

</p>
<p>Классы, унаследованные от RuntimeException, описывают про­граммные сбои. Ожидается, что программист сведет
вероятность таких ошибок к минимуму, а потому, чтобы не загромождать код, они
являются непроверяемыми, компилятор оставляет обработку на усмотрение разра­ботчика.
Ошибки-наследники Error свидетельствуют о
фатальных сбоях, поэтому их также необязательно обрабатывать.

</p>
<p>Методы, код которых может порождать проверяемые
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>исключения, должны либо
сами их обрабатывать, либо в заголовке метода должно быть указано ключевое
слово throws с перечислением
необрабатываемых про­веряемых исключений. На непроверяемые ошибки это правило
не распро­страняется.

</p>
<p>Переопределенный (overridden) метод не может расширять список возможных исключений исходного метода.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>I _   Приведенная ниже программа должна вывести на
консоль Hello World! Выберите
строки, которые нужно модифицировать в вашей программе, чтобы получить
правильный результат.

</p>
<p>1   public class Test {

</p>
<p>2      
public Test() {

</p>
<p>3      
}

</p>
<p>4       public static void main (String [] args) {

</p>
<p> 

</p>
<p>5         
Test test = new Test();

</p>
<p>6         
String [] arr =
{"Н","е","Г,"Г,"о"," ","w","o","r",'T',"d","!"};

</p>
<p>7         
String result =
"";

</p>
<p>8         
int i= 0;

</p>
<p>9         
for(;;;){

</p>
<p>10             result+=
arr[i++];

</p>
<p>11          
}

</p>
<p>12          
System, out.
println(result);

</p>
<p>13       }

</p>
<p>14    }

</p>
<p>&#9633;       
заменить строку 9 на for(i =
0; i &lt;
arr.length;){

</p>
<p>&#9633;       
заменить строку 9 на for(int int i = 0; i &lt; arr.length;){

</p>
<p>&#9633;       
заменить строку 9 на for(i =
0; i &lt; arr.length;i++){

</p>
<p>&#9633;       
заменить строку 9 на for(i =
1; i &lt;= arr.length;i++){








</p>
<p> 








</p>
<p>Какая
строка будет выдана на консоль после выполнения фрагмента кода, приведенного
ниже? public class Test { public Test()
(

</p>
<p>}

</p>
<p>public static void main(String[] args) { inti.j;

</p>
<p>lab: for(i = 0; i &lt; 6; i++){ for(j = 3;j&gt;1;j«){ if(i ==j){ System.out.printlnf' " + j); break lab;

</p>
<p>}

</p>
<p>}



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="18" height="96">
 <tr>
  <td valign="top" align="left" height="96">
  <p>&#9633; &#9633;
  &#9633; &#9633;
  </p>
</td>
 </tr>
</table>



<p> 

</p>
<p> 

</p>
<p>}

</p>
<p>2345
234 3 2




</p>
<p>



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="19" height="259">
 <tr>
  <td valign="top" align="left" height="259">
  <p>1 2 3 4 5 6 7 8 9 10 11 12 13
  </p>
</td>
 </tr>
</table>



<p>3-




</p>
<p>Предположим,
нам необходимо создать собственную иерархию исключений. Рассмотрим следующий
пример.

</p>
<p>Exception

</p>
<p>I

</p>
<p>+--LengthException

</p>
<p>I

</p>
<p>+--TooLongException

</p>
<p>I

</p>
<p>+--TooShort
Exception

</p>
<p> 

</p>
<p>class BaseMeasurer{ public BaseMeasurer(){

</p>
<p>}

</p>
<p>int measureLength(Dimension
d) throws LengthException{

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>class DerivedMeasurer extends BaseMeasurer{ public
BaseMeasurer(){

</p>
<p>}

</p>
<p>XXX {

</p>
<p>}

</p>
<p>}








</p>
<p>Какое
из перечисленных ниже выражений можно использовать в строке 11с тем, чтобы код успешно
откомпилировался?

</p>
<p>&#9633;   int measureLength(Dimension
d) throws LengthException П   int measureLength(Dimension d) throws Exception П   int measureLength(Dimension d) throws TooLongException П   int measureLength(Dimension d)








</p>
<p>курс

</p>
<p>Программирование на.Ь,

</p>
<p>Вариант
2

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Каков будет результат выполнения программы:

</p>
<p>1   public class Test {

</p>
<p>2      
public Test() {

</p>
<p>3      
} 4

</p>
<p>5      public static void main(String[] args) {

</p>
<p>6         
Test test = new Test();

</p>
<p>7         
int i =
5;

</p>
<p>8         
while(i = 5){

</p>
<p>9             System.out.println(i++); Ю     }

</p>
<p>11       }

</p>
<p>12    }

</p>
<p>П   компилятор
выдаст сообщение об ошибке в строке 8

</p>
<p>Г")   на
консоль будут последовательно выведены значения 01234

</p>
<p>[~1   на консоль будут последовательно
выведены значения 43210

</p>
<p>Г~1   программа откомпилируется, но на
консоль ничего выведено не будет

</p>
<p>секция Ю                                                         Операторы
и структура кода. Исключения

</p>
<p>2  
выберите все правильные варианты ответов в этом примере:

</p>
<p>public class Test {

</p>
<p>float fVal = 0. Of;

</p>
<p>public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) {

</p>
<p>Test t = new Test();

</p>
<p>String testVal = "0.123";

</p>
<p>System.out.println("Was returned " + t.testParse(testVal)
+ " with value " + t.tVal);

</p>
<p>}

</p>
<p>private boolean
testParse(String val){ try {

</p>
<p>fVal = Float. parseFloat(val); return true;

</p>
<p>}

</p>
<p>catch
(NumberFormatException ex) {

</p>
<p>System.out.println("Test.testParse()
Bad number -&gt; "

</p>
<p>+ val);

</p>
<p>fVal = Float. NaN; } finally{

</p>
<p>System.out.println( "Finally part executed");

</p>
<p>}

</p>
<p>return false;

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;   testVal="0.123"; Finally part
executed Was returned true with value 0.123

</p>
<p>П   testVal = "0,123"; Finally part executed Was
returned false with value 0.123

</p>
<p>П   testVal = null; Finally part executed

</p>
<p>Далее будет вызвано исключение NullPointer

</p>
<p>П   testVal = "0.123"; Finally part executed Was
returned false with value null








</p>
<p>3.   Предположим, нам необходимо
создать собственную иерархию исключений. Рассмотрим следующий пример. Exception

</p>
<p>I

</p>
<p>+--LengthException

</p>
<p>I

</p>
<p>+--TooLongException

</p>
<p>I

</p>
<p>+- - TooShortException

</p>
<p> 

</p>
<p>1   class TooShortException extends Exception!

</p>
<p>2          public TooShortException(String description){

</p>
<p>3                super(description);

</p>
<p>4          }

</p>
<p>5   } 6

</p>
<p>7   class Measurer {

</p>
<p>8          public Measurer(){

</p>
<p>9                super(); 10     }

</p>
<p>11

</p>
<p>12          int measureLength(Dimension d) throws LengthException {

</p>
<p>13               XXX

</p>
<p>14         }

</p>
<p>15   }

</p>
<p>В строке 13 необходимо вызвать исключение.

</p>
<p>Какой из предложенных вариантов
будет правильным?

</p>
<p>&#9633;      new
TooShortExceptionC'Shhhhort");

</p>
<p>П    throws new TooShortExceptionC'Shhhhort");

</p>
<p>П    throw new TooShortExceptionC'Shhhhort");

</p>
<p>П    throw TooShortExceptionC'Shhhhort").

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>В данном случае выберите все правильные ответы, private void say(int digit) { switch(x){ case 1: System.out.print("ONE");

</p>
<p>break;

</p>
<p>case 2: System.out.printf TWO'); case 3: System.out.print("TREE");
default:System.out.pritn("Unknown value")

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;          
digit = 1 ONE

</p>
<p>&#9633;          
digit = 0 TWO TREE

</p>
<p>&#9633;          
digit = 2 TWO Unknown
value

</p>
<p>&#9633;          
digit = 3 TREE Unknown
value

</p>
<p>2.   Рассмотрим пример.

</p>
<p>Эти
исключения имеют следующую иерархию наследования: StringlndexOutOfBoundsException и ArraylndexOutOfBoundsException

</p>
<p>java.lang.Object

</p>
<p>I

</p>
<p>+--java.lang.Throwable

</p>
<p>I

</p>
<p>+- -java. lang. Exception

</p>
<p>I

</p>
<p>+--java.lang.RuntimeException

</p>
<p>I

</p>
<p>+- -java. lang. IndexOutOf BoundsException

</p>
<p>I

</p>
<p>+--java.lang.StringlndexOutOf
BoundsException

</p>
<p> 

</p>
<p>+--java.lang.ArraylndexOutOfBoundsException

</p>
<p>Предположим,
что в методе testSomeValue могут
быть возбуждены оба вида исключений, при этом они не обрабатываются в блоке try - catch.

</p>
<p>Какое
из перечисленных ниже утверждений будет верным?

</p>
<p>Г~1   определение
метода testSomeValue должно
включать throws StringlndexOutOf
BoundsException, ArraylndexOutOfBoundsException

</p>
<p>П   если метод, вызывающий testSomeValue, перехватывает IndexOutOfBoundsException, то исключения StringlndexOutOf BoundsException,

</p>
<p>ArraylndexOutOfBoundsException
тоже будут перехватываться

</p>
<p>П   так как в определении метода указано throws StringlndexOutOf BoundsException,

</p>
<p>ArraylndexOutOfBoundsException, любой
вызывающий его метод должен перехватывать эти типы исключений, вне зависимости
от того, возбуждается во время работы исключение или нет

</p>
<p>П   при
объявлении метода testSomeValue не
обязательно указывать возбуждаемые исключения

</p>
<p>3.  
Каков будет результат работы следующего кода: 1 public class Test { 2

</p>
<p>3      
public Test() {

</p>
<p>4      
}

</p>
<p>5       public static void main(String[] args) {

</p>
<p> 

</p>
<p>6         
Test t = new Test();

</p>
<p>7         
XXX

</p>
<p> 

</p>
<p>8      
}

</p>
<p>9       private int check(String x,int n){

</p>
<p> 

</p>
<p>10      if( n ==0
)return n;

</p>
<p>11      elseif(n== 1){

</p>
<p>12            if (x != null) return 5;

</p>
<p>13      }

</p>
<p>14     
else if (n==2&amp;&amp;x!=null){

</p>
<p> 

</p>
<p>15       
if
(x.equals("YES"» return 3;

</p>
<p>16       
else if ( x.equals("NO"))
return 4;

</p>
<p> 

</p>
<p>17      }

</p>
<p>18      return-1;

</p>
<p>19       }

</p>
<p>20    }

</p>
<p>Если
в строке 7 поместить код вызова метода check, то
какое из предложений будет верным?

</p>
<p>П   t.check("ANY",1) в этом случае
обязательно будет выполнена строка 14

</p>
<p>Г~| t.check("NO",2) в
этом случае функция вернет значение 4 П t.checkfYES",
1) в этом случае функция вернет значение 3 Г~!  
else в строке 14 относится к if в
строке 11








</p>
<p>
</p>
<center> 
</center>
    </div>