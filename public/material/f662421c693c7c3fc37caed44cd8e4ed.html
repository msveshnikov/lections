# encoding: windows-1251







<p>В этой лекции рассматривается реализация на Python простейшего клиент–серверного приложения, дается представление о типичном для сети Internet приложении. Стандартная библиотека Python имеет несколько модулей для работы с различными протоколами. Этими модулями охватываются как низкоуровневые протоколы (TCP/IP, UDP/IP), так и высокоуровневые (HTTP, FTP, SMTP, POP3, IMAP, NNTP, …). Здесь будет рассмотрена работа с сокетами (модуль socket) и три модуля высокоуровневых протоколов (urllib2, poplib, smtplib). При этом предполагается, что имеется понимание принципов работы IP–сети и некоторых ее сервисов, а также представление о системе WWW.</p>
<p>Работа с сокетами</p>
<p>Применяемая в IP–сетях архитектура клиент–сервер использует IP–пакеты для коммуникации между клиентом и сервером. Клиент отправляет запрос серверу, на который тот отвечает. В случае с TCP/IP между клиентом и сервером устанавливается соединение (обычно с двусторонней передачей данных), а в случае с UDP/IP — клиент и сервер обмениваются пакетами (дейтаграммамми) с негарантированной доставкой.</p>
<p>Каждый сетевой интерфейс IP–сети имеет уникальный в этой сети адрес (IP–адрес). Упрощенно можно считать, что каждый компьютер в сети Интернет имеет собственный IP–адрес. При этом в рамках одного сетевого интерфейса может быть несколько сетевых портов. Для установления сетевого соединения приложение клиента должно выбрать свободный порт и установить соединение с серверным приложением, которое слушает (listen) порт с определенным номером на удаленном сетевом интерфейсе. Пара IP–адрес и порт характеризуют сокет (гнездо) - начальную (конечную) точку сетевой коммуникации. Для создания соединения TCP/IP необходимо два сокета: один на локальной машине, а другой — на удаленной. Таким образом, каждое сетевое соединение имеет IP–адрес и порт на локальной машине, а также IP–адрес и порт на удаленной машине.</p>
<p>Модуль socket обеспечивает возможность работать с сокетами из Python. Сокеты используют транспортный уровень согласно семиуровневой модели OSI (Open Systems Interconnection, взаимодействие открытых систем), то есть относятся к более низкому уровню, чем большинство описываемых в этом разделе протоколов.</p>
<p>Уровни модели OSI:</p>
<p>Физический</p>
<p>Поток битов, передаваемых по физической линии. Определяет параметры физической линии.</p>
<p>Канальный (Ethernet, PPP, ATM и т.п.)</p>
<p>Кодирует и декодирует данные в виде потока битов, справляясь с ошибками, возникающими на физическом уровне в пределах физически единой сети.</p>
<p>Сетевой (IP)</p>
<p>Маршрутизирует информационные пакеты от узла к узлу.</p>
<p>Транспортный (TCP, UDP и т.п.)</p>
<p>Обеспечивает прозрачную передачу данных между двумя точками соединения.</p>
<p>Сеансовый</p>
<p>Управляет сеансом соединения между участниками сети. Начинает, координирует и завершает соединения.</p>
<p>Представления</p>
<p>Обеспечивает независимость данных от формы их представления путем преобразования форматов. На этом уровне может выполняться прозрачное (с точки зрения вышележащего уровня) шифрование и дешифрование данных.</p>
<p>Приложений (HTTP, FTP, SMTP, NNTP, POP3, IMAP и т.д.)</p>
<p>Поддерживает конкретные сетевые приложения. Протокол зависит от типа сервиса.</p>
<p>Каждый сокет относится к одному из коммуникационных доменов. Модуль socket поддерживает домены UNIX и Internet. Каждый домен подразумевает свое семейство протоколов и адресацию. Данное изложение будет затрагивать только домен Internet, а именно протоколы TCP/IP и UDP/IP, поэтому для указания коммуникационного домена при создании сокета будет указываться константа socket.AF_INET.</p>
<p>В качестве примера следует рассмотреть простейшую клиент–серверную пару. Сервер будет принимать строку и отвечать клиенту. Сетевое устройство иногда называют хостом (host), поэтому будет употребляться этот термин по отношению к компьютеру, на котором работает сетевое приложение.</p>
<p>Сервер:</p>
<p>Листинг</p>
<p>import socket, string</p>
<p>def do_something(x):</p>
<p>lst = map(None, x);</p>
<p>lst.reverse();</p>
<p>return string.join(lst, "")</p>
<p>HOST = "" # localhost</p>
<p>PORT = 33333</p>
<p>srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
<p>srv.bind((HOST, PORT))</p>
<p>while 1:</p>
<p>print «Слушаю порт 33333»</p>
<p>srv.listen(1)</p>
<p>sock, addr = srv.accept()</p>
<p>while 1:</p>
<p>pal = sock.recv(1024)</p>
<p>if not pal:</p>
<p>break</p>
<p>print «Получено от %s:%s:" % addr, pal</p>
<p>lap = do_something(pal)</p>
<p>print «Отправлено %s:%s:" % addr, lap</p>
<p>sock.send(lap)</p>
<p>sock.close()</p>
<p>Клиент:</p>
<p>Листинг</p>
<p>import socket</p>
<p>HOST = "" # удаленный компьютер (localhost)</p>
<p>PORT = 33333 # порт на удаленном компьютере</p>
<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
<p>sock.connect((HOST, PORT))</p>
<p>sock.send(«ПАЛИНДРОМ»)</p>
<p>result = sock.recv(1024)</p>
<p>sock.close()</p>
<p>print «Получено:", result</p>
<p>Примечание:</p>
<p>В примере использованы русские буквы: необходимо указывать кодировку.</p>
<p>Прежде всего, нужно запустить сервер. Сервер открывает сокет на локальной машине на порту 33333, и адресе 127.0.0.1. После этого он слушает (listen()) порт. Когда на порту появляются данные, принимается (accept()) входящее соединение. Метод accept() возвращает пару — Socket–объект и адрес удаленного компьютера, устанавливающего соединение (пара — IP–адрес, порт на удаленной машине). После этого можно применять методы recv() и send() для общения с клиентом. В recv() задается число байтов в очередной порции. От клиента может прийти и меньшее количество данных.</p>
<p>Код программы–клиента достаточно очевиден. Метод connect() устанавливает соединение с удаленным хостом (в приведенном примере он расположен на той же машине). Данные передаются методом send() и принимаются методом recv() — аналогично тому, что происходит на сервере.</p>
<p>Модуль socket имеет несколько вспомогательных функций. В частности, функции для работы с системой доменных имен (DNS):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import socket</p>
<p>&gt;&gt;&gt; socket.gethostbyaddr('www.onego.ru')</p>
<p>('www.onego.ru', [], ['195.161.136.4'])</p>
<p>&gt;&gt;&gt; socket.gethostbyaddr('195.161.136.4')</p>
<p>('www.onego.ru', [], ['195.161.136.4'])</p>
<p>&gt;&gt;&gt; socket.gethostname()</p>
<p>'rnd.onego.ru'</p>
<p>В новых версиях Python появилась такая функция как socket.getservbyname(). Она позволяет преобразовывать наименования Интернет–сервисов в общепринятые номера портов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; for srv in 'http', 'ftp', 'imap', 'pop3', 'smtp':</p>
<p>… print socket.getservbyname(srv, 'tcp'), srv</p>
<p>…</p>
<p>80 http</p>
<p>21 ftp</p>
<p>143 imap</p>
<p>110 pop3</p>
<p>25 smtp</p>
<p>Модуль также содержит большое количество констант для указания протоколов, типов сокетов, коммуникационных доменов и т.п. Другие функции модуля socket можно при необходимости изучить по документации.</p>
<p>Модуль smtplib</p>
<p>Сообщения электронной почты в Интернете передаются от клиента к серверу и между серверами в основном по протоколу SMTP (Simple Mail Transfer Protocol, простой протокол передачи почты). Протокол SMTP и ESMTP (расширенный вариант SMTP) описаны в RFC 821 и RFC 1869. Для работы с SMTP в стандартной библиотеке модулей имеется модуль smtplib. Для того чтобы начать SMTP–соединение с сервером электронной почты, необходимо в начале создать объект для управления SMTP–сессией с помощью конструктора класса SMTP:</p>
<p>Листинг</p>
<p>smtplib.SMTP([host[, port]])</p>
<p>Параметры host и port задают адрес и порт SMTP–сервера, через который будет отправляться почта. По умолчанию, port=25. Если host задан, конструктор сам установит соединение, иначе придется отдельно вызывать метод connect(). Экземпляры класса SMTP имеют методы для всех распространенных команд SMTP–протокола, но для отправки почты достаточно вызова конструктора и методов sendmail() и quit():</p>
<p>Листинг</p>
<p># -*- coding: cp1251 -*-from smtplib import SMTP</p>
<p>fromaddr = «student@mail.ru» # От кого</p>
<p>toaddr = «rnd@onego.ru» # Кому</p>
<p>message = ""«From: Student &lt;%(fromaddr)s&gt;</p>
<p>To: Lecturer &lt;%(toaddr)s&gt;</p>
<p>Subject: From Python course student</p>
<p>MIME–Version: 1.0</p>
<p>Content–Type: text/plain; charset=Windows–1251</p>
<p>Content–Transfer–Encoding: 8bit</p>
<p>Здравствуйте! Я изучаю курс по языку Python и</p>
<p>отправляю письмо его автору.</p>
<p>"""</p>
<p>connect = SMTP('mail.onego.ru')</p>
<p>connect.set_debuglevel(1)</p>
<p>connect.sendmail(fromaddr, toaddr, message % vars())</p>
<p>connect.quit()</p>
<p>Следует заметить, что toaddr в сообщении (в поле To) и при отправке могут не совпадать. Дело в том, что получатель и отправитель в ходе SMTP–сессии передается командами SMTP–протокола. При запуске указанного выше примера на экране появится отладочная информация (ведь уровень отладки задан равным 1):</p>
<p>Листинг</p>
<p>send: 'ehlo rnd.onego.ru\r\n'</p>
<p>reply: '250–mail.onego.ru Hello as3–042.dialup.onego.ru [195.161.147.4], pleased to meet you\r\n'</p>
<p>send: 'mail FROM:&lt;student@mail.ru&gt; size=270\r\n'</p>
<p>reply: '250 2.1.0 &lt;student@mail.ru&gt;… Sender ok\r\n'</p>
<p>send: 'rcpt TO:&lt;rnd@onego.ru&gt;\r\n'</p>
<p>reply: '250 2.1.5 &lt;rnd@onego.ru&gt;… Recipient ok\r\n'</p>
<p>send: 'data\r\n'</p>
<p>reply: '354 Enter mail, end with ".» on a line by itself\r\n'</p>
<p>send: 'From: Student &lt;student@mail.ru&gt;\r\n … '</p>
<p>reply: '250 2.0.0 iBPFgQ7q028433 Message accepted for delivery\r\n'</p>
<p>send: 'quit\r\n'</p>
<p>reply: '221 2.0.0 mail.onego.ru closing connection\r\n'</p>
<p>Из этой (несколько сокращенной) отладочной информации можно увидеть, что клиент отправляет (send) команды SMTP–серверу (EHLO, MAIL FROM, RCPT TO, DATA, QUIT), а тот выполняет команды и отвечает (reply), возвращая код возврата.</p>
<p>В ходе одной SMTP–сессии можно отправить сразу несколько писем подряд, если не вызывать quit().</p>
<p>В принципе, команды SMTP можно подавать и отдельно: для этого у объекта–соединения есть методы (helo(), ehlo(), expn(), help(), mail(), rcpt(), vrfy(), send(), noop(), data()), соответствующие одноименным командам SMTP–протокола.</p>
<p>Можно задать и произвольную команду SMTP–серверу с помощью метода docmd(). В следующем примере показан простейший сценарий, который могут использовать те, кто время от времени принимает почту на свой сервер по протоколу SMTP от почтового сервера, на котором хранится очередь сообщений для некоторого домена:</p>
<p>Листинг</p>
<p>from smtplib import SMTP</p>
<p>connect = SMTP('mx.abcde.ru')</p>
<p>connect.set_debuglevel(1)</p>
<p>connect.docmd(«ETRN rnd.abcde.ru»)</p>
<p>connect.quit()</p>
<p>Этот простенький сценарий предлагает серверу mx.abcde.ru попытаться связаться с основным почтовым сервером домена rnd.abcde.ru и переслать всю накопившуюся для него почту.</p>
<p>При работе с классом smtplib.SMTP могут возбуждаться различные исключения. Назначение некоторых из них приведено ниже:</p>
<p>Листинг</p>
<p>smtplib.SMTPException</p>
<p>Базовый класс для всех исключений модуля.</p>
<p>Листинг</p>
<p>smtplib.SMTPServerDisconnected</p>
<p>Сервер неожиданно прервал связь (или связь с сервером не была установлена).</p>
<p>Листинг</p>
<p>smtplib.SMTPResponseException</p>
<p>Базовый класс для всех исключений, которые имеют код ответа SMTP–сервера.</p>
<p>Листинг</p>
<p>smtplib.SMTPSenderRefused</p>
<p>Отправитель отвергнут</p>
<p>Листинг</p>
<p>smtplib.SMTPRecipientsRefused</p>
<p>Все получатели отвергнуты сервером.</p>
<p>Листинг</p>
<p>smtplib.SMTPDataError</p>
<p>Сервер ответил неизвестным кодом на данные сообщения.</p>
<p>Листинг</p>
<p>smtplib.SMTPConnectError</p>
<p>Ошибка установления соединения.</p>
<p>Листинг</p>
<p>smtplib.SMTPHeloError</p>
<p>Сервер не ответил правильно на команду HELO или отверг ее.</p>
<p>Модуль poplib</p>
<p>Еще один протокол — POP3 (Post Office Protocol, почтовый протокол) - служит для приема почты из почтового ящика на сервере (протокол определен в RFC 1725).</p>
<p>Для работы с почтовым сервером требуется установить с ним соединение и, подобно рассмотренному выше примеру, с помощью SMTP–команд получить требуемые сообщения. Объект–соединение POP3 можно установить посредством конструктора класса POP3 из модуля poplib:</p>
<p>Листинг</p>
<p>poplib.POP3(host[, port])</p>
<p>Где host — адрес POP3–сервера, port — порт на сервере (по умолчанию 110), pop_obj — объект для управления сеансом работы с POP3–сервером.</p>
<p>Следующий пример демонстрирует основные методы для работы с POP3–соединением:</p>
<p>Листинг</p>
<p>import poplib, email</p>
<p># Учетные данные пользователя:</p>
<p>SERVER = «pop.server.com»</p>
<p>USERNAME = «user»</p>
<p>USERPASSWORD = «secretword»</p>
<p>p = poplib.POP3(SERVER)</p>
<p>print p.getwelcome()</p>
<p># этап идентификации</p>
<p>print p.user(USERNAME)</p>
<p>print p.pass_(USERPASSWORD)</p>
<p># этап транзакций</p>
<p>response, lst, octets = p.list()</p>
<p>print response</p>
<p>for msgnum, msgsize in [i.split() for i in lst]:</p>
<p>print «Сообщение %(msgnum)s имеет длину %(msgsize)s» % vars()</p>
<p>print «UIDL =", p.uidl(int(msgnum)).split()[2]</p>
<p>if int(msgsize) &gt; 32000:</p>
<p>(resp, lines, octets) = p.top(msgnum, 0)</p>
<p>else:</p>
<p>(resp, lines, octets) = p.retr(msgnum)</p>
<p>msgtxt = "\n».join(lines)+»\n\n»</p>
<p>msg = email.message_from_string(msgtxt)</p>
<p>print "* От: %(from)s\n* Кому: %(to)s\n* Тема: %(subject)s\n» % msg</p>
<p># msg содержит заголовки сообщения или все сообщение (если оно небольшое)</p>
<p># этап обновления</p>
<p>print p.quit()</p>
<p>Примечание:</p>
<p>Разумеется, чтобы пример сработал корректно, необходимо внести реальные учетные данные.</p>
<p>При выполнении сценарий выведет на экран примерно следующее.</p>
<p>Листинг</p>
<p>+OK POP3 pop.server.com server ready</p>
<p>+OK User name accepted, password please</p>
<p>+OK Mailbox open, 68 messages</p>
<p>+OK Mailbox scan listing follows</p>
<p>Сообщение 1 имеет длину 4202</p>
<p>UIDL = 4152a47e00000004</p>
<p>* От: online@kaspersky.com</p>
<p>* Кому: user@server.com</p>
<p>* Тема: KL Online Activation</p>
<p>…</p>
<p>+OK Sayonara</p>
<p>Эти и другие методы экземпляров класса POP3 описаны ниже:</p>
<p>Метод Команда POP3 Описание</p>
<p>getwelcome() Получает строку s с приветствием POP3–сервера</p>
<p>user(name) USER name Посылает команду USER с указанием имени пользователя name. Возвращает строку с ответом сервера</p>
<p>pass_(pwd) PASS pwd Отправляет пароль пользователя в команде PASS. После этой команды и до выполнения команды QUIT почтовый ящик блокируется</p>
<p>apop(user, secret) APOP user secret Идентификация на сервере по APOP</p>
<p>rpop(user) RPOP user Идентификация по методу RPOP</p>
<p>stat() STAT Возвращает кортеж с информацией о почтовом ящике. В нем m — количество сообщений, l — размер почтового ящика в байтах</p>
<p>list([num]) LIST [num] Возвращает список сообщений в формате (resp, ['num octets', …]), если не указан num, и «+OK num octets», если указан. Список lst состоит из строк в формате «num octets».</p>
<p>retr(num) RETR num Загружает с сервера сообщение с номером num и возвращает кортеж с ответом сервера (resp, lst, octets)</p>
<p>dele(num) DELE num Удаляет сообщение с номером num</p>
<p>rset() RSET Отменяет пометки удаления сообщений</p>
<p>noop() NOOP Ничего не делает (поддерживает соединение)</p>
<p>quit() QUIT Отключение от сервера. Сервер выполняет все необходимые изменения (удаляет сообщения) и снимает блокировку почтового ящика</p>
<p>top(num, lines) TOP num lines Команда аналогична RETR, но загружает только заголовок и lines строк тела сообщения. Возвращает кортеж (resp, lst, octets)</p>
<p>uidl([num]) UIDL [num] Сокращение от «unique–id listing» (список уникальных идентификаторов сообщений). Формат результата: (resp, lst, octets), если num не указан, и «+OK num uniqid», если указан. Список lst состоит из строк вида «+OK num uniqid»</p>
<p>В этой таблице num обозначает номер сообщения (он не меняется на протяжении всей сессии), resp — ответ сервера, возвращается для любой команды, начинается с «+OK " для успешных операций (при неудаче возбуждается исключение poplib.proto_error). Параметр octets обозначает количество байт в принятых данных. uniqid — идентификатор сообщения, генерируемый сервером.</p>
<p>Работа с POP3–сервером состоит из трех фаз: идентификации, транзакций и обновления. На этапе идентификации сразу после создания POP3–объекта разрешены только команды USER, PASS (иногда APOP и RPOP). После идентификации сервер получает информацию о пользователе и наступает этап транзакций. Здесь уместны остальные команды. Этап обновления вызывается командой QUIT, после которой POP3–сервер обновляет почтовый ящик пользователя в соответствии с поданными командами, а именно — удаляет помеченные для удаления сообщения.</p>
<p>Модули для клиента WWW</p>
<p>Стандартные средства языка Python позволяют получать из программы доступ к объектам WWW как в простых случаях, так и при сложных обстоятельствах, в частности при необходимости передавать данные формы, идентификации, доступа через прокси и т.п.</p>
<p>Стоит отметить, что при работе с WWW используется в основном протокол HTTP, однако WWW охватывает не только HTTP, но и многие другие схемы (FTP, gopher, HTTPS и т.п.). Используемая схема обычно указана в самом начале URL.</p>
<p>Функции для загрузки сетевых объектов</p>
<p>Простой случай получения WWW–объекта по известному URL показан в следующем примере:</p>
<p>Листинг</p>
<p>import urllib</p>
<p>doc = urllib.urlopen(«http://python.onego.ru»).read()</p>
<p>print doc[:40]</p>
<p>Функция urllib.urlopen() создает файлоподобный объект, который читает методом read(). Другие методы этого объекта: readline(), readlines(), fileno(), close() работают как и у обычного файла, а также есть метод info(), который возвращает соответствующий полученному с сервера Message–объект. Этот объект можно использовать для получения дополнительной информации:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import urllib</p>
<p>&gt;&gt;&gt; f = urllib.urlopen(«http://python.onego.ru»)</p>
<p>&gt;&gt;&gt; print f.info()</p>
<p>Date: Sat, 25 Dec 2004 19:46:11 GMT</p>
<p>Server: Apache/1.3.29 (Unix) PHP/4.3.10</p>
<p>Content–Type: text/html; charset=windows–1251</p>
<p>Content–Length: 4291</p>
<p>&gt;&gt;&gt; print f.info()['Content–Type']</p>
<p>text/html; charset=windows–1251</p>
<p>С помощью функции urllib.urlopen() можно делать и более сложные вещи, например, передавать web–серверу данные формы. Как известно, данные заполненной web–формы могут быть переданы на web–сервер с использованием метода GET или метода POST. Метод GET связан с кодированием всех передаваемых параметров после знака "?» в URL, а при методе POST данные передаются в теле HTTP–запроса. Оба варианта передачи представлены ниже:</p>
<p>Листинг</p>
<p>import urllib</p>
<p>data = {«search»: «Python»}</p>
<p>enc_data = urllib.urlencode(data)</p>
<p># метод GET</p>
<p>f = urllib.urlopen(«http://searchengine.com/search» + "?» + enc_data)</p>
<p>print f.read()</p>
<p># метод POST</p>
<p>f = urllib.urlopen(«http://searchengine.com/search», enc_data)</p>
<p>print f.read()</p>
<p>В некоторых случаях данные имеют повторяющиеся имена. В этом случае в качестве параметра urllib.urlencode() можно использовать вместо словаря последовательность пар имя–значение:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import urllib</p>
<p>&gt;&gt;&gt; data = [(«n», «1»), («n», «3»), («n», «4»), («button», «Привет»),]</p>
<p>&gt;&gt;&gt; enc_data = urllib.urlencode(data)</p>
<p>&gt;&gt;&gt; print enc_data</p>
<p>n=1&amp;n=3&amp;n=4&amp;button=%F0%D2%C9%D7%C5%D4</p>
<p>Модуль urllib позволяет загружать web–объекты через прокси–сервер. Если ничего не указывать, будет использоваться прокси–сервер, который был задан принятым в конкретной ОС способом. В Unix прокси–серверы задаются в переменных окружения http_proxy, ftp_proxy и т.п., в Windows прокси–серверы записаны в реестре, а в Mac OS они берутся из конфигурации Internet. Задать прокси–сервер можно и как именованный параметр proxies к urllib.urlopen():</p>
<p>Листинг</p>
<p># Использовать указанный прокси</p>
<p>proxies = {'http': 'http://www.proxy.com:3128'}</p>
<p>f = urllib.urlopen(some_url, proxies=proxies)</p>
<p># Не использовать прокси</p>
<p>f = urllib.urlopen(some_url, proxies={})</p>
<p># Использовать прокси по умолчанию</p>
<p>f = urllib.urlopen(some_url, proxies=None)</p>
<p>f = urllib.urlopen(some_url)</p>
<p>Функция urlretrieve() позволяет записать заданный URL сетевой объект в файл. Она имеет следующие параметры:</p>
<p>Листинг</p>
<p>urllib.urlretrieve(url[, filename[, reporthook[, data]]])</p>
<p>Здесь url — URL сетевого объекта, filename — имя локального файла для помещения объекта, reporthook — функция, которая будет вызываться для сообщения о состоянии загрузки, data — данные для метода POST (если он используется). Функция возвращает кортеж (filepath, headers) , где filepath — имя локального файла, в который закачан объект, headers — результат метода info() для объекта, возвращенного urlopen().</p>
<p>Для обеспечения интерактивности функция urllib.urlretrieve() вызывает время от времени функцию, заданную в reporthook(). Этой функции передаются три аргумента: количество принятых блоков, размер блока и общий размер принимаемого объекта в байтах (если он неизвестен, этот параметр равен–1).</p>
<p>В следующем примере программа принимает большой файл и, чтобы пользователь не скучал, пишет процент от выполненной загрузки и предполагаемое оставшееся время:</p>
<p>Листинг</p>
<p>FILE = 'boost–1.31.0–9.src.rpm'</p>
<p>URL = 'http://download.fedora.redhat.com/pub/fedora/linux/core/3/SRPMS/' + FILE</p>
<p>def download(url, file):</p>
<p>import urllib, time</p>
<p>start_t = time.time()</p>
<p>def progress(bl, blsize, size):</p>
<p>dldsize = min(bl*blsize, size)</p>
<p>if size != -1:</p>
<p>p = float(dldsize) / size</p>
<p>try:</p>
<p>elapsed = time.time() - start_t</p>
<p>est_t = elapsed / p — elapsed</p>
<p>except:</p>
<p>est_t = 0</p>
<p>print "%6.2f %% %6.0f s %6.0f s %6i / %-6i bytes» % (</p>
<p>p*100, elapsed, est_t, dldsize, size)</p>
<p>else:</p>
<p>print "%6i / %-6i bytes» % (dldsize, size)</p>
<p>urllib.urlretrieve(URL, FILE, progress)</p>
<p>download(URL, FILE)</p>
<p>Эта программа выведет примерно следующее (процент от полного объема закачки, прошедшие секунды, предполагаемое оставшееся время, закачанные байты, полное количество байтов):</p>
<p>Листинг</p>
<p>0.00 % 1 s 0 s 0 / 6952309 bytes</p>
<p>0.12 % 5 s 3941 s 8192 / 6952309 bytes</p>
<p>0.24 % 7 s 3132 s 16384 / 6952309 bytes</p>
<p>0.35 % 10 s 2864 s 24576 / 6952309 bytes</p>
<p>0.47 % 12 s 2631 s 32768 / 6952309 bytes</p>
<p>0.59 % 15 s 2570 s 40960 / 6952309 bytes</p>
<p>0.71 % 18 s 2526 s 49152 / 6952309 bytes</p>
<p>0.82 % 20 s 2441 s 57344 / 6952309 bytes</p>
<p>…</p>
<p>Функции для анализа URL</p>
<p>Согласно документу RFC 2396 URL должен строиться по следующему шаблону:</p>
<p>Листинг</p>
<p>scheme://netloc/path;parameters?query#fragment</p>
<p>где</p>
<p>Листинг</p>
<p>scheme</p>
<p>Адресная схема. Например: http, ftp, gopher.</p>
<p>Листинг</p>
<p>netloc</p>
<p>Местонахождение в сети.</p>
<p>Листинг</p>
<p>path</p>
<p>Путь к ресурсу.</p>
<p>Листинг</p>
<p>params</p>
<p>Параметры.</p>
<p>Листинг</p>
<p>query</p>
<p>Строка запроса.</p>
<p>Листинг</p>
<p>frag</p>
<p>Идентификатор фрагмента.</p>
<p>Одна из функций уже использовалась для формирования URL — urllib.urlencode(). Кроме нее в модуле urllib имеются и другие функции:</p>
<p>Листинг</p>
<p>quote(s, safe='/')</p>
<p>Функция экранирует символы в URL, чтобы их можно было отправлять на web–сервер. Она предназначена для экранирования пути к ресурсу, поэтому оставляет '/' как есть. Например:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; urllib.quote(«rnd@onego.ru»)</p>
<p>'rnd%40onego.ru'</p>
<p>&gt;&gt;&gt; urllib.quote(«a = b + c»)</p>
<p>'a%20%3D%20b%20%2B%20c'</p>
<p>&gt;&gt;&gt; urllib.quote(«0/1/1»)</p>
<p>'0/1/1'</p>
<p>&gt;&gt;&gt; urllib.quote(«0/1/1», safe="")</p>
<p>'0%2F1%2F1'</p>
<p>quote_plus(s, safe='')</p>
<p>Функция экранирует некоторые символы в URL (в строке запроса), чтобы их можно было отправлять на web–сервер. Аналогична quote(), но заменяет пробелы на плюсы.</p>
<p>Листинг</p>
<p>unquote(s)</p>
<p>Преобразование, обратное quote_plus(). Пример:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; urllib.unquote('a%20%3D%20b%20%2B%20c')</p>
<p>'a = b + c'</p>
<p>unquote_plus(s)</p>
<p>Преобразование, обратное quote_plus(). Пример:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; urllib.unquote_plus('a+=+b+%2B+c')</p>
<p>'a = b + c'</p>
<p>Для анализа URL можно использовать функции из модуля urlparse:</p>
<p>Листинг</p>
<p>urlparse(url, scheme='', allow_fragments=1)</p>
<p>Разбирает URL в 6 компонентов (сохраняя экранирование символов): scheme://netloc/path;params?query#frag</p>
<p>Листинг</p>
<p>urlsplit(url, scheme='', allow_fragments=1)</p>
<p>Разбирает URL в 6 компонентов (сохраняя экранирование символов): scheme://netloc/path?query#frag</p>
<p>Листинг</p>
<p>urlunparse((scheme, netloc, url, params, query, fragment))</p>
<p>Собирает URL из 6 компонентов.</p>
<p>Листинг</p>
<p>urlunsplit((scheme, netloc, url, query, fragment))</p>
<p>Собирает URL из 5 компонентов.</p>
<p>Пример:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from urlparse import urlsplit, urlunsplit</p>
<p>&gt;&gt;&gt; URL = «http://google.com/search?q=Python»</p>
<p>&gt;&gt;&gt; print urlsplit(URL)</p>
<p>('http', 'google.com', '/search', 'q=Python', '')</p>
<p>&gt;&gt;&gt; print urlunsplit(</p>
<p>… ('http', 'google.com', '/search', 'q=Python', ''))</p>
<p>http://google.com/search?q=Python</p>
<p>Еще одна функция того же модуля urlparse позволяет корректно соединить две части URL — базовую и относительную:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import urlparse</p>
<p>&gt;&gt;&gt; urlparse.urljoin('http://python.onego.ru', 'itertools.html')</p>
<p>'http://python.onego.ru/itertools.html'</p>
<p>Возможности urllib2</p>
<p>Функциональности модулей urllib и urlparse хватает для большинства задач, которые решают сценарии на Python как web–клиенты. Тем не менее, иногда требуется больше. На этот случай можно использовать модуль для работы с протоколом HTTP — httplib — и создать собственный класс для HTTP–запросов (в лекциях модуль httplib не рассматривается). Однако вполне вероятно, что нужная функциональность уже имеется в модуле urllib2.</p>
<p>Одна из полезных возможностей этих модулей — доступ к web–объектам, требующий авторизации. Ниже будет рассмотрен пример, который не только обеспечит доступ с авторизацией, но и обозначит основную идею модуля urllib2: использование обработчиков (handlers), каждый из которых решает узкую специфическую задачу.</p>
<p>Следующий пример показывает, как создать собственный открыватель URL с помощью модуля urllib2 (этот пример взят из документации по Python):</p>
<p>Листинг</p>
<p>import urllib2</p>
<p># Подготовка идентификационных данных</p>
<p>authinfo = urllib2.HTTPBasicAuthHandler()</p>
<p>authinfo.add_password('My page', 'localhost', 'user1', 'secret')</p>
<p># Доступ через прокси</p>
<p>proxy_support = urllib2.ProxyHandler({'http' : 'http://localhost:8080'})</p>
<p># Создание нового открывателя с указанными обработчиками</p>
<p>opener = urllib2.build_opener(proxy_support,</p>
<p>authinfo,</p>
<p>urllib2.CacheFTPHandler)</p>
<p># Установка поля с названием клиента</p>
<p>opener.addheaders = [('User–agent', 'Mozilla/5.0')]</p>
<p># Установка нового открывателя по умолчанию</p>
<p>urllib2.install_opener(opener)</p>
<p># Использование открывателя</p>
<p>f = urllib2.urlopen('http://localhost/mywebdir/')</p>
<p>print f.read()[:100]</p>
<p>В этом примере получен доступ к странице, которую охраняет mod_python (см. предыдущую лекцию). Первый аргумент при вызове метода add_password() задает область действия (realm) идентификационных данных (он задан директивой AuthName «My page» в конфигурации web–сервера). Остальные параметры достаточно понятны: имя хоста, на который нужно получить доступ, имя пользователя и его пароль. Разумеется, для корректной работы примера нужно, чтобы на локальном web–сервере был каталог, требующий авторизации.</p>
<p>В данном примере явным образом затронуты всего три обработчика: HTTPBasicAuthHandler, ProxyHandler и CacheFTPHandler. В модуле urllib2 их более десятка, назначение каждого можно узнать из документации к используемой версии Python. Есть и специальный класс для управления открывателями: OpenerDirector. Именно его экземпляр создала функция urllib2.build_opener().</p>
<p>Модуль urllib2 имеет и специальный класс для воплощения запроса на открытие URL. Называется этот класс urllib2.Request. Его экземпляр содержит состояние запроса. Следующий пример показывает, как получить доступ к каталогу с авторизацией, используя добавление заголовка в HTTP–запрос:</p>
<p>Листинг</p>
<p>import urllib2, base64</p>
<p>req = urllib2.Request('http://localhost/mywebdir')</p>
<p>b64 = base64.encodestring('user1:secret').strip()</p>
<p>req.add_header('Authorization', 'Basic %s' % b64)</p>
<p>req.add_header('User–agent', 'Mozilla/5.0')</p>
<p>f = urllib2.urlopen(req)</p>
<p>print f.read()[:100]</p>
<p>Как видно из этого примера, ничего загадочного в авторизации нет: web–клиент вносит (закодированные base64) идентификационные данные в поле Authorization HTTP–запроса.</p>
<p>Примечание:</p>
<p>Приведенные два примера почти эквивалентны, только во втором примере прокси–сервер не назначен явно.</p>
<p>XML–RPC сервер</p>
<p>До сих пор высокоуровневые протоколы рассматривались с точки зрения клиента. Не менее просто создавать на Python и их серверные части. Для иллюстрации того, как разработать программу на Python, реализующую сервер, был выбран протокол XML–RPC. Несмотря на свое название, конечному пользователю необязательно знать XML (об этом языке разметки говорилось на одной из предыдущих лекций), так как он скрыт от него. Сокращение RPC (Remote Procedure Call, вызов удаленной процедуры) объясняет суть дела: с помощью XML–RPC можно вызывать процедуры на удаленном хосте. Причем при помощи XML–RPC можно абстрагироваться от конкретного языка программирования за счет использования общепринятых типов данных (строки, числа, логические значения и т.п.). В языке Python вызов удаленной функции по синтаксису ничем не отличается от вызова обычной функции:</p>
<p>Листинг</p>
<p>import xmlrpclib</p>
<p># Установить соединение</p>
<p>req = xmlrpclib.ServerProxy(«http://localhost:8000»)</p>
<p>try:</p>
<p># Вызвать удаленную функцию</p>
<p>print req.add(1, 3)</p>
<p>except xmlrpclib.Error, v:</p>
<p>print «ERROR»,</p>
<p>А вот как выглядит XML–RPC–сервер (для того чтобы попробовать пример выше, необходимо сначала запустить сервер):</p>
<p>Листинг</p>
<p>from SimpleXMLRPCServer import SimpleXMLRPCServer</p>
<p>srv = SimpleXMLRPCServer((«localhost», 8000)) # Запустить сервер</p>
<p>srv.register_function(pow) # Зарегистрировать функцию</p>
<p>srv.register_function(lambda x,y: x+y, 'add') # И еще одну</p>
<p>srv.serve_forever() # Обслуживать запросы</p>
<p>С помощью XML–RPC (а этот протокол достаточно «легковесный» среди других подобных протоколов) приложения могут общаться друг с другом на понятном им языке вызова функций с параметрами основных общепринятых типов и такими же возвращаемыми значениями. Преимуществом же Python является удобный синтаксис вызова удаленных функций.</p>
<p>Внимание!</p>
<p>Разумеется, это только пример. При реальном использовании необходимо позаботиться, чтобы XML–RPC сервер отвечал требованиям безопасности. Кроме того, сервер лучше делать многопоточным, чтобы он мог обрабатывать несколько потоков одновременно. Для многопоточности (она будет обсуждаться в отдельной лекции) не нужно многое переделывать: достаточно определить свой класс, скажем, ThreadingXMLRPCServer, в котором вместо SocketServer.TCPServer использовать SocketServer.ThreadingTCPServer. Это предлагается в качестве упражнения. Наводящий вопрос: где находится определение класса SimpleXMLRPCServer?</p>
<p>Заключение</p>
<p>В этой лекции на практических примерах и сведениях из документации были показаны возможности, которые дает стандартный Python для работы в Интернете. Из сценария на Python можно управлять соединением на уровне сокетов, а также использовать модули для конкретного сетевого протокола или набора протоколов. Для работы с сокетами служит модуль socket, а модули для высокоуровневых протоколов имеют такие названия как smtplib, poplib, httplib и т.п. Для работы с системой WWW можно использовать модули urllib, urllib2, urlparse. Указанные модули рассмотрены с точки зрения типичного применения. Для решения нестандартных задач лучше обратиться к другим источникам: документации, исходному коду модулей, поиску в Интернете. В этой лекции говорилось и о серверной составляющей высокоуровневых сетевых протоколов. В качестве примера приведена клиент–серверная пара для протокола XML–RPC. Этот протокол создан на основе HTTP, но служит специальной цели.</p>
<center><div align="center"></div></center>





