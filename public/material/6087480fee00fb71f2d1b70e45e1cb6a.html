# encoding: windows-1251







<p>В данной лекции рассматривается пакет Numeric для осуществления численных расчетов и выполнения матричных вычислений, приводится обзор других пакетов для научных вычислений.</p>
<p>Numeric Python — это несколько модулей для вычислений с многомерными массивами, необходимых для многих численных приложений. Модуль Numeric вносит в Python возможности таких пакетов и систем как MatLab, Octave (аналог MatLab), APL, J, S+, IDL. Пользователи найдут Numeric достаточно простым и удобным. Стоит заметить, что некоторые синтаксические возможности Python (связанные с использованием срезов) были специально разработаны для Numeric.</p>
<p>Numeric Python имеет средства для:</p>
<p>матричных вычислений LinearAlgebra;</p>
<p>быстрого преобразования Фурье FFT;</p>
<p>работы с недостающими экспериментальными данными MA;</p>
<p>статистического моделирования RNG;</p>
<p>эмуляции базовых функций программы MatLab.</p>
<p>Модуль Numeric</p>
<p>Модуль Numeric определяет полноценный тип–массив и содержит большое число функций для операций с массивами. Массив — это набор однородных элементов, доступных по индексам. Массивы модуля Numeric могут быть многомерными, то есть иметь более одной размерности.</p>
<p>Создание массива</p>
<p>Для создания массива можно использовать функцию array() с указанием содержимого массива (в виде вложенных списков) и типа. Функция array() делает копию, если ее аргумент — массив. Функция asarray() работает аналогично, но не создает нового массива, когда ее аргумент уже является массивом:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from Numeric import *</p>
<p>&gt;&gt;&gt; print array([[1, 2], [3, 4], [5, 6]])</p>
<p>[[1 2]</p>
<p>[3 4]</p>
<p>[5 6]]</p>
<p>&gt;&gt;&gt; print array([[1, 2, 3], [4, 5, 6]], Float)</p>
<p>[[ 1. 2. 3.]</p>
<p>[ 4. 5. 6.]]</p>
<p>&gt;&gt;&gt; print array([78, 85, 77, 69, 82, 73, 67], 'c')</p>
<p>[N U M E R I C]</p>
<p>В качестве элементов массива можно использовать следующие типы: Int8–Int32, UnsignedInt8–UnsignedInt32, Float8–Float64, Complex8–Complex64 и PyObject. Числа 8, 16, 32 и 64 показывают количество битов для хранения величины. Типы Int, UnsignedInteger, Float и Complex соответствуют наибольшим принятым на данной платформе значениям. В массиве можно также хранить ссылки на произвольные объекты.</p>
<p>Количество размерностей и длина массива по каждой оси называются формой массива (shape). Доступ к форме массива реализуется через атрибут shape:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from Numeric import *</p>
<p>&gt;&gt;&gt; a = array(range(15), Int)</p>
<p>&gt;&gt;&gt; print a.shape</p>
<p>(15,)</p>
<p>&gt;&gt;&gt; print a</p>
<p>[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]</p>
<p>&gt;&gt;&gt; a.shape = (3, 5)</p>
<p>&gt;&gt;&gt; print a.shape</p>
<p>(3, 5)</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[ 0 1 2 3 4]</p>
<p>[ 5 6 7 8 9]</p>
<p>[10 11 12 13 14]]</p>
<p>Методы массивов</p>
<p>Придать нужную форму массиву можно функцией Numeric.reshape(). Эта функция сразу создает объект–массив нужной формы из последовательности.</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; print Numeric.reshape(«абракадабр», (5, — 1))</p>
<p>[[а б]</p>
<p>[р а]</p>
<p>[к а]</p>
<p>[д а]</p>
<p>[б р]]</p>
<p>В этом примере–1 в указании формы говорит о том, что соответствующее значение можно вычислить. Общее количество элементов массива известно (10), поэтому длину вдоль одной из размерностей задавать не обязательно.</p>
<p>Через атрибут flat можно получить одномерное представление массива:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a = array([[1, 2], [3, 4]])</p>
<p>&gt;&gt;&gt; b = a.flat</p>
<p>&gt;&gt;&gt; b</p>
<p>array([1, 2, 3, 4])</p>
<p>&gt;&gt;&gt; b[0] = 9</p>
<p>&gt;&gt;&gt; b</p>
<p>array([9, 2, 3, 4])</p>
<p>&gt;&gt;&gt; a</p>
<p>array([[9, 2],</p>
<p>[3, 4]])</p>
<p>Следует заметить, что это новый вид того же массива, поэтому присваивание значений его элементам приводит к изменениям в исходном массиве.</p>
<p>Функция Numeric.resize()похожа на Numeric.reshape, но может подстраивать число элементов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print Numeric.resize(«NUMERIC», (3, 2))</p>
<p>[[N U]</p>
<p>[M E]</p>
<p>[R I]]</p>
<p>&gt;&gt;&gt; print Numeric.resize(«NUMERIC», (3, 4))</p>
<p>[[N U M E]</p>
<p>[R I C N]</p>
<p>[U M E R]]</p>
<p>Функция Numeric.zeros() порождает массив из одних нулей, а Numeric.ones() - из одних единиц. Единичную матрицу можно получить с помощью функции Numeric.identity(n):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print Numeric.zeros((2,3))</p>
<p>[[0 0 0]</p>
<p>[0 0 0]]</p>
<p>&gt;&gt;&gt; print Numeric.ones((2,3))</p>
<p>[[1 1 1]</p>
<p>[1 1 1]]</p>
<p>&gt;&gt;&gt; print Numeric.identity(4)</p>
<p>[[1 0 0 0]</p>
<p>[0 1 0 0]</p>
<p>[0 0 1 0]</p>
<p>[0 0 0 1]]</p>
<p>Для копирования массивов можно использовать метод copy():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; a = Numeric.arrayrange(9)</p>
<p>&gt;&gt;&gt; a.shape = (3, 3)</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[0 1 2]</p>
<p>[3 4 5]</p>
<p>[6 7 8]]</p>
<p>&gt;&gt;&gt; a1 = a.copy()</p>
<p>&gt;&gt;&gt; a1[0, 1] = -1 # операция над копией</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[0 1 2]</p>
<p>[3 4 5]</p>
<p>[6 7 8]]</p>
<p>Массив можно превратить обратно в список с помощью метода tolist():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a.tolist()</p>
<p>[[0, 1, 2], [3, 4, 5], [6, 7, 8]]</p>
<p>Срезы</p>
<p>Объекты–массивы Numeric используют расширенный синтаксис выделения среза. Следующие примеры иллюстрируют различные варианты записи срезов. Функция Numeric.arrayrange() является аналогом range() для массивов.</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; a = Numeric.arrayrange(24) + 1</p>
<p>&gt;&gt;&gt; a.shape = (4, 6)</p>
<p>&gt;&gt;&gt; print a # исходный массив</p>
<p>[[ 1 2 3 4 5 6]</p>
<p>[ 7 8 9 10 11 12]</p>
<p>[13 14 15 16 17 18]</p>
<p>[19 20 21 22 23 24]]</p>
<p>&gt;&gt;&gt; print a[1,2] # элемент 1,2</p>
<p>9</p>
<p>&gt;&gt;&gt; print a[1,:] # строка 1</p>
<p>[ 7 8 9 10 11 12]</p>
<p>&gt;&gt;&gt; print a[1] # тоже строка 1</p>
<p>[ 7 8 9 10 11 12]</p>
<p>&gt;&gt;&gt; print a[:,1] # столбец 1</p>
<p>[ 2 8 14 20]</p>
<p>&gt;&gt;&gt; print a[-2,:] # предпоследняя строка</p>
<p>[13 14 15 16 17 18]</p>
<p>&gt;&gt;&gt; print a[0:2,1:3] # окно 2x2</p>
<p>[[2 3]</p>
<p>[8 9]]</p>
<p>&gt;&gt;&gt; print a[1,::3] # каждый третий элемент строки 1</p>
<p>[ 7 10]</p>
<p>&gt;&gt;&gt; print a[:,:: — 1] # элементы строк в обратном порядке</p>
<p>[[ 6 5 4 3 2 1]</p>
<p>[12 11 10 9 8 7]</p>
<p>[18 17 16 15 14 13]</p>
<p>[24 23 22 21 20 19]]</p>
<p>Срез не копирует массив (как это имеет место со списками), а дает доступ к некоторой части массива. Далее в примере меняется на 0 каждый третий элемент строки 1:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a[1,::3] = Numeric.array([0,0])</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[ 1 2 3 4 5 6]</p>
<p>[ 0 8 9 0 11 12]</p>
<p>[13 14 15 16 17 18]</p>
<p>[19 20 21 22 23 24]]</p>
<p>В следующих примерах находит применение достаточно редкая синтаксическая конструкция: срез с многоточием (Ellipsis). Многоточие ставится для указания произвольного числа пропущенных размерностей (:,:,…,:):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; a = Numeric.arrayrange(24) + 1</p>
<p>&gt;&gt;&gt; a.shape = (2,2,2,3)</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[[[ 1 2 3]</p>
<p>[ 4 5 6]]</p>
<p>[[ 7 8 9]</p>
<p>[10 11 12]]]</p>
<p>[[[13 14 15]</p>
<p>[16 17 18]]</p>
<p>[[19 20 21]</p>
<p>[22 23 24]]]]</p>
<p>&gt;&gt;&gt; print a[0,…] # 0–й блок</p>
<p>[[[ 1 2 3]</p>
<p>[ 4 5 6]]</p>
<p>[[ 7 8 9]</p>
<p>[10 11 12]]]</p>
<p>&gt;&gt;&gt; print a[0,:,:,0] # срез по первой и последней размерностям</p>
<p>[[ 1 4]</p>
<p>[ 7 10]]</p>
<p>&gt;&gt;&gt; print a[0,…,0] # то же, но с использованием многоточия</p>
<p>[[ 1 4]</p>
<p>[ 7 10]]</p>
<p>Универсальные функции</p>
<p>Модуль Numeric определяет набор функций для применения к элементам массива. Функции применимы не только к массивам, но и к последовательностям (к сожалению, итераторы пока не поддерживаются). В результате получаются массивы.</p>
<p>Функция Описание</p>
<p>add(x, y), subtract(x, y) Сложение и вычитание</p>
<p>multiply(x, y), divide(x, y) Умножение и деление</p>
<p>remainder(x, y), fmod(x, y) Получение остатка от деления (для целых чисел и чисел с плавающей запятой)</p>
<p>power(x) Возведение в степень</p>
<p>sqrt(x) Извлечение корня квадратного</p>
<p>negative(x), absolute(x), fabs(x) Смена знака и абсолютное значение</p>
<p>ceil(x), floor(x) Наименьшее (наибольшее) целое, большее (меньшее) или равное аргументу</p>
<p>hypot(x, y) Длина гипотенузы (даны длины двух катетов)</p>
<p>sin(x), cos(x), tan(x) Тригонометрические функции</p>
<p>arcsin(x), arccos(x), arctan(x) Обратные тригонометрические функции</p>
<p>arctan2(x, y) Арктангенс от частного аргумента</p>
<p>sinh(x), cosh(x), tanh(x) Гиперболические функции</p>
<p>arcsinh(x), arccosh(x), arctanh(x) Обратные гиперболические функции</p>
<p>exp(x) Экспонента (ex)</p>
<p>log(x), log10(x) Натуральный и десятичный логарифмы</p>
<p>maximum(x, y), minimum(x, y) Максимум и минимум</p>
<p>conjugate(x) Сопряжение (для комплексных чисел)</p>
<p>equal(x, y), not_equal(x, y) Равно, не равно</p>
<p>greater(x, y), greater_equal(x, y) Больше, больше или равно</p>
<p>less(x, y), less_equal(x, y) Меньше, меньше или равно</p>
<p>logical_and(x, y), logical_or(x, y) Логические И, ИЛИ</p>
<p>logical_xor(x, y) Логическое исключающее ИЛИ</p>
<p>logical_not(x) Логические НЕ</p>
<p>bitwise_and(x, y), bitwise_or(x, y) Побитовые И, ИЛИ</p>
<p>bitwise_xor(x, y) Побитовое исключающее ИЛИ</p>
<p>invert(x) Побитовая инверсия</p>
<p>left_shift(x, n), right_shift(x, n) Побитовые сдвиги влево и вправо на n битов</p>
<p>Перечисленные функции являются объектами типа ufunc и применяются к массивам поэлементно. Эти функции имеют специальные методы:</p>
<p>accumulate() Аккумулирование результата.</p>
<p>outer() Внешнее «произведение».</p>
<p>reduce() Сокращение.</p>
<p>reduceat() Сокращение в заданных точках.</p>
<p>Пример с функцией add() позволяет понять смысл универсальной функции и ее методов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from Numeric import add</p>
<p>&gt;&gt;&gt; add([[1, 2], [3, 4]], [[1, 0], [0, 1]])</p>
<p>array([[2, 2],</p>
<p>[3, 5]])</p>
<p>&gt;&gt;&gt; add([[1, 2], [3, 4]], [1, 0])</p>
<p>array([[2, 2],</p>
<p>[4, 4]])</p>
<p>&gt;&gt;&gt; add([[1, 2], [3, 4]], 1)</p>
<p>array([[2, 3],</p>
<p>[4, 5]])</p>
<p>&gt;&gt;&gt; add.reduce([1, 2, 3, 4]) # т.е. 1+2+3+4</p>
<p>10</p>
<p>&gt;&gt;&gt; add.reduce([[1, 2], [3, 4]], 0) # т.е. [1+3 2+4]</p>
<p>array([4, 6])</p>
<p>&gt;&gt;&gt; add.reduce([[1, 2], [3, 4]], 1) # т.е. [1+2 3+4]</p>
<p>array([3, 7])</p>
<p>&gt;&gt;&gt; add.accumulate([1, 2, 3, 4]) # т.е. [1 1+2 1+2+3 1+2+3+4]</p>
<p>array([ 1, 3, 6, 10])</p>
<p>&gt;&gt;&gt; add.reduceat(range(10), [0, 3, 6]) # т.е. [0+1+2 3+4+5 6+7+8+9]</p>
<p>array([ 3, 12, 30])</p>
<p>&gt;&gt;&gt; add.outer([1,2], [3,4]) # т.е. [[1+3 1+4] [2+3 2+4]]</p>
<p>array([[4, 5],</p>
<p>[5, 6]])</p>
<p>Методы accumulate(), reduce() и reduceat() принимают необязательный аргумент — номер размерности, используемой для соответствующего действия. По умолчанию применяется нулевая размерность.</p>
<p>Универсальные функции, помимо одного или двух необходимых параметров, позволяют задавать и еще один аргумент, для приема результата функции. Тип третьего аргумента должен строго соответствовать типу результата. Например, функция sqrt() даже от целых чисел имеет тип Float.</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from Numeric import array, sqrt, Float</p>
<p>&gt;&gt;&gt; a = array([0, 1, 2])</p>
<p>&gt;&gt;&gt; r = array([0, 0, 0], Float)</p>
<p>&gt;&gt;&gt; sqrt(a, r)</p>
<p>array([ 0. , 1. , 1.41421356])</p>
<p>&gt;&gt;&gt; print r</p>
<p>[ 0. 1. 1.41421356]</p>
<p>Предупреждение:</p>
<p>Не следует использовать в качестве приемника результата массив, который фигурирует в предыдущих аргументах функции, так как при этом результат может быть испорчен. Следующий пример показывает именно такой вариант:</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; m = Numeric.array([0, 0, 0, 1, 0, 0, 0, 0])</p>
<p>&gt;&gt;&gt; add(m[: — 1], m[1:], m[1:])</p>
<p>array([0, 0, 1, 1, 1, 1, 1])В таких неоднозначных случаях необходимо использовать промежуточный массив.</p>
<p>Функции модуля Numeric</p>
<p>Следующие функции модуля Numeric являются краткой записью некоторых наиболее употребительных сочетаний функций и методов:</p>
<p>Функция Аналог функции</p>
<p>sum(a, axis) add.reduce(a, axis)</p>
<p>cumsum(a, axis) add.accumulate(a, axis)</p>
<p>product(a, axis) multiply.reduce(a, axis)</p>
<p>cumproduct(a, axis) multiply.accumulate(a, axis)</p>
<p>alltrue(a, axis) logical_and.reduce(a, axis)</p>
<p>sometrue(a, axis) logical_or.reduce(a, axis)</p>
<p>Примечание:</p>
<p>Параметр axis указывает размерность.</p>
<p>Функции для работы с массивами</p>
<p>Функций достаточно много, поэтому подробно будут рассмотрены только две из них, а остальные сведены в таблицу.</p>
<p>Функция Numeric.take()</p>
<p>Функция Numeric.take() позволяет взять часть массива по заданным на определенном измерении индексам. По умолчанию номер измерения (третий аргумент) равен нулю.</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; a = Numeric.reshape(Numeric.arrayrange(25), (5, 5))</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[ 0 1 2 3 4]</p>
<p>[ 5 6 7 8 9]</p>
<p>[10 11 12 13 14]</p>
<p>[15 16 17 18 19]</p>
<p>[20 21 22 23 24]]</p>
<p>&gt;&gt;&gt; print Numeric.take(a, [1], 0)</p>
<p>[ [5 6 7 8 9]]</p>
<p>&gt;&gt;&gt; print Numeric.take(a, [1], 1)</p>
<p>[[ 1]</p>
<p>[ 6]</p>
<p>[11]</p>
<p>[16]</p>
<p>[21]]</p>
<p>&gt;&gt;&gt; print Numeric.take(a, [[1,2],[3,4]])</p>
<p>[[[ 5 6 7 8 9]</p>
<p>[10 11 12 13 14]]</p>
<p>[[15 16 17 18 19]</p>
<p>[20 21 22 23 24]]]</p>
<p>В отличие от среза, функция Numeric.take() сохраняет размерность массива, если конечно, структура заданных индексов одномерна. Результат Numeric.take(a, [[1,2],[3,4]]) показывает, что взятые по индексам части помещаются в массив со структурой самих индексов, как если бы вместо 1 было написано [5 6 7 8 9], а вместо 2 — [10 11 12 13 14] и т.д.</p>
<p>Функции Numeric.diagonal() и Numeric.trace()</p>
<p>Функция Numeric.diagonal() возвращает диагональ матрицы. Она имеет следующие аргументы:</p>
<p>a Исходный массив.</p>
<p>offset Смещение вправо от «главной» диагонали (по умолчанию 0).</p>
<p>axis1 Первое из измерений, на которых берется диагональ (по умолчанию 0).</p>
<p>axis2 Второе измерение, образующее вместе с первым плоскость, на которой и берется диагональ. По умолчанию axis2=1.</p>
<p>Функция Numeric.trace() (для вычисления следа матрицы) имеет те же аргументы, но суммирует элементы на диагонали. В примере ниже рассмотрены обе эти функции:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric</p>
<p>&gt;&gt;&gt; a = Numeric.reshape(Numeric.arrayrange(16), (4, 4))</p>
<p>&gt;&gt;&gt; print a</p>
<p>[[ 0 1 2 3]</p>
<p>[ 4 5 6 7]</p>
<p>[ 8 9 10 11]</p>
<p>[12 13 14 15]]</p>
<p>&gt;&gt;&gt; for i in range(-3, 4):</p>
<p>… print «Sum», Numeric.diagonal(a, i), "=", Numeric.trace(a, i)</p>
<p>…</p>
<p>Sum [12] = 12</p>
<p>Sum [ 8 13] = 21</p>
<p>Sum [ 4 9 14] = 27</p>
<p>Sum [ 0 5 10 15] = 30</p>
<p>Sum [ 1 6 11] = 18</p>
<p>Sum [2 7] = 9</p>
<p>Sum [3] = 3</p>
<p>Функция Numeric.choose()</p>
<p>Эта функция использует один массив с целыми числами от 0 до n для выбора значения из одного из заданных массивов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a = Numeric.identity(4)</p>
<p>&gt;&gt;&gt; b0 = Numeric.reshape(Numeric.arrayrange(16), (4, 4))</p>
<p>&gt;&gt;&gt; b1 = -Numeric.reshape(Numeric.arrayrange(16), (4, 4))</p>
<p>&gt;&gt;&gt; print Numeric.choose(a, (b0, b1))</p>
<p>[[ 0 1 2 3]</p>
<p>[ 4 -5 6 7]</p>
<p>[ 8 9–10 11]</p>
<p>[ 12 13 14–15]]</p>
<p>Свод функций модуля Numeric</p>
<p>Следующая таблица приводит описания функций модуля Numeric.</p>
<p>Функция и ее аргументы Назначение функции</p>
<p>allclose(a, b[, eps[, A]]) Сравнение a и b с заданными относительными eps и абсолютными A погрешностями. По умолчанию eps равен 1.0e–1, а A = 1.0e–8.</p>
<p>alltrue(a[, axis]) Логическое И по всей оси axis массива a</p>
<p>argmax(a[, axis]) Индекс максимального значения в массиве по заданному измерению axis</p>
<p>argmin(a[, axis]) Индекс минимального значения в массиве по заданному измерению axis</p>
<p>argsort(a[, axis]) Индексы отсортированного массива, такие, что take(a,argsort(a, axis),axis) дает отсортированный массив a, как если бы было выполнено sort(a, axis)</p>
<p>array(a[, type]) Создание массива на основе последовательности a данного типа type</p>
<p>arrayrange(start[, stop[, step[, type]]]) Аналог range() для массивов</p>
<p>asarray(a[, type[, savespace]]) То же, что и array(), но не создает новый массив, если a уже является массивом.</p>
<p>choose(a, (b0,…,bn)) Создает массив на основе элементов, взятых по индексам из a (индексы от 0 до n включительно). Формы массивов a, b1, …, bn должны совпадать</p>
<p>clip(a, a_min, a_max) Обрубает значения массива a так, чтобы они находились между значениями из a_min и a_max поэлементно</p>
<p>compress(cond, a[, axis]) Возвращает массив только из тех элементов массива a, для которых условие cond истинно (не нуль)</p>
<p>concatenate(a[, axis]) Соединение двух массивов (конкатенация) по заданному измерению axis (по умолчанию — по нулевой)</p>
<p>convolve(a, b[, mode]) Свертка двух массивов. Аргумент mode может принимать значения 0, 1 или 2</p>
<p>cross_correlate(a, b[, mode]) Взаимная корреляция двух массивов. Параметр mode может принимать значения 0, 1 или 2</p>
<p>cumproduct(a[, axis]) Произведение по измерению axis массива a с промежуточными результатами</p>
<p>cumsum(a[, axis]) Суммирование с промежуточными результатами</p>
<p>diagonal(a[, k[, axis1[, axis2]]]) Взятие k–й диагонали массива a в плоскости измерений axis1 и axis2</p>
<p>dot(a, b) Внутреннее (матричное) произведение массивов. По определению: innerproduct(a, swapaxes(b, — 1, — 2)), т.е. с переставленными последними измерениями, как и должно быть при перемножении матриц</p>
<p>dump(obj, file) Запись массива a (в двоичном виде) в открытый файловый объект file. Файл должен быть открыт в бинарном режиме. В файл можно записать несколько объектов подряд</p>
<p>dumps(obj) Строка с двоичным представлением объекта obj</p>
<p>fromfunction(f, dims) Строит массив, получая информацию от функции f(), в качестве аргументов которой выступают значения кортежа индексов. Фактически является сокращением для f(*tuple(indices(dims)))</p>
<p>fromstring(s[, count[, type]]) Создание массива на основе бинарных данных, хранящихся в строке</p>
<p>identity(n) Возвращает двумерный массив формы (n, n)</p>
<p>indices(dims[, type]) Возвращает массив индексов заданной длины по каждому измерению с изменением поочередно по каждому изменению. Например, indices([2, 2])[1] дает двумерный массив [[0, 1], [0, 1]].</p>
<p>innerproduct(a, b) Внутреннее произведение двух массивов (по общему измерению). Для успешной операции a.shape[-1] должен быть равен b.shape[-1]. Форма результата будет a.shape[: — 1] + b.shape[: — 1]. Элементы пропадающего измерения попарно умножаются и получающиеся произведения суммируются</p>
<p>load(file) Чтение массива из файла file. Файл должен быть открыт в бинарном режиме</p>
<p>loads(s) Возвращает объект, соответствующий бинарному представлению, заданному в строке</p>
<p>nonzero(a) Возвращает индексы ненулевых элементов одномерного массива</p>
<p>ones(shape[, type]) Массив из единиц заданной формы shape и обозначения типа type</p>
<p>outerproduct(a, b) Внешнее произведение a и b</p>
<p>product(a[, axis]) Произведение по измерению axis массива a</p>
<p>put(a, indices, b) Присваивание частям массива, a[n] = b[n] для всех индексов indices</p>
<p>putmask(a, mask, b) Присваивание a элементов из b, для которых маска mask имеет значение истина</p>
<p>ravel(a) Превращение массива в одномерный. Аналогично reshape(a, (-1,))</p>
<p>repeat(a, n[, axis]) Повторяет элементы массива a n раз по измерению axis</p>
<p>reshape(a, shape) Возвращает массив нужной формы (нового массива не создает). Количество элементов в исходном и новом массивах должно совпадать</p>
<p>resize(a, shape) Возвращает массив с произвольной новой формой shape. Размер исходного массива не важен</p>
<p>searchsorted(a, i) Для каждого элемента из i найти место в массиве a. Массив a должен быть одномерным и отсортированным. Результат имеет форму массива i</p>
<p>shape(a) Возвращает форму массива a</p>
<p>sometrue(a[, axis]) Логическое ИЛИ по всему измерению axis массива a</p>
<p>sort(a[, axis]) Сортировка элементов массива по заданному измерению</p>
<p>sum(a[, axis]) Суммирование по измерению axis массива a</p>
<p>swapaxes(a, axis1, axis1) Смена измерений (частный случай транспонирования)</p>
<p>take(a, indices[, axis]) Выбор частей массива a на основе индексов indices по измерению axis</p>
<p>trace(a[, k[, axis1[, axis2]]]) Сумма элементов вдоль диагонали, то есть add.reduce(diagonal(a, k, axis1, axis2))</p>
<p>transpose(a[, axes]) Перестановка измерений в соответствии с axes, либо, если axes не заданы — расположение их в обратном порядке</p>
<p>where(cond, a1, a2) Выбор элементов на основании условия cond из a1 (если не нуль) и a2 (при нуле) поэлементно. Равносилен choose(not_equal(cond, 0), (y, x)). Формы массивов–аргументов a1 и a2 должны совпадать</p>
<p>zeros(shape[, type]) Массив из нулей заданной формы shape и обозначения типа type</p>
<p>В этой таблице в качестве обозначения типа type можно указывать рассмотренные выше константы: Int, Float и т.п.</p>
<p>Модуль Numeric также определяет константы e (число e) и pi (число пи).</p>
<p>Модуль LinearAlgebra</p>
<p>Модуль LinearAlgebra содержит алгоритмы линейной алгебры, в частности нахождение определителя матрицы, решений системы линейных уравнений, обращение матрицы, нахождение собственных чисел и собственных векторов матрицы, разложение матрицы на множители: Холецкого, сингулярное, метод наименьших квадратов.</p>
<p>Функция LinearAlgebra.determinant() находит определитель матрицы:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric, LinearAlgebra</p>
<p>&gt;&gt;&gt; print LinearAlgebra.determinant(</p>
<p>… Numeric.array([[1, — 2],</p>
<p>… [1, 5]]))</p>
<p>7</p>
<p>Функция LinearAlgebra.solve_linear_equations() решает линейные уравнения вида ax=b по заданным аргументам a и b:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import Numeric, LinearAlgebra</p>
<p>&gt;&gt;&gt; a = Numeric.array([[1.0, 2.0], [0.0, 1.0]])</p>
<p>&gt;&gt;&gt; b = Numeric.array([1.2, 1.5])</p>
<p>&gt;&gt;&gt; x = LinearAlgebra.solve_linear_equations(a, b)</p>
<p>&gt;&gt;&gt; print «x =", x</p>
<p>x = [-1.8 1.5]</p>
<p>&gt;&gt;&gt; print «Проверка:", Numeric.dot(a, x) - b</p>
<p>Проверка: [ 0. 0.]</p>
<p>Когда матрица a имеет нулевой определитель, система имеет не единственное решение и возбуждается исключение LinearAlgebraError:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a = Numeric.array([[1.0, 2.0], [0.5, 1.0]])</p>
<p>&gt;&gt;&gt; x = LinearAlgebra.solve_linear_equations(a, b)</p>
<p>Traceback (most recent call last):</p>
<p>File "&lt;stdin&gt;", line 1, in ?</p>
<p>File "/usr/local/lib/python2.3/site–packages/Numeric/LinearAlgebra.py», line 98,</p>
<p>in solve_linear_equations raise LinAlgError, 'Singular matrix'</p>
<p>LinearAlgebra.LinAlgError: Singular matrix</p>
<p>Функция LinearAlgebra.inverse() находит обратную матрицу. Однако не следует решать линейные уравнения с помощью LinearAlgebra.inverse() умножением на обратную матрицу, так как она определена через LinearAlgebra.solve_linear_equations():</p>
<p>Листинг</p>
<p>def inverse(a):</p>
<p>return solve_linear_equations(a, Numeric.identity(a.shape[0]))</p>
<p>Функция LinearAlgebra.eigenvalues() находит собственные значения матрицы, а LinearAlgebra.eigenvectors() - пару: собственные значения, собственные вектора:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from Numeric import array, dot</p>
<p>&gt;&gt;&gt; from LinearAlgebra import eigenvalues, eigenvectors</p>
<p>&gt;&gt;&gt; a = array([[-5, 2], [2, — 7]])</p>
<p>&gt;&gt;&gt; lmd = eigenvalues(a)</p>
<p>&gt;&gt;&gt; print «Собственные значения:", lmd</p>
<p>Собственные значения: [-3.76393202–8.23606798]</p>
<p>&gt;&gt;&gt; (lmd, v) = eigenvectors(a)</p>
<p>&gt;&gt;&gt; print «Собственные вектора:"</p>
<p>Собственные вектора:</p>
<p>&gt;&gt;&gt; print v</p>
<p>[[ 0.85065081 0.52573111]</p>
<p>[-0.52573111 0.85065081]]</p>
<p>&gt;&gt;&gt; print «Проверка:", dot(a, v[0]) - v[0] * lmd[0]</p>
<p>Проверка: [ -4.44089210e–16 2.22044605e–16]</p>
<p>Проверка показывает, что тождество выполняется с достаточно большой точностью (числа совсем маленькие, практически нули): собственные числа и векторы найдены верно.</p>
<p>Модуль RandomArray</p>
<p>В этом модуле собраны функции для генерации массивов случайных чисел различных распределений и свойств. Их можно применять для математического моделирования.</p>
<p>Функция RandomArray.random() создает массивы из псевдослучайных чисел, равномерно распределенных в интервале (0, 1):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import RandomArray</p>
<p>&gt;&gt;&gt; print RandomArray.random(10) # массив из 10 псевдослучайных чисел</p>
<p>[ 0.28374212 0.19260929 0.07045474 0.30547682 0.10842083 0.14049676</p>
<p>0.01347435 0.37043894 0.47362471 0.37673479]</p>
<p>&gt;&gt;&gt; print RandomArray.random([3,3]) # массив 3x3 из псевдослучайных чисел</p>
<p>[[ 0.53493741 0.44636754 0.20466961]</p>
<p>[ 0.8911635 0.03570878 0.00965272]</p>
<p>[ 0.78490953 0.20674807 0.23657821]]</p>
<p>Функция RandomArray.randint() для получения массива равномерно распределенных чисел из заданного интервала и заданной формы:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print RandomArray.randint(1, 10, [10])</p>
<p>[8 1 9 9 7 5 2 5 3 2]</p>
<p>&gt;&gt;&gt; print RandomArray.randint(1, 10, [10])</p>
<p>[2 2 5 5 7 7 3 4 3 7]</p>
<p>Можно получать и случайные перестановки с помощью RandomArray.permutation():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print RandomArray.permutation(6)</p>
<p>[4 0 1 3 2 5]</p>
<p>&gt;&gt;&gt; print RandomArray.permutation(6)</p>
<p>[1 2 0 3 5 4]</p>
<p>Доступны и другие распределения для получения массива нормально распределенных величин с заданным средним и стандартным отклонением:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print RandomArray.normal(0, 1, 30)</p>
<p>[-1.0944078 1.24862444 0.20415567–0.74283403 0.72461408–0.57834256</p>
<p>0.30957144 0.8682853 1.10942173–0.39661118 1.33383882 1.54818618</p>
<p>0.18814971 0.89728773–0.86146659 0.0184834 -1.46222591–0.78427434</p>
<p>1.09295738–1.09731364 1.34913492–0.75001568–0.11239344 2.73692131</p>
<p>— 0.19881676–0.49245331 1.54091263–1.81212211 0.46522358–0.08338884]</p>
<p>Следующая таблица приводит функции для других распределений:</p>
<p>Функция и ее аргументы Описание</p>
<p>F(dfn, dfd, shape=[]) F–распределение</p>
<p>beta(a, b, shape=[]) Бета–распределение</p>
<p>binomial(trials, p, shape=[]) Биномиальное распределение</p>
<p>chi_square(df, shape=[]) Распределение хи–квадрат</p>
<p>exponential(mean, shape=[]) Экспоненциальное распределение</p>
<p>gamma(a, r, shape=[]) Гамма–распределение</p>
<p>multivariate_normal(mean, cov, shape=[]) Многомерное нормальное распределение</p>
<p>negative_binomial(trials, p, shape=[]) Негативное биномиальное</p>
<p>noncentral_F(dfn, dfd, nconc, shape=[]) Нецентральное F–распределение</p>
<p>noncentral_chi_square(df, nconc, shape=[]) Нецентральное хи–квадрат распределение</p>
<p>normal(mean, std, shape=[]) Нормальное распределение</p>
<p>permutation(n) Случайная перестановка</p>
<p>poisson(mean, shape=[]) Пуассоновское распределение</p>
<p>randint(min, max=None, shape=[]) Случайное целое</p>
<p>random(shape=[]) Равномерное распределение на интервале (0, 1)</p>
<p>random_integers(max, min=1, shape=[]) Случайное целое</p>
<p>standard_normal(shape=[]) Стандартное нормальное распределение</p>
<p>uniform(min, max, shape=[]) Равномерное распределение</p>
<p>Заключение</p>
<p>В этой лекции рассматривался набор модулей для численных вычислений. Модуль Numeric определяет тип многомерный массив и множество функций для работы с массивами. Также были представлены модули для линейной алгебры и моделирования последовательностей случайных чисел различных распределений.</p>
<center><div align="center"></div></center>





