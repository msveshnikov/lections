<p style="text-align:justify"><span style="font-size:20px">Конструкторы и деструкторы являются специализированными формами методов. Используемые в связи с расширенным синтаксисом стандартных процедур New и Dispose конструкторы и деструкторы обладают способностью размещения и удаления динамических объектов. Кроме того, конструкторы имеют возможность выполнить требуемую инициализацию объектов, содержащих виртуальные методы. Как и все другие методы, конструкторы и деструкторы могут наследоваться, а объекты могут содержать любое число конструкторов и деструкторов.</span></p><p style="text-align:justify"><span style="font-size:20px">Конструкторы используются для инициализации вновь созданных объектов. Обычно инициализация основывается на значениях, передаваемых конструктору в качестве параметров. Конструктор не может быть виртуальным, так как механизм диспетчеризации виртуального метода зависит от конструктора, который первым совершил инициализацию объекта.</span></p><p style="text-align:justify"><span style="font-size:20px">Приведем несколько примеров конструкторов:</span></p><p style="text-align:justify"><span style="font-size:20px">constructor Field.Copy(var F: Field);</span></p><p style="text-align:justify"><span style="font-size:20px">begin</span></p><p style="text-align:justify"><span style="font-size:20px">Self:= F;</span></p><p style="text-align:justify"><span style="font-size:20px">end;</span></p><p style="text-align:justify"><span style="font-size:20px">Главным действием конструктора порожденного (дочернего) типа почти всегда является вызов соответствующего конструктора его непосредственного родителя для инициализации наследуемых полей объекта. После выполнения этой процедуры конструктор инициализирует поля объекта, которые принадлежат только порожденному типу.</span></p><p style="text-align:justify"><span style="font-size:20px">Деструкторы являются противоположностями конструкторови используются для очистки объектов после их использования. Обычно очистка состоит в удалении всех полей указателей в объекте.</span></p><p style="text-align:justify"><span style="font-size:20px">Примечание</span></p><p style="text-align:justify"><span style="font-size:20px">Деструктор может быть виртуальным и часто является таковым. Деструктор редко имеет параметры. Приведем несколько примеров деструкторов:</span></p><p style="text-align:justify"><span style="font-size:20px">destructor Field.Done;</span></p><p style="text-align:justify"><span style="font-size:20px">begin</span></p><p style="text-align:justify"><span style="font-size:20px">FreeMem(Name, Length (Name^) + 1);</span></p><p style="text-align:justify"><span style="font-size:20px">end;</span></p><p style="text-align:justify"><span style="font-size:20px">destructor StrField.Done;</span></p><p style="text-align:justify"><span style="font-size:20px">begin</span></p><p style="text-align:justify"><span style="font-size:20px">FreeMem(Value, Len);</span></p><p style="text-align:justify"><span style="font-size:20px">Field.Done;</span></p><p style="text-align:justify"><span style="font-size:20px">end;</span></p><div class="fb2-empty-line" style="font-family: Arial; color: rgb(0, 0, 0); text-align: justify; font-size: 18px; height: 10px; line-height: 27px;">&nbsp;</div><p style="text-align:justify"><span style="font-size:20px">Деструктор дочернего типа, такой как указанный выше TStrField. Done, обычно сначала удаляет введенные в порожденном типе поля указателей, а затем в качестве последнего действия вызывает соответствующий сборщик-деструктор непосредственного родителя для удаления унаследованных полей указателей объекта.</span></p>