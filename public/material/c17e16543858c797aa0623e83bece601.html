# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 9.
Массивы</h2></center>

<p> 

</p>
<p>Лекция посвящена описанию массивов в Java. Массивы издавна
при­сутствуют в языках программирования, поскольку при выполнении многих задач
приходится оперировать целым рядом однотипных значений.

</p>
<p>Массивы в Java — один из ссылочных типов, который, однако, имеет
особенности при инициализации, создании и оперировании со своими значе­ниями.
Наибольшие различия проявляются при преобразовании таких типов. Также
объясняется, почему многомерные массивы в Java можно (и зачастую более правильно) рассматривать как
одномерные. Завершается классификация типов переменных и типов значений,
которые они могут хранить.

</p>
<p>В заключение рассматривается механизм клонирования Java, позволяю­щий в
любом классе описать возможность создания точных копий объектов, порожденных от
него.

</p>
<p> 

</p>
<p>Массивы как тип данных в Java

</p>
<p>В отличие от обычных переменных, которые хранят только одно значение,
массивы (arrays) используются для хранения целого набора зна­чений. Количество значений
в массиве называется его длиной, сами значе­ния — элементами массива. Значений
может не быть вовсе, в этом случае массив считается пустым, а его длина равной
нулю.

</p>
<p>Элементы не имеют имен, доступ к ним осуществляется по номеру индекса.
Если массив имеет длину п, отличную от нуля, то корректными значениями индекса
являются числа от 0 до п-1. Все значения имеют одинаковый тип и говорится, что массив основан на
этом базовом типе. Массивы могут быть основаны как на примитивных типах
(например, для хранения числовых значений 100
измерений), так и на
ссылочных (на­пример, если нужно хранить описание 100
автомобилей в гараже в
виде экземпляров класса Саг).

</p>
<p>Сразу оговоримся, что в Java массив символов char[] и класс String яв­ляются различными типами. Их значения могут легко конвертироваться
ДРУГ в друга с помощью специальных методов, но все же они не относятся к идентичным типам.

</p>
<p>Как уже говорилось, массивы в Java являются объектами (примитив­ных типов в Java всего восемь и их количество не меняется), их тип напря­мую наследуется от
класса Object, поэтому все элементы данного класса Доступны у объектов-массивов.

</p>
<p>Базовый тип также может быть массивом. Таким образом конструи­руется
массив массивов, или многомерный массив.








</p>
<p> 








</p>
<p>-3440




</p>
<p>273








</p>
<p>Работа с любым массивом включает обычные операции, уже описан­ные для
других типов, - объявление, инициализация и т.д. Начнем после­довательно
изучать их в приложении к массивам.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Объявление
массивов

</p>
<p>В качестве примера рассмотрим объявление переменной типа "мас­сив,
основанный на примитивном типе int":

</p>
<p>int а[];

</p>
<p> 

</p>
<p>Как мы видим, сначала указывается базовый тип. Затем идет имя пе­ременной,
а пара квадратных скобок указывает на то, что используемый тип является именно
массивом. Также допустима запись:

</p>
<p> 

</p>
<p>int[] а;

</p>
<p> 

</p>
<p>Количество пар квадратных скобок указывает на размерность масси­ва. Для
многомерных массивов допускается смешанная запись:

</p>
<p> 

</p>
<p>int[] а[];

</p>
<p> 

</p>
<p>Переменная а имеет тип "двумерный массив, основанный на int". Аналогично объявляются массивы с базовым объектным типом:

</p>
<p> 

</p>
<p>Point р,р1[],р2[][];

</p>
<p> 

</p>
<p>Создание переменной типа массив еще не создает экземпляры это­го
массива. Такие переменные имеют объектный тип и хранят ссылки на объекты,
однако изначально имеют значение null (если они являются
по­лями класса; напомним, что локальные переменные необходимо явно
инициализировать). Чтобы создать экземпляр массива, нужно воспользо­ваться
ключевым словом new, после чего указывается тип массива и в квадратных скобках — длина
массива.

</p>
<p> 

</p>
<p>int a[]=new
int[5]; Point[] p = new Point[10];

</p>
<p>Переменная инициализируется ссылкой, указывающей на только что созданный
массив. После его создания можно обращаться к элемен­там, используя ссылку на
массив, далее в квадратных скобках указывает­ся индекс элемента. Индекс
меняется от нуля, пробегая всю длину массИ'

</p>
<p>до максимально допустимого значения, на единицу меньшего длины массива.

</p>
<p>int array[]=new
int[5]; for (int i=0;
i&lt;5; i++) { array[i]=i*i;

</p>
<p>}

</p>
<p>for (int j-0;
j&lt;6; j++) {

</p>
<p>System.out.println(j+"*"+j+"="+array[j]);

</p>
<p>}

</p>
<p>Результатом выполнения
программы будет:

</p>
<p> 

</p>
<p>0*0=0 1*1-1 2*2=4 3*3=9 4*4=16

</p>
<p>И далее появится ошибка времени исполнения, так как индекс пре­высит
максимально возможное для такого массива значение. Проверка, не выходит ли
индекс за допустимые пределы, происходит только во вре­мя исполнения программы,
т.е. компилятор не пытается выявить эту ошибку даже в таких явных случаях, как:

</p>
<p> 

</p>
<p>int i[]=new
int[5];

</p>
<p>i[-2]=0; // ошибка! индекс не может быть отрицательным

</p>
<p>Ошибка возникнет только на
этапе выполнения программы.

</p>
<p>Хотя при создании массива необходимо указывать его длину, это значение
не входит в определение типа массива, важна лишь размерность. Таким образом,
одна переменная может ссылаться на массивы разной длины:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>inti[]=newint[5];

</p>
<p> 

</p>
<p>i=new int[7]; // переменная та же, длина массива другая

</p>
<p>Однако для объекта массива длина обязательно должна указываться ПРИ
создании и уже никак не может быть изменена. В последнем примере *^ Присвоения
переменной ссылки на массив большей длины потребо-^ось создать новый экземпляр.








</p>
<p>Поскольку для экземпляра массива длина является постоянной ха­рактеристикой,
для всех массивов существует специальное поле length позволяющее узнать ее значение. Например:

</p>
<p>Point p[]=new Point[5]; for (int i=0;
i&lt;p.length; i++) { p[i]=new Point(i, i);

</p>
<p>}

</p>
<p>Значение индекса массива всегда имеет тип int. При обращении к
элементу можно также использовать byte, short или char, поскольку эти типы автоматически расширяются до int. Попытка
задействовать long приведет к ошибке
компиляции.

</p>
<p>Соответственно, и поле length имеет тип int, а теоретическая
макси­мально возможная длина массива равняется 23'-1, то есть
немногим боль­ше 2 млрд.

</p>
<p>Продолжая рассматривать тип массива, подчеркнем, что в качестве базового
типа может использоваться любой тип Java, в том числе:

</p>
<p>•   
интерфейсы. В таком случае
элементы массива могут иметь значе­ние null или ссылаться на объекты любого класса, реализующего этот интерфейс;

</p>
<p>•   
абстрактные классы. В этом
случае элементы массива могут иметь значение null или ссылаться на объекты любого неабстрактного класса-наследника.

</p>
<p>Поскольку массив является объектным типом данных, его значения могут
быть приведены к типу Object или, что то же
самое, присвоены пе­ременной типа Object. Например,

</p>
<p> 

</p>
<p>Object о = new int[4];

</p>
<p> 

</p>
<p>Это дает интересную возможность для массивов, основанных на ти­пе Object, хранить в
качестве элемента ссылку на самого себя:

</p>
<p>Object arr[] = new Object[3]; arr[0]=new Objecto; arr[1]=null;

</p>
<p>arr[2]=arr; // Элемент ссылается на весь массив!

</p>
<p>Инициализация
массивов

</p>
<p>Теперь, когда мы выяснили, как создавать экземпляры массива, рас-сМОтрим, какие значения принимают его элементы.

</p>
<p>Если создать массив на основе примитивного числового типа, то из­начально
после создания все элементы массива имеют значение по умол­чанию, то есть 0.
Если массив объявлен на основе примитивного типа boolean, то и в этом
случае все элементы будут иметь значение по умол­чанию false. Выше
рассматривался пример инициализации элементов с помощью цикла for.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Рассмотрим создание массива на основе ссылочного типа. Предпо­ложим, это будет класс Point. При создании экземпляра массива с приме­нением ключевого слова new не создается ни
один объект класса Point, создается лишь один объект массива. Каждый элемент массива будет иметь
пустое значение null. В этом можно убедиться на простом примере:

</p>
<p> 

</p>
<p>Point p[]=new Point[5]; for (int i=0;
Kp.length; i++) { System.out.pritnln(p[i]);

</p>
<p>}

</p>
<p>Результатом будут лишь
слова null.

</p>
<p>Далее нужно инициализировать элементы массива по отдельности, например, в цикле. Вообще, создание массива длиной п можно рассмат­ривать как
заведение п переменных и работать с элементами массива (в последнем примере p[i]) по правилам
обычных переменных.

</p>
<p>Кроме того, существует и другой способ создания массивов — ини­циализаторы.
В этом случае ключевое слово new не используется, а
ста­вятся фигурные скобки, и в них через запятую перечисляются значения всех
элементов массива. Например, для числового массива явная иници­ализация записывается следующим образом:

</p>
<p> 

</p>
<p>inti[]={1,3, 5};

</p>
<p>int j[]={}; // эквивалентно new int[0]

</p>
<p>Длина массива вычисляется автоматически, исходя из количества Введенных
значений. Далее создается массив такой длины и каждому его Цементу
присваивается указанное значение.

</p>
<p>Аналогично можно порождать массивы на основе объектных типов, Например:

</p>
<p> 

</p>
<p>Point p=new
Point(1,3);

</p>
<p>Point arr[]={p,
new Point(2,2), null, p};

</p>
<p>277








</p>
<p>// или

</p>
<p>String
sarr[]={"aaa", "bbb", "cde"+"xyz"};

</p>
<p> 

</p>
<p>Однако инициализатор нельзя использовать для анонимного созда­ния
экземпляров массива, то есть не для инициализации переменной, а например,
для передачи параметров метода или конструктора.

</p>
<p>Например:

</p>
<p> 

</p>
<p>public
class Parent { private String[] values;

</p>
<p> 

</p>
<p>protected Parent(String[] s) { values=s;

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>public class
Child extends Parent {

</p>
<p> 

</p>
<p>public Child(String firstName, String lastName) {

</p>
<p>super(???); //требуется
анонимное создание массива

</p>
<p>}

</p>
<p>}

</p>
<p>В конструкторе класса Child необходимо
осуществить обращение к конструктору родителя и передать в качестве параметра
ссылку на массив. Теоретически можно передать null, но это приведет в
большинстве случаев к некорректной работе классов. Можно вставить выражение new String[2], но тогда
вместо значений firstName и lastName будут переданы пустые строки. Попытка записать {firstName, lastName} приведет к ошибке компиляции, так можно только инициализировать
переменные.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Корректное выражение
выглядит так:

</p>
<p> 

</p>
<p>new String[]{firstName, lastName}

</p>
<p> 

</p>
<p>Что является некоторой смесью выражения, создающего массивы с помо­щью new, и инициализатора.
Длина массива определяется количеством указанных значений.

</p>
<p>Многомерные
массивы

</p>
<p>Теперь перейдем к рассмотрению многомерных массивов. Так, в сле­дующем
примере

</p>
<p>inti[][]=newint[3][5];

</p>
<p>переменная i ссылается на
двумерный массив, который можно предста­вить себе в виде таблицы 3x5. Суммарно
в таком массиве содержится 15 элементов, к которым можно обращаться через
комбинацию индексов от (О, 0) до (2, 4). Пример заполнения двумерного массива через цикл:

</p>
<p>int
pithagor_table[][]=new int[5][5]; for (int i=0; i&lt;5; i++) { for (int j=0; j&lt;5; j++) {

</p>
<p>pithagor_table[i][j]=i*j;

</p>
<p>System.out.print(pithagor_table[i][j]+ "\П;

</p>
<p>}

</p>
<p>System.out.println();

</p>
<p>}

</p>
<p>Результатом выполнения
программы будет:

</p>
<p> 

</p>
<p>0 0 0 0 0 0  12 3
4 0 2 4 6 8 О 3 6 9  12 0 4 8  12 16

</p>
<p>Однако такой взгляд на двумерные и многомерные массивы является неполным.
Более точный подход заключается в том, что в Java нет двумер­ных, и вообще многомерных массивов, а есть массивы, базовыми типами которых
являются также массивы. Например, тип int[] означает
"массив чисел", a int[][] означает
"массив массивов чисел". Поясним такую точку зрения.

</p>
<p>Если создать двумерный массив и определить переменную х, которая На него ссылается, то,
используя х и два числа в паре квадратных скобок Каждое (например, х[0][0]), можно обратиться к любому элементу дву­мерного
массива. Но в то же время, используя х и одно число в паре ква-ДРатных скобок, можно обратиться к одномерному массиву,
который яв­ляется элементом двумерного массива. Его можно проинициализировать н°вым
массивом с некоторой другой длиной и таблица перестанет быть прямоугольной -
она примет произвольную форму. В частности, можно одному из одномерных массивов
присвоить даже значение null.

</p>
<p>int x[][]=new int[3][5]; // прямоугольная таблица x[0]=new int[7];
x[1]=new int[0]; x[2]=null;

</p>
<p> 

</p>
<p>После таких операций массив, на который ссылается переменная х, назвать
прямоугольным никак нельзя. Зато хорошо видно, что это просто набор одномерных
массивов или значений null.

</p>
<p>Полезно подсчитать, сколько объектов порождается выражением new int[3][5]
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Правильный
подсчет таков: создается один массив массивов (один объект) и три массива
чисел, каждый длиной 5 (три объекта). Итого, четыре объекта.

</p>
<p>В рассмотренном примере три из них (массивы чисел) были тут же
переопределены новыми значениями. Для таких случаев полезно исполь­зовать
упрощенную форму выражения создания массивов:

</p>
<p> 

</p>
<p>intx[][]=newint[3][];

</p>
<p> 

</p>
<p>Такая запись порождает один объект - массив массивов - и заполня­ет его
значениями null. Теперь понятно, что и в этом, и в предыдущем ва­рианте выражение х.length возвращает значение 3 - длину массива мас­сивов. Далее можно с помощью
выражений x[i].length узнать длину каж­дого
вложенного массива чисел, при условии, что i неотрицательно и меньше x.length, а также x[i] не равно null. Иначе будут возникать ошибки во время выполнения программы.

</p>
<p>Вообще, при создании многомерных массивов с помощью new необ­ходимо указывать все пары квадратных скобок, соответственно
количест­ву измерений. Но заполненной обязательно должна быть лишь крайняя
левая пара, это значение задаст длину верхнего массива массивов. Если за­полнить
следующую пару, то этот массив заполнится не значениями по умолчанию null, а новыми
созданными массивами с меньшей на единицу размерностью. Если заполнена вторая
пара скобок, то можно заполнить третью, и так далее.

</p>
<p>Аналогично, для создания многомерных массивов можно использо­вать
инициализаторы. В этом случае применяется столько вложенных фигурных скобок,
сколько требуется:

</p>
<p> 

</p>
<p>int i[][] = {{1,2}, null, {3}, {}};

</p>
<p>В этом примере порождается четыре объекта. Это, во-первых, мас­сив
массивов длиной 4, а во-вторых, три массива чисел с длинами 2, 1,0,
соответственно.

</p>
<p>Все рассмотренные примеры и утверждения одинаково верны для многомерных
массивов, основанных как на примитивных, так и на ссы­лочных типах.

</p>
<p> 

</p>
<p>Класс
массива

</p>
<p>Поскольку массив является объектным типом данных, можно попы-таться
представить себе, как выглядело бы объявление класса такого типа. На самом деле
эти объявления не хранятся в файлах, или еще каком-ни­будь формате. Учитывая,
что массив может быть объявлен на основе любо­го типа и иметь произвольную
размерность, это физически невыполнимо, дай не требуется. Вместо этого во время
выполнения приложения вирту­альная машина генерирует эти объявления динамически
на основе базо­вого типа и размерности, а затем они хранятся в памяти в виде
таких же экземпляров класса Class, как и для любых других типов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Рассмотрим гипотетическое объявление класса для массива, осно­ванного на
неком объектном типе Element.

</p>
<p>Объявление класса начинается с перечисления модификаторов, среди которых
особую роль играют модификаторы доступа. Класс массива будет иметь такой же
уровень доступа, как и базовый тип. То есть если Element объявлен как public-класс, то и массив будет иметь уровень доступа pub­lic» Для любого примитивного типа класс массива будет public. Можно также указать
модификатор final, поскольку никакой класс не может на­следоваться от класса массива.

</p>
<p>Затем следует имя класса, на котором можно подробно не останав­ливаться,
т.к. к типу массив обращение идет не по его имени, а по имени базового типа и
набору квадратных скобок.

</p>
<p>Затем нужно указать родительский класс. Все массивы наследуются Напрямую
от класса Object. Далее перечисляются интерфейсы, которые Реализует класс. Для массива
это будут интерфейсы Cloneable и ^Tializable. Первый из них подробно рассматривается в конце этой лек­ции, а второй будет
описан в следующих лекциях.

</p>
<p>Тело класса
содержит объявление одного public final поля length типа Кроме того, переопределен метод с1опе() для поддержки интерфейса C|oneable.

</p>
<p>Сведем все вышесказанное в
формальную запись класса:

</p>
<p> 

</p>
<p>[public] class A implements Cloneable,
java.io.Serializable { public final int length; // инициализируется при создании

</p>
<p>public
Object clone() { try{

</p>
<p>return
super.clone(); } catch (CloneNotSupportedException e) { throw new
lnternalError(e.getMessage());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>Таким образом, экземпляр типа массив является полноценным объ­ектом,
который, в частности, наследует все методы, определенные в классе Object, например, toString(), hashCodeQ и остальные.

</p>
<p>Например:

</p>
<p> 

</p>
<p>// результат работы метода toString() System.out.println(new int[3]);
System.out.println(new int[3][5]); System.out.println(new String[2]);

</p>
<p> 

</p>
<p>// результат работы метода hashCode() System.out.println(newfloat[2].hashCode()); Результатом
выполнения программы будет:

</p>
<p>[I@26b249 [[I@82f0db

</p>
<p>[Ljava.lang.String;@92d342 7051261

</p>
<p> 

</p>
<p> 

</p>
<p>Преобразование типов для
массивов

</p>
<p>Теперь, когда массив введен как полноценный тип данных в Java, рассмотрим, какое
влияние он окажет на преобразование типов.

</p>
<p>Ранее подробно рассматривались переходы между примитивными11 обычными
(не являющимися массивами) ссылочными типами
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Хотя мас­сивы являются объектными
типами, их также будет полезно разделить п° базовому типу на две группы -
основанные на примитивном или ссылоч­ном типе.

</p>
<p>Имейте в виду, что переходы между массивами и примитивными т11'
пами являются запрещенными. Преобразования между массивами и ДР&gt;" гими
объектными типами возможны только для класса Object и интеР' фейсов Cloneable и Serializable.. Массив всегда можно привести к эти&gt;'

</p>
<p>М типам, обратный же переход является сужением и должен произво-1*1-ся
явным образом по усмотрению разработчика. Таким образом, ин-пес представляют
только переходы между разными типами массивов. ^евИдно, что массив,
основанный на примитивном типе, принципиально цельзя преобразовать к типу
массива, основанному на ссылочном типе, и наоборот.

</p>
<p>Пока не будем останавливаться на этом подробно, однако заметим, уф преобразования
между типами массивов, основанных на различных примитивных типах, невозможны ни
при каких условиях.

</p>
<p>.;, Для ссылочных же типов такого строгого правила нет.
Например, ес-дЯ/СОЗДать экземпляр массива, основанного на типе Child, то ссылку на него
можно привести к типу массива, основанного на типе Parent.

</p>
<p>Child с[] = newChild[3];
Parent р[] = с;

</p>
<p>Вообще, существует универсальное правило: массив, основанный на типе А, можно привести к
массиву, основанному на типе В, если сам тип А Приводится к типу В.

</p>
<p>4 // если допустимо
такое приведение: Bb = (B)newA();

</p>
<p>//то допустимо и
приведение массивов: Bb[]=(B[]) newA[3];

</p>
<p>; Применяя это правило рекурсивно, можно преобразовывать много­мерные
массивы. Например, массив Child[][] можно привести к Parent[][], так как их базовые типы приводимы (Child[] к Parent[]) также на основе
этого правила (поскольку базовые типы Child и Parent приво­димы в силу правил наследования).

</p>
<p>Как обычно, расширения можно проводить неявно (как в предыду­щем
примере), а сужения - только явным приведением.

</p>
<p>* Вернемся к массивам, основанным на примитивном типе. Невозмож­ность их
участия в преобразованиях типов связана, конечно, с различиями м*Аду
простыми и ссылочными типами данных. Поскольку элементами °®Ьектных массивов
являются ссылки, они легко могут участвовать в при-^ении. Напротив, элементы
простых типов действительно хранят число-Вь,еили булевские значения.
Предположим, такое преобразование осуще-Ст»Имо:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>// пример вызовет ошибку компиляции byte Ь[]={1, 2,3}; int i[]=b;

</p>
<p>В таком случае, элементы Ь[0] и &#161;[0] хранили бы значения разцц типов. Стало быть,
преобразование потребовало бы копирования с одн0 временным
преобразованием типа всех элементов исходного массива. ЎЎ результате был бы
создан новый массив, элементы которого равнялись б( по значению
элементам исходного массива.

</p>
<p>Но преобразование типа не может порождать новые объекты. Такие операции
должны выполняться только явным образом с применение^ ключевого слова new. По этой причине
преобразования типов массивов основанных на примитивных типах, запрещены.

</p>
<p>Если же копирование элементов действительно требуется, то нужно сначала
создать новый массив, а затем воспользоваться стандартной функцией System.аггауСору(),
которая эффективно выполняет копиро-вание элементов одного массива в другой.

</p>
<p> 

</p>
<p>Ошибка
ArrayStoreException

</p>
<p>Преобразование между
типами массивов, основанных на ссылочных типах, может стать причиной одной
довольно неочевидной ошибки. Рассмотрим пример:

</p>
<p> 

</p>
<p>Child с[] = new Child[5]; Parent р[]=с; p[0]=new Parent();

</p>
<p> 

</p>
<p>С точки зрения компилятора код совершенно корректен. Преобра­зование во
второй строке допустимо. В третьей строке элементу массива типа Parent присваивается значение того же типа.

</p>
<p>Однако при выполнении такой программы возникнет ошибка. Нельзя забывать,
что преобразование не меняет объект, изменяется лишь способ доступа к нему. В
свою очередь, объект всегда "помнит", от какого типа он был порожден. С
учетом этих замечаний становится ясно, что в третьей строке делается
попытка добавить в массив Child значение типа Parent, что некорректно.

</p>
<p>Действительно, ведь переменная с продолжает ссылаться на этот массив, а
значит, следующей строкой может быть такое обращение:

</p>
<p> 

</p>
<p>c[0].onlyChildMethod();

</p>
<p> 

</p>
<p>где метод onlyChildMethodO определен только в
классе Child. Данное об­ращение совершенно корректно, а значит, недопустима
ситуация, коь*1 элемент с[0] ссылается на объект, несовместимый с Child.

</p>
<p>Таким образом,
несмотря на отсутствие ошибок компиляции, вирту-наЯ машина при
выполнении программы всегда осуществляет допол-\ггельную проверку перед
присвоением значения элементу массива. Не-бхоДиМО Удостовериться,
что реальный массив, существующий на мо-°ент
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>исполнения, действительно может
хранить присваиваемое значение, рели это условие нарушается, то
возникает ошибка, которая называется ArrayStoreException.

</p>
<p>Может сложиться впечатление, что разобранная ситуация является надуманной,-
зачем преобразовывать массив и тут же задавать для него неверное значение?
Однако преобразование при присвоении значений является лишь примером.
Рассмотрим объявление метода:

</p>
<p>public void process(Parent[] р) { if (p!=null
&amp;&amp; p.length&gt;0) { p[0]=new Parent();

</p>
<p>}

</p>
<p>}

</p>
<p>Метод выглядит абсолютно корректным, все потенциально ошибоч­ные
ситуации проверяются if-выражением. Однако следующий вызов этого метода все равно приводит к
ошибке:

</p>
<p> 

</p>
<p>process(new Chмld[3] ));

</p>
<p> 

</p>
<p>И это будет как раз ошибка ArrayStoreException.

</p>
<p> 

</p>
<p>Переменные
типа массив и их значения

</p>
<p>Завершим описание взаимосвязи типа переменной и типа значений, которые
она может хранить.

</p>
<p>Как обычно,
массивы, основанные на простых и ссылочных типах, мы описываем раздельно.

</p>
<p>Переменная типа
массив примитивных величин может хранить зна­чения только точно такого же типа,
либо null.

</p>
<p>Переменная типа
"массив ссылочных величин" может хранить сле­дующие значения:

</p>
<p>1- null;

</p>
<p>2.  значения точно такого же типа, что и тип переменной;

</p>
<p>3.  все значения типа массив, основанный на типе, приводимом к ба­зовому
типу исходного массива.

</p>
<p>Все эти утверждения непосредственно следуют из рассмотренных вЫЩе
особенностей приведения типов массивов.

</p>
<p>Еще раз напомним про исключительный класс Object. Перемени такого
типа могут ссылаться на любые объекты, порожденные как классов, так и от
массивов.

</p>
<p>Сведем все эти утверждения в таблицу.

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>Тип переменной
  </p>
</td>
  <td width="318" valign="top">
  <p>Допустимые типы ее значения
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>Массив
  </p>
</td>
  <td width="318" valign="top">
  <p>•null
  </p>
</td>
  <td width="11" rowspan="2" valign="top">
  <p>І
  </p>
<p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>простых чисел
  </p>
</td>
  <td width="318" valign="top">
  <p>• в точности совпадающий
  с типом переменной
  </p>
</td>
  <p> 
 </p>
</tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>Массив
  </p>
</td>
  <td width="318" valign="top">
  <p>•null
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>ссылочных
  </p>
</td>
  <td width="318" valign="top">
  <p>• совпадающий с типом
  переменной
  </p>
</td>
  <td width="11" valign="top">
  <p>ї
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>значений
  </p>
</td>
  <td width="318" valign="top">
  <p>• массивы
  ссылочных значений, удовлетворяющих следующему условию: если тип переменной
  -массив на основе типа А, то значение типа массив на основе типа В допустимо
  тогда и только тогда, когда В приводимо к А
  </p>
</td>
  <td width="11" valign="top">
  <p>І
  </p>
<p>!
  </p>
<p>si
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p>Object
  </p>
</td>
  <td width="318" valign="top">
  <p>•null
  </p>
<p>•любой ссылочный,
  включая массивы
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="9" valign="top">
  <p> 
  </p>
</td>
  <td width="105" valign="top">
  <p> 
  </p>
</td>
  <td width="318" valign="top">
  <p> 
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
</table>

<p>Табл. 7.1. Тип переменной и тип ее значения.

</p>
<p> 

</p>
<p>Клонирование

</p>
<p>Механизм клонирования, как следует из названия, позволяет по­рождать
новые объекты на основе существующего, которые обладали бы точно таким же
состоянием, что и исходный. То есть ожидается, что для исходного объекта,
представленного ссылкой х, и результата клонирова­ния, возвращаемого методом
х.с1опе(), выражение

</p>
<p>х != х.с1опе()

</p>
<p>должно быть истинным, как и выражение

</p>
<p>х.с1опе().деЮ1аз5() ==
х.деЮ1аз5()

</p>
<p>Наконец, выражение

</p>
<p>х.едиа1з(х.с1опе())

</p>
<p> 

</p>
<p>также верно. Реализация такого метода с1опе() осложняется целым ряд0&gt;|
потенциальных проблем, например:

</p>
<p>•    класс, от которого порожден объект, может иметь разнообразные
конструкторы, которые к тому же могут быть недоступны (напри­мер, модификатор
доступа private);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•    цепочка наследования, которой принадлежит исходный класс, может быть
довольно длинной, и каждый родительский класс мо­жет иметь свои поля -
недоступные, но важные для воссоздания состояния исходного объекта;

</p>
<p>•    в зависимости от логики реализации возможна ситуация, когда не все поля
должны копироваться для корректного клонирования; одни могут оказаться лишними,
другие потребуют дополнитель­ных вычислений или преобразований;

</p>
<p>•    возможна ситуация, когда объект нельзя клонировать, дабы не на­рушить
целостность системы.

</p>
<p>Поэтому было реализовано
следующее решение.

</p>
<p>Класс Object содержит метод clone(). Рассмотрим его объявление:

</p>
<p>protected native Object clone() throws CloneNotSupportedException; Именно он используется для клонирования. Далее возможны два ва-пЮнта.

</p>
<p>Первый вариант: разработчик может в своем классе переопределить эЦг метод
и реализовать его по своему усмотрению, решая перечисленные ЩЮблемы так, как
того требует логика разрабатываемой системы. Упомя­нутые условия, которые должны
быть истинными для клонированного овЫжта, не являются обязательными и
программист может им не следо­вать, если это требуется для его класса.

</p>
<p>Второй вариант предполагает использование реализации метода clone()
в самом классе Object. То, что он
объявлен как native, говорит о ЮМ, что его реализация предоставляется виртуальной машиной. Естест­венно, перечисленные трудности легко могут быть преодолены самой WM, ведь она хранит в памяти все свойства объектов.

</p>
<p>„.-; При выполнении
метода clone() сначала проверяется, можно ли ^Тонировать исходный объект. Если
разработчик хочет сделать объек-IW своего класса доступными для клонирования через Object.clone(), ^ он должен реализовать в своем классе интерфейс Cloneable. В этом интерфейсе нет ни одного элемента, он служит лишь признаком для
вИртуальной машины, что объекты могут быть клонированы. Если
^Роверка не выполняется успешно, метод порождает ошибку C|°neNotSupportedException.

</p>
<p>Если интерфейс Cloneable реализован, то
порождается новый объ-е*тоттого же класса, от которого был создан исходный объект. При этом ^Пирование
выполняется на уровне виртуальной машины, никакие кон-^УКторы не вызываются.
Затем значения всех полей, объявленных, унаследованных либо объявленных в
родительских классах, копируют^ Полученный объект возвращается в качестве
клона.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Обратите внимание, что сам класс Object не реализует интерфС1] Cloneable, а потому попытка вызова new Object().clone() будет приводи, к ошибке времени исполнения. Метод с1опе()
предназначен скорее ;щ использования в наследниках, которые могут обращаться к нему с пом0.
шью выражения super.clone(). При этом могут быть сделаны следующ^ изменения:

</p>
<p>•   
модификатор доступа
расширен до public;

</p>
<p>•   
удалено предупреждение об
ошибке CloneNotSupportedException

</p>
<p>•   
результирующий объект
может быть модифицирован любым спо­собом, на усмотрение разработчика.

</p>
<p>Напомним, что все массивы реализуют интерфейс Cloneable и, та­ким образом,
доступны для клонирования.

</p>
<p>Важно помнить, что все поля клонированного объекта приравнива­ются, их
значения никогда не клонируются. Рассмотрим пример:

</p>
<p>public class Test implements Cloneable { Point
p; int height;

</p>
<p> 

</p>
<p>public Test(int x, int y,
int z) { p=new Point(x, y); height=z;

</p>
<p>}

</p>
<p> 

</p>
<p>public static void main(String s[]) { Test
t1=new Test(1, 2, 3), t2; try{

</p>
<p>t2=(Test)t1.clone();
} catch (CloneNotSupportedException e) {} t1.p.x=-1; t1.height=-1;

</p>
<p>System. out.println("t2. p. x=" + t2.p.x +
", t2.height=" +12.height);

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом работы программы будет: t2.p.x=-1, t2.height=3

</p>
<p>Из примера видно, что примитивное поле было скопировано и далее
существует независимо в исходном и клонированном объектах. Изменение одного не
сказывается на другом.

</p>
<p>А вот ссылочное поле было скопировано по ссылке, оба объекта ссы­лаются
на один и тот же экземпляр класса Point. Поэтому
изменения, происходящие с исходным объектом, сказываются на клонированном.

</p>
<p>Этого можно избежать, если
переопределить метод clone() в классе Test.

</p>
<p> 

</p>
<p>public Object clone() { Test clone=null;
try{

</p>
<p>clone=(Test) super.clone(); } catch
(CloneNotSupportedException e) { throw new InternalError(e.getMessageO);

</p>
<p>}

</p>
<p>clone.p=(Point)clone.p.clone();
return clone;

</p>
<p>}

</p>
<p>Обратите внимание, что результат метода Object.clone() приходится явно
приводить к типу Test, хотя его реализация гарантирует, что клониро­ванный объект будет
порожден именно от этого класса. Однако тип возвра­щаемого значения в данном
методе для универсальности объявлен как Object, поэтому явное
сужение необходимо.

</p>
<p>Теперь метод main можно упростить:

</p>
<p>public static void main(String s[]) { Testt1=newTest(1,
2, 3); Test t2=(Test)t1.clone(); t1.p.x=-1; t1.height=-1;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>System.out.println("t2.p.x="
+ t2.p.x + ", t2.height=" +12.height);

</p>
<p>}

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>І2.р.х=1, і2.ІтеідІтг=3

</p>
<p>То есть теперь все поля исходного и клонированного объектов стали Независимыми.

</p>
<p>Реализация такого "неглубокого" клонирования в методе °^есісІопе() необходима, так как в противном случае клонирование вто­ростепенного
объекта могло бы привести к огромным затратам ресурсов ведь этот объект может
содержать ссылки на более значимые объекты, а те при клонировании также
начали бы копировать свои поля, и так далее Кроме того, типом поля клонируемого
объекта может быть класс, не реа­лизующий Cloneable, что приводило бы к дополнительным проблемам. Как показано в примере,
при необходимости дополнительное копирова­ние можно добавить самостоятельно.

</p>
<p> 

</p>
<p>Клонирование массивов

</p>
<p>Итак, любой массив может быть клонирован. В этом разделе хоте­лось бы
рассмотреть особенности, возникающие из-за того, что Object.с1опе() копирует только один объект.

</p>
<p>Рассмотрим пример:

</p>
<p> 

</p>
<p>int а[]={1, 2, 3};

</p>
<p>intb[]=(int[])a.clone();

</p>
<p>а[0]=0;

</p>
<p>System.out.println(b[0]);

</p>
<p>Результатом будет ноль, что вполне очевидно, так как весь массив
представлен одним объектом, который не будет зависеть от своей копии. Усложняем
пример:

</p>
<p> 

</p>
<p>inta[][]={{1,2},{3}};

</p>
<p>int
b[][]=(int[][])a.clone();

</p>
<p> 

</p>
<p>if (-И

</p>
<p>// первый вариант:

</p>
<p>a[0]=newint[]{0};

</p>
<p>System.out.println(b[0][0]); } else {

</p>
<p>// второй вариант:

</p>
<p>a[0][0]=0;

</p>
<p>System.
out.println(b[0][0]);

</p>
<p>}

</p>
<p>Разберем, что будет происходить в этих двух случаях. Начнем с того, что в первой строке
создается двухмерный массив, состоящий из двух од­номерных. Итого три объекта.
Затем, на следующей строке при клониро­вании будет создан новый двухмерный
массив, содержащий ссылки на те же самые одномерные массивы.

</p>
<p>Теперь несложно предсказать результат обоих вариантов. В перв0&gt;| случае
в исходном массиве меняется ссылка, хранящаяся в первом эДе' менте, что не
принесет никаких изменений для клонированного объекта. jja консоли появится 1.

</p>
<p>Во втором случае модифицируется существующий массив, что ска­жется на
обоих двухмерных массивах. На консоли появится 0.

</p>
<p>Обратите внимание, что если из примера убрать условие if-else, так, что­бы
отрабатывал первый вариант, а затем
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>второй, то результатом будет опять 1,
поскольку в части второго варианта модифицироваться будет уже новый массив,
порожденный в части первого варианта.

</p>
<p>Таким образом, в Java предоставляется
мощный, эффективный и гибкий механизм клонирования, который легко применять и
модифицировать под конкретные нужды. Особенное внимание должно уделяться
копированию объектных полей, которые по умолчанию копируются только по ссылке.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции было рассмотрено устройство массивов в Java. Подоб­но массивам
в других языках, они представляют собой набор значений од­ного типа. Основным
свойством массива является длина, которая в Java может равняться нулю. В противном случае, массив обладает элементами в
количестве, равном длине, к которым можно обратиться, используя ин­декс, изменяющийся от 0 до величины длины без единицы. Длина задает­ся при создании массива и у
созданного массива не может быть изменена. Однако она не входит в определение
типа, а потому одна переменная мо­жет ссылаться на массивы одного типа с
различной длиной.

</p>
<p>Создать массив можно с помощью ключевого слова new, поскольку все
массивы, включая определенные на основе примитивных значений, Имеют объектный
тип. Другой способ - воспользоваться инициализато­ром и перечислить значения
всех элементов. В первом случае элементы принимают значения по умолчанию (0, false, null).

</p>
<p>Особым образом в Java устроены многомерные массивы. Они, по сути, *Мяются одномерными, основанными на массивах меньшей размерности. Такой подход
позволяет единообразно работать с многомерными масси­вами. Также он дает
возможность создавать не только "прямоугольные" Массивы, но и массивы любой конфигурации.

</p>
<p>Хотя массив и является ссылочным типом, работа с ним зачастую Имеет
некоторые особенности. Рассматриваются правила приведения ти-ца массива. Как для любого объектного типа, приведение к Object явля-

</p>
<p>расширяющим. Приведение массивов, основанных на ссылочных ^ах, во многом подчиняется
обычным правилам. А вот примитивные ^ссивы преобразовывать нельзя. С преобразованиями связано и возник­новение
ошибки ArrayStoreException, причина которой - невозможность *°ЧНого отслеживания типов в преобразованном массиве для компилятора.








</p>
<p>В заключение рассматриваются последние случаи взаимосвязи типа переменной
и ее значения.

</p>
<p>Наконец, изучается механизм клонирования, существующий с са­мых первых
версий Java и позволяющий
создавать точные копии объек-тов, если их классы позволяют это делать, реализуя
интерфейс Cloneable Поскольку стандартное клонирование порождает только один новый объект,
это приводит к особым эффектам при работе с объектными поля­ми классов и
массивами.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>Сколько
различных ошибок (компиляции, времени выполнения, логических) в следующем
примере? intb[]=newint[5]; for (int i=1; i&lt;=b.length();       { b[i]=Math.sqrt(i);

</p>
<p>}

</p>
<p>&#9633;       3

</p>
<p>&#9633;       4

</p>
<p>&#9633;          
5








</p>
<p> 

</p>
<p> 

</p>
<p>2.      Сколько
объектов порождается при инициализации
массива new int[3][4]? new int[3][][]?

</p>
<p>&#9633;   
1,1

</p>
<p>&#9633;   
3,3

</p>
<p>&#9633;       
4, 1

</p>
<p>&#9633;   
4,3

</p>
<p>&#9633;       
12, 3

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Хотя
примитивные массивы не могут участвовать в
преобразованиях, однако массивы int[][] и byte[][] могут
рассматриваться как одномерные объектные массивы,
основанные на ссылочном типе «одномерный примитивный
массив». Могут ли такие типы быть преобразованы из
одного в другой?

</p>
<p>&#9633; да П   нет








</p>
<p> 








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0" align="left">
 <tr>
  <td width="472" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="49" height="25" src="http://kufas.ru/java.files/image016.png" alt="Подпись:  "></center></td>
 </tr>
</table>




<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.   Может ли массив
основываться на абстрактных классах? Интерфейсах?

</p>
<p>&#9633;       
да, да

</p>
<p>&#9633;       
да, нет

</p>
<p>&#9633;       
нет, да

</p>
<p>&#9633;       
нет, нет

</p>
<p> 

</p>
<p> 

</p>
<p>2.   От какого класса
наследуются классы массивов?

</p>
<p>П   особый класс для массивов
&#9633;   object

</p>
<p>П   одномерные массивы - от Object, двумерные
- от одномерных и т.д.

</p>
<p>П   ни
от какого

</p>
<p> 

</p>
<p> 

</p>
<p>3.   Может ли возникнуть ошибка ArrayStoreException при работе следующих методов? public void setCars(Car с[])
{ c[0]=newCar();

</p>
<p>}

</p>
<p>public void setCars2(Car c[]) { if (c[0] instanceof
Car) { c[0]=newCar();

</p>
<p>}

</p>
<p>}

</p>
<p>public void setNumbers(int x[]) { x[0]=0;

</p>
<p>}

</p>
<p>П   ошибка
возможна в первом методе П   ошибка
возможна во втором методе П   ошибка
возможна в третьем методе

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1.      Как
создать массив, эквивалентный объявляемому ниже,
но без заведения переменной?
intx[][]=newint[2][3];

</p>
<p>&#9633;       
newint[2][3]

</p>
<p>&#9633;       
{{0, 0}, {0, 0}, {0, 0}}

</p>
<p>&#9633;       
{{0, 0, 0}, {0, 0, 0}}

</p>
<p>&#9633;       
newint[][]{{0, 0},
{0, 0}, {0, 0}}

</p>
<p>&#9633;       
newint[][]{{0, 0,
0}, {0, 0, 0}}

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Как
определить, можно ли преобразовать один
тип массива к другому?

</p>
<p>[~|  
любые массивы приводимы, поскольку являются объектами

</p>
<p>&#9633;        А[]
можно привести к В[], если А приводится к В

</p>
<p>&#9633;       А[]
можно привести к В[], если А приводится к В, и А, В - ссылочные типы

</p>
<p>Г~|  
массивы не преобразовываются

</p>
<p> 

</p>
<p> 

</p>
<p>3.     Можно
ли клонировать объекты следующего класса?
public class Point {

</p>
<p>private int x, у;

</p>
<p>public Point(int nx, int ny) {

</p>
<p>x=nx;

</p>
<p>y=ny;

</p>
<p>}

</p>
<p>public Object clone() { return new Point(x, y);

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;       да
Ц   нет








</p>
<p>
</p>
<center> 
</center>
    </div>