# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 3.
Лексика
языка</h2></center>

<p> 

</p>
<p> 

</p>
<p>Лекция посвящена описанию
лексики языка Java.

</p>
<p>Лексика описывает, из чего состоит текст программы,
каким образом он записывается и на какие простейшие слова (лексемы) компилятор
разбивает программу при анализе. Лексемы (или tokens в английском
варианте) - это основные "кирпичики", из которых строится любая
программа на языке Java.

</p>
<p>Эта тема раскрывает многие детали внутреннего
устройства языка, и невозможно написать ни одной строчки кода, не затронув ее.
Именно поэтому курс начинается с основ лексического анализа.

</p>
<p> 

</p>
<p>Ключевые слова: ASCII, Unicode, carriage return, linefeed, пробел, javadoc, идентификаторы, underscore, литералы.

</p>
<p> 

</p>
<p>Кодировка

</p>
<p>Технология Java, как платформа, изначально спроектированная для Глобальной сети Internet, должна быть
многоязыковой, а значит, обыч­ный набор символов ASCII (American Standard Code for Information Interchange, Американский стандартный код обмена информацией), включающий в себя
лишь латинский алфавит, цифры и простейшие спе­циальные знаки (скобки, знаки
препинания, арифметические операции и т.д.), недостаточен. Поэтому для записи
текста программы применяется более универсальная кодировка Unicode.

</p>
<p>Как известно, Unicode представляет
символы кодом из 2 байт, опи­сывая, таким образом, 65535 символов. Это
позволяет поддерживать практически все распространенные языки мира. Первые 128
символов совпадают с набором ASCII. Однако понятно, что требуется некоторое специальное обозначение, чтобы
иметь возможность задавать в програм­ме любой символ Unicode, ведь никакая
клавиатура не позволяет вводить более 65 тысяч различных знаков. Эта
конструкция представляет символ Unicode, используя только символы ASCII. Например, если в
программу нужно вставить знак с кодом 6917, необходимо его представить в
шест-надцатеричном формате (1В05) и записать:

</p>
<p> 

</p>
<p>\u1B05,

</p>
<p>причем буква и
должна быть прописной, а шестнадцатеричные циф-РЬ1
А, В, С, D, Е, F можно использовать произвольно, как заглавные, Так и
строчные. Таким образом можно закодировать все символы








</p>
<p>Unicode от \u0000 до \uFFFF. Буквы русского алфавита начинаются с \u0410 (только буква Ё имеет код \u0401) по \u044F (код буквы ё \u0451). В последних версиях JDK в состав
демонстрационных при­ложений и апплетов входит небольшая программа SymbolTest, позво­ляющая просматривать весь набор символов Unicode
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Ее аналог не­сложно
написать самостоятельно. Для перекодирования больших текстов служит утилита native2ascii, также входящая в JDK. Она мо­жет
работать как в прямом режиме — переводить из разнообразных кодировок в Unicode, записанный ASCII-символами, так и в
обрат­ном (опция -reverse) — из Unicode в стандартную
кодировку опера­ционной системы.

</p>
<p>В версиях языка Java до 1.1 применялся Unicode версии 1.1.5, в по­следнем выпуске 1.4 используется 3.0. Таким образом, Java следит за раз­витием стандарта и базируется на современных версиях. Для
любой JDK точную версию Unicode, используемую в
ней, можно узнать из докумен­тации к классу Character. Официальный web-сайт стандарта, где можно получить дополнительную
информацию,— http://www.Linicocle.org/.

</p>
<p>Итак, используя простейшую кодировку ASCII, можно ввести
произ­вольную последовательность символов Unicode. Далее будет
показано, что Unicode используется не для
всех лексем, а только для тех, для которых важна поддержка многих языков, а
именно: комментарии, идентификато­ры, символьные и строковые литералы. Для
записи остальных лексем вполне достаточно ASCII-символов.

</p>
<p> 

</p>
<p>Анализ программы

</p>
<p>Компилятор, анализируя
программу, сразу разделяет ее на:

</p>
<p>•   
пробелы (white spaces);

</p>
<p>•   
комментарии (comments);

</p>
<p>•   
основные лексемы (tokens).

</p>
<p> 

</p>
<p>Пробелы

</p>
<p>Пробелами в данном случае называют все символы, разбивающие текст
программы на лексемы. Это как сам символ пробела (space, \u0020, десятичный код 32), так и знаки табуляции и перевода строки. Они ис­пользуются
для разделения лексем, а также для оформления кода, чтобы его было легче
читать. Например, следующую часть программы (вычисле­ние корней квадратного
уравнения):

</p>
<p> 

</p>
<p>double а = 1, b = 1, с = 6; double D = b * b - 4 * а * с;

</p>
<p>if (D &gt;=0) {

</p>
<p>double х1 = (-b + Math.sqrt (D)) / (2 * а); double х2 - (-b - Math.sqrt
(D)) / (2 * а);

</p>
<p>}

</p>
<p>можно записать и в таком виде:

</p>
<p> 

</p>
<p>double
a=1,b=1,c=6;double D=b*b-4*a*c;if(D&gt;=0) {double

</p>
<p>x1
=(-b+Math.sqrt(D))/(2*a);double x2=(-b-Math.sqrt(D))/(2*a);}

</p>
<p>В обоих случаях компилятор сгенерирует абсолютно одинаковый код.
Единственное соображение, которым должен руководствоваться разработчик,—
легкость чтения и дальнейшей поддержки такого кода.

</p>
<p>Для разбиения текста на строки в ASCII используется два символа -"возврат каретки" (carriage return, CR, \u000d, десятичный код 13) и сим­вол новой строки (linefeed, LF, \u000a, десятичный код 10)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Чтобы не за­висеть от особенностей используемой
платформы, в Java применяется на­иболее
гибкий подход. Завершением строки считается:

</p>
<p>•   
ASCII-символ LF, символ новой строки;

</p>
<p>•   
ASCII-символ CR, "возврат каретки";

</p>
<p>•   
символ CR, за которым сразу же следует символ LF. Разбиение на строки важно для корректного разбиения на лексемы

</p>
<p>(как уже говорилось, завершение строки также служит
разделителем меж­ду лексемами), для правильной работы со строковыми
комментариями (см. следующую тему "Комментарии"), а также для вывода
отладочной информации (при выводе ошибок компиляции и времени исполнения
указывается, на какой строке исходного кода они возникли). Итак, пробелами в Java считаются:

</p>
<p>•  ASCII-символ SP, space, пробел, \u0020, десятичный код 32;

</p>
<p>•   
ASCII-символ НТ, horizontal tab, символ горизонтальной табу­ляции, \u0009, десятичный код 9;

</p>
<p>•   
ASCII-символ FF, form feed, символ перевода
страницы (был вве­ден для работы с принтером), \u000c, десятичный код 12;

</p>
<p>•   
завершение строки.

</p>
<p> 

</p>
<p>Комментарии

</p>
<p>Комментарии не влияют на
результирующий бинарный код и ис­пользуются только для ввода пояснений к
программе. В Java комментарии бывают двух видов:

</p>
<p>•   
строчные

</p>
<p>•   
блочные








</p>
<p>Курс




</p>
<p>Программирование
на Java




</p>
<p>Лексика
языка








</p>
<p> 








</p>
<p>Строчные комментарии начинаются с ASCII-символов // и
длятся до конца текущей строки. Как правило, они используются для пояснения
именно этой строки, например:

</p>
<p>int у=1970; // год рождения

</p>
<p>Блочные комментарии располагаются между ASCII-символами /* и */,
могут занимать произвольное количество строк, например:

</p>
<p> 

</p>
<p>/*

</p>
<p>Этот цикл не может начинаться с нуля из-за особенностей алгоритма

</p>
<p>7

</p>
<p>for (int i=1; К10; i++) { }

</p>
<p>Часто блочные комментарии оформляют следующим образом (каж­дая строка
начинается с *):

</p>
<p> 

</p>
<p>Г

</p>
<p>* 
Описание алгоритма работы

</p>
<p>* 
следующего цикла while

</p>
<p>7

</p>
<p>while (х &gt; 0) { }

</p>
<p>Блочный комментарий не обязательно должен располагаться на не­скольких
строках, он может даже находиться в середине оператора:

</p>
<p> 

</p>
<p>float s = 2*Math.PI/*getRadius()7; // Закомментировано для отладки

</p>
<p>В этом примере блочный комментарий разбивает арифметические операции.
Выражение Math.PI предоставляет значение константы PI, опре­деленное в
классе Math. Вызов метода getRadius()
теперь закомментирован и
не будет произведен, переменная s всегда будет принимать значение 2 PI. Завершает строку
строчный комментарий.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Комментарии не могут находиться в символьных и строковых лите­ралах,
идентификаторах (эти понятия подробно рассматриваются далее в этой лекции).
Следующий пример содержит случаи неправильного при­менения комментариев:

</p>
<p>// В этом примере текст
/*...*/ станет просто частью строки s

</p>
<p>String s = "text/*just
text7";

</p>
<p>/*

</p>
<p>* 
Следующая строка станет
причиной ошибки при компиляции,

</p>
<p>* 
так как комментарий разбил
имя метода getRadius()

</p>
<p>7

</p>
<p>circle.
get/*comment7Radius(); А такой код допустим:

</p>
<p>// Комментарий может
разделять вызовы функций: cirle./*commerrt7getRadius();

</p>
<p>// Комментарий может
заменять пробелы: int/*comment7x=1 ;

</p>
<p>В последней строке
между названием типа данных int и названием йеременной х обязательно должен быть пробел или, как в
данном примере, комментарий.

</p>
<p>Комментарии не могут быть вложенными. Символы /*, */. // не име­ют
никакого особенного значения внутри уже открытых комментариев, как строчных, так и
блочных. Таким образом, в примере

</p>
<p> 

</p>
<p>/* начало комментария /* ///** завершение тут: */

</p>
<p> 

</p>
<p>описан только один блочный комментарий. А в следующем примере (строки
кода пронумерованы для удобства)

</p>
<p> 

</p>
<p>1.   г

</p>
<p>2.          comment

</p>
<p>4.        
more comments

</p>
<p>5.        
7

</p>
<p>6.        
finish

</p>
<p>7.   7

</p>
<p> 

</p>
<p>компилятор выдаст
ошибку. Блочный комментарий начался в строке 1 с комбинации символов /*. Вторая открывающая комбинация /* на строке 3 будет проигнорирована, так как находится уже внутри комментария. Символы
7 в строке 5 завершат его, а строка 7 породит ошибку — попыт­ка закрыть комментарий, который не был начат.

</p>
<p>Любые комментарии полностью удаляются из программы во время компиляции,
поэтому их можно использовать неограниченно, не опаса-

</p>
<p>87

</p>
<p>ясь, что это повлияет на бинарный код. Основное их
предназначение -сделать программу простой для понимания, в том числе и для
других раз­работчиков, которым придется в ней разбираться по какой-либо причи­не.
Также комментарии зачастую используются для временного исключе­ния частей кода,
например:

</p>
<p>intx = 2; int у = 0;

</p>
<p>/*

</p>
<p>if (х &gt; 0)

</p>
<p>у = у + х*2; else

</p>
<p>у = -у - х*4;

</p>
<p>7

</p>
<p>У = У*У;// + 2*х;

</p>
<p>В этом примере закомментировано выражение if-else и оператор сложения +2*х.

</p>
<p>Как уже говорилось выше, комментарии можно писать символами Unicode, то есть на любом
языке, удобном разработчику.

</p>
<p>Кроме этого, существует особый вид блочного комментария -комментарий
разработчика
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Он применяется для автоматического со­здания документации кода. В
стандартную поставку JDK, начиная с версии 1.0, входит специальная утилита javadoc. На вход ей
подается исходный код классов, а на выходе получается удобная документация в HTML-формате, которая
описывает все классы, все их поля и методы. При этом активно используются
гиперссылки, что существенно упро­щает изучение программы (например, читая
описание метода, можно с помощью одного нажатия мыши перейти на описание типов,
использу­емых в качестве аргументов или возвращаемого значения). Однако по­нятно,
что одного названия метода и перечисления его аргументов не­достаточно для
понимания его работы. Необходимы дополнительные пояснения от разработчика.

</p>
<p>Комментарий разработчика записывается так же, как и блочный.
Единственное различие в начальной комбинации символов — для доку­ментации
комментарий необходимо начинать с /**. Например:

</p>
<p>* 
Вычисление модуля целого
числа.

</p>
<p>* 
Этот метод возвращает

</p>
<p>* 
абсолютное значение
аргумента х.

</p>
<p>7

</p>
<p>int getAbs(intx) { if (х&gt;=0)

</p>
<p>return х; else

</p>
<p>return -x;

</p>
<p>}

</p>
<p>Первое предложение должно содержать краткое резюме всего комментария. В
дальнейшем оно будет использовано как пояснение этой функции в списке всех
методов класса (ниже будут описаны все конструкции языка, для которых
применяется комментарий разра­ботчика).

</p>
<p>Поскольку в результате создается HTML-документация, то и
ком­ментарий необходимо писать по правилам HTML. Допускается
примене­ние тегов, таких как &lt;Ь&gt; и &lt;р&gt; . Однако теги заголовков с &lt;h1 &gt; по &lt;h6&gt; и &lt;hr&gt; использовать
нельзя, так как они активно применяются javadoc для создания структуры документации.

</p>
<p>Символ * в начале каждой строки и предшествующие ему пробелы и знаки
табуляции игнорируются. Их можно не использовать вообще, но они удобны, когда
необходимо форматирование, скажем, в примерах кода.

</p>
<p> 

</p>
<p>j-k-k

</p>
<p>*  
Первое предложение -
краткое описание метода.

</p>
<p>*  
&lt;р&gt;

</p>
<p>*  
Так оформляется пример
кода:

</p>
<p>*  
&lt;blockquote&gt;

</p>
<p>*  
&lt;рге&gt;

</p>
<p>*  
if
(condition==true) {

</p>
<p>x = getWidht(); у =
x.getHeight();

</p>
<p>*   }

</p>
<p>*  
&lt;/pre&gt;&lt;/blockquote&gt;

</p>
<p>*  
Атак описывается HTML-список:

</p>
<p>*  
&lt;ul&gt;

</p>
<p>*  
&lt;П&gt;Можно
использовать наклонный шрифт &lt;i&gt;KypcnB&lt;/i&gt;,

</p>
<p>*  
&lt;Н&gt;или жирный
&lt;Ь&gt;жирный&lt;/Ь&gt;.

</p>
<p>*  
&lt;/ul&gt; 7

</p>
<p>public void
calculate (int x, int y) { }

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Из этого комментария будет сгенерирован HTML-код, выглядящий
примерно так:

</p>
<p> 

</p>
<p>Первое предложение -
краткое описание метода.

</p>
<p> 

</p>
<p>Так оформляется пример
кода:

</p>
<p>if (condition==true) { x = gerWidht(); у = x.getHeight();

</p>
<p>}

</p>
<p>А так описывается HTML-список:

</p>
<p>•      
Можно использовать
наклонный шрифт курсив,

</p>
<p>•      
или жирный жирный.

</p>
<p>Наконец, javadoc поддерживает
специальные теги. Они начинаются с символа @. Подробное описание этих тегов
можно найти в документа­ции. Например, можно использовать тег @see, чтобы сослаться
на другой класс, поле или метод, или даже на другой Internet-сайт.

</p>
<p>*  
Краткое описание.

</p>
<p>*  
Развернутый комментарий.

</p>
<p>*

</p>
<p>*  
@see java.lang.String

</p>
<p>*  
@see java.lang.Math#PI

</p>
<p>*   @see &lt;a href="java.sun.com"&gt;Official
Java site&lt;/a&gt;

</p>
<p>7

</p>
<p>Первая ссылка указывает на класс String Qava.lang - название биб­лиотеки, в которой находится этот класс), вторая - на
поле PI класса Math (символ # разделяет название класса и его полей или методов), тре­тья
ссылается на официальный сайт Java.

</p>
<p>Комментарии
разработчика могут быть записаны перед объявлением классов, интерфейсов, полей,
методов и конструкторов. Если записать комментарий /**...*/ в другой части
кода, то ошибки не будет, но он не по­падет в документацию, генерируемую javadoc. Кроме того, можно
описать пакет (так называются библиотеки, или модули, в Java). Для этого необхо­димо
создать специальный файл package.html, сохранить в нем коммента­рий и поместить его в каталог пакета. HTML-текст,
содержащийся между тегами &lt;body&gt; и &lt;/body&gt;, будет помещен в документацию, а первое пред­ложение будет
использоваться для краткой характеристики этого пакета.

</p>
<p>Все классы стандартных библиотек Java поставляются в виде исход­ного текста и можно увидеть, как хорошо они
комментированы. Стан­дартная документация по этим классам сгенерирована
утилитой javadoc. Для любой программы также можно подготовить подобное описание, не­обходимы
лишь грамотные и аккуратные комментарии в исходном коде. Кроме того, Java предоставляет возможность генерировать с помощью javadoc документацию с нестандартным внешним видом.

</p>
<p> 

</p>
<p>Лексемы

</p>
<p>Итак, мы рассмотрели пробелы (в широком смысле этого слова, т.е. все
символы, отвечающие за форматирование текста программы) и ком­ментарии,
применяемые для ввода пояснений к коду. С точки зрения программиста они
применяются для того, чтобы сделать программу более читаемой и понятной для
дальнейшего развития.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>С точки зрения компилятора, а точнее его части, отвечающей за лек­сический
разбор, основная роль пробелов и комментариев — служить раз­делителями между
лексемами, причем сами разделители далее отбрасыва­ются и на компилированный
код не влияют. Например, все следующие примеры объявления переменной
эквивалентны:

</p>
<p> 

</p>
<p>// Используем пробел в
качестве разделителя, int х = 3 ;

</p>
<p> 

</p>
<p>// здесь разделителем
является перевод строки int

</p>
<p>x

</p>
<p> 

</p>
<p>3

</p>
<p> 

</p>
<p> 

</p>
<p>// здесь разделяем знаком
табуляции int х = 3 ;

</p>
<p> 

</p>
<p>/*

</p>
<p>*  Единственный принципиально необходимый разделитель

</p>
<p>*  между названием типа данных int и именем переменной
х

</p>
<p>* 
здесь описан комментарием
блочного типа.

</p>
<p>7

</p>
<p>int/**/x=3;

</p>
<p>Конечно, лексемы очень разнообразными именно они определяют многие
свойства языка. Рассмотрим все их виды более подробно.

</p>
<p> 

</p>
<p>Виды лексем

</p>
<p>Ниже перечислены все виды
лексем в Java:

</p>
<p>•   
идентификаторы (identifiers);

</p>
<p>•   
ключевые слова (key words);

</p>
<p>•   
литералы (literals);

</p>
<p>•   
разделители (separators);

</p>
<p>•   
операторы (operators). Рассмотрим их по отдельности.

</p>
<p> 

</p>
<p>Идентификаторы

</p>
<p>Идентификаторы - это имена, которые даются различным элементам языка для
упрощения доступа к ним. Имена имеют пакеты, классы, ин­терфейсы, поля, методы,
аргументы и локальные переменные (все эти по­нятия подробно рассматриваются в
следующих лекциях). Идентификато­ры можно записывать символами Unicode, то есть на любом
удобном язы­ке. Длина имени не ограничена.

</p>
<p>Идентификатор состоит из букв и цифр. Имя не может начинаться с цифры. Java-буквы,
используемые в идентификаторах, включают в себя ASCII-символы A-Z (\u0041-\u005a), a-z (\u0061-\u007a), а также знаки подчеркивания _ (ASCII underscore, \u005f) и доллара $ (\u0024). Знак дол­лара используется только при автоматической генерации кода
(чтобы ис­ключить случайное совпадение имен), либо при использовании каких-ли­бо
старых библиотек, в которых допускались имена с этим символом. Java-цифры включают в
себя обычные ASCII-цифры 0-9 (\u0030-\u0039).

</p>
<p>Для идентификаторов не допускаются совпадения с зарезервирован­ными
словами (это ключевые слова, булевские литералы true и false и null-литерал null). Конечно, если 2 идентификатора включают в себя разные буквы, которые
одинаково выглядят (например, латинская и русская буквы А), то они считаются
различными.

</p>
<p>В этой лекции уже
применялись следующие идентификаторы:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Character, а, Ь, с, D, х1, х2, Math, sqrt, х, у, i, s, PI, getRadius,

</p>
<p>circle, getAbs, calculate, condition, getWidth, getHeight, java,

</p>
<p>lang, String

</p>
<p>Также допустимыми являются идентификаторы: Компьютер, COLOR_RED, _, aVeryLongNameOfTheMethod

</p>
<p>Ключевые
слова

</p>
<p>Ключевые слова — это зарезервированные слова, состоящие из А8СП-символов
и выполняющие различные задачи языка. Вот их полный список (48 слов):

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="69" valign="top">
  <p>abstract
  </p>
</td>
  <td width="81" valign="top">
  <p>default
  </p>
</td>
  <td width="98" valign="top">
  <p>if
  </p>
</td>
  <td width="95" valign="top">
  <p>private
  </p>
</td>
  <td width="61" valign="top">
  <p>this
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>boolean
  </p>
</td>
  <td width="81" valign="top">
  <p>do
  </p>
</td>
  <td width="98" valign="top">
  <p>implements
  </p>
</td>
  <td width="95" valign="top">
  <p>protected
  </p>
</td>
  <td width="61" valign="top">
  <p>throw
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>break
  </p>
</td>
  <td width="81" valign="top">
  <p>double
  </p>
</td>
  <td width="98" valign="top">
  <p>import
  </p>
</td>
  <td width="95" valign="top">
  <p>public
  </p>
</td>
  <td width="61" valign="top">
  <p>throws
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>byte
  </p>
</td>
  <td width="81" valign="top">
  <p>else
  </p>
</td>
  <td width="98" valign="top">
  <p>instanceof
  </p>
</td>
  <td width="95" valign="top">
  <p>return
  </p>
</td>
  <td width="61" valign="top">
  <p>transient
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>case
  </p>
</td>
  <td width="81" valign="top">
  <p>extends
  </p>
</td>
  <td width="98" valign="top">
  <p>int
  </p>
</td>
  <td width="95" valign="top">
  <p>short
  </p>
</td>
  <td width="61" valign="top">
  <p>try
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>catch
  </p>
</td>
  <td width="81" valign="top">
  <p>final
  </p>
</td>
  <td width="98" valign="top">
  <p>interface
  </p>
</td>
  <td width="95" valign="top">
  <p>static
  </p>
</td>
  <td width="61" valign="top">
  <p>void
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>char
  </p>
</td>
  <td width="81" valign="top">
  <p>finally
  </p>
</td>
  <td width="98" valign="top">
  <p>long
  </p>
</td>
  <td width="95" valign="top">
  <p>strictfp
  </p>
</td>
  <td width="61" valign="top">
  <p>volatile
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>class
  </p>
</td>
  <td width="81" valign="top">
  <p>float
  </p>
</td>
  <td width="98" valign="top">
  <p>native
  </p>
</td>
  <td width="95" valign="top">
  <p>super
  </p>
</td>
  <td width="61" valign="top">
  <p>while
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>const
  </p>
</td>
  <td width="81" valign="top">
  <p>for
  </p>
</td>
  <td width="98" valign="top">
  <p>new
  </p>
</td>
  <td width="95" valign="top">
  <p>switch
  </p>
</td>
  <td width="61" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>continue
  </p>
</td>
  <td width="81" valign="top">
  <p>goto
  </p>
</td>
  <td width="98" valign="top">
  <p>package
  </p>
</td>
  <td width="95" valign="top">
  <p>synchronized
  </p>
</td>
  <td width="61" valign="top">
  <p> 
  </p>
</td>
 </tr>
</table>

<p>Ключевые слова goto и const зарезервированы, но не используются. Это сделано для того, чтобы
компилятор мог правильно отреагировать на их использование в других языках. Напротив, оба булевских литерала true, false и null-литерал null часто считают ключевыми
словами (возмож­но, потому, что многие средства разработки подсвечивают их
таким же образом), однако это именно литералы.

</p>
<p>Значение всех ключевых слов будет рассматриваться в следующих лекциях.

</p>
<p> 

</p>
<p>Литералы

</p>
<p>Литералы позволяют задать в программе значения для числовых, символьных
и строковых выражений, а также null-литералов. Всего в Java определены следующие виды литералов:

</p>
<p>•   
целочисленный (integer);

</p>
<p>•   
дробный (floating-point);

</p>
<p>•   
булевский (boolean);

</p>
<p>•   
символьный (character);

</p>
<p>•   
строковый (string);

</p>
<p>•   
null-литерал (null-literal). Рассмотрим их по отдельности.

</p>
<p>Целочисленные литералы

</p>
<p>Целочисленные литералы позволяют задавать целочисленные зна­чения в
десятеричном, восьмеричном и шестнадцатеричном виде. Деся­теричный формат
традиционен и ничем не отличается от правил, приня­тых в других языках.
Значения в восьмеричном виде начинаются с нуля, и, конечно, использование цифр
8 и 9 запрещено. Запись шестнадцате-ричных чисел начинается с Ох или ОХ (цифра
0 и латинская ASCII-буква X в произвольном регистре). Таким образом, ноль можно записать
тремя различными способами:

</p>
<p> 

</p>
<p>О

</p>
<p>00 0x0

</p>
<p>Как обычно, для записи цифр 10-15 в шестнадцатеричном формате
используются буквы А, В, С, D, Е, F, заглавные или
прописные. Примеры таких литералов:

</p>
<p> 

</p>
<p>OxaBcDeF, OxCafe, OxDEC

</p>
<p> 

</p>
<p>Типы данных рассматриваются ниже, однако здесь необходимо упомянуть два
целочисленных типа int и long длиной 4 и 8 байт, соответственно (или 32 и 64 бита, соответственно).
Оба эти типа знаковые, т.е. тип int хранит значения от -231 до 23,-1, или от
-2.147.483.648 до 2.147.483.647. По умолчанию целочисленный литерал имеет тип int, а значит, в
программе допустимо использовать литералы только от 0 до 2147483648, иначе
возникнет ошибка компиляции
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> При этом литерал 2147483648 можно использовать
только как аргумент унарного оператора -:

</p>
<p> 

</p>
<p>int х = -2147483648; \\верно

</p>
<p>int у = 5-2147483648; \\
здесь возникнет ошибка компиляции

</p>
<p> 

</p>
<p>Соответственно, допустимые литералы в восьмеричной записи долж­ны быть
от 00 до 017777777777 (=231-1), с унарным оператором - допусти­мо
также -020000000000 (= -231). Аналогично для шестнадцатеричного
формата - от 0x0 до 0x7fffffff (=23,-1), а также -0x80000000 (= -231).

</p>
<p>Тип long имеет длину 64 бита, а значит, позволяет хранить значения от -263
до 263-1. Чтобы ввести такой литерал, необходимо в конце поста­вить
латинскую букву L или I, тогда все значение будет трактоваться как long. Аналогично можно выписать
максимальные допустимые значения для них:

</p>
<p>9223372036854775807L

</p>
<p>0777777777777777777777L

</p>
<p>0x7fffffffffffffffL

</p>
<p>//
наибольшие отрицательные значения: -9223372036854775808L -01000000000000000000000L -0x8000000000000000L

</p>
<p>Другие примеры целочисленных литералов типа long: 0L, 1231, OxCOBOL

</p>
<p> 

</p>
<p>Дробные литералы

</p>
<p>Дробные литералы представляют собой числа с плавающей десятич­ной
точкой. Правила записи таких чисел такие же, как и в большинстве современных
языков программирования.

</p>
<p>Примеры:

</p>
<p> 

</p>
<p>3.14 2.

</p>
<p>.5

</p>
<p>7е10 3.1Е-20

</p>
<p>Таким образом, дробный литерал состоит из следующих составных частей:

</p>
<p>•   
целая часть;

</p>
<p>•   
десятичная точка
(используется ASCII-символ точка);

</p>
<p>•   
дробная часть;

</p>
<p>•   
показатель степени
(состоит из латинской ASCII-буквы Е в про­извольном регистре и целого числа с опциональным знаком +
или -);

</p>
<p>•   
окончание-указатель типа.

</p>
<p>Целая и дробная части записываются десятичными цифрами, а ука­затель
типа (аналог указателя L или I для
целочисленных литералов типа long)

</p>
<p>имеет два возможных значения - латинская ASCII-буква D (для ти­па double) или F (для типа float) в произвольном
регистре. Они будут по­дробно рассмотрены ниже.

</p>
<p>Необходимыми частями
являются:

</p>
<p>•   
хотя бы одна цифра в целой
или дробной части;

</p>
<p>•   
десятичная точка или
показатель степени, или указатель типа.

</p>
<p>Все остальные части необязательные. Таким образом,
"минимальные" дробные литералы могут быть записаны, например, так:

</p>
<p>1. .1

</p>
<p>1е1 1f

</p>
<p>В Java есть два дробных
типа, упомянутые выше, - float и double. Их длина - 4 и 8 байт или 32 и 64 бита, соответственно. Дробный литерал
имеет тип float, если он заканчивается на латинскую букву F в произволь­ном регистре
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В противном случае он рассматривается как
значение типа double и может включать в себя
окончание D или d, как признак типа double (используется только для наглядности).

</p>
<p> 

</p>
<p>//float-литералы:

</p>
<p>1f, 3.14F, Of, 1e+5F

</p>
<p>// double-литералы:

</p>
<p>0., 3.14d, 1e-4, 31.34E45D

</p>
<p>В Java дробные числа 32-битного типа float и 64-битного типа dou­ble хранятся в памяти в бинарном виде в формате, стандартизированном спецификацией IEEE
754 (полное название — IEEE Standard for Binary Floating-Point Arithmetic,
ANSI/IEEE Standard 754-1985 (IEEE, New York)). В этой спецификации описаны не только конечные дробные вели­чины, но и
еще несколько особых значений, а именно:

</p>
<p>•   положительная и отрицательная бесконечности (positive/negative infinity);

</p>
<p>•   значение "не число", Not-a-Number, сокращенно NaN;

</p>
<p>•   положительный и отрицательный нули.

</p>
<p>Для этих значений нет специальных обозначений. Чтобы получить та­кие
величины, необходимо либо произвести арифметическую операцию (на­пример,
результатом деления ноль на ноль 0.0/0.0 является NaN), либо обра­титься
к константам в классах Float и Double, а именно POSIT1VEJNFINITY, NEGATIVEJNFINITY и NaN. Более подробно ра­бота
с этими особенными значениями рассматривается в следующей лекции.

</p>
<p>Типы данных накладывают
ограничения на возможные значения ли­тералов, как и для целочисленных типов.
Максимальное положительное конечное значение дробного литерала:

</p>
<p>•   для float: 3.40282347e+38f

</p>
<p>•   для double: 1.79769313486231570е+308

</p>
<p>Кроме того, для дробных величин становится важным еще одно Предельное значение — минимальное положительное ненулевое значение:

</p>
<p>•   
для float: 1.40239846e-45f

</p>
<p>•   
для double: 4.94065645841246544e-324

</p>
<p>Попытка указать литерал со слишком большим абсолютным значе­нием
(например, 1 e40F) приведет к ошибке компиляции. Такая величина должна представляться
бесконечностью. Аналогично, указание литерала со слишком малым ненулевым
значением (например, 1е-350) также при­водит к ошибке. Это значение должно быть округлено до нуля.
Однако ес­ли округление приводит не к нулю, то компилятор произведет его сам:

</p>
<p>//
ошибка, выражение должно быть округлено до О

</p>
<p>0.0000000000000000000000000000000000000000000001f

</p>
<p>//
ошибки нет, компилятор сам округляет до 1

</p>
<p>1.0000000000000000000000000000000000000000000001f

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>' Стандартных
возможностей вводить дробные значения не в десятич­ной системе в Java нет, однако классы Float и Double предоставляют много вспомогательных методов, в том числе и для такой
задачи.

</p>
<p> 

</p>
<p>Логические литералы

</p>
<p>Логические литералы имеют два возможных значения — true и false. Эти
два зарезервированных
слова не являются ключевыми, но также не могут использоваться в качестве
идентификатора.

</p>
<p> 

</p>
<p>Символьные литералы

</p>
<p>Символьные литералы описывают один символ из набора Unicode, заключенный в
одиночные кавычки, или апострофы (ASCII-символ sin­gly quote, \u0027). Например:

</p>
<p>'а'
// латинская буква а '' // пробел

</p>
<p>'К'
// греческая буква каппа

</p>
<p> 

</p>
<p>Также допускается специальная запись для описания символа через его код (см. тему
"Кодировка"). Примеры:

</p>
<p>'\u0041' //
латинская буква А '\u0410' // русская буква А '\u0391' // греческая буква А

</p>
<p>Символьный литерал должен содержать строго один символ, или специальную
последовательность, начинающуюся с \. Для записи специ­альных символов
(неотображаемых и служебных, таких как ",', \) исполь­зуются следующие
обозначения:

</p>
<p> 

</p>
<p>\Ь \u0008  backspace BS - забой

</p>
<p>\х \u0009 horizontal tab НТ- табуляция

</p>
<p>\п \u000a  linefeed LF - конец строки

</p>
<p>\f \u000c form feed FF - конец страницы

</p>
<p>\r \u000d
carriage return CR - возврат каретки

</p>
<p>\" \u0022 
double quote " - двойная кавычка

</p>
<p>V \u0027
single quote ' - одинарная кавычка

</p>
<p>\\ \u005c  backslash \ - обратная косая черта

</p>
<p>\восьмеричный код

</p>
<p>от \u0000 до \u00ff символа в
восьмеричном формате.

</p>
<p> 

</p>
<p>Первая колонка описывает стандартные обозначения специальных символов,
используемые в Java-программах. Вторая колонка представляет их в стандартном виде Unicode-символов. Третья
колонка содержит анг­лийские и русские описания. Использование \ в комбинации с
другими символами приведет к ошибке компиляции.

</p>
<p>Поддержка ввода символов через восьмеричный код обеспечивается для
совместимости с С. Например:

</p>
<p> 

</p>
<p>'\101 ' // Эквивалентно '\u0041 '

</p>
<p> 

</p>
<p>Однако таким образом можно задать лишь символы от \u0000 до \u00ff (т.е. с кодом от 0
до 255), поэтому Unicode-последовательности предпочтительней.

</p>
<p>Поскольку обработка Unicode-последовательностей (\uhhhh) произво­дится раньше лексического анализа, то следующий пример
является ошибкой:

</p>
<p> 

</p>
<p>'\u000a' // символ конца
строки

</p>
<p> 

</p>
<p>Компилятор сначала преобразует \u000a в символ конца
строки и кавычки окажутся на разных строках кода, что является ошибкой. Необ­ходимо
использовать специальную последовательность:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>'\п' // правильное
обозначение конца строки

</p>
<p> 

</p>
<p>Аналогично и для символа \u000d (возврат каретки)
необходимо ис­пользовать обозначение \г.

</p>
<p>Специальные символы можно использовать в составе как символь­ных, так и
строковых литералов.

</p>
<p> 

</p>
<p>Строковые литералы

</p>
<p>Строковые литералы состоят из набора символов и записываются в двойных
кавычках. Длина может быть нулевой или сколь угодно боль­шой. Любой символ может быть представлен специальной последова­тельностью,
начинающейся с \ (см. "Символьные литералы").

</p>
<p>""
// литерал нулевой длины

</p>
<p>"\""
//литерал, состоящий из одного символа "

</p>
<p>"Простой
текст" //литерал длины 13

</p>
<p>Строковый литерал нельзя разбивать на несколько строк в коде про­граммы.
Если требуется текстовое значение, состоящее из нескольких строк, то необходимо
воспользоваться специальными символами \п и/или \г. Если же текст просто
слишком длинный, чтобы уместиться на одной строке кода, можно использовать
оператор конкатенации строк +. Примеры строковых литералов:

</p>
<p>//
выражение-константа, составленное из двух литералов "Длинный текст "
+ "с переносом" /*

</p>
<p>* 
Строковый литерал, содержащий текст из
двух строк:

</p>
<p>* 
Hello, world!

</p>
<p>* 
Hello!

</p>
<p>7

</p>
<p>"Hello,
world!\r\nHello!"

</p>
<p>На строковые литералы распространяются те же правила, что и на сим­вольные
в отношении использования символов новой строки \u000a и \u000d.

</p>
<p>Каждый строковый литерал является экземпляром класса String. Это определяет
некоторые необычные свойства строковых литералов, ко­торые будут рассмотрены в
следующей лекции.

</p>
<p> 

</p>
<p>Null-литерал

</p>
<p>Null-литерал может
принимать всего одно значение: null. Это литерал ссылочного типа, причем эта ссылка никуда не ссылается,
объект отсутст-вУет. Разумеется, его можно применять к ссылкам
любого объектного типа Д^ных. Типы данных подробно рассматриваются в следующей
лекции.

</p>
<p>Разделители

</p>
<p>Разделители - это специальные символы, которые используются в служебных
целях языка. Назначение каждого из них будет рассмотрено по ходу изложения
курса. Вот их полный список:

</p>
<p> 

</p>
<p>()[]{};&#9632;,

</p>
<p> 

</p>
<p>Операторы

</p>
<p>Операторы используются в различных операциях — арифметичес­ких,
логических, битовых, операциях сравнения и присваивания. Следу­ющие 37 лексем
(все состоят только из ASCII-символов) являются опера­торами языка Java:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="21" valign="top">
  <p>-
  </p>
</td>
  <td width="28" valign="top">
  <p>&gt; 
  </p>
</td>
  <td width="36" valign="top">
  <p>&lt; 
  </p>
</td>
  <td width="36" valign="top">
  <p>і
  </p>
</td>
  <td width="75" valign="top">
  <p>?
  </p>
</td>
  <td width="43" valign="top">
  <p> 
  </p>
</td>
  <td width="39" valign="top">
  <p> 
  </p>
</td>
  <td width="40" valign="top">
  <p> 
  </p>
</td>
  <td width="75" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>- -
  </p>
</td>
  <td width="28" valign="top">
  <p>&lt;-
  </p>
</td>
  <td width="36" valign="top">
  <p>&gt;=
  </p>
</td>
  <td width="36" valign="top">
  <p>!=
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;&amp;   &#161;1
  </p>
</td>
  <td width="43" valign="top">
  <p>++
  </p>
</td>
  <td width="39" valign="top">
  <p>--
  </p>
</td>
  <td width="40" valign="top">
  <p> 
  </p>
</td>
  <td width="75" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>+
  </p>
</td>
  <td width="28" valign="top">
  <p>-
  </p>
</td>
  <td width="36" valign="top">
  <p>*
  </p>
</td>
  <td width="36" valign="top">
  <p>/
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;   1
  </p>
</td>
  <td width="43" valign="top">
  <p>Л
  </p>
</td>
  <td width="39" valign="top">
  <p>%
  </p>
</td>
  <td width="40" valign="top">
  <p>«
  </p>
</td>
  <td width="75" valign="top">
  <p>»     »&gt;
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>+=
  </p>
</td>
  <td width="28" valign="top">
  <p>-=
  </p>
</td>
  <td width="36" valign="top">
  <p> 
  </p>
</td>
  <td width="36" valign="top">
  <p>/=
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;= 1=
  </p>
</td>
  <td width="43">
  <p>Л____ 
  </p>
</td>
  <td width="39" valign="top">
  <p>%=
  </p>
</td>
  <td width="40" valign="top">
  <p>«=
  </p>
</td>
  <td width="75" valign="top">
  <p>»=   »=
  </p>
</td>
 </tr>
</table>

<p>Большинство из них вполне очевидны и хорошо известны из других языков
программирования, однако некоторые нюансы в работе с опера­торами в Java все же
присутствуют, поэтому в конце лекции приводятся краткие комментарии к ним.

</p>
<p> 

</p>
<p>Пример
программы

</p>
<p>В заключение для примера приведем простейшую программу (тра­диционное Hello, world!), а затем
классифицируем и подсчитаем исполь­зуемые лексемы:

</p>
<p> 

</p>
<p>public class Demo {

</p>
<p>J-k-k

</p>
<p>* 
Основной метод, с которого начинается
выполнение

</p>
<p>* 
любой Java программы.

</p>
<p>7

</p>
<p>public static void main (String
args[]) { System.out.printlnf'Hello, world!");

</p>
<p>}

</p>
<p>}

</p>
<p>Итак, в приведенной программе есть один комментарий разработчи­ка, 7
идентификаторов, 5 ключевых слов, 1 строковый литерал, 13 разде­лителей и ни
одного оператора. Этот текст можно сохранить в файле Demo.java, скомпилировать й
запустить (работа с JDK и стандартными
утилитами была рассмотрена в первой лекции). Результатом работы будет, как
очевидно:

</p>
<p> 

</p>
<p>Hello, world!

</p>
<p> 

</p>
<p>Дополнение. Работа с
операторами

</p>
<p>Рассмотрим некоторые детали использования операторов в Java. Здесь будут описаны
подробности, относящиеся к работе самих операто­ров. В следующей лекции
детально рассматриваются особенности, возни­кающие при использовании различных
типов данных (например, значе-йие операции 1 /2 равно 0, а 1/2. равно 0.5).

</p>
<p> 

</p>
<p>Операторы присваивания и сравнения

</p>
<p>Во-первых, конечно же, различаются оператор присваивания = и оператор
сравнения ==.

</p>
<p> 

</p>
<p>х = 1 ; // присваиваем переменной х значение 1

</p>
<p>х == 1 // сравниваем значение переменной х с единицей

</p>
<p> 

</p>
<p>Оператор сравнения всегда возвращает булевское значение trae или false. Оператор
присваивания возвращает значение правого операнда. Поэтому обычная опечатка в
языке С, когда эти операторы путают:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компилятора

</p>
<p>if (х=0) {// здесь должен применятся оператор
сравнения ==

</p>
<p> 

</p>
<p>}

</p>
<p>в Java легко устраняется.
Поскольку выражение х=0 имеет числовое зна­чение 0, а не булевское (и тем более
не воспринимается как всегда истин­ное), то компилятор сообщает об ошибке
(необходимо писать х==0). Условие "не равно" записывается как !=.
Например:

</p>
<p> 

</p>
<p>if (х!=0) {

</p>
<p>float f = 1./х;

</p>
<p>}

</p>
<p> 

</p>
<p>Сочетание какого-либо оператора с оператором присваивания = • нижнюю
строку в полном перечне в разделе "Операторы") использу­ется при
изменении значения переменной. Например, следующие две строки эквивалентны:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>х = х + 1; х+= 1;

</p>
<p> 

</p>
<p>Арифметические операции

</p>
<p>Наряду с четырьмя обычными арифметическими операциями +,-,*, /,
существует оператор получения остатка от деления %, который может быть применен
как к целочисленным аргументам, так и к дробным.

</p>
<p>Работа с целочисленными аргументами подчиняется простым пра­вилам. Если
делится значение а на значение Ь, то выражение (а/Ь)*Ь+(а%Ь) должно в точности
равняться а. Здесь, конечно, оператор деления целых чисел / всегда возвращает
целое число. Например:

</p>
<p>9/5 возвращает 1 9/(-5) возвращает -1 (-9)/5 возвращает -1 (-9)/(-5) возвращает 1

</p>
<p> 

</p>
<p>Остаток может быть положительным, только если делимое было по­ложительным.
Соответственно, остаток может быть отрицательным только в случае отрицательного
делимого.

</p>
<p> 

</p>
<p>9%5 возвращает 4 9%(-5) возвращает 4 (-9)%5 возвращает -4 (-9)%(-5)
возвращает -4

</p>
<p> 

</p>
<p>Попытка получить остаток от деления на 0 приводит к ошибке.

</p>
<p>Деление с остатком для дробных чисел может быть произведено по двум
различным алгоритмам. Один из них повторяет правила для целых чисел, и именно
он представлен оператором %. Если в рассмотренном примере деления 9 на 5
перейти к дробным числам, значение остатка во всех вариантах не изменится (оно
будет также дробным, конечно).

</p>
<p>9.0%5.0 возвращает 4.0 9.0%(-5.0) возвращает 4.0 (-9.0)%5.0 возвращает
-4.0 (-9.0)%(-5.0) возвращает -4.0

</p>
<p>Однако стандарт IEEE 754 определяет
другие правила. Такой способ представлен методом стандартного класса Math.lEEEremainder(double f 1, double f2). Результат этого
метода - значение, которое равно f 1 -f2*n, где п — целое число, ближайшее к значению f 1/f2, а если два целых
числа одинаково близки к этому отношению, то выбирается четное. По этому
правилу значение остатка будет другим:

</p>
<p>Math.lEEEremainder(9.0, 5.0) возвращает -1.0 Math.lEEEremainder(9.0, -5.0) возвращает -1.0 Math.lEEEremainder(-9.0, 5.0) возвращает 1.0 Math.lEEEremainder(-9.0, -5.0) возвращает 1.0

</p>
<p>Унарные операторы инкрементации ++ и декрементации --, как обычно, можно
использовать как справа, так и слева.

</p>
<p>int х=1; int у=++х;

</p>
<p>В этом примере оператор ++ стоит перед переменной х, это означает, что
сначала произойдет инкрементация, а затем значение х будет исполь­зовано для
инициализации у. В результате после выполнения этих строк значения х и у будут равны 2.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>int х=1; int у=х++;

</p>
<p>А в этом примере сначала значение х будет использовано для инициализации
у, и лишь затем
произойдет инкрементация. В результате значение х будет равно 2, а у будет равно 1.

</p>
<p> 

</p>
<p>Логические операторы

</p>
<p>Логические операторы "и" и "или" (&amp; и |) можно
использовать в двух вариантах. Это связано с тем, что, как легко убедиться, для
каждого опера­тора возможны случаи, когда значение первого операнда сразу
определяет значение всего логического выражения. Если вторым операндом является
значение некоторой функции, то появляется выбор - вызывать ее или нет, причем
это решение может сказаться как на скорости, так и на функцио­нальности
программы.

</p>
<p>Первый вариант операторов (&amp;, |) всегда вычисляет оба операнда,
второй же - ( &amp;&amp;, 11 ) не будет продолжать вычисления, если значение выражения уже очевидно.
Например:

</p>
<p> 

</p>
<p>int х=1;

</p>
<p>(х&gt;0) | calculate(x) // в таком выражении произойдет вызов calulate (х&gt;0) 11 calculate(x) // а в этом - нет

</p>
<p> 

</p>
<p>Логический оператор отрицания "не" записывается как ! и,
конечно, имеет только один вариант использования. Этот оператор меняет булев­ское
значение на противоположное.

</p>
<p> 

</p>
<p>int х=1;

</p>
<p>х&gt;0 // выражение
истинно !(х&gt;0) // выражение ложно

</p>
<p> 

</p>
<p>Оператор с условием ? : состоит из трех частей - условия и двух выра­жений.
Сначала вычисляется условие (булевское выражение), а на основа­нии результата
значение всего оператора определяется первым выражени­ем в случае получения
истины и вторым - если условие ложно. Например, так можно вычислить модуль
числа х:

</p>
<p> 

</p>
<p>х&gt;0 ? х : -х

</p>
<p> 

</p>
<p>Битовые операции

</p>
<p>Прежде чем переходить к битовым операциям, необходимо уточнить, каким
именно образом целые числа представляются в двоичном виде. Ко­нечно, для
неотрицательных величин это практически очевидно:

</p>
<p>0      
О

</p>
<p>1      
1

</p>
<p>2      
10

</p>
<p>3      
11

</p>
<p>4      
100

</p>
<p>5    
101

</p>
<p> 

</p>
<p>и так далее. Однако как представляются отрицательные числа? Во-пер­вых,
вводят понятие знакового бита. Первый бит начинает отвечать за знак, а именно 0
означает положительное число, 1 — отрицательное. Но не следует думать, что
остальные биты остаются неизменными. Напри­мер, если рассмотреть 8-битовое
представление:

</p>
<p>-1 10000001 //это
НЕВЕРНО! -2 10000010//это НЕВЕРНО! -3 10000011 //это НЕВЕРНО!

</p>
<p>Такой подход неверен! В частности, мы получаем сразу два представления дудя - 00000000 и 100000000, что нерационально. Правильный алгоритм можно
представить себе так. Чтобы получить значение -1, надо из 0 вычесть 1: 00000000

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>-00000001

</p>
<p> 

</p>
<p>-11111111

</p>
<p>Итак, -1 в двоичном виде представляется как 11111111. Продолжаем
применять тот же алгоритм (вычитаем 1):

</p>
<p>0 00000000 -1 11111111 -2 11111110 -3 11111101

</p>
<p>и так далее до
значения 10000000, которое представляет собой наибольшее по модулю
отрицательное число. Для 8-битового представления наиболь­шее положительное число
01111111 (=127), а наименьшее отрицательное 10000000 (=-128). Поскольку всего 8
бит определяет 28=256 значений, причем одно из них отводится для
нуля, то становится ясно, почему наи­большие по модулю положительные й
отрицательные значения различа­ются на единицу, а не совпадают.

</p>
<p>Как известно, битовые операции "и", "или",
"исключающее или" принимают два аргумента и выполняют логическое
действие попарно над соответствующими битами аргументов. При этом используются
те же обозначения, что и для логических операторов, но, конечно, только в
первом (одиночном) варианте. Например, вычислим выражение 5&amp;6:

</p>
<p> 

</p>
<p>00000101    // число 5 в двоичном виде &amp;00000110    //число 6 в двоичном виде

</p>
<p>00000100    //проделали
операцию "и" попарно над битами // в каждой позиции

</p>
<p> 

</p>
<p>То есть выражение 5&amp;6
равно 4.

</p>
<p>Исключение составляет лишь оператор "не" или "NOT", который для
побитовых операций записывается как ~ (для логических было !). Этот оператор
меняет каждый бит в числе на противоположный. Например,

</p>
<p>)=0. Можно легко установить общее правило для получения битового
представления отрицательных чисел:

</p>
<p>Если п - целое положительное число, то -п в битовом представлении Равняется ~(п-1).

</p>
<p>Наконец, осталось
рассмотреть лишь операторы побитового сдвига. В Java есть один оператор сдвига влево и два варианта сдвига вправо. Такое
различие связано с наличием знакового бита.

</p>
<p>При сдвиге влево оператором &lt;&lt; все биты числа смещаются на ука­занное
количество позиций влево, причем освободившиеся справа пози­ции заполняются
нулями. Эта операция аналогична умножению на 2п и действует вполне
предсказуемо, как при положительных, так и при отри­цательных аргументах.

</p>
<p>Рассмотрим примеры применения операторов сдвига для значений типа int, т.е. 32-битных
чисел. Пусть положительным аргументом будет число 20, а отрицательным -21.

</p>
<p> 

</p>
<p>// Сдвиг
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>влево для
положительного числа 20 20 « 00 =
00000000000000000000000000010100 = 20 20 « 01 =00000000000000000000000000101000
= 40 20 « 02 = 00000000000000000000000001010000 = 80 20 «03 = 00000000000000000000000010100000
= 160 20 « 04 = 00000000000000000000000101000000 = 320

</p>
<p> 

</p>
<p>20 « 25 =
00101000000000000000000000000000 = 671088640

</p>
<p>20 « 26 =
01010000000000000000000000000000 = 1342177280

</p>
<p>20 « 27 = 10100000000000000000000000000000 =
-1610612736

</p>
<p>20 « 28 =
01000000000000000000000000000000 = 1073741824

</p>
<p>20 « 29 = 10000000000000000000000000000000 = -2147483648

</p>
<p>20 « 30 =
00000000000000000000000000000000 = о

</p>
<p>20 « 31
=00000000000000000000000000000000 = о

</p>
<p>//
Сдвиг влево для отрицательного числа -21

</p>
<p>-21 «00=
11111111111111111111111111101011 =-21

</p>
<p>-21 «01 =
11111111111111111111111111010110 = -42

</p>
<p>-21 «02 =
11111111111111111111111110101100 =-84

</p>
<p>-21 « 03=11111111111111111111111101011000=-168

</p>
<p>-21 &lt;^ 04 = 11111111111111111111111010110000 = -336

</p>
<p>-21 «
05=11111111111111111111110101100000=-672

</p>
<p>-21 « 25 =
11010110000000000000000000000000 = -704643072 -21 « 26 =
10101100000000000000000000000000 = -1409286144 -21 « 27 =
01011000000000000000000000000000 = 1476395008 -21 « 28 =
10110000000000000000000000000000 = -1342177280 -21 « 29 =
01100000000000000000000000000000 =1610612736 -21 « 30 =
11000000000000000000000000000000 .= -1073741824 -21 « 31 = 10000000000000000000000000000000
= -2147483648

</p>
<p>Как видно из примера, неожиданности возникают тогда, когда $начащие биты
начинают занимать первую позицию и влиять на знак результата.

</p>
<p>При сдвиге вправо все биты аргумента смещаются на указанное коли­чество
позиций, соответственно, вправо. Однако встает вопрос — каким значением
заполнять освобождающиеся позиции слева, в том числе и отве­чающую за знак.
Есть два варианта. Оператор » использует для заполне­ния этих позиций значение
знакового бита, то есть результат всегда имеет тот же знак, что и начальное
значение. Второй оператор »&gt; заполняет их нулями, то есть результат всегда
положительный.

</p>
<p>// Сдвиг вправо для положительного числа 20 // Оператор »

</p>
<p>20 » 00 = 00000000000000000000000000010100 = 20 20 » 01 =
00000000000000000000000000001010 = 10 20 » 02 =
00000000000000000000000000000101 =5 20 » 03 = 00000000000000000000000000000010
= 2 20 » 04 = 00000000000000000000000000000001 = 1 20 » 05 =
00000000000000000000000000000000 = о // Оператор »&gt;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>20 »&gt; 00 = 00000000000000000000000000010100 = 20 20 »&gt; 01 =
00000000000000000000000000001010 = 10 20 »&gt; 02 =
00000000000000000000000000000101 = 5 20 »&gt; 03 =
00000000000000000000000000000010 = 2 20 »&gt; 04 =
00000000000000000000000000000001 = 1 20 »&gt; 05 = 00000000000000000000000000000000
= о

</p>
<p>Очевидно, что для положительного аргумента операторы &gt;&gt; и
&gt;&gt;&gt; Работают совершенно одинаково. Дальнейший сдвиг на большее количе­ство позиций будет также давать нулевой результат.

</p>
<p>// Сдвиг вправо для отрицательного числа -21 // Оператор &gt;&gt;

</p>
<p>-21 » 00 =11111111111111111111111111101011= -21 -21 »01 =
11111111111111111111111111110101 =-11 -21 »02 =
11111111111111111111111111111010 = -6 -21 » 03
=11111111111111111111111111111101 =-3 -21 »04 =
11111111111111111111111111111110 = -2 -21 »05 = 11111111111111111111111111111111
=-1 // Оператор »&gt;

</p>
<p>-21 »&gt; 00 =
11111111111111111111111111101011 = -21

</p>
<p>-21 &gt;» 01
=01111111111111111111111111110101 =2147483637

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="50" colspan="2" valign="top">
  <p>&gt;» 02:
  </p>
</td>
  <td width="261" valign="top">
  <p>=00111111111111111111111111111010=
  </p>
</td>
  <td width="81" valign="top">
  <p>1073741818
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>03
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00011111111111111111111111111101 :
  </p>
</td>
  <td width="81" valign="top">
  <p>= 536870909
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>04
  </p>
</td>
  <td width="261" valign="top">
  <p>=00001111111111111111111111111110=
  </p>
</td>
  <td width="81" valign="top">
  <p>= 268435454
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>05
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000111111111111111111111111111 =
  </p>
</td>
  <td width="81" valign="top">
  <p>=134217727
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>24
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000011111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 255
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>25
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000001111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 127
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>26
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 63
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>27
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000011111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 31
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>28
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000001111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 15
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>29
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000000111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 7
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>&gt;»
  </p>
</td>
  <td width="20" valign="top">
  <p>30
  </p>
</td>
  <td width="261" valign="top">
  <p>=00000000000000000000000000000011
  </p>
</td>
  <td width="81" valign="top">
  <p>= 3
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>31
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000000001
  </p>
</td>
  <td width="81" valign="top">
  <p>= 1
  </p>
</td>
 </tr>
</table>

<p>Как видно из примеров, эти операции аналогичны делению на 2п. При­чем,
если для положительных аргументов с ростом п результат закономерно стремится к
0, то для отрицательных предельным значением является -1.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены основы лексического анализа про­грамм Java. Для их записи
применяется универсальная кодировка ишсос1е,позволяющая использовать любой язык
помимо традиционного английского. Еще раз напомним, что использование Unicode возможно и необходимо в следующих конструкциях:

</p>
<p>•   
комментарии;

</p>
<p>•   
идентификаторы;

</p>
<p>•   
символьные и строковые
литералы.

</p>
<p>Остальные же (пробелы, ключевые слова, числовые,
булевские и null-ли-тералы, разделители и операторы) легко записываются с применением
лишь ASCII-символов. В то же время любой Unicode-символ также мож­но
задать в виде специальной последовательности ASCII-символов.

</p>
<p>Во время анализа компилятор выделяет из текста программы
&lt;про-белы&gt; (были рассмотрены все символы, которые рассматриваются как
пробелы) и комментарии,которые полностью удаляются из кода (были рассмотрены
все виды комментариев, в частности комментарий разра­ботчика). Пробелы и все
виды комментариев служат для разбиения текс­та программы на лексемы. Были
рассмотрены все виды лексем,в том чис­ле все виды литералов.

</p>
<p>В дополнении были рассмотрены особенности применения различ­ных
операторов.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>Как записать в Java-программе символ с кодом 514?

</p>
<p>&#9633;       
'514'

</p>
<p>&#9633;       
\u0546

</p>
<p>&#9633;       
\u222

</p>
<p>&#9633;       
\u0222

</p>
<p> 

</p>
<p>Какие
из перечисленных идентификаторов являются корректными?

</p>
<p>&#9633;       
abc

</p>
<p>&#9633;       
lab

</p>
<p>&#9633;       
_bc

</p>
<p>&#9633;       
_1с$ас

</p>
<p>&#9633;       
$ас

</p>
<p>&#9633;          
for_

</p>
<p>&#9633;       
Int

</p>
<p>&#9633;       
byte

</p>
<p> 

</p>
<p>Каким будет результат следующих
действий?

</p>
<p>1/0 1./0 i/o-

</p>
<p>'\n'+V

</p>
<p>&#9633;       
все 4 операции деления вызовут
ошибку деления на 0, сложение даст "\п\г"

</p>
<p>&#9633;       
результатом всех 4 операций
деления будет POSITIVEJNnNITf,
сложение даст '\п\г'

</p>
<p>&#9633;       
операция 1/0 приведет K/P^MeTM4^b^pos,T|VE INFINITY; следующие
3 операции будут иметь результат РОЫ ivt_

</p>
<p>последнее сложение даст 23








</p>
<p>Вариант
2




</p>
<p>Вариант
3








</p>
<p> 








</p>
<p>Сколько
пробелов в следующем примере кода: intx = 3; int у=1; int z = х+у;

</p>
<p>&#9633;          
7

</p>
<p>&#9633;       
8

</p>
<p>&#9633;       
9

</p>
<p>&#9633;   
11

</p>
<p> 

</p>
<p> 

</p>
<p>2.   Являются ли следующие слова ключевыми:

</p>
<p>&#9633;       
true

</p>
<p>&#9633;       
goto

</p>
<p>&#9633;       
null

</p>
<p>&#9633;       
const

</p>
<p>&#9633;       
false

</p>
<p> 

</p>
<p> 

</p>
<p>Чему
будет равно следующее выражение и значение переменной х после вычислений? int х=0;

</p>
<p>print(++x==x++);

</p>
<p>&#9633;       
true

</p>
<p>&#9633;       
false

</p>
<p>1.      Сколько комментариев в
следующем примере кода:
int х = О; /* text //
text /*

</p>
<p>int у=1;
// text */ // text */

</p>
<p>&#9633;         1
блочный, 0 строчных
П        1
блочный, 1 строчный
Г~1    1 блочный, 2 строчных
П        2
блочных, 3 строчных

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Равны
ли следующие числа:

</p>
<p>&#9633;        
5 и 05

</p>
<p>&#9633;        
9 и 09

</p>
<p>&#9633;    
ЮиОЮ
•&#9633;   0x5Am90L

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Чему будет равно следующее
выражение и значения
переменных х и у после вычислений?

</p>
<p>int х=0,
у=0;

</p>
<p>print((++x==1) || (у++==1));

</p>
<p>&#9633;      
true

</p>
<p>&#9633;      
false








</p>
<p>
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 3.
Лексика
языка</h2></center>

<p> 

</p>
<p> 

</p>
<p>Лекция посвящена описанию
лексики языка Java.

</p>
<p>Лексика описывает, из чего состоит текст программы,
каким образом он записывается и на какие простейшие слова (лексемы) компилятор
разбивает программу при анализе. Лексемы (или tokens в английском
варианте) - это основные "кирпичики", из которых строится любая
программа на языке Java.

</p>
<p>Эта тема раскрывает многие детали внутреннего
устройства языка, и невозможно написать ни одной строчки кода, не затронув ее.
Именно поэтому курс начинается с основ лексического анализа.

</p>
<p> 

</p>
<p>Ключевые слова: ASCII, Unicode, carriage return, linefeed, пробел, javadoc, идентификаторы, underscore, литералы.

</p>
<p> 

</p>
<p>Кодировка

</p>
<p>Технология Java, как платформа, изначально спроектированная для Глобальной сети Internet, должна быть
многоязыковой, а значит, обыч­ный набор символов ASCII (American Standard Code for Information Interchange, Американский стандартный код обмена информацией), включающий в себя
лишь латинский алфавит, цифры и простейшие спе­циальные знаки (скобки, знаки
препинания, арифметические операции и т.д.), недостаточен. Поэтому для записи
текста программы применяется более универсальная кодировка Unicode.

</p>
<p>Как известно, Unicode представляет
символы кодом из 2 байт, опи­сывая, таким образом, 65535 символов. Это
позволяет поддерживать практически все распространенные языки мира. Первые 128
символов совпадают с набором ASCII. Однако понятно, что требуется некоторое специальное обозначение, чтобы
иметь возможность задавать в програм­ме любой символ Unicode, ведь никакая
клавиатура не позволяет вводить более 65 тысяч различных знаков. Эта
конструкция представляет символ Unicode, используя только символы ASCII. Например, если в
программу нужно вставить знак с кодом 6917, необходимо его представить в
шест-надцатеричном формате (1В05) и записать:

</p>
<p> 

</p>
<p>\u1B05,

</p>
<p>причем буква и
должна быть прописной, а шестнадцатеричные циф-РЬ1
А, В, С, D, Е, F можно использовать произвольно, как заглавные, Так и
строчные. Таким образом можно закодировать все символы








</p>
<p>Unicode от \u0000 до \uFFFF. Буквы русского алфавита начинаются с \u0410 (только буква Ё имеет код \u0401) по \u044F (код буквы ё \u0451). В последних версиях JDK в состав
демонстрационных при­ложений и апплетов входит небольшая программа SymbolTest, позво­ляющая просматривать весь набор символов Unicode
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Ее аналог не­сложно
написать самостоятельно. Для перекодирования больших текстов служит утилита native2ascii, также входящая в JDK. Она мо­жет
работать как в прямом режиме — переводить из разнообразных кодировок в Unicode, записанный ASCII-символами, так и в
обрат­ном (опция -reverse) — из Unicode в стандартную
кодировку опера­ционной системы.

</p>
<p>В версиях языка Java до 1.1 применялся Unicode версии 1.1.5, в по­следнем выпуске 1.4 используется 3.0. Таким образом, Java следит за раз­витием стандарта и базируется на современных версиях. Для
любой JDK точную версию Unicode, используемую в
ней, можно узнать из докумен­тации к классу Character. Официальный web-сайт стандарта, где можно получить дополнительную
информацию,— http://www.Linicocle.org/.

</p>
<p>Итак, используя простейшую кодировку ASCII, можно ввести
произ­вольную последовательность символов Unicode. Далее будет
показано, что Unicode используется не для
всех лексем, а только для тех, для которых важна поддержка многих языков, а
именно: комментарии, идентификато­ры, символьные и строковые литералы. Для
записи остальных лексем вполне достаточно ASCII-символов.

</p>
<p> 

</p>
<p>Анализ программы

</p>
<p>Компилятор, анализируя
программу, сразу разделяет ее на:

</p>
<p>•   
пробелы (white spaces);

</p>
<p>•   
комментарии (comments);

</p>
<p>•   
основные лексемы (tokens).

</p>
<p> 

</p>
<p>Пробелы

</p>
<p>Пробелами в данном случае называют все символы, разбивающие текст
программы на лексемы. Это как сам символ пробела (space, \u0020, десятичный код 32), так и знаки табуляции и перевода строки. Они ис­пользуются
для разделения лексем, а также для оформления кода, чтобы его было легче
читать. Например, следующую часть программы (вычисле­ние корней квадратного
уравнения):

</p>
<p> 

</p>
<p>double а = 1, b = 1, с = 6; double D = b * b - 4 * а * с;

</p>
<p>if (D &gt;=0) {

</p>
<p>double х1 = (-b + Math.sqrt (D)) / (2 * а); double х2 - (-b - Math.sqrt
(D)) / (2 * а);

</p>
<p>}

</p>
<p>можно записать и в таком виде:

</p>
<p> 

</p>
<p>double
a=1,b=1,c=6;double D=b*b-4*a*c;if(D&gt;=0) {double

</p>
<p>x1
=(-b+Math.sqrt(D))/(2*a);double x2=(-b-Math.sqrt(D))/(2*a);}

</p>
<p>В обоих случаях компилятор сгенерирует абсолютно одинаковый код.
Единственное соображение, которым должен руководствоваться разработчик,—
легкость чтения и дальнейшей поддержки такого кода.

</p>
<p>Для разбиения текста на строки в ASCII используется два символа -"возврат каретки" (carriage return, CR, \u000d, десятичный код 13) и сим­вол новой строки (linefeed, LF, \u000a, десятичный код 10)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Чтобы не за­висеть от особенностей используемой
платформы, в Java применяется на­иболее
гибкий подход. Завершением строки считается:

</p>
<p>•   
ASCII-символ LF, символ новой строки;

</p>
<p>•   
ASCII-символ CR, "возврат каретки";

</p>
<p>•   
символ CR, за которым сразу же следует символ LF. Разбиение на строки важно для корректного разбиения на лексемы

</p>
<p>(как уже говорилось, завершение строки также служит
разделителем меж­ду лексемами), для правильной работы со строковыми
комментариями (см. следующую тему "Комментарии"), а также для вывода
отладочной информации (при выводе ошибок компиляции и времени исполнения
указывается, на какой строке исходного кода они возникли). Итак, пробелами в Java считаются:

</p>
<p>•  ASCII-символ SP, space, пробел, \u0020, десятичный код 32;

</p>
<p>•   
ASCII-символ НТ, horizontal tab, символ горизонтальной табу­ляции, \u0009, десятичный код 9;

</p>
<p>•   
ASCII-символ FF, form feed, символ перевода
страницы (был вве­ден для работы с принтером), \u000c, десятичный код 12;

</p>
<p>•   
завершение строки.

</p>
<p> 

</p>
<p>Комментарии

</p>
<p>Комментарии не влияют на
результирующий бинарный код и ис­пользуются только для ввода пояснений к
программе. В Java комментарии бывают двух видов:

</p>
<p>•   
строчные

</p>
<p>•   
блочные








</p>
<p>Курс




</p>
<p>Программирование
на Java




</p>
<p>Лексика
языка








</p>
<p> 








</p>
<p>Строчные комментарии начинаются с ASCII-символов // и
длятся до конца текущей строки. Как правило, они используются для пояснения
именно этой строки, например:

</p>
<p>int у=1970; // год рождения

</p>
<p>Блочные комментарии располагаются между ASCII-символами /* и */,
могут занимать произвольное количество строк, например:

</p>
<p> 

</p>
<p>/*

</p>
<p>Этот цикл не может начинаться с нуля из-за особенностей алгоритма

</p>
<p>7

</p>
<p>for (int i=1; К10; i++) { }

</p>
<p>Часто блочные комментарии оформляют следующим образом (каж­дая строка
начинается с *):

</p>
<p> 

</p>
<p>Г

</p>
<p>* 
Описание алгоритма работы

</p>
<p>* 
следующего цикла while

</p>
<p>7

</p>
<p>while (х &gt; 0) { }

</p>
<p>Блочный комментарий не обязательно должен располагаться на не­скольких
строках, он может даже находиться в середине оператора:

</p>
<p> 

</p>
<p>float s = 2*Math.PI/*getRadius()7; // Закомментировано для отладки

</p>
<p>В этом примере блочный комментарий разбивает арифметические операции.
Выражение Math.PI предоставляет значение константы PI, опре­деленное в
классе Math. Вызов метода getRadius()
теперь закомментирован и
не будет произведен, переменная s всегда будет принимать значение 2 PI. Завершает строку
строчный комментарий.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Комментарии не могут находиться в символьных и строковых лите­ралах,
идентификаторах (эти понятия подробно рассматриваются далее в этой лекции).
Следующий пример содержит случаи неправильного при­менения комментариев:

</p>
<p>// В этом примере текст
/*...*/ станет просто частью строки s

</p>
<p>String s = "text/*just
text7";

</p>
<p>/*

</p>
<p>* 
Следующая строка станет
причиной ошибки при компиляции,

</p>
<p>* 
так как комментарий разбил
имя метода getRadius()

</p>
<p>7

</p>
<p>circle.
get/*comment7Radius(); А такой код допустим:

</p>
<p>// Комментарий может
разделять вызовы функций: cirle./*commerrt7getRadius();

</p>
<p>// Комментарий может
заменять пробелы: int/*comment7x=1 ;

</p>
<p>В последней строке
между названием типа данных int и названием йеременной х обязательно должен быть пробел или, как в
данном примере, комментарий.

</p>
<p>Комментарии не могут быть вложенными. Символы /*, */. // не име­ют
никакого особенного значения внутри уже открытых комментариев, как строчных, так и
блочных. Таким образом, в примере

</p>
<p> 

</p>
<p>/* начало комментария /* ///** завершение тут: */

</p>
<p> 

</p>
<p>описан только один блочный комментарий. А в следующем примере (строки
кода пронумерованы для удобства)

</p>
<p> 

</p>
<p>1.   г

</p>
<p>2.          comment

</p>
<p>4.        
more comments

</p>
<p>5.        
7

</p>
<p>6.        
finish

</p>
<p>7.   7

</p>
<p> 

</p>
<p>компилятор выдаст
ошибку. Блочный комментарий начался в строке 1 с комбинации символов /*. Вторая открывающая комбинация /* на строке 3 будет проигнорирована, так как находится уже внутри комментария. Символы
7 в строке 5 завершат его, а строка 7 породит ошибку — попыт­ка закрыть комментарий, который не был начат.

</p>
<p>Любые комментарии полностью удаляются из программы во время компиляции,
поэтому их можно использовать неограниченно, не опаса-

</p>
<p>87

</p>
<p>ясь, что это повлияет на бинарный код. Основное их
предназначение -сделать программу простой для понимания, в том числе и для
других раз­работчиков, которым придется в ней разбираться по какой-либо причи­не.
Также комментарии зачастую используются для временного исключе­ния частей кода,
например:

</p>
<p>intx = 2; int у = 0;

</p>
<p>/*

</p>
<p>if (х &gt; 0)

</p>
<p>у = у + х*2; else

</p>
<p>у = -у - х*4;

</p>
<p>7

</p>
<p>У = У*У;// + 2*х;

</p>
<p>В этом примере закомментировано выражение if-else и оператор сложения +2*х.

</p>
<p>Как уже говорилось выше, комментарии можно писать символами Unicode, то есть на любом
языке, удобном разработчику.

</p>
<p>Кроме этого, существует особый вид блочного комментария -комментарий
разработчика
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Он применяется для автоматического со­здания документации кода. В
стандартную поставку JDK, начиная с версии 1.0, входит специальная утилита javadoc. На вход ей
подается исходный код классов, а на выходе получается удобная документация в HTML-формате, которая
описывает все классы, все их поля и методы. При этом активно используются
гиперссылки, что существенно упро­щает изучение программы (например, читая
описание метода, можно с помощью одного нажатия мыши перейти на описание типов,
использу­емых в качестве аргументов или возвращаемого значения). Однако по­нятно,
что одного названия метода и перечисления его аргументов не­достаточно для
понимания его работы. Необходимы дополнительные пояснения от разработчика.

</p>
<p>Комментарий разработчика записывается так же, как и блочный.
Единственное различие в начальной комбинации символов — для доку­ментации
комментарий необходимо начинать с /**. Например:

</p>
<p>* 
Вычисление модуля целого
числа.

</p>
<p>* 
Этот метод возвращает

</p>
<p>* 
абсолютное значение
аргумента х.

</p>
<p>7

</p>
<p>int getAbs(intx) { if (х&gt;=0)

</p>
<p>return х; else

</p>
<p>return -x;

</p>
<p>}

</p>
<p>Первое предложение должно содержать краткое резюме всего комментария. В
дальнейшем оно будет использовано как пояснение этой функции в списке всех
методов класса (ниже будут описаны все конструкции языка, для которых
применяется комментарий разра­ботчика).

</p>
<p>Поскольку в результате создается HTML-документация, то и
ком­ментарий необходимо писать по правилам HTML. Допускается
примене­ние тегов, таких как &lt;Ь&gt; и &lt;р&gt; . Однако теги заголовков с &lt;h1 &gt; по &lt;h6&gt; и &lt;hr&gt; использовать
нельзя, так как они активно применяются javadoc для создания структуры документации.

</p>
<p>Символ * в начале каждой строки и предшествующие ему пробелы и знаки
табуляции игнорируются. Их можно не использовать вообще, но они удобны, когда
необходимо форматирование, скажем, в примерах кода.

</p>
<p> 

</p>
<p>j-k-k

</p>
<p>*  
Первое предложение -
краткое описание метода.

</p>
<p>*  
&lt;р&gt;

</p>
<p>*  
Так оформляется пример
кода:

</p>
<p>*  
&lt;blockquote&gt;

</p>
<p>*  
&lt;рге&gt;

</p>
<p>*  
if
(condition==true) {

</p>
<p>x = getWidht(); у =
x.getHeight();

</p>
<p>*   }

</p>
<p>*  
&lt;/pre&gt;&lt;/blockquote&gt;

</p>
<p>*  
Атак описывается HTML-список:

</p>
<p>*  
&lt;ul&gt;

</p>
<p>*  
&lt;П&gt;Можно
использовать наклонный шрифт &lt;i&gt;KypcnB&lt;/i&gt;,

</p>
<p>*  
&lt;Н&gt;или жирный
&lt;Ь&gt;жирный&lt;/Ь&gt;.

</p>
<p>*  
&lt;/ul&gt; 7

</p>
<p>public void
calculate (int x, int y) { }

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Из этого комментария будет сгенерирован HTML-код, выглядящий
примерно так:

</p>
<p> 

</p>
<p>Первое предложение -
краткое описание метода.

</p>
<p> 

</p>
<p>Так оформляется пример
кода:

</p>
<p>if (condition==true) { x = gerWidht(); у = x.getHeight();

</p>
<p>}

</p>
<p>А так описывается HTML-список:

</p>
<p>•      
Можно использовать
наклонный шрифт курсив,

</p>
<p>•      
или жирный жирный.

</p>
<p>Наконец, javadoc поддерживает
специальные теги. Они начинаются с символа @. Подробное описание этих тегов
можно найти в документа­ции. Например, можно использовать тег @see, чтобы сослаться
на другой класс, поле или метод, или даже на другой Internet-сайт.

</p>
<p>*  
Краткое описание.

</p>
<p>*  
Развернутый комментарий.

</p>
<p>*

</p>
<p>*  
@see java.lang.String

</p>
<p>*  
@see java.lang.Math#PI

</p>
<p>*   @see &lt;a href="java.sun.com"&gt;Official
Java site&lt;/a&gt;

</p>
<p>7

</p>
<p>Первая ссылка указывает на класс String Qava.lang - название биб­лиотеки, в которой находится этот класс), вторая - на
поле PI класса Math (символ # разделяет название класса и его полей или методов), тре­тья
ссылается на официальный сайт Java.

</p>
<p>Комментарии
разработчика могут быть записаны перед объявлением классов, интерфейсов, полей,
методов и конструкторов. Если записать комментарий /**...*/ в другой части
кода, то ошибки не будет, но он не по­падет в документацию, генерируемую javadoc. Кроме того, можно
описать пакет (так называются библиотеки, или модули, в Java). Для этого необхо­димо
создать специальный файл package.html, сохранить в нем коммента­рий и поместить его в каталог пакета. HTML-текст,
содержащийся между тегами &lt;body&gt; и &lt;/body&gt;, будет помещен в документацию, а первое пред­ложение будет
использоваться для краткой характеристики этого пакета.

</p>
<p>Все классы стандартных библиотек Java поставляются в виде исход­ного текста и можно увидеть, как хорошо они
комментированы. Стан­дартная документация по этим классам сгенерирована
утилитой javadoc. Для любой программы также можно подготовить подобное описание, не­обходимы
лишь грамотные и аккуратные комментарии в исходном коде. Кроме того, Java предоставляет возможность генерировать с помощью javadoc документацию с нестандартным внешним видом.

</p>
<p> 

</p>
<p>Лексемы

</p>
<p>Итак, мы рассмотрели пробелы (в широком смысле этого слова, т.е. все
символы, отвечающие за форматирование текста программы) и ком­ментарии,
применяемые для ввода пояснений к коду. С точки зрения программиста они
применяются для того, чтобы сделать программу более читаемой и понятной для
дальнейшего развития.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>С точки зрения компилятора, а точнее его части, отвечающей за лек­сический
разбор, основная роль пробелов и комментариев — служить раз­делителями между
лексемами, причем сами разделители далее отбрасыва­ются и на компилированный
код не влияют. Например, все следующие примеры объявления переменной
эквивалентны:

</p>
<p> 

</p>
<p>// Используем пробел в
качестве разделителя, int х = 3 ;

</p>
<p> 

</p>
<p>// здесь разделителем
является перевод строки int

</p>
<p>x

</p>
<p> 

</p>
<p>3

</p>
<p> 

</p>
<p> 

</p>
<p>// здесь разделяем знаком
табуляции int х = 3 ;

</p>
<p> 

</p>
<p>/*

</p>
<p>*  Единственный принципиально необходимый разделитель

</p>
<p>*  между названием типа данных int и именем переменной
х

</p>
<p>* 
здесь описан комментарием
блочного типа.

</p>
<p>7

</p>
<p>int/**/x=3;

</p>
<p>Конечно, лексемы очень разнообразными именно они определяют многие
свойства языка. Рассмотрим все их виды более подробно.

</p>
<p> 

</p>
<p>Виды лексем

</p>
<p>Ниже перечислены все виды
лексем в Java:

</p>
<p>•   
идентификаторы (identifiers);

</p>
<p>•   
ключевые слова (key words);

</p>
<p>•   
литералы (literals);

</p>
<p>•   
разделители (separators);

</p>
<p>•   
операторы (operators). Рассмотрим их по отдельности.

</p>
<p> 

</p>
<p>Идентификаторы

</p>
<p>Идентификаторы - это имена, которые даются различным элементам языка для
упрощения доступа к ним. Имена имеют пакеты, классы, ин­терфейсы, поля, методы,
аргументы и локальные переменные (все эти по­нятия подробно рассматриваются в
следующих лекциях). Идентификато­ры можно записывать символами Unicode, то есть на любом
удобном язы­ке. Длина имени не ограничена.

</p>
<p>Идентификатор состоит из букв и цифр. Имя не может начинаться с цифры. Java-буквы,
используемые в идентификаторах, включают в себя ASCII-символы A-Z (\u0041-\u005a), a-z (\u0061-\u007a), а также знаки подчеркивания _ (ASCII underscore, \u005f) и доллара $ (\u0024). Знак дол­лара используется только при автоматической генерации кода
(чтобы ис­ключить случайное совпадение имен), либо при использовании каких-ли­бо
старых библиотек, в которых допускались имена с этим символом. Java-цифры включают в
себя обычные ASCII-цифры 0-9 (\u0030-\u0039).

</p>
<p>Для идентификаторов не допускаются совпадения с зарезервирован­ными
словами (это ключевые слова, булевские литералы true и false и null-литерал null). Конечно, если 2 идентификатора включают в себя разные буквы, которые
одинаково выглядят (например, латинская и русская буквы А), то они считаются
различными.

</p>
<p>В этой лекции уже
применялись следующие идентификаторы:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Character, а, Ь, с, D, х1, х2, Math, sqrt, х, у, i, s, PI, getRadius,

</p>
<p>circle, getAbs, calculate, condition, getWidth, getHeight, java,

</p>
<p>lang, String

</p>
<p>Также допустимыми являются идентификаторы: Компьютер, COLOR_RED, _, aVeryLongNameOfTheMethod

</p>
<p>Ключевые
слова

</p>
<p>Ключевые слова — это зарезервированные слова, состоящие из А8СП-символов
и выполняющие различные задачи языка. Вот их полный список (48 слов):

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="69" valign="top">
  <p>abstract
  </p>
</td>
  <td width="81" valign="top">
  <p>default
  </p>
</td>
  <td width="98" valign="top">
  <p>if
  </p>
</td>
  <td width="95" valign="top">
  <p>private
  </p>
</td>
  <td width="61" valign="top">
  <p>this
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>boolean
  </p>
</td>
  <td width="81" valign="top">
  <p>do
  </p>
</td>
  <td width="98" valign="top">
  <p>implements
  </p>
</td>
  <td width="95" valign="top">
  <p>protected
  </p>
</td>
  <td width="61" valign="top">
  <p>throw
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>break
  </p>
</td>
  <td width="81" valign="top">
  <p>double
  </p>
</td>
  <td width="98" valign="top">
  <p>import
  </p>
</td>
  <td width="95" valign="top">
  <p>public
  </p>
</td>
  <td width="61" valign="top">
  <p>throws
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>byte
  </p>
</td>
  <td width="81" valign="top">
  <p>else
  </p>
</td>
  <td width="98" valign="top">
  <p>instanceof
  </p>
</td>
  <td width="95" valign="top">
  <p>return
  </p>
</td>
  <td width="61" valign="top">
  <p>transient
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>case
  </p>
</td>
  <td width="81" valign="top">
  <p>extends
  </p>
</td>
  <td width="98" valign="top">
  <p>int
  </p>
</td>
  <td width="95" valign="top">
  <p>short
  </p>
</td>
  <td width="61" valign="top">
  <p>try
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>catch
  </p>
</td>
  <td width="81" valign="top">
  <p>final
  </p>
</td>
  <td width="98" valign="top">
  <p>interface
  </p>
</td>
  <td width="95" valign="top">
  <p>static
  </p>
</td>
  <td width="61" valign="top">
  <p>void
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>char
  </p>
</td>
  <td width="81" valign="top">
  <p>finally
  </p>
</td>
  <td width="98" valign="top">
  <p>long
  </p>
</td>
  <td width="95" valign="top">
  <p>strictfp
  </p>
</td>
  <td width="61" valign="top">
  <p>volatile
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>class
  </p>
</td>
  <td width="81" valign="top">
  <p>float
  </p>
</td>
  <td width="98" valign="top">
  <p>native
  </p>
</td>
  <td width="95" valign="top">
  <p>super
  </p>
</td>
  <td width="61" valign="top">
  <p>while
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>const
  </p>
</td>
  <td width="81" valign="top">
  <p>for
  </p>
</td>
  <td width="98" valign="top">
  <p>new
  </p>
</td>
  <td width="95" valign="top">
  <p>switch
  </p>
</td>
  <td width="61" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="69" valign="top">
  <p>continue
  </p>
</td>
  <td width="81" valign="top">
  <p>goto
  </p>
</td>
  <td width="98" valign="top">
  <p>package
  </p>
</td>
  <td width="95" valign="top">
  <p>synchronized
  </p>
</td>
  <td width="61" valign="top">
  <p> 
  </p>
</td>
 </tr>
</table>

<p>Ключевые слова goto и const зарезервированы, но не используются. Это сделано для того, чтобы
компилятор мог правильно отреагировать на их использование в других языках. Напротив, оба булевских литерала true, false и null-литерал null часто считают ключевыми
словами (возмож­но, потому, что многие средства разработки подсвечивают их
таким же образом), однако это именно литералы.

</p>
<p>Значение всех ключевых слов будет рассматриваться в следующих лекциях.

</p>
<p> 

</p>
<p>Литералы

</p>
<p>Литералы позволяют задать в программе значения для числовых, символьных
и строковых выражений, а также null-литералов. Всего в Java определены следующие виды литералов:

</p>
<p>•   
целочисленный (integer);

</p>
<p>•   
дробный (floating-point);

</p>
<p>•   
булевский (boolean);

</p>
<p>•   
символьный (character);

</p>
<p>•   
строковый (string);

</p>
<p>•   
null-литерал (null-literal). Рассмотрим их по отдельности.

</p>
<p>Целочисленные литералы

</p>
<p>Целочисленные литералы позволяют задавать целочисленные зна­чения в
десятеричном, восьмеричном и шестнадцатеричном виде. Деся­теричный формат
традиционен и ничем не отличается от правил, приня­тых в других языках.
Значения в восьмеричном виде начинаются с нуля, и, конечно, использование цифр
8 и 9 запрещено. Запись шестнадцате-ричных чисел начинается с Ох или ОХ (цифра
0 и латинская ASCII-буква X в произвольном регистре). Таким образом, ноль можно записать
тремя различными способами:

</p>
<p> 

</p>
<p>О

</p>
<p>00 0x0

</p>
<p>Как обычно, для записи цифр 10-15 в шестнадцатеричном формате
используются буквы А, В, С, D, Е, F, заглавные или
прописные. Примеры таких литералов:

</p>
<p> 

</p>
<p>OxaBcDeF, OxCafe, OxDEC

</p>
<p> 

</p>
<p>Типы данных рассматриваются ниже, однако здесь необходимо упомянуть два
целочисленных типа int и long длиной 4 и 8 байт, соответственно (или 32 и 64 бита, соответственно).
Оба эти типа знаковые, т.е. тип int хранит значения от -231 до 23,-1, или от
-2.147.483.648 до 2.147.483.647. По умолчанию целочисленный литерал имеет тип int, а значит, в
программе допустимо использовать литералы только от 0 до 2147483648, иначе
возникнет ошибка компиляции
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> При этом литерал 2147483648 можно использовать
только как аргумент унарного оператора -:

</p>
<p> 

</p>
<p>int х = -2147483648; \\верно

</p>
<p>int у = 5-2147483648; \\
здесь возникнет ошибка компиляции

</p>
<p> 

</p>
<p>Соответственно, допустимые литералы в восьмеричной записи долж­ны быть
от 00 до 017777777777 (=231-1), с унарным оператором - допусти­мо
также -020000000000 (= -231). Аналогично для шестнадцатеричного
формата - от 0x0 до 0x7fffffff (=23,-1), а также -0x80000000 (= -231).

</p>
<p>Тип long имеет длину 64 бита, а значит, позволяет хранить значения от -263
до 263-1. Чтобы ввести такой литерал, необходимо в конце поста­вить
латинскую букву L или I, тогда все значение будет трактоваться как long. Аналогично можно выписать
максимальные допустимые значения для них:

</p>
<p>9223372036854775807L

</p>
<p>0777777777777777777777L

</p>
<p>0x7fffffffffffffffL

</p>
<p>//
наибольшие отрицательные значения: -9223372036854775808L -01000000000000000000000L -0x8000000000000000L

</p>
<p>Другие примеры целочисленных литералов типа long: 0L, 1231, OxCOBOL

</p>
<p> 

</p>
<p>Дробные литералы

</p>
<p>Дробные литералы представляют собой числа с плавающей десятич­ной
точкой. Правила записи таких чисел такие же, как и в большинстве современных
языков программирования.

</p>
<p>Примеры:

</p>
<p> 

</p>
<p>3.14 2.

</p>
<p>.5

</p>
<p>7е10 3.1Е-20

</p>
<p>Таким образом, дробный литерал состоит из следующих составных частей:

</p>
<p>•   
целая часть;

</p>
<p>•   
десятичная точка
(используется ASCII-символ точка);

</p>
<p>•   
дробная часть;

</p>
<p>•   
показатель степени
(состоит из латинской ASCII-буквы Е в про­извольном регистре и целого числа с опциональным знаком +
или -);

</p>
<p>•   
окончание-указатель типа.

</p>
<p>Целая и дробная части записываются десятичными цифрами, а ука­затель
типа (аналог указателя L или I для
целочисленных литералов типа long)

</p>
<p>имеет два возможных значения - латинская ASCII-буква D (для ти­па double) или F (для типа float) в произвольном
регистре. Они будут по­дробно рассмотрены ниже.

</p>
<p>Необходимыми частями
являются:

</p>
<p>•   
хотя бы одна цифра в целой
или дробной части;

</p>
<p>•   
десятичная точка или
показатель степени, или указатель типа.

</p>
<p>Все остальные части необязательные. Таким образом,
"минимальные" дробные литералы могут быть записаны, например, так:

</p>
<p>1. .1

</p>
<p>1е1 1f

</p>
<p>В Java есть два дробных
типа, упомянутые выше, - float и double. Их длина - 4 и 8 байт или 32 и 64 бита, соответственно. Дробный литерал
имеет тип float, если он заканчивается на латинскую букву F в произволь­ном регистре
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В противном случае он рассматривается как
значение типа double и может включать в себя
окончание D или d, как признак типа double (используется только для наглядности).

</p>
<p> 

</p>
<p>//float-литералы:

</p>
<p>1f, 3.14F, Of, 1e+5F

</p>
<p>// double-литералы:

</p>
<p>0., 3.14d, 1e-4, 31.34E45D

</p>
<p>В Java дробные числа 32-битного типа float и 64-битного типа dou­ble хранятся в памяти в бинарном виде в формате, стандартизированном спецификацией IEEE
754 (полное название — IEEE Standard for Binary Floating-Point Arithmetic,
ANSI/IEEE Standard 754-1985 (IEEE, New York)). В этой спецификации описаны не только конечные дробные вели­чины, но и
еще несколько особых значений, а именно:

</p>
<p>•   положительная и отрицательная бесконечности (positive/negative infinity);

</p>
<p>•   значение "не число", Not-a-Number, сокращенно NaN;

</p>
<p>•   положительный и отрицательный нули.

</p>
<p>Для этих значений нет специальных обозначений. Чтобы получить та­кие
величины, необходимо либо произвести арифметическую операцию (на­пример,
результатом деления ноль на ноль 0.0/0.0 является NaN), либо обра­титься
к константам в классах Float и Double, а именно POSIT1VEJNFINITY, NEGATIVEJNFINITY и NaN. Более подробно ра­бота
с этими особенными значениями рассматривается в следующей лекции.

</p>
<p>Типы данных накладывают
ограничения на возможные значения ли­тералов, как и для целочисленных типов.
Максимальное положительное конечное значение дробного литерала:

</p>
<p>•   для float: 3.40282347e+38f

</p>
<p>•   для double: 1.79769313486231570е+308

</p>
<p>Кроме того, для дробных величин становится важным еще одно Предельное значение — минимальное положительное ненулевое значение:

</p>
<p>•   
для float: 1.40239846e-45f

</p>
<p>•   
для double: 4.94065645841246544e-324

</p>
<p>Попытка указать литерал со слишком большим абсолютным значе­нием
(например, 1 e40F) приведет к ошибке компиляции. Такая величина должна представляться
бесконечностью. Аналогично, указание литерала со слишком малым ненулевым
значением (например, 1е-350) также при­водит к ошибке. Это значение должно быть округлено до нуля.
Однако ес­ли округление приводит не к нулю, то компилятор произведет его сам:

</p>
<p>//
ошибка, выражение должно быть округлено до О

</p>
<p>0.0000000000000000000000000000000000000000000001f

</p>
<p>//
ошибки нет, компилятор сам округляет до 1

</p>
<p>1.0000000000000000000000000000000000000000000001f

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>' Стандартных
возможностей вводить дробные значения не в десятич­ной системе в Java нет, однако классы Float и Double предоставляют много вспомогательных методов, в том числе и для такой
задачи.

</p>
<p> 

</p>
<p>Логические литералы

</p>
<p>Логические литералы имеют два возможных значения — true и false. Эти
два зарезервированных
слова не являются ключевыми, но также не могут использоваться в качестве
идентификатора.

</p>
<p> 

</p>
<p>Символьные литералы

</p>
<p>Символьные литералы описывают один символ из набора Unicode, заключенный в
одиночные кавычки, или апострофы (ASCII-символ sin­gly quote, \u0027). Например:

</p>
<p>'а'
// латинская буква а '' // пробел

</p>
<p>'К'
// греческая буква каппа

</p>
<p> 

</p>
<p>Также допускается специальная запись для описания символа через его код (см. тему
"Кодировка"). Примеры:

</p>
<p>'\u0041' //
латинская буква А '\u0410' // русская буква А '\u0391' // греческая буква А

</p>
<p>Символьный литерал должен содержать строго один символ, или специальную
последовательность, начинающуюся с \. Для записи специ­альных символов
(неотображаемых и служебных, таких как ",', \) исполь­зуются следующие
обозначения:

</p>
<p> 

</p>
<p>\Ь \u0008  backspace BS - забой

</p>
<p>\х \u0009 horizontal tab НТ- табуляция

</p>
<p>\п \u000a  linefeed LF - конец строки

</p>
<p>\f \u000c form feed FF - конец страницы

</p>
<p>\r \u000d
carriage return CR - возврат каретки

</p>
<p>\" \u0022 
double quote " - двойная кавычка

</p>
<p>V \u0027
single quote ' - одинарная кавычка

</p>
<p>\\ \u005c  backslash \ - обратная косая черта

</p>
<p>\восьмеричный код

</p>
<p>от \u0000 до \u00ff символа в
восьмеричном формате.

</p>
<p> 

</p>
<p>Первая колонка описывает стандартные обозначения специальных символов,
используемые в Java-программах. Вторая колонка представляет их в стандартном виде Unicode-символов. Третья
колонка содержит анг­лийские и русские описания. Использование \ в комбинации с
другими символами приведет к ошибке компиляции.

</p>
<p>Поддержка ввода символов через восьмеричный код обеспечивается для
совместимости с С. Например:

</p>
<p> 

</p>
<p>'\101 ' // Эквивалентно '\u0041 '

</p>
<p> 

</p>
<p>Однако таким образом можно задать лишь символы от \u0000 до \u00ff (т.е. с кодом от 0
до 255), поэтому Unicode-последовательности предпочтительней.

</p>
<p>Поскольку обработка Unicode-последовательностей (\uhhhh) произво­дится раньше лексического анализа, то следующий пример
является ошибкой:

</p>
<p> 

</p>
<p>'\u000a' // символ конца
строки

</p>
<p> 

</p>
<p>Компилятор сначала преобразует \u000a в символ конца
строки и кавычки окажутся на разных строках кода, что является ошибкой. Необ­ходимо
использовать специальную последовательность:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>'\п' // правильное
обозначение конца строки

</p>
<p> 

</p>
<p>Аналогично и для символа \u000d (возврат каретки)
необходимо ис­пользовать обозначение \г.

</p>
<p>Специальные символы можно использовать в составе как символь­ных, так и
строковых литералов.

</p>
<p> 

</p>
<p>Строковые литералы

</p>
<p>Строковые литералы состоят из набора символов и записываются в двойных
кавычках. Длина может быть нулевой или сколь угодно боль­шой. Любой символ может быть представлен специальной последова­тельностью,
начинающейся с \ (см. "Символьные литералы").

</p>
<p>""
// литерал нулевой длины

</p>
<p>"\""
//литерал, состоящий из одного символа "

</p>
<p>"Простой
текст" //литерал длины 13

</p>
<p>Строковый литерал нельзя разбивать на несколько строк в коде про­граммы.
Если требуется текстовое значение, состоящее из нескольких строк, то необходимо
воспользоваться специальными символами \п и/или \г. Если же текст просто
слишком длинный, чтобы уместиться на одной строке кода, можно использовать
оператор конкатенации строк +. Примеры строковых литералов:

</p>
<p>//
выражение-константа, составленное из двух литералов "Длинный текст "
+ "с переносом" /*

</p>
<p>* 
Строковый литерал, содержащий текст из
двух строк:

</p>
<p>* 
Hello, world!

</p>
<p>* 
Hello!

</p>
<p>7

</p>
<p>"Hello,
world!\r\nHello!"

</p>
<p>На строковые литералы распространяются те же правила, что и на сим­вольные
в отношении использования символов новой строки \u000a и \u000d.

</p>
<p>Каждый строковый литерал является экземпляром класса String. Это определяет
некоторые необычные свойства строковых литералов, ко­торые будут рассмотрены в
следующей лекции.

</p>
<p> 

</p>
<p>Null-литерал

</p>
<p>Null-литерал может
принимать всего одно значение: null. Это литерал ссылочного типа, причем эта ссылка никуда не ссылается,
объект отсутст-вУет. Разумеется, его можно применять к ссылкам
любого объектного типа Д^ных. Типы данных подробно рассматриваются в следующей
лекции.

</p>
<p>Разделители

</p>
<p>Разделители - это специальные символы, которые используются в служебных
целях языка. Назначение каждого из них будет рассмотрено по ходу изложения
курса. Вот их полный список:

</p>
<p> 

</p>
<p>()[]{};&#9632;,

</p>
<p> 

</p>
<p>Операторы

</p>
<p>Операторы используются в различных операциях — арифметичес­ких,
логических, битовых, операциях сравнения и присваивания. Следу­ющие 37 лексем
(все состоят только из ASCII-символов) являются опера­торами языка Java:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="21" valign="top">
  <p>-
  </p>
</td>
  <td width="28" valign="top">
  <p>&gt; 
  </p>
</td>
  <td width="36" valign="top">
  <p>&lt; 
  </p>
</td>
  <td width="36" valign="top">
  <p>і
  </p>
</td>
  <td width="75" valign="top">
  <p>?
  </p>
</td>
  <td width="43" valign="top">
  <p> 
  </p>
</td>
  <td width="39" valign="top">
  <p> 
  </p>
</td>
  <td width="40" valign="top">
  <p> 
  </p>
</td>
  <td width="75" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>- -
  </p>
</td>
  <td width="28" valign="top">
  <p>&lt;-
  </p>
</td>
  <td width="36" valign="top">
  <p>&gt;=
  </p>
</td>
  <td width="36" valign="top">
  <p>!=
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;&amp;   &#161;1
  </p>
</td>
  <td width="43" valign="top">
  <p>++
  </p>
</td>
  <td width="39" valign="top">
  <p>--
  </p>
</td>
  <td width="40" valign="top">
  <p> 
  </p>
</td>
  <td width="75" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>+
  </p>
</td>
  <td width="28" valign="top">
  <p>-
  </p>
</td>
  <td width="36" valign="top">
  <p>*
  </p>
</td>
  <td width="36" valign="top">
  <p>/
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;   1
  </p>
</td>
  <td width="43" valign="top">
  <p>Л
  </p>
</td>
  <td width="39" valign="top">
  <p>%
  </p>
</td>
  <td width="40" valign="top">
  <p>«
  </p>
</td>
  <td width="75" valign="top">
  <p>»     »&gt;
  </p>
</td>
 </tr>
 <tr>
  <td width="21" valign="top">
  <p>+=
  </p>
</td>
  <td width="28" valign="top">
  <p>-=
  </p>
</td>
  <td width="36" valign="top">
  <p> 
  </p>
</td>
  <td width="36" valign="top">
  <p>/=
  </p>
</td>
  <td width="75" valign="top">
  <p>&amp;= 1=
  </p>
</td>
  <td width="43">
  <p>Л____ 
  </p>
</td>
  <td width="39" valign="top">
  <p>%=
  </p>
</td>
  <td width="40" valign="top">
  <p>«=
  </p>
</td>
  <td width="75" valign="top">
  <p>»=   »=
  </p>
</td>
 </tr>
</table>

<p>Большинство из них вполне очевидны и хорошо известны из других языков
программирования, однако некоторые нюансы в работе с опера­торами в Java все же
присутствуют, поэтому в конце лекции приводятся краткие комментарии к ним.

</p>
<p> 

</p>
<p>Пример
программы

</p>
<p>В заключение для примера приведем простейшую программу (тра­диционное Hello, world!), а затем
классифицируем и подсчитаем исполь­зуемые лексемы:

</p>
<p> 

</p>
<p>public class Demo {

</p>
<p>J-k-k

</p>
<p>* 
Основной метод, с которого начинается
выполнение

</p>
<p>* 
любой Java программы.

</p>
<p>7

</p>
<p>public static void main (String
args[]) { System.out.printlnf'Hello, world!");

</p>
<p>}

</p>
<p>}

</p>
<p>Итак, в приведенной программе есть один комментарий разработчи­ка, 7
идентификаторов, 5 ключевых слов, 1 строковый литерал, 13 разде­лителей и ни
одного оператора. Этот текст можно сохранить в файле Demo.java, скомпилировать й
запустить (работа с JDK и стандартными
утилитами была рассмотрена в первой лекции). Результатом работы будет, как
очевидно:

</p>
<p> 

</p>
<p>Hello, world!

</p>
<p> 

</p>
<p>Дополнение. Работа с
операторами

</p>
<p>Рассмотрим некоторые детали использования операторов в Java. Здесь будут описаны
подробности, относящиеся к работе самих операто­ров. В следующей лекции
детально рассматриваются особенности, возни­кающие при использовании различных
типов данных (например, значе-йие операции 1 /2 равно 0, а 1/2. равно 0.5).

</p>
<p> 

</p>
<p>Операторы присваивания и сравнения

</p>
<p>Во-первых, конечно же, различаются оператор присваивания = и оператор
сравнения ==.

</p>
<p> 

</p>
<p>х = 1 ; // присваиваем переменной х значение 1

</p>
<p>х == 1 // сравниваем значение переменной х с единицей

</p>
<p> 

</p>
<p>Оператор сравнения всегда возвращает булевское значение trae или false. Оператор
присваивания возвращает значение правого операнда. Поэтому обычная опечатка в
языке С, когда эти операторы путают:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компилятора

</p>
<p>if (х=0) {// здесь должен применятся оператор
сравнения ==

</p>
<p> 

</p>
<p>}

</p>
<p>в Java легко устраняется.
Поскольку выражение х=0 имеет числовое зна­чение 0, а не булевское (и тем более
не воспринимается как всегда истин­ное), то компилятор сообщает об ошибке
(необходимо писать х==0). Условие "не равно" записывается как !=.
Например:

</p>
<p> 

</p>
<p>if (х!=0) {

</p>
<p>float f = 1./х;

</p>
<p>}

</p>
<p> 

</p>
<p>Сочетание какого-либо оператора с оператором присваивания = • нижнюю
строку в полном перечне в разделе "Операторы") использу­ется при
изменении значения переменной. Например, следующие две строки эквивалентны:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>х = х + 1; х+= 1;

</p>
<p> 

</p>
<p>Арифметические операции

</p>
<p>Наряду с четырьмя обычными арифметическими операциями +,-,*, /,
существует оператор получения остатка от деления %, который может быть применен
как к целочисленным аргументам, так и к дробным.

</p>
<p>Работа с целочисленными аргументами подчиняется простым пра­вилам. Если
делится значение а на значение Ь, то выражение (а/Ь)*Ь+(а%Ь) должно в точности
равняться а. Здесь, конечно, оператор деления целых чисел / всегда возвращает
целое число. Например:

</p>
<p>9/5 возвращает 1 9/(-5) возвращает -1 (-9)/5 возвращает -1 (-9)/(-5) возвращает 1

</p>
<p> 

</p>
<p>Остаток может быть положительным, только если делимое было по­ложительным.
Соответственно, остаток может быть отрицательным только в случае отрицательного
делимого.

</p>
<p> 

</p>
<p>9%5 возвращает 4 9%(-5) возвращает 4 (-9)%5 возвращает -4 (-9)%(-5)
возвращает -4

</p>
<p> 

</p>
<p>Попытка получить остаток от деления на 0 приводит к ошибке.

</p>
<p>Деление с остатком для дробных чисел может быть произведено по двум
различным алгоритмам. Один из них повторяет правила для целых чисел, и именно
он представлен оператором %. Если в рассмотренном примере деления 9 на 5
перейти к дробным числам, значение остатка во всех вариантах не изменится (оно
будет также дробным, конечно).

</p>
<p>9.0%5.0 возвращает 4.0 9.0%(-5.0) возвращает 4.0 (-9.0)%5.0 возвращает
-4.0 (-9.0)%(-5.0) возвращает -4.0

</p>
<p>Однако стандарт IEEE 754 определяет
другие правила. Такой способ представлен методом стандартного класса Math.lEEEremainder(double f 1, double f2). Результат этого
метода - значение, которое равно f 1 -f2*n, где п — целое число, ближайшее к значению f 1/f2, а если два целых
числа одинаково близки к этому отношению, то выбирается четное. По этому
правилу значение остатка будет другим:

</p>
<p>Math.lEEEremainder(9.0, 5.0) возвращает -1.0 Math.lEEEremainder(9.0, -5.0) возвращает -1.0 Math.lEEEremainder(-9.0, 5.0) возвращает 1.0 Math.lEEEremainder(-9.0, -5.0) возвращает 1.0

</p>
<p>Унарные операторы инкрементации ++ и декрементации --, как обычно, можно
использовать как справа, так и слева.

</p>
<p>int х=1; int у=++х;

</p>
<p>В этом примере оператор ++ стоит перед переменной х, это означает, что
сначала произойдет инкрементация, а затем значение х будет исполь­зовано для
инициализации у. В результате после выполнения этих строк значения х и у будут равны 2.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>int х=1; int у=х++;

</p>
<p>А в этом примере сначала значение х будет использовано для инициализации
у, и лишь затем
произойдет инкрементация. В результате значение х будет равно 2, а у будет равно 1.

</p>
<p> 

</p>
<p>Логические операторы

</p>
<p>Логические операторы "и" и "или" (&amp; и |) можно
использовать в двух вариантах. Это связано с тем, что, как легко убедиться, для
каждого опера­тора возможны случаи, когда значение первого операнда сразу
определяет значение всего логического выражения. Если вторым операндом является
значение некоторой функции, то появляется выбор - вызывать ее или нет, причем
это решение может сказаться как на скорости, так и на функцио­нальности
программы.

</p>
<p>Первый вариант операторов (&amp;, |) всегда вычисляет оба операнда,
второй же - ( &amp;&amp;, 11 ) не будет продолжать вычисления, если значение выражения уже очевидно.
Например:

</p>
<p> 

</p>
<p>int х=1;

</p>
<p>(х&gt;0) | calculate(x) // в таком выражении произойдет вызов calulate (х&gt;0) 11 calculate(x) // а в этом - нет

</p>
<p> 

</p>
<p>Логический оператор отрицания "не" записывается как ! и,
конечно, имеет только один вариант использования. Этот оператор меняет булев­ское
значение на противоположное.

</p>
<p> 

</p>
<p>int х=1;

</p>
<p>х&gt;0 // выражение
истинно !(х&gt;0) // выражение ложно

</p>
<p> 

</p>
<p>Оператор с условием ? : состоит из трех частей - условия и двух выра­жений.
Сначала вычисляется условие (булевское выражение), а на основа­нии результата
значение всего оператора определяется первым выражени­ем в случае получения
истины и вторым - если условие ложно. Например, так можно вычислить модуль
числа х:

</p>
<p> 

</p>
<p>х&gt;0 ? х : -х

</p>
<p> 

</p>
<p>Битовые операции

</p>
<p>Прежде чем переходить к битовым операциям, необходимо уточнить, каким
именно образом целые числа представляются в двоичном виде. Ко­нечно, для
неотрицательных величин это практически очевидно:

</p>
<p>0      
О

</p>
<p>1      
1

</p>
<p>2      
10

</p>
<p>3      
11

</p>
<p>4      
100

</p>
<p>5    
101

</p>
<p> 

</p>
<p>и так далее. Однако как представляются отрицательные числа? Во-пер­вых,
вводят понятие знакового бита. Первый бит начинает отвечать за знак, а именно 0
означает положительное число, 1 — отрицательное. Но не следует думать, что
остальные биты остаются неизменными. Напри­мер, если рассмотреть 8-битовое
представление:

</p>
<p>-1 10000001 //это
НЕВЕРНО! -2 10000010//это НЕВЕРНО! -3 10000011 //это НЕВЕРНО!

</p>
<p>Такой подход неверен! В частности, мы получаем сразу два представления дудя - 00000000 и 100000000, что нерационально. Правильный алгоритм можно
представить себе так. Чтобы получить значение -1, надо из 0 вычесть 1: 00000000

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>-00000001

</p>
<p> 

</p>
<p>-11111111

</p>
<p>Итак, -1 в двоичном виде представляется как 11111111. Продолжаем
применять тот же алгоритм (вычитаем 1):

</p>
<p>0 00000000 -1 11111111 -2 11111110 -3 11111101

</p>
<p>и так далее до
значения 10000000, которое представляет собой наибольшее по модулю
отрицательное число. Для 8-битового представления наиболь­шее положительное число
01111111 (=127), а наименьшее отрицательное 10000000 (=-128). Поскольку всего 8
бит определяет 28=256 значений, причем одно из них отводится для
нуля, то становится ясно, почему наи­большие по модулю положительные й
отрицательные значения различа­ются на единицу, а не совпадают.

</p>
<p>Как известно, битовые операции "и", "или",
"исключающее или" принимают два аргумента и выполняют логическое
действие попарно над соответствующими битами аргументов. При этом используются
те же обозначения, что и для логических операторов, но, конечно, только в
первом (одиночном) варианте. Например, вычислим выражение 5&amp;6:

</p>
<p> 

</p>
<p>00000101    // число 5 в двоичном виде &amp;00000110    //число 6 в двоичном виде

</p>
<p>00000100    //проделали
операцию "и" попарно над битами // в каждой позиции

</p>
<p> 

</p>
<p>То есть выражение 5&amp;6
равно 4.

</p>
<p>Исключение составляет лишь оператор "не" или "NOT", который для
побитовых операций записывается как ~ (для логических было !). Этот оператор
меняет каждый бит в числе на противоположный. Например,

</p>
<p>)=0. Можно легко установить общее правило для получения битового
представления отрицательных чисел:

</p>
<p>Если п - целое положительное число, то -п в битовом представлении Равняется ~(п-1).

</p>
<p>Наконец, осталось
рассмотреть лишь операторы побитового сдвига. В Java есть один оператор сдвига влево и два варианта сдвига вправо. Такое
различие связано с наличием знакового бита.

</p>
<p>При сдвиге влево оператором &lt;&lt; все биты числа смещаются на ука­занное
количество позиций влево, причем освободившиеся справа пози­ции заполняются
нулями. Эта операция аналогична умножению на 2п и действует вполне
предсказуемо, как при положительных, так и при отри­цательных аргументах.

</p>
<p>Рассмотрим примеры применения операторов сдвига для значений типа int, т.е. 32-битных
чисел. Пусть положительным аргументом будет число 20, а отрицательным -21.

</p>
<p> 

</p>
<p>// Сдвиг
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>влево для
положительного числа 20 20 « 00 =
00000000000000000000000000010100 = 20 20 « 01 =00000000000000000000000000101000
= 40 20 « 02 = 00000000000000000000000001010000 = 80 20 «03 = 00000000000000000000000010100000
= 160 20 « 04 = 00000000000000000000000101000000 = 320

</p>
<p> 

</p>
<p>20 « 25 =
00101000000000000000000000000000 = 671088640

</p>
<p>20 « 26 =
01010000000000000000000000000000 = 1342177280

</p>
<p>20 « 27 = 10100000000000000000000000000000 =
-1610612736

</p>
<p>20 « 28 =
01000000000000000000000000000000 = 1073741824

</p>
<p>20 « 29 = 10000000000000000000000000000000 = -2147483648

</p>
<p>20 « 30 =
00000000000000000000000000000000 = о

</p>
<p>20 « 31
=00000000000000000000000000000000 = о

</p>
<p>//
Сдвиг влево для отрицательного числа -21

</p>
<p>-21 «00=
11111111111111111111111111101011 =-21

</p>
<p>-21 «01 =
11111111111111111111111111010110 = -42

</p>
<p>-21 «02 =
11111111111111111111111110101100 =-84

</p>
<p>-21 « 03=11111111111111111111111101011000=-168

</p>
<p>-21 &lt;^ 04 = 11111111111111111111111010110000 = -336

</p>
<p>-21 «
05=11111111111111111111110101100000=-672

</p>
<p>-21 « 25 =
11010110000000000000000000000000 = -704643072 -21 « 26 =
10101100000000000000000000000000 = -1409286144 -21 « 27 =
01011000000000000000000000000000 = 1476395008 -21 « 28 =
10110000000000000000000000000000 = -1342177280 -21 « 29 =
01100000000000000000000000000000 =1610612736 -21 « 30 =
11000000000000000000000000000000 .= -1073741824 -21 « 31 = 10000000000000000000000000000000
= -2147483648

</p>
<p>Как видно из примера, неожиданности возникают тогда, когда $начащие биты
начинают занимать первую позицию и влиять на знак результата.

</p>
<p>При сдвиге вправо все биты аргумента смещаются на указанное коли­чество
позиций, соответственно, вправо. Однако встает вопрос — каким значением
заполнять освобождающиеся позиции слева, в том числе и отве­чающую за знак.
Есть два варианта. Оператор » использует для заполне­ния этих позиций значение
знакового бита, то есть результат всегда имеет тот же знак, что и начальное
значение. Второй оператор »&gt; заполняет их нулями, то есть результат всегда
положительный.

</p>
<p>// Сдвиг вправо для положительного числа 20 // Оператор »

</p>
<p>20 » 00 = 00000000000000000000000000010100 = 20 20 » 01 =
00000000000000000000000000001010 = 10 20 » 02 =
00000000000000000000000000000101 =5 20 » 03 = 00000000000000000000000000000010
= 2 20 » 04 = 00000000000000000000000000000001 = 1 20 » 05 =
00000000000000000000000000000000 = о // Оператор »&gt;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>20 »&gt; 00 = 00000000000000000000000000010100 = 20 20 »&gt; 01 =
00000000000000000000000000001010 = 10 20 »&gt; 02 =
00000000000000000000000000000101 = 5 20 »&gt; 03 =
00000000000000000000000000000010 = 2 20 »&gt; 04 =
00000000000000000000000000000001 = 1 20 »&gt; 05 = 00000000000000000000000000000000
= о

</p>
<p>Очевидно, что для положительного аргумента операторы &gt;&gt; и
&gt;&gt;&gt; Работают совершенно одинаково. Дальнейший сдвиг на большее количе­ство позиций будет также давать нулевой результат.

</p>
<p>// Сдвиг вправо для отрицательного числа -21 // Оператор &gt;&gt;

</p>
<p>-21 » 00 =11111111111111111111111111101011= -21 -21 »01 =
11111111111111111111111111110101 =-11 -21 »02 =
11111111111111111111111111111010 = -6 -21 » 03
=11111111111111111111111111111101 =-3 -21 »04 =
11111111111111111111111111111110 = -2 -21 »05 = 11111111111111111111111111111111
=-1 // Оператор »&gt;

</p>
<p>-21 »&gt; 00 =
11111111111111111111111111101011 = -21

</p>
<p>-21 &gt;» 01
=01111111111111111111111111110101 =2147483637

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="50" colspan="2" valign="top">
  <p>&gt;» 02:
  </p>
</td>
  <td width="261" valign="top">
  <p>=00111111111111111111111111111010=
  </p>
</td>
  <td width="81" valign="top">
  <p>1073741818
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>03
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00011111111111111111111111111101 :
  </p>
</td>
  <td width="81" valign="top">
  <p>= 536870909
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>04
  </p>
</td>
  <td width="261" valign="top">
  <p>=00001111111111111111111111111110=
  </p>
</td>
  <td width="81" valign="top">
  <p>= 268435454
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>05
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000111111111111111111111111111 =
  </p>
</td>
  <td width="81" valign="top">
  <p>=134217727
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>24
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000011111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 255
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>25
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000001111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 127
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>26
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000111111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 63
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>27
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000011111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 31
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>28
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000001111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 15
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>29
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000000111
  </p>
</td>
  <td width="81" valign="top">
  <p>= 7
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>&gt;»
  </p>
</td>
  <td width="20" valign="top">
  <p>30
  </p>
</td>
  <td width="261" valign="top">
  <p>=00000000000000000000000000000011
  </p>
</td>
  <td width="81" valign="top">
  <p>= 3
  </p>
</td>
 </tr>
 <tr>
  <td width="23" valign="top">
  <p>-21
  </p>
</td>
  <td width="30" valign="top">
  <p>»&gt;
  </p>
</td>
  <td width="20" valign="top">
  <p>31
  </p>
</td>
  <td width="261" valign="top">
  <p>= 00000000000000000000000000000001
  </p>
</td>
  <td width="81" valign="top">
  <p>= 1
  </p>
</td>
 </tr>
</table>

<p>Как видно из примеров, эти операции аналогичны делению на 2п. При­чем,
если для положительных аргументов с ростом п результат закономерно стремится к
0, то для отрицательных предельным значением является -1.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены основы лексического анализа про­грамм Java. Для их записи
применяется универсальная кодировка ишсос1е,позволяющая использовать любой язык
помимо традиционного английского. Еще раз напомним, что использование Unicode возможно и необходимо в следующих конструкциях:

</p>
<p>•   
комментарии;

</p>
<p>•   
идентификаторы;

</p>
<p>•   
символьные и строковые
литералы.

</p>
<p>Остальные же (пробелы, ключевые слова, числовые,
булевские и null-ли-тералы, разделители и операторы) легко записываются с применением
лишь ASCII-символов. В то же время любой Unicode-символ также мож­но
задать в виде специальной последовательности ASCII-символов.

</p>
<p>Во время анализа компилятор выделяет из текста программы
&lt;про-белы&gt; (были рассмотрены все символы, которые рассматриваются как
пробелы) и комментарии,которые полностью удаляются из кода (были рассмотрены
все виды комментариев, в частности комментарий разра­ботчика). Пробелы и все
виды комментариев служат для разбиения текс­та программы на лексемы. Были
рассмотрены все виды лексем,в том чис­ле все виды литералов.

</p>
<p>В дополнении были рассмотрены особенности применения различ­ных
операторов.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>Как записать в Java-программе символ с кодом 514?

</p>
<p>&#9633;       
'514'

</p>
<p>&#9633;       
\u0546

</p>
<p>&#9633;       
\u222

</p>
<p>&#9633;       
\u0222

</p>
<p> 

</p>
<p>Какие
из перечисленных идентификаторов являются корректными?

</p>
<p>&#9633;       
abc

</p>
<p>&#9633;       
lab

</p>
<p>&#9633;       
_bc

</p>
<p>&#9633;       
_1с$ас

</p>
<p>&#9633;       
$ас

</p>
<p>&#9633;          
for_

</p>
<p>&#9633;       
Int

</p>
<p>&#9633;       
byte

</p>
<p> 

</p>
<p>Каким будет результат следующих
действий?

</p>
<p>1/0 1./0 i/o-

</p>
<p>'\n'+V

</p>
<p>&#9633;       
все 4 операции деления вызовут
ошибку деления на 0, сложение даст "\п\г"

</p>
<p>&#9633;       
результатом всех 4 операций
деления будет POSITIVEJNnNITf,
сложение даст '\п\г'

</p>
<p>&#9633;       
операция 1/0 приведет K/P^MeTM4^b^pos,T|VE INFINITY; следующие
3 операции будут иметь результат РОЫ ivt_

</p>
<p>последнее сложение даст 23








</p>
<p>Вариант
2




</p>
<p>Вариант
3








</p>
<p> 








</p>
<p>Сколько
пробелов в следующем примере кода: intx = 3; int у=1; int z = х+у;

</p>
<p>&#9633;          
7

</p>
<p>&#9633;       
8

</p>
<p>&#9633;       
9

</p>
<p>&#9633;   
11

</p>
<p> 

</p>
<p> 

</p>
<p>2.   Являются ли следующие слова ключевыми:

</p>
<p>&#9633;       
true

</p>
<p>&#9633;       
goto

</p>
<p>&#9633;       
null

</p>
<p>&#9633;       
const

</p>
<p>&#9633;       
false

</p>
<p> 

</p>
<p> 

</p>
<p>Чему
будет равно следующее выражение и значение переменной х после вычислений? int х=0;

</p>
<p>print(++x==x++);

</p>
<p>&#9633;       
true

</p>
<p>&#9633;       
false

</p>
<p>1.      Сколько комментариев в
следующем примере кода:
int х = О; /* text //
text /*

</p>
<p>int у=1;
// text */ // text */

</p>
<p>&#9633;         1
блочный, 0 строчных
П        1
блочный, 1 строчный
Г~1    1 блочный, 2 строчных
П        2
блочных, 3 строчных

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Равны
ли следующие числа:

</p>
<p>&#9633;        
5 и 05

</p>
<p>&#9633;        
9 и 09

</p>
<p>&#9633;    
ЮиОЮ
•&#9633;   0x5Am90L

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Чему будет равно следующее
выражение и значения
переменных х и у после вычислений?

</p>
<p>int х=0,
у=0;

</p>
<p>print((++x==1) || (у++==1));

</p>
<p>&#9633;      
true

</p>
<p>&#9633;      
false








</p>
<p>
</p>
<center> 
</center>
    </div>