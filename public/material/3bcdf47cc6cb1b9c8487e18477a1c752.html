# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 12. Потоки выполнения. Синхронизация</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции завершается описание ключевых
особенностей Java. Последняя тема раскрывает особенности создания многопоточных
прило­жений — такая возможность присутствует в языке, начиная с самых первых
дерсий.

</p>
<p>Первый вопрос — как на много — и, самое интересное,
однопроцессор­ных машинах выполняется несколько потоков одновременно и
для чего они нужны в программе. Затем описываются классы, необходимые для созда­ли, запуска и управления
потоками в Java. При одновременной работе с данными из нескольких мест
возникает проблема синхронного доступа, блокировок и, как следствие, взаимных
блокировок. Изучаются все меха­низмы, предусмотренные в языке для корректной
организации такой логи­ки работы.

</p>
<p> 

</p>
<p>Ключевые слова: thread, time-slicing, приоритет потока,
демон, daemon, garbage collector, reflection, классы-обертки.

</p>
<p> 

</p>
<p>Введение

</p>
<p>До сих пор во всех
рассматриваемых примерах подразумевалось, что в один момент времени исполняется лишь одно выражение или действие. Однако
начиная с самых первых версий, виртуальные машины Java под­держивают многопоточность, т.е. поддержку нескольких потоков испол­нения (threads) одновременно.

</p>
<p>В данной лекции
сначала рассматриваются преимущества такого подхода, способы реализации и возможные недостатки.

</p>
<p>Затем описываются базовые классы Java, которые позволяют
запус­кать потоки исполнения и управлять ими.

</p>
<p>При одновременном обращении нескольких потоков к одним и тем *е Данным
может возникнуть ситуация, когда результат программы будет зависеть от
случайных факторов, таких как временное чередование испол­нения операций
несколькими потоками. В такой ситуации становятся не­обходимым механизмы синхронизации, обеспечивающие
последователь-ный, или монопольный,
доступ. В Java этой цели служит ключевое слово Synchronized. Предварительно будет рассмотрен подход к организации хРанения
данных в виртуальной машине.

</p>
<p>В заключение
рассматриваются методы wait(), notify(), notifyAII() ^acca Object.








</p>
<p>Многопоточная архитектура

</p>
<p>Не претендуя на полноту изложения, рассмотрим общее устройство
многопоточной архитектуры, ее достоинства и недостатки.

</p>
<p>Реализацию многопоточной архитектуры проще всего представить себе для
системы, в которой есть несколько центральных вычислитель, ных процессоров. В
этом случае для каждого из них можно выделить за­дачу, которую он будет
выполнять. В результате несколько задач будут об­служиваться одновременно.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Однако возникает вопрос — каким же тогда образом обеспечивается
многопоточность в системах с одним центральным процессором, кото­рый, в
принципе, выполняет лишь одно вычисление в один момент вре­мени? В таких
системах применяется процедура квантования времени (time-slicing). Время
разделяется на небольшие интервалы. Перед нача­лом каждого интервала
принимается решение, какой именно поток вы­полнения будет отрабатываться на
протяжении этого кванта времени. За счет частого переключения между задачами
эмулируется многопоточная архитектура.

</p>
<p>На самом деле, как правило, и для многопроцессорных систем приме­няется
процедура квантования времени. Дело в том, что даже в мощных серверах
приложений процессоров не так много (редко бывает больше де­сяти), а потоков
исполнения запускается, как правило, гораздо больше. На­пример, операционная
система Windows без единого
запушенного приложе­ния инициализирует десятки, а то и сотни потоков.
Квантование времени позволяет упростить управление выполнением задач на всех
процессорах.

</p>
<p>Теперь перейдем к вопросу о преимуществах - зачем вообще может
потребоваться более одного потока выполнения?

</p>
<p>Среди начинающих программистов бытует мнение, что многопоточ­ные
программы работают быстрее. Рассмотрев способ реализации много-поточности,
можно утверждать, что такие программы работают на самом деле медленнее.
Действительно, для переключения между задачами на каж­дом интервале требуется
дополнительное время, а ведь они (переключения) происходят довольно часто. Если
бы процессор, не отвлекаясь, выполнял задачи последовательно, одну за другой,
он завершил бы их заметно быст­рее. Стало быть, преимущества заключаются не в
этом.

</p>
<p>Первый тип приложений, который выигрывает от поддержки мно-гопоточности,
предназначен для задач, где действительно требуется вы­полнять несколько
действий одновременно. Например, будет вполне обоснованно ожидать, что сервер
общего пользования станет обслуживать несколько клиентов одновременно. Можно
легко представить себе при­мер из сферы обслуживания, когда имеется несколько потоков клиентов и
желательно обслуживать их все одновременно.

</p>
<p>Другой пример - активные игры, или подобные приложения
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Необ­ходимо
одновременно опрашивать клавиатуру и другие устройства ввода, чтобы реагировать
на действия пользователя. В то же время необходимо рассчитывать и
перерисовывать изменяющееся состояние игрового поля.

</p>
<p>Понятно, что в случае отсутствия поддержки многопоточности для
реализации подобных приложений потребовалось бы реализовывать квантование
времени вручную. Условно говоря, одну секунду проверять состояние клавиатуры, а
следующую — пересчитывать и перерисовывать игровое поле. Если сравнить две
реализации time-slicing, одну — на низком уровне, выполненную средствами, как правило,
операционной системы, другую - выполняемую вручную, на языке высокого уровня,
мало подходя­щего для таких задач, то становится понятным первое и, возможно,
главное преимущество многопоточности. Она обеспечивает наиболее эффектив­ную
реализацию процедуры квантования времени, существенно облегчая и укорачивая
процесс разработки приложения. Код переключения между за­дачами на Java выглядел бы куда более громоздко, чем независимое описа­ние действий для
каждого потока.

</p>
<p>Следующее преимущество проистекает из того, что компьютер состоит не
только из одного или нескольких процессоров. Вычислительное устрой­ство — лишь
один из ресурсов, необходимых для выполнения задач. Всегда есть оперативная
память, дисковая подсистема, сетевые подключения, периферия и т.д. Предположим,
пользователю требуется распечатать боль­шой документ и скачать большой файл из
сети. Очевидно, что обе задачи требуют совсем незначительного участия
процессора, а основные необходи­мые ресурсы, которые будут задействованы на
пределе возможностей, у них разные — сетевое подключение и принтер. Значит,
если выполнять задачи одновременно, но замедление от организации квантования
времени будет незначительным, процессор легко справится с обслуживанием обеих
задач. В то же время, если каждая задача по отдельности занимала, скажем, два
часа, то вполне вероятно, что и при одновременном исполнении потребу­ется не
более тех же двух часов, а сделано при этом будет гораздо больше.

</p>
<p>Если же задачи в основном загружают процессор (например, мате­матические
расчеты), то их одновременное исполнение займет в лучшем случае столько же
времени, что и последовательное, а то и больше.

</p>
<p>Третье преимущество появляется из-за возможности более гибко уп­равлять
выполнением задач
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Предположим, пользователь системы, не Поддерживающей
многопоточность, решил скачать большой файл из се­ти, или произвести сложное
вычисление, что занимает, скажем, два часа. Запустив задачу на выполнение, он
может внезапно обнаружить, что ему Нужен не этот, а какой-нибудь другой файл
(или вычисление с другими Начальными параметрами). Однако если приложение
занимается только Работой с сетью (вычислениями) и не реагирует на действия
пользовате­ля (не обрабатываются данные с устройств ввода, таких как клавиатура
или мышь), то он не сможет быстро исправить ошибку. Получается, чт0 процессор
выполняет большее количество вычислений, но при этом при­носит гораздо меньше
пользы.

</p>
<p>Процедура квантования времени поддерживает приоритеты (priori­ty) задач. В Java приоритет
представляется целым числом. Чем больще число, тем выше приоритет.
Строгих правил работы с приоритетами нет каждая реализация может вести себя
по-разному на разных платформах Однако есть общее правило — поток с более
высоким приоритетом будет получать большее количество квантов времени на
исполнение и таким образом сможет быстрее выполнять свои действия и реагировать
на по­ступающие данные.

</p>
<p>В описанном примере представляется разумным запустить дополни­тельный
поток, отвечающий за взаимодействие с пользователем. Ему можно поставить
высокий приоритет, так как в случае бездействия поль­зователя этот поток
практически не будет занимать ресурсы машины. В случае же активности
пользователя необходимо как можно быстрее про­извести необходимые действия,
чтобы обеспечить максимальную эффек­тивность работы пользователя.

</p>
<p>Рассмотрим здесь же еще одно свойство потоков. Раньше, когда рас­сматривались
однопоточные приложения, завершение вычислений одно­значно приводило к
завершению выполнения программы. Теперь же при­ложение должно работать до тех
пор, пока есть хоть один действующий поток исполнения. В то же время часто
бывают нужны обслуживающие потоки, которые не имеют никакого смысла, если они
остаются в системе одни. Например, автоматический сборщик мусора в Java запускается в виде фонового (низкоприоритетного) процесса. Его задача —
отслеживать объекты, которые уже не используются другими потоками, и затем унич­тожать
их, освобождая оперативную память. Понятно, что работа одного потока garbage collector'a не имеет никакого
смысла.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Такие обслуживающие потоки называют демонами (daemon), это свойство
можно установить любому потоку. В итоге приложение выпол­няется до тех пор, пока есть хотя бы один поток
не-демон.

</p>
<p>Рассмотрим, как потоки
реализованы в Java.

</p>
<p>Базовые
классы для работы с потоками Класс
Thread

</p>
<p>Поток выполнения в Java представляется
экземпляром класса Thread. Для того, чтобы написать свой поток исполнения, необходим0 наследоваться
от этого класса и переопределить метод run(). Например.

</p>
<p>public class MyThread extends Thread { public void run() {

</p>
<p>// некоторое долгое
действие, вычисление long sum=0;

</p>
<p>for (int i=0; i&lt;1000; i++) { sum+=i;

</p>
<p>}

</p>
<p>System.out.println(sum);

</p>
<p>}

</p>
<p>}

</p>
<p>Метод run() содержит действия, которые должны выполняться в ио­дом потоке
исполнения. Чтобы запустить его, необходимо создать эк­земпляр
класса-наследника и вызвать унаследованный метод start(), ко­торый
сообщает виртуальной машине, что требуется запустить новый по­ток исполнения и
начать выполнять в нем метод run().

</p>
<p>MyThread t = new
MyThread(); t.start();

</p>
<p>В результате чего на консоли появится результат: 499500

</p>
<p>Когда метод run() завершен (в частности, встретилось выражение return), поток выполнения
останавливается. Однако ничто не препятству­ет записи бесконечного
цикла в этом методе. В результате поток не прервет своего исполнения и будет остановлен только при завершении работы всего
приложения.

</p>
<p> 

</p>
<p> 

</p>
<p>Интерфейс Runnable

</p>
<p>Описанный подход имеет один недостаток. Поскольку в Java множе­ственное наследование отсутствует, требование наследоваться от Thread Может привести к конфликту. Если еще раз посмотреть на приведенный Вьпле пример, станет понято, что наследование производилось только с Целью переопределения метода run(). Поэтому предлагается более про­стой способ создать свой поток исполнения. Достаточно реализовать ин­терфейс Runnable, в котором
объявлен только один метод - уже знако­вый void run(). Запишем пример,
приведенный выше, с помощью этого ^ерфейса:

</p>
<p>public class MyRunnable implements Runnable { public void run() {

</p>
<p>// некоторое долгое действие, вычисление long sum=0;

</p>
<p>for (inti=0; i&lt;1000; i++) { sum+=i;

</p>
<p>}

</p>
<p>System, out. println(sum);

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Также незначительно меняется процедура запуска потока:

</p>
<p> 

</p>
<p>Runnable г = new
MyRunnable(); Thread t = new Thread(r); t.start();

</p>
<p> 

</p>
<p>Если
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>раньше объект, представляющий сам поток выполнения, и объект с
методом run(), реализующим необходимую функциональность, были объединены в одном
экземпляре класса MyThread, то теперь они разделены. Какой из двух подходов удобней, решается в
каждом конкрет­ном случае.

</p>
<p>Подчеркнем, что Runnable не является полной
заменой классу Thread, поскольку создание и запуск самого потока исполнения возможно только
через метод Thread.start().

</p>
<p> 

</p>
<p>Работа с приоритетами

</p>
<p>Рассмотрим, как в Java можно назначать
потокам приоритеты. Для этого в классе Thread существуют методы getPriority() и setPriority(), а также объявлены три константы:

</p>
<p>MIN_PRIORI7Y MAX_PRIORITY NORMPRIORITY

</p>
<p> 

</p>
<p>Из названия понятно, что
их значения описывают минимальное, максимальное и нормальное (по умолчанию)
значения приоритета. Рассмотрим следующий пример:

</p>
<p> 

</p>
<p>public class ThreadTest implements Runnable {
public void run() {

</p>
<p>double calc;

</p>
<p>for (int NO; K50000; i++) { calc=Math.sin(i*i); if
(i%10000==0) {

</p>
<p>System.out.println(getName()+" counts " + i/10000);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>public String getNameO {

</p>
<p>return Thread.currentThread().getNameO;

</p>
<p>}

</p>
<p>public static void main(String s[]) { // Подготовка потоков Thread
t[] = newThread[3]; for (int i=0; Kt.length; i++) {

</p>
<p>t[i]=newThread(newThreadTest(), "Thread "+i);

</p>
<p>}

</p>
<p>// Запуск потоков for (int i=0; Kt.length; i++) { t[i].start();

</p>
<p>System.out.println(t[i].getName()+"
started");

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>В примере используется несколько новых методов класса Thread:

</p>
<p> 

</p>
<p>•   getName()

</p>
<p>Обратите внимание,
что конструктору класса Thread передается два
параметра. К реализации Runnable добавляется строка.
Это имя потока, которое используется только для упрощения его иден­тификации.
Имена нескольких потоков могут совпадать. Если его не задать, то Java генерирует простую строку вида "Thread-" и но­мер
потока (вычисляется простым счетчиком). Именно это имя возвращается методом getName(). Его можно
сменить с помощью метода setName().

</p>
<p> 

</p>
<p>•   current-Thread ()

</p>
<p>Этот статический метод позволяет в любом месте кода получить ссылку на
объект класса Thread, представляющий текущий поток исполнения.








</p>
<p>Курс




</p>
<p>Программирование
на і




</p>
<p>,ІіИЯ 12________________________________________ Потоки выполнения.
Синхронизация








</p>
<p>Результат работы такой программы будет иметь следующий вИД:

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1С
  </p>
</td>
  <td width="46" valign="top">
  <p>) startec
  </p>
</td>
  <td width="15" valign="top">
  <p>]
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1 1
  </p>
</td>
  <td width="46" valign="top">
  <p>startec
  </p>
</td>
  <td width="15" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>! startec
  </p>
</td>
  <td width="15" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>i counts
  </p>
</td>
  <td width="15" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="15" valign="top">
  <p>4
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts •
  </p>
</td>
  <td width="15" valign="top">
  <p>4
  </p>
</td>
 </tr>
 <tr>
  <td width="50" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts &lt;
  </p>
</td>
  <td width="15" valign="top">
  <p>4
  </p>
</td>
 </tr>
</table>

<p>Мы видим, что все три потока были запущены один за другим и на­чали
проводить вычисления
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Видно также, что потоки исполняются без определенного
порядка, случайным образом. Тем не менее, в среднем они движутся с одной
скоростью, никто не отстает и не догоняет.

</p>
<p>Введем в программу работу с приоритетами, расставим разные зна­чения для
разных потоков и посмотрим, как это скажется на выполнении. Изменяется только метод main().

</p>
<p>public static
void main(String s[]) { // Подготовка потоков

</p>
<p>Thread t[] = new Thread[3]; for (int i=0; Kt.length;
i++) {

</p>
<p>t[i]=newThread(new
ThreadTest(), "Thread "+i); t[i].setPriority(Thread.MIN_PRIORITY+
(Thread. MAX_PRIORI-TY-Thread.MlN_PRIORITY)/t.length*i); }

</p>
<p>// Запуск потоков

</p>
<p>for (int i=0; Kt.length; i++) { t[i].start();

</p>
<p>System.out.println(t[i].getName()+"
started");

</p>
<p>}

</p>
<p> 

</p>
<p>формула вычисления приоритетов позволяет равномерно распреде-все
допустимые значения для всех запускаемых потоков. На самом константа
минимального приоритета имеет значение 1, максималь-

</p>
<p>0^                                       г:  -г

</p>
<p>Лого Ю, нормального 5. Так что в простых программах можно явно поль рваться этими величинами и
указывать в качестве, например, понижен цого приоритета значение 3.
Результатом работы будет:

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>started
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>started
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>started
  </p>
</td>
  <td width="11" valign="top">
  <p> 
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>4
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>4
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>1
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>2
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>3
  </p>
</td>
 </tr>
 <tr>
  <td width="46" valign="top">
  <p>Thread
  </p>
</td>
  <td width="11" valign="top">
  <p>0
  </p>
</td>
  <td width="46" valign="top">
  <p>counts
  </p>
</td>
  <td width="11" valign="top">
  <p>4
  </p>
</td>
 </tr>
</table>

<p> 

</p>
<p>Потоки, как и раньше, стартуют последовательно. Но затем мы ви­дим, что
чем выше приоритет, тем быстрее отрабатывает поток. Тем не ме­нее, весьма
показательно, что поток с минимальным приоритетом (Thread 0)все же получил возможность выполнить одно действие раньше, чем от­работал
поток с более высоким приоритетом (Thread 1). Это говорит о ^м, что приоритеты не делают систему однопоточной,
выполняющей единовременно лишь один поток с наивысшим приоритетом. Напротив,
Приоритеты позволяют одновременно работать над несколькими задачами сУчетом
их важности.

</p>
<p>Если увеличить параметры метода (выполнять 500000 вычислений, а не
50000, и выводить сообщение каждое 1000-е вычисление, а не 10000-е), 10
Можно будет наглядно увидеть, что все три потока имеют возможность поднять свои действия
одновременно, просто более высокий приоритет позволяет выполнять их чаще.

</p>
<p>Курс_______________________________________________________ Программирование
на^и

</p>
<p>Демон-потоки

</p>
<p>Демон-потоки позволяют описывать фоновые процессы, КОТОр! нужны только для
обслуживания основных потоков выполнения и не \,( гут существовать
без них. Для работы с этим свойством существуют метот зетОаегтюп() и 1зОаетоп().

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Рассмотрим следующий пример:

</p>
<p> 

</p>
<p>public class ThreadTest implements Runnable {

</p>
<p>// Отдельная группа, в которой будут // находиться все потоки ThreadTest public final static ThreadGroup GROUP = newThreadGroupf'Daemon
demo");

</p>
<p> 

</p>
<p>// Стартовое значение,

</p>
<p>// указывается при создании объекта

</p>
<p>private int start;

</p>
<p>public ThreadTest(int s) { start = (s%2==0)?s:
s+1;

</p>
<p>newThread(GROUP, this, "Thread "+start).start();

</p>
<p>}

</p>
<p>public void run() {

</p>
<p>// Начинаем обратный отсчет for (int Nstart; i&gt;0; i-) { try{

</p>
<p>Thread. sleep(300); } catch (InterruptedException e) {} // По достижении середины порождаем новый // поток с половинным
начальным значением if (start&gt;2 &amp;&amp; i==start/2) {

</p>
<p>new ThreadTest(i);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>public static void main(String s[]) { new
ThreadTest( 16); new DaemonDemo(); }

</p>
<p>Потоки выполнения. Синхронизация

</p>
<p> 

</p>
<p>public class DaemonDemo extends Thread { public
DaemonDemo() {

</p>
<p>superf'Daemon
demo thread"); setDaemon(true); start();

</p>
<p>}

</p>
<p>public void run() {

</p>
<p>Thread threads[]=new Thread[10]; while (true) {

</p>
<p>// Получаем набор всех потоков из // тестовой группы

</p>
<p>int count=ThreadTest.GROUP.activeCount(); if
(threads.length&lt;count) threads =

</p>
<p>newThread[count+10];
count=ThreadTest.GROUP.enumerate(threads);

</p>
<p> 

</p>
<p>// Распечатываем имя каждого потока for (int i=0; Kcount; i++) {

</p>
<p>System.out.print(threads[i].getName()+", ");

</p>
<p>}

</p>
<p>System.out.println(); try{

</p>
<p>Thread.sleep(300); } catch
(InterruptedException e) {}

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>В этом примере происходит следующее. Потоки ThreadTest имеют некоторое
стартовое значение, передаваемое им при создании. В методе run() это значение последовательно уменьшается. При достижении по­ловины от
начальной величины порождается новый поток с вдвое мень­шим начальным
значением. По исчерпании счетчика поток останавли-^ется. Метод main() порождает первый
поток со стартовым значением ^6- В ходе программы будут дополнительно порождены потоки со значе­ниями 8,
4, 2.

</p>
<p>За этим процессом наблюдает демон-поток DaemonDemo. Этот по-регулярно получает список всех существующих потоков ThreadTest и Распечатывает их имена для удобства наблюдения.








</p>
<p>Результатом программы будет:

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16,

</p>
<p>Thread 16, Thread 8,



</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="64" height="32">
 <tr>
  <td valign="top" align="left" height="32">
  <p>Thread
  4, Thread 4,
  </p>
</td>
 </tr>
</table>



<p>Thread 16, Thread 8, Thread 16, Thread 8, Thread 16,
Thread 8, Thread 16, Thread 8, Thread 16, Thread 8, Thread 16, Thread 8, Thread
8, Thread 4, Thread 4, Thread 2, Thread 2,

</p>
<p> 

</p>
<p>Несмотря на то, что демон-поток никогда не выходит из методг гип(), виртуальная машина прекращает работу, как только все не-демон-потоки
завершаются.

</p>
<p>В примере использовалось несколько дополнительных классоп и методов,
которые еще не были рассмотрены:

</p>
<p>• класс ThreadGroup

</p>
<p>Все потоки находятся в группах, представляемых экземплярами класса
ThreadGroup. Группа указывается при создании потока. Если группа не была
указана, то поток помешается в ту же группу. где находится поток, породивший
его.

</p>
<p>Методы асйуеСоиптД) и епитегаге() возвращают количество и полный список, соответственно, всех потоков в
группе.

</p>
<p>• sleep()

</p>
<p> 

</p>
<p>HeZ;Сущего""НОГ0"
КЛЭССа Thread "Рио-анашшвает
выпол-
ОбратиГвЗанТе                                    УКа3аНН°е КОЛИЧес™ миллисекунд

</p>
<p>иоратите внимание, что метод требует обработки
исключения

</p>
<p>|пт.еггиргг^Ехсерпоп. Он связан с возможностью активизировать метод, который
приостановил свою работу. Например, если поток занят выполнением метода
з1еер(), то есть бездействует на протя­жении указанного периода времени, его
можно вывести из этого состояния, вызвав метод 1пг.еггирг() из другого потока
выполне­ния.  В  результате  метод  з1еер()  прервется  исключением
1гг1еггир1^Ехсерпоп. Кроме метода э1еер(), существует еще один статический
метод без параметров. Когда поток вызывает его, он временно приоста-цавливает свою работу и позволяет отработать другим потокам. Один из щетодов
обязательно должен применяться внутри бесконечных циклов ожидания, иначе есть
риск, что такой ничего не делающий поток затор­мозит работу остальных потоков.

</p>
<p> 

</p>
<p>Синхронизация

</p>
<p>При многопоточной архитектуре приложения возможны
ситуации, когда несколько потоков будут одновременно работать с одними и теми
жеданными, используя их значения и присваивая новые. В таком случае результат
работы программы становится невозможно предугадать, глядя только на исходный
код. Финальные значения переменных будут зави­сеть от случайных факторов,
исходя из того, какой поток какое действие успел сделать первым или последним.

</p>
<p>Рассмотрим пример:

</p>
<p> 

</p>
<p>public class ThreadTest {

</p>
<p> 

</p>
<p>private int a=1,
b=2; public void one() { a=b;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>public void two() { b=a;

</p>
<p>}

</p>
<p>public static void main(String s[]) { int a11=0,
a22=0, a12=0; for (int i=0; i&lt;1000; i++) {

</p>
<p>final
ThreadTest о = new ThreadTest();

</p>
<p>// Запускаем первый поток, который // вызывает один метод

</p>
<p>new Thread() { public void run() { o.one();

</p>
<p>}

</p>
<p>}.start();

</p>
<p> 

</p>
<p>// Запускаем второй поток, который // вызывает второй метод new Thread() { public void run() { o.two();

</p>
<p>}

</p>
<p>}.start();

</p>
<p> 

</p>
<p>//даем потокам время отработать try {

</p>
<p>Thread. sleep(100); } catch
(InterruptedException e) {}

</p>
<p>// анализируем финальные значения if (o.a==1 &amp;&amp;o.b==1) a11++; if (o.a==2 &amp;&amp;
o.b==2) a22++; if (o.a!=o.b)a12++;

</p>
<p>}

</p>
<p>System.out.println(a11+" "+a22+"
"+a12);

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В этом примере два потока исполнения одновременно обращаются к одному и
тому же объекту, вызывая у него два разных метода, опе() и ґллгаО-Эти методы пытаются
приравнять два поля класса а и Ь друг другу, но в разном порядке. Учитывая, что
исходные значения полей равны 1 и 2, со­ответственно, можно было ожидать, что
после того, как потоки завершат свою работу, поля будут иметь одинаковое
значение. Однако понять, какое из двух возможных значений они примут, уже
невозможно. Посмотрим на результат программы:

</p>
<p> 

</p>
<p>135 864 1

</p>
<p> 

</p>
<p>Первое число показывает, сколько раз из тысячи обе переменны^ приняли
значение 1. Второе число соответствует значению 2. Такое силь­ное преобладание
одного из значений обусловлено последовательность!0

</p>
<p>^пусков потоков. Если ее
изменить, то и количества случаев с 1 и 2 так-^е меняются местами. Третье же число сообщает, что на
тысячу случаев дроизошел один, когда поля вообще обменялись значениями!

</p>
<p>При количестве итераций, равном 10000, были получены следующие данные, которые подтверждают сделанные выводы:

</p>
<p>494 9498 8

</p>
<p>А если убрать задержку перед анализом результатов, то получаемые данные
радикально меняются:

</p>
<p>0 3 997

</p>
<p> 

</p>
<p>Видимо, потоки просто не
успевают отработать.

</p>
<p>Итак, наглядно показано, сколь сильно и непредсказуемо может ме­няться
результат работы одной и той же программы, применяющей много­поточную
архитектуру. Необходимо учитывать, что в приведенном простом примере задержки
создавались вручную методом Thread.sleep(). В реаль­ных сложных системах задержки могут возникать в местах проведения
сложных операций, их длина непредсказуема и оценить их последствия не­возможно.

</p>
<p>Для более глубокого
понимания принципов многопоточной работы в Java рассмотрим организацию памяти в виртуальной машине для не­скольких
потоков.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Хранение переменных в памяти

</p>
<p>Виртуальная машина поддерживает основное хранилище дачных (main storage), в котором
сохраняются значения всех переменных и ко­торое используется всеми потоками. Под переменными здесь понима­ются поля
объектов и классов, а также элементы массивов. Что касает-Ся
локальных переменных и параметров методов, то их значения не Могут быть доступны другим потокам, поэтому они не представляют интереса.

</p>
<p>Для каждого потока
создается его собственная рабочая память (work-"Ч» memory), в которую перед
использованием копируются значения всех переменных.

</p>
<p>Рассмотрим основные операции, доступные для потоков при работе с Памятью:

</p>
<p>•   
use - чтение значения
переменной из рабочей памяти потока;

</p>
<p>•   
assign - запись значения переменной
в рабочую память потока;

</p>
<p>•   
read - получение
значения переменной из основного хранилища;

</p>
<p>•   
load — сохранение
значения переменной, прочитанного из осноц ного хранилища, в рабочей памяти;

</p>
<p>•   
store - передача значения
переменной из рабочей памяти в основ­ное хранилище для дальнейшего хранения;

</p>
<p>•   
write — сохраняет в
основном хранилище значение переменной переданной командой store.

</p>
<p>Подчеркнем, что перечисленные команды не являются методами каких-либо
классов, они недоступны программисту. Сама виртуальная машина использует их для
обеспечения корректной работы потоков испол­нения.

</p>
<p>Поток, работая с переменной, регулярно применяет команды use и assign для использования
ее текущего значения и присвоения ново­го. Кроме того, должны осуществляться
действия по передаче значе­ний в основное хранилище и из него. Они выполняются
в два этапа. При получении данных сначала основное хранилище считывает значе­ние
командой read, а затем поток сохраняет результат в своей рабочей памяти командой load. Эта пара команд
всегда выполняется вместе именно в таком порядке, т.е. нельзя выполнить одну,
не выполнив дру­гую. При отправлении данных сначала поток считывает значение из
рабочей памяти командой store, а затем основное хранилище сохраня­ет его командой write. Эта пара команд
также всегда выполняется вме­сте именно в таком порядке, т.е. нельзя выполнить
одну, не выполнив другую.

</p>
<p>Набор этих правил составлялся с тем, чтобы операции с памятью были
достаточно строги
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>для точного анализа их результатов, а с другой стороны,
правила должны оставлять достаточное пространство для различных техно­логий
оптимизаций (регистры, очереди, кэш и т.д.).

</p>
<p>Последовательность команд
подчиняется следующим правилам:

</p>
<p>•   
все действия, выполняемые
одним потоком, строго упорядочены, т.е. выполняются одно за другим;

</p>
<p>•   
все действия, выполняемые
с одной переменной в основном хра­нилище памяти, строго упорядочены, т.е.
следуют одно за другим-

</p>
<p>За исключением некоторых дополнительных очевидных правил, больше никаких
ограничений нет. Например, если поток изменил значе­ние сначала одной, а затем
другой переменной, то эти изменения могут быть переданы в основное хранилище в
обратном порядке.

</p>
<p>Поток создается с чистой рабочей памятью и должен перед использо­ванием
загрузить все необходимые переменные из основного хранилиШ3, Любая переменная
сначала создается в основном хранилище и лишь зат^1 копируется в
рабочую память потоков, которые будут ее применять.

</p>
<p>Таким образом, потоки никогда не взаимодействуют друг с дрУг°м
напрямую, только через главное хранилище.

</p>
<p>Модификатор volatile

</p>
<p>При объявлении полей объектов и классов может быть указан моди­фикатор volatile. Он устанавливает
более строгие правила работы со зна­ниями переменных.

</p>
<p>Если поток собирается выполнить команду use для volatile перемен­ной, то
требуется, чтобы предыдущим действием с этой переменной было обязательно load, и наоборот -
операция load может выполняться
только перед use. Таким образом, переменная и главное хранилище всегда имеют самое
последнее значение этой переменной.

</p>
<p>Аналогично, если поток собирается выполнить команду store для volatile переменной, то
требуется, чтобы предыдущим действием над этой переменной было обязательно assign, и наоборот -
операция assign мо­жет выполняться,
только если следующей будет store. Таким образом, пе­ременная и главное хранилище всегда имеют самое
последнее значение этой переменной.

</p>
<p>Наконец, если проводятся операции над несколькими volatile пере­менными, то передача соответствующих изменений в основное хранилище
должна проводиться строго в том же порядке.

</p>
<p>При работе с обычными переменными компилятор имеет больше Пространства
для маневра. Например, при благоприятных обстоятельствах может оказаться
возможным предсказать значение переменной, заранее Иычислить и сохранить его, а
затем в нужный момент использовать уже готовым.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Следует обратить внимание на два 64-разрядных типа, double и jbng. Поскольку многие платформы поддерживают лишь 32-битную па­мять,
величины этих типов рассматриваются как две переменные и все описанные действия
выполняются независимо для двух половинок таких значений. Конечно, если
производитель виртуальной машины считает воз­можным, он может обеспечить
атомарность операций и над этими типами. Для volatile переменных это является обязательным требованием.

</p>
<p> 

</p>
<p>Блокировки

</p>
<p>В основном хранилище для каждого объекта поддерживается блоки­ровка (lock), над которой
можно произвести два действия - установить Cock) и снять (unlock). Только один поток в один момент времени может ''^тановить блокировку
на некоторый объект. Если до того, как этот поток Выполнит операцию unlock, другой поток
попытается установить блокиров­ка' его выполнение будет приостановлено до тех пор, пока первый поток не
^ститее.

</p>
<p>Операции lock и unlock накладывают жесткое
ограничение на работу Переменными в рабочей памяти потока. После успешно
выполненного








</p>
<p> 

</p>
<p> 

</p>
<p>lock рабочая память очищается и все переменные необходимо заново счи­тывать
из основного хранилища. Аналогично, перед операцией unlock не­обходимо все переменные
сохранить в основном хранилище.

</p>
<p>Важно подчеркнуть, что блокировка является чем-то вроде флага Если блокировка на объект
установлена, это не означает, что данным объ­ектом нельзя пользоваться,
что его поля и методы становятся недоступны­ми,— это не так. Единственное
действие, которое становится невозмож­ным,— установка этой же блокировки другим
потоком, до тех пор, пока первый поток не выполнит unlock.

</p>
<p>В Java-программе для того, чтобы воспользоваться механизмом бло­кировок, существует
ключевое слово synchronized. Оно может быть при­менено в двух вариантах — для объявления synchronized-блока и как моди­фикатор метода. В обоих случаях действие его примерно одинаковое.

</p>
<p>Synchronized-блок записывается следующим образом:

</p>
<p> 

</p>
<p>synchronized (ref) {

</p>
<p> 

</p>
<p>}

</p>
<p>Прежде, чем начать выполнять действия, описанные в этом блоке, поток обязан установить
блокировку на объект, на который ссылается переменная ref (поэтому она не может быть null). Если другой
поток уже установил блокировку на этот объект, то выполнение первого потока при­останавливается до тех
пор, пока не удастся выполнить операцию lock.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>После этого блок выполняется. При завершении исполнения (как успешном, так и в случае
ошибок) производится операция unlock, чтобы освободить объект для других потоков.

</p>
<p>Рассмотрим пример:

</p>
<p> 

</p>
<p>public class
ThreadTest implements Runnable {

</p>
<p>private static
ThreadTest shared = new ThreadTest(); public void processo { for (int i=0; i&lt;3; i++) {

</p>
<p>System.out.println (Thread.currentThread().

</p>
<p>getName()+" "+i); Thread.yield();

</p>
<p>}

</p>
<p>}

</p>
<p>public void run() { shared. process();

</p>
<p>10                                                                      Потоки выполнения. Синхронизация

</p>
<p>jgKUHgJf__     
--- =—=—------- —------ —

</p>
<p>public static void main(String s[]) { for
(int i=0; i&lt;3; i++) {

</p>
<p>new Thread(new ThreadTest(),
"Thread-"+i).start();

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>В этом простом примере три потока вызывают метод у одного объекта, чтобы
тот распечатал три значения. Результатом будет:

</p>
<p>Thread-0 0 Thread-1 0 Thread-2 0 Thread-0 1 Thread-2 1 Thread-0 2 Thread-1 1 Thread-2 2 Thread-1 2

</p>
<p>To есть все потоки одновременно работают с одним методом одного объекта.
Заключим обращение к методу в synchronized-блок:

</p>
<p> 

</p>
<p>public void run() {

</p>
<p>synchronized (shared) { shared. processO;

</p>
<p>}

</p>
<p>}

</p>
<p>Теперь результат будет
строго упорядочен:

</p>
<p> 

</p>
<p>Thread-0 0 Thread-0 1 Thread-0 2 Thread-1 0 Thread-1 1 Thread-1 2 Thread-2 0 Thread-2 1 Thread-2 2








</p>
<p>Synchronized-методы работают аналогичным образом. Прежде, 4eiv начать выполнять
их, поток пытается заблокировать объект, у которого вызывается метод. После
выполнения блокировка снимается. В предыду шем примере аналогичной
упорядоченности можно было добиться, если использовать не synchronized-блок, а объявить метод process() синхро­низированным.

</p>
<p>Также допустимы методы static synchronized. При их вызове блоки­ровка устанавливается на объект класса Class, отвечающего за
тип, у ко­торого вызывается этот метод.

</p>
<p>При работе с блокировками всегда надо помнить о возможности по­явления deadlock - взаимных блокировок, которые приводят к зависа­нию программы. Если
один поток заблокировал один ресурс и пытается заблокировать второй, а другой
поток заблокировал второй и пытается за­блокировать первый, то такие потоки уже
никогда не выйдут из состояния ожидания.

</p>
<p>Рассмотрим простейший
пример:

</p>
<p>public class DeadlockDemo { //Два
объекта-ресурса

</p>
<p>public final static Object one=new Object(), two=new
Object();

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public static void main(String s[]) {

</p>
<p>// Создаем два потока, которые будут // конкурировать за доступ к
объектам one и two Thread t1 = new Thread() { public void run() {

</p>
<p>// Блокировка первого объекта synchronized(one) { Thread. yield();

</p>
<p>// Блокировка второго объекта synchronized (two) {

</p>
<p>System, out. printlnf'Success!");

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>};

</p>
<p>Thread t2 = new Thread() { public void run()
{

</p>
<p>// Блокировка второго объекта synchronized(two) { Thread.yield();

</p>
<p>// Блокировка первого объекта synchronized (one) {

</p>
<p>System, out. println("Success!");

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>};

</p>
<p>// Запускаем потоки t1 .startO; t2.start();

</p>
<p>}

</p>
<p>}

</p>
<p>Если запустить такую программу, то она никогда не закончит свою работу.
Обратите внимание на вызовы метода yield() в каждом потоке.
Они гарантируют, что когда один поток выполнил первую блокировку и переходит к
следующей, второй поток находится в таком же состоянии. Очевидно, что в
результате оба потока "замрут", не смогут продолжить свое выполнение.
Первый поток будет ждать освобождения второго объ­екта, и наоборот. Именно
такая ситуация называется "мертвой блокиров­кой", или deadlock. Если один из
потоков успел бы заблокировать оба объекта, то программа успешно бы выполнилась
до конца. Однако мно­гопоточная архитектура не дает никаких гарантий, как
именно потоки бу­дут выполняться друг относительно друга. Задержки (которые в
примере моделируются вызовами yield()) могут возникать из логики программы (необходимость произвести вычисления),
действий пользователя (не сра­зу нажал кнопку "ОК."), занятости ОС
(из-за нехватки физической опера­тивной памяти пришлось воспользоваться
виртуальной), значений при­оритетов потоков и так далее.

</p>
<p>В Java нет никаких средств
распознавания или предотвращения си­туаций deadlock. Также нет способа
перед вызовом синхронизированно­го Метода узнать, заблокирован ли уже объект
другим потоком. Програм­мист сам должен строить работу программы таким образом,
чтобы нераз­решимые блокировки не возникали. Например, в рассмотренном примере
Достаточно было организовать блокировки объектов в одном порядке (все-^ сначала
первый, затем второй) - и программа всегда выполнялась бы Успешно.

</p>
<p>Опасность возникновения взаимных блокировок заставляет с осо-\  нНым
вниманием относиться к работе с потоками. Например, важно п°мнить,
что если у объекта потока был вызван метод sleep(
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>.), то
та-"^Й поток будет бездействовать определенное время, но при этом все








</p>
<p>заблокированные им объекты будут оставаться недоступными для бло­кировок
со стороны других потоков, а это потенциальный deadlock. Та кие ситуации
крайне сложно выявить путем тестирования и отладки, г1о этому
вопросам синхронизации надо уделять много времени на этагц проектирования.

</p>
<p> 

</p>
<p> 

</p>
<p>Методы wait(), notify(), notifyAIIQ
класса Object

</p>
<p>Наконец, перейдем к рассмотрению трех методов класса Object, за­вершая
описание механизмов поддержки многопоточности в Java.

</p>
<p>Каждый объект в Java имеет не только
блокировку для synchro­nized блоков и методов,
но и так называемый wait-set, набор потоков исполнения. Любой поток может вызвать метод wait() любого объекта и
таким образом попасть в его wait-set. При этом выполнение такого по­тока приостанавливается до тех пор, пока
другой поток не вызовет у этого же объекта метод notifyAII(), который пробуждает все потоки из wait-set. Метод notify() пробуждает один
случайно выбранный поток из данного набора.

</p>
<p>Однако применение этих методов связано с одним важным ограниче­нием.
Любой из них может быть вызван потоком у объекта только после ус­тановления
блокировки на этот объект. То есть либо внутри synchronized-блока с ссылкой на этот объект в качестве аргумента, либо обращения к
ме­тодам должны быть в синхронизированных методах класса самого объекта.
Рассмотрим пример:

</p>
<p> 

</p>
<p>public class WaitThread implements Runnable {
private Object shared;

</p>
<p> 

</p>
<p>public WaitThread(Object o) { shared=o;

</p>
<p>}

</p>
<p>public void
run() {

</p>
<p>synchronized (shared) { try{

</p>
<p>shared.wait();
} catch (InterruptedException e) {} System.out.println("after wait");

</p>
<p>}

</p>
<p>public static void main(String s[]) { Object
o = new Object(); WaitThread w = new WaitThread(o); new Thread(w).start(); try{

</p>
<p>Thread.sleep(100); } catch
(InterruptedException e) {} System .out. printlnfbef ore notify");
synchronized (o) {

</p>
<p>o. notify All ();

</p>
<p>} }

</p>
<p> 

</p>
<p>Результатом программы
будет:

</p>
<p>before notify after wait

</p>
<p>Обратите внимание, что метод wait(), как и sleepO, требует обработки
ItfterruptedException, то есть его выполнение также можно прервать мето­дом interrupt().

</p>
<p>В заключение рассмотрим
более сложный пример для трех потоков:

</p>
<p>public class
ThreadTest implements Runnable {

</p>
<p>final static
private Object shared=new ObjectQ; private int type; public ThreadTest(int i) {
type=i;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>public void
run() {

</p>
<p>if (type—1 || type==2){ synchronized
(shared) {

</p>
<p>try{

</p>
<p>shared.wait(); } catch (InterruptedException e) {} System.
out. pri ntln ("Thread "+type+

</p>
<p>" after wait()");

</p>
<p>}

</p>
<p>) else {

</p>
<p>synchronized
(shared) {

</p>
<p>shared.notifyAII();

</p>
<p>System.out.println("Thread "+type+
" after notifyAII()");

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>public static void main(String s[]) { Threadiest
w1 = new ThreadTest( 1); new Thread(w1 ).start(); try {

</p>
<p>Thread.sleep(100);
} catch (InterruptedException e) {} Threadiest w2 = new ThreadTest(2); new
Thread(w2).start(); try {

</p>
<p>Thread.sleep(tOO);
} catch (InterruptedException e) {} Threadiest w3 = new ThreadTest(3); new
Thread(w3).start(); }

</p>
<p>}

</p>
<p> 

</p>
<p>Результатом работы программы будет:

</p>
<p>Thread 3 after notifyAII() Thread 1 after wait() Thread
2 after wait()

</p>
<p> 

</p>
<p>Рассмотрим, что произошло. Во-первых, был запущен поток 1, кото­рый тут
же вызвал метод wait() и приостановил свое выполнение. Затем то же самое произошло с потоком
2. Далее начинает выполняться поток 3-

</p>
<p>Сразу обращает на себя внимание следующий факт. Еще поток 1 во-шел в synchronized-блок, а стало быть, установил блокировку на объект shared. Но, судя по
результатам, это не помешало и потоку 2 зайти в syn-chronized-блок, а затем и потоку 3. Причем, для последнего это просто необходимо,
иначе как можно "разбудить" потоки 1 и 2?

</p>
<p>Можно сделать вывод, что потоки, прежде чем приостановить вы­полнение
после вызова метода wait(), отпускают все занятые блокировки-Итак, вызывается метод notifyAII(). Как уже было сказано, все потоки и3 wait-set возобновляют свою работу. Однако чтобы корректно продолжить

</p>
<p>Яр*»--

</p>
<p>волнение, необходимо вернуть блокировку на объект, ведь следующая й       і также находится
внутри synchronized-блока!

</p>
<p>Получается, что
даже после вызова notifyAII() все потоки не могут сра-возобновить работу. Лишь один из них сможет вернуть себе
блокировку Продолжить работу. Когда он покинет свой synchronized-блок и отпустит объект, второй поток возобновит свою работу, и так далее. Если по какой-фПричине объект так
и не будет освобожден, поток так никогда и не вый­дет из метода wait(), даже если будет вызван метод notifyАІІ(). В рассмотрен­ном примере потоки один за другим смогли возобновить свою работу.

</p>
<p>Кроме того, определен метод wait() с параметром,
который задает пе­риод тайм-аута, по истечении которого поток сам попытается возобновить СПОЮ работу. Но начать ему
придется все равно с повторного получения блокировки.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены принципы построения многопо-гочного приложения. В начале разбирались
достоинства и недостатки та­кой архитектуры — как правило ОС не выделяет отдельный процессор под каждый процесс, а значит
применяется процедура time slicing. Было выде­лено три признака, указывающие на целесообразность запуска нескольких потоков в рамках программы.

</p>
<p>Основу работы с потоками в Java состовляют интерфейс Runnable и класс Thread. С их помощью можно запускать и
останавливать потоки, менять их свойства, среди которых основные: приоритет и свойство dae­mon. Главная проблема, возникающая в таких программах - одновремен­ный доступ нескольких потоков
к одним и тем же данным, в первую оче­редь — к полям объектов. Для понимания, как в Java решается эта задача, был сделан краткий обзор по организации памяти в JVM, работы с пере­менными и блокировками.
Блокировки, несмотря на название, сами по &lt;*бе не ограничивают доступ к переменной. Программист использует их через ключевое слово synchronized, которое может быть указано в сигна-тУРе метода или в начале блока. В результате
выполнение не будет продол­ьно, пока блокировка не освободится.

</p>
<p>Новый механизм порождает новую проблему - взаимные блокировки Weadмock), к которой программист всегда должен быть готов, тем более, 410
Java не имеет встроенных средств для опеределения такой ситуации. В ^КЦИи разбирался пример, как организовать работу программы без "зави-^Ния" ожидающих потоков.

</p>
<p>^   В завершение рассматривались специализированные методы базово-класса
Object, которые также позволяют управлять последовательное-Работы потоков.








</p>
<p>——J[3




</p>
<p>

</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>j   
Каким образом на однопроцессорной машине исполняются
многопоточные приложения?

</p>
<p>_]   на однопроцессорном компьютере многопоточные
приложения не исполняются

</p>
<p>(~1   количество
процессоров для многопоточной архитектуры не имеет значения

</p>
<p>("1   рабочее
время процессора разбивается на небольшие интервалы, в течение которых
выполняется одна задача, после чего происходит переключение на следующую задачу

</p>
<p> 

</p>
<p> 

</p>
<p>2.     Для
чего служит в Java класс Thread?

</p>
<p>П   для
запуска потоков

</p>
<p>П   для
остановки потоков

</p>
<p>П   для
синхронизации потоков

</p>
<p>П   для
изменения свойств (например, приоритета) потоков

</p>
<p> 

</p>
<p> 

</p>
<p>3.     Какие
из методов выбрасывают InterruptedException?

</p>
<p>&#9633;       sleep

</p>
<p>—       wait

</p>
<p>—       notify

</p>
<p>&#9633;       yield








</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.   Какие преимущества дает
многопоточная архитектура?

</p>
<p>П упрощается
программа, если ее алгоритм требует выполнения нескольких действий одновременно
(например, обслуживание запросов)

</p>
<p>П   программа выполняется быстрее

</p>
<p>Г~|  
можно более полно использовать аппаратные ресурсы для каждой задачи

</p>
<p>П если
различные задачи требуют разных аппаратных ресурсов, причем, все они могут
управляться центральным процессором без перегрузки, то за счет распределенной
работы суммарное время выполнения уменьшится

</p>
<p>П   за
счет управления приоритетами потоков можно настроить систему так, что, выполняя
меньшее количество действий, она будет совершать больше полезной работы
для пользователя

</p>
<p>П   за
счет управления приоритетами потоков можно добиться ускорения работы программы

</p>
<p>Рели один поток начал исполнение synchronized-блoкa,
«казав ссылку на некий объект, может ли другой поток обратиться к полю этого
объекта? К методу?

</p>
<p>Р      да,
да

</p>
<p>Р      да,
да (если это не syпchroпized-мeтoд)

</p>
<p>Р      да,
нет

</p>
<p>Р      нет,
да

</p>
<p>Р     нет,
да (если это не syпchroпized-мeтoд)

</p>
<p>Р     нет,
нет








</p>
<p> 

</p>
<p> 

</p>
<p>2. Поскольку интерфейс Runnable представляет собой
альтернативный способ программирования потоков исполнения, можно ли в такой
программе обойтись без класса Thread?

</p>
<p>&#9633;       да

</p>
<p>П   да, если не модифицировать
свойства потока (приоритет и т.п.)

</p>
<p>&#9633;       нет








</p>
<p>Вариант З

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Что такое приоритет потока?

</p>
<p>&#9633;  
число

</p>
<p>—       количество интервалов времени,
в течение которого процессор будет обслуживать поток

</p>
<p>Г~і   процессор сначала выполняет все задачи
с более высоким приоритетом, затем - с менее высоким

</p>
<p>—       качественная характеристика,
обеспечивающая распределение процессорного времени между потоками: чем выше
приоритет тем в среднем чаще будет выделяться процессорное время для такого
потока

</p>
<p>Каким будет результат работы следующего кода? public abstract class Test implements Runnable { private
Object lock = new Object();

</p>
<p> 

</p>
<p>public void lock() { synchronized (lock) { try {
lock.wait();

</p>
<p>System, out. println("1"); } catch
(InterruptedException e) {

</p>
<p>}

</p>
<p>}

</p>
<p>}








</p>
<p> 








</p>
<p>2.   Что такое демон-поток?

</p>
<p>&#9633;   поток, который
постоянно работает и выполняет некие периодические действия

</p>
<p>—  
поток, который не может существовать без обычных потоков, так как без них
виртуальная машина прекращает свою работу

</p>
<p>П   поток, который автоматически
останавливается виртуальной машиной, когда программа больше не нуждается в нем




</p>
<p>public void unlock() { synchronized (lock) { lock.notify();
System.out.println("2");

</p>
<p>}

</p>
<p>}








</p>
<p>public static void main(String s[]) {
newThread(newTest() { public void run() { lock();

</p>
<p>}

</p>
<p>}.start();

</p>
<p>new Thread(new Test() { public void run() { unlock();

</p>
<p>}

</p>
<p>}.start();

</p>
<p>}








</p>
<p>Курс                                                                                             Программирование^^;

</p>
<p> 

</p>
<p>П      программа
не завершит работу, на консоли ничего не появится

</p>
<p>&#9633;       
1,2

</p>
<p>&#9633;          
2,1

</p>
<p>&#9633;       
программа не завершит работу,
на консоли появится 1

</p>
<p>&#9633;       
программа не завершит работу,
на консоли появится 2

</p>
<p>&#9633;       
результат трудно предугадать



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="12">
 <tr>
  <td valign="top" align="left" height="12">
  <p>«ция
  13
  </p>
</td>
 </tr>
</table>



<p>Пакет
java.lang

</p>
<p> 

</p>
<p>
</p>
<center> 
</center>
    </div>