<p style="text-align:justify"><span style="font-size:20px">Далее будем рассматривать все операции применительно к бинарным деревьям. I. Построение дерева.</span></p><p style="text-align:justify"><span style="font-size:20px">Приведем алгоритм построения упорядоченного дерева.</span></p><p style="text-align:justify"><span style="font-size:20px">1.&nbsp;Если дерево пусто, то данные переносятся в корень дерева. Если же дерево не пусто, то осуществляется спуск по одной из его ветвей таким образом, чтобы упорядоченность дерева не нарушалась. В результате новый узел становится очередным листом дерева.</span></p><p style="text-align:justify"><span style="font-size:20px">2.&nbsp;Чтобы добавить узел в уже существующее дерево, можно воспользоваться вышеприведенным алгоритмом.</span></p><p style="text-align:justify"><span style="font-size:20px">3.&nbsp;При удалении узла из дерева следует быть внимательным. Если удаляемый узел является листом, или же имеет только одного потомка, то операция проста. Если же удаляемый узел имеет двух потомков, то необходимо будет найти узел среди его потомков, который можно будет поставить на его место. Это нужно в силу требования упорядоченности дерева.</span></p><p style="text-align:justify"><span style="font-size:20px">Можно поступить таким образом: поменять удаляемый узел местами с узлом, имеющем самое большое значение ключа в левом поддереве, или с узлом, имеющем самое малое значение ключа в правом поддереве, а затем удалить искомый узел как лист.</span></p><p style="text-align:justify"><span style="font-size:20px">II. Поиск узла с заданным значением ключевого поля.</span></p><p style="text-align:justify"><span style="font-size:20px">При осуществлении этой операции необходимо совершить обход дерева. Необходимо учитывать различные формы записи дерева: префиксную, инфиксную и постфиксную.</span></p><p style="text-align:justify"><span style="font-size:20px">Возникает вопрос: каким образом представить узлы дерева, чтобы было наиболее удобно работать с ними? Можно представлять дерево с помощью массива, где каждый узел описывается величиной комбинированного типа, у которой информационное поле символьного типа и два поля ссылочного типа. Но это не совсем удобно, так как деревья имеют большое количество узлов, заранее не определенное. Поэтому лучше всего при описании дерева использовать динамические переменные. Тогда каждый узел представляется величиной одного типа, которая содержит описание заданного количества информационных полей, а количество соответствующих полей должно быть равно степени дерева. Логично отсутствие потомков определять ссылкой nil. Тогда на языке Pascal описание бинарного дерева может выглядеть следующим образом:</span></p><p style="text-align:justify"><span style="font-size:20px">TYPE TreeLink = ^Tree;</span></p><p style="text-align:justify"><span style="font-size:20px">Tree = record;</span></p><p style="text-align:justify"><span style="font-size:20px">Inf: &lt;тип данных&gt;;</span></p><p style="text-align:justify"><span style="font-size:20px">Left, Right: TreeLink;</span></p><p style="text-align:justify"><span style="font-size:20px">End.</span></p>