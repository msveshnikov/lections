<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p><span>Далее будем рассматривать все операции применительно к бинарным деревьям. I. Построение дерева.</span></p>
<p><span>Приведем алгоритм построения упорядоченного дерева.</span></p>
<p><span>1. Если дерево пусто, то данные переносятся в корень дерева. Если же дерево не пусто, то осуществляется спуск по одной из его ветвей таким образом, чтобы упорядоченность дерева не нарушалась. В результате новый узел становится очередным листом дерева.</span></p>
<p><span>2. Чтобы добавить узел в уже существующее дерево, можно воспользоваться вышеприведенным алгоритмом.</span></p>
<p><span>3. При удалении узла из дерева следует быть внимательным. Если удаляемый узел является листом, или же имеет только одного потомка, то операция проста. Если же удаляемый узел имеет двух потомков, то необходимо будет найти узел среди его потомков, который можно будет поставить на его место. Это нужно в силу требования упорядоченности дерева.</span></p>
<p><span>Можно поступить таким образом: поменять удаляемый узел местами с узлом, имеющем самое большое значение ключа в левом поддереве, или с узлом, имеющем самое малое значение ключа в правом поддереве, а затем удалить искомый узел как лист.</span></p>
<p><span>II. Поиск узла с заданным значением ключевого поля.</span></p>
<p><span>При осуществлении этой операции необходимо совершить обход дерева. Необходимо учитывать различные формы записи дерева: префиксную, инфиксную и постфиксную.</span></p>
<p><span>Возникает вопрос: каким образом представить узлы дерева, чтобы было наиболее удобно работать с ними? Можно представлять дерево с помощью массива, где каждый узел описывается величиной комбинированного типа, у которой информационное поле символьного типа и два поля ссылочного типа. Но это не совсем удобно, так как деревья имеют большое количество узлов, заранее не определенное. Поэтому лучше всего при описании дерева использовать динамические переменные. Тогда каждый узел представляется величиной одного типа, которая содержит описание заданного количества информационных полей, а количество соответствующих полей должно быть равно степени дерева. Логично отсутствие потомков определять ссылкой nil. Тогда на языке Pascal описание бинарного дерева может выглядеть следующим образом:</span></p>
<p><span>TYPE TreeLink = ^Tree;</span></p>
<p><span>Tree = record;</span></p>
<p><span>Inf: &lt;тип данных&gt;;</span></p>
<p><span>Left, Right: TreeLink;</span></p>
<p><span>End.</span></p>
</body></html>
