<div class="document">




<h4></h4>

<p>

Стандарт SQL/89 рекомендует рассматривать вычисление табличного выражения как последовательное применение разделов FROM, WHERE, GROUP BY и HAVING к таблицам, заданным в списке FROM. Раздел FROM имеет следующий синтаксис:

</p>
<pre>&lt;from clause&gt; ::=

   FROM &lt;table reference&gt;

 ({,&lt;table reference&gt;}...]

&lt;table reference&gt; ::=

   &lt;table name&gt; [&lt;correlation name&gt;]</pre>

<h5></h5>

<p>

Результатом выполнения раздела FROM является расширенное декартово произведение таблиц, заданных списком таблиц раздела FROM. Расширенное декартово произведение (расширенное, потому что в качестве операндов и результата допускаются мультимножества) в стандарте определяется следующим образом:

</p>
<p>

"Расширенное произведение R есть мультимножество всех строк r таких, что r является конкатенацией строк из всех идентифицированных таблиц в том порядке, в котором они идентифицированы. Мощность R есть произведение мощностей идентифицированных таблиц. Порядковый номер столбца в R есть n+s, где n - порядковый номер порождающего столбца в именованной таблице T, а s - сумма степеней всех таблиц, идентифицированных до T в разделе FROM".

</p>
<p>

Как видно из синтаксиса, рядом с именем таблицы можно указывать еще одно имя "correlation name". Фактически, это некоторый синоним имени таблицы, который можно использовать в других разделах табличного выражения для ссылки на строки именно этого вхождения таблицы.

</p>
<p>

Если табличное выражение содержит только раздел FROM (это единственный обязательный раздел табличного выражения), то результат табличного выражения совпадает с результатом раздела FROM.

</p>
<h5></h5>

<p>

Если в табличном выражении присутствует раздел WHERE, то следующим вычисляется он. Синтаксис раздела WHERE следующий:

</p>
<pre>&lt;where clause&gt; ::= WHERE &lt;search condition&gt;

&lt;search condition&gt; ::=

   &lt;boolean term&gt;

 ( &lt;search condition&gt; OR &lt;boolean term&gt;

&lt;Boolean term&gt; ::=

   &lt;boolean factor&gt;

 ( &lt;boolean term&gt; AND &lt;boolean factor&gt;

&lt;boolean factor&gt; ::= [NOT] &lt;boolean primary&gt;

&lt;boolean primary&gt; ::= &lt;predicate&gt; | (&lt;search condition&gt;)</pre>

<p>

Вычисление раздела WHERE производится по следующим правилам: Пусть R - результат вычисления раздела FROM. Тогда условие поиска применяется ко всем строкам R, и результатом раздела WHERE является таблица, состоящая из тех строк R, для которого результатом вычисления условия поиска является true. Если условие выборки включает подзапросы, то каждый подзапрос вычисляется для каждого кортежа таблицы R (в стандарте используется термин "effectively" в том смысле, что результат должен быть таким, как если бы каждый подзапрос действительно вычислялся заново для каждого кортежа R).

</p>
<p>

Заметим, что поскольку SQL/89 допускает наличие в базе данных неопределенных значений, то вычисление условия поиска производится не в булевой, а в трехзначной логике со значениями true, false и unknown (неизвестно). Для любого предиката известно, в каких ситуациях он может порождать значение unknown. Булевские операции AND, OR и NOT работают в трехзначной логике следующим образом:

</p>
<pre>true AND unknown = unknown

unknown AND true = unknown

unknown AND unknown = unknown

true OR unknown = true

unknown OR true = true

unknown OR unknown = unknown

NOT unknown = unknown</pre>

<p>

Среди предикатов условия поиска в соответствии с SQL/89 могут находиться следующие предикаты: предикат сравнения, предикат between, предикат in, предикат like, предикат null, предикат с квантором и предикат exists. Сразу заметим, что во всех реализациях SQL на эффективность выполнения запроса существенно влияет наличие в условии поиска простых предикатов сравнения (предикатов, задающих сравнение столбца таблицы с константой). Наличие таких предикатов позволяет СУБД использовать индексы при выполнении запроса, т.е. избегать полного просмотра таблицы. Хотя в принципе язык SQL позволяет пользователям не заботиться о конкретном наборе предикатов в условии выборки (лишь бы они были синтаксически и семантически правильны), при реальном использовании SQL-ориентированных СУБД такие технические детали стоит иметь в виду.

</p>
<p>

<b>Предикат сравнения

</b></p>
<p>

Синтаксис предиката сравнения определяется следующими правилами:

</p>
<pre>&lt;comparison predicate&gt; ::=

   &lt;value expression&gt; &lt;comp op&gt;

  {&lt;value expression&gt; | &lt;subquery&gt;}

&lt;comp op&gt; ::=

   = | &lt;&gt; | &lt; | &gt; | &lt;= | &gt;=</pre>

<p>

Через "&lt;&gt;" обозначается операция "неравенства". Арифметические выражения левой и правой частей предиката сравнения строятся по общим правилам построения арифметических выражений и могут включать в общем случае имена столбцов таблиц из раздела FROM и константы. Типы данных арифметических выражений должны быть сравнимыми (например, если тип столбца a таблицы A является типом символьных строк, то предикат "a = 5" недопустим).

</p>
<p>

Если правый операнд операции сравнения задается подзапросом, то дополнительным ограничением является то, что мощность результата подзапроса должна быть не более единицы. Если хотя бы один из операндов операции сравнения имеет неопределенное значение, или если правый операнд является подзапросом с пустым результатом, то значение предиката сравнения равно unknown.

</p>
<p>

Заметим, что значение арифметического выражения не определено, если в его вычислении участвует хотя бы одно неопределенное значение. Еще одно важное замечание из стандарта SQL/89: в контексте GROUP BY, DISTINCT и ORDER BY неопределенное значение выступает как специальный вид определенного значения, т.е. возможно, например, образование группы строк, значение указанного столбца которых является неопределенным. Для обеспечения переносимости прикладных программ нужно внимательно оценивать специфику работы с неопределенными значениями в конкретной СУБД.

</p>
<p>

<b>Предикат between

</b></p>
<p>

Предикат between имеет следующий синтаксис:

</p>
<pre>&lt;between predicate&gt; ::=

   &lt;value expression&gt;

   [NOT] BETWEEN &lt;value expression&gt; AND &lt;value expression&gt;</pre>

<p>

Результат "x BETWEEN y AND z" тот же самый, что результат "x &gt;= y AND x &lt;= z". Результат "x NOT BETWEEN y AND z" тот же самый, что результат "NOT (x BETWEEN y AND z)".

</p>
<p>

<b>Предикат in

</b></p>
<p>

Предикат in определяется следующими синтаксическими правилами:

</p>
<pre>&lt;in predicate&gt; ::=

   &lt;value expression&gt; [NOT] IN

  {&lt;subquery&gt; | (&lt;in value list&gt;)}

&lt;in value list&gt; ::=

   &lt;value specification&gt;

 {,&lt;value specification&gt;}...</pre>

<p>

Типы левого операнда и значений из списка правого операнда (напомним, что результирующая таблица подзапроса должна содержать ровно один столбец) должны быть сравнимыми.

</p>
<p>

Значение предиката равно true в том и только в том случае, когда значение левого операнда совпадает хотя бы с одним значением списка правого операнда. Если список правого операнда пуст (так может быть, если правый операнд задается подзапросом), или значение "подразумеваемого" предиката сравнения x = y (где x - значение арифметического выражения левого операнда) равно false для каждого элемента y списка правого операнда, то значение предиката in равно false. В противном случае значение предиката in равно unknown. По определению значение предиката "x NOT IN S" равно значению предиката "NOT (x IN S)".

</p>
<p>

<b>Предикат like

</b></p>
<p>

Предикат like имеет следующий синтаксис:

</p>
<pre>&lt;like predicate&gt; ::=

   &lt;column specification&gt; [NOT] LIKE &lt;pattern&gt;

   [ESCAPE &lt;escape character&gt;]

&lt;pattern&gt; ::= &lt;value specification&gt;

   &lt;escape character&gt; ::= &lt;value specification&gt;</pre>

<p>

Типы данных столбца левого операнда и образца должны быть типами символьных строк. В разделе ESCAPE должен специфицироваться одиночный символ.

</p>
<p>

Значение предиката равно true, если pattern является подстрокой заданного столбца. При этом, если раздел ESCAPE отсутствует, то при сопоставлении шаблона со строкой производится специальная интерпретация двух символов шаблона: символ подчеркивания ("_") обозначает любой одиночный символ; символ процента ("%") обозначает последовательность произвольных символов произвольной длины (может быть, нулевой).

</p>
<p>

Если же раздел ESCAPE присутствует и специфицирует некоторый одиночный символ x, то пары символов "x_" и "x%" представляют одиночные символы "_" и "%" соответственно.

</p>
<p>

Значение предиката like есть unknown, если значение столбца, либо шаблона не определено.

</p>
<p>

Значение предиката "x NOT LIKE y ESCAPE z" совпадает со значением "NOT x LIKE y



ESCAPE z".

</p>
<p>

<b>Предикат null

</b></p>
<p>

Предикат null описывается синтаксическим правилом:

</p>
<pre>&lt;null predicate&gt; ::=

   &lt;column specification&gt; IS [NOT] NULL</pre>

<p>

Этот предикат всегда принимает значения true или false. При этом значение "x IS NULL" равно true тогда и только тогда, когда значение x не определено. Значение предиката "x NOT IS NULL" равно значению "NOT x IS NULL".

</p>
<p>

<b>Предикат с квантором

</b></p>
<p>

Предикат с квантором имеет следующий синтаксис:

</p>
<pre>&lt;quantified predicate&gt; ::=

   &lt;value expression&gt; &lt;comp op&gt; &lt;quantifier&gt; &lt;subquery&gt;

&lt;quantifier&gt; ::=

   &lt;all&gt; | &lt;some&gt;

&lt;all&gt; ::= ALL

&lt;some&gt; ::= SOME | ANY</pre>

<p>

Обозначим через x результат вычисления арифметического выражения левой части предиката, а через S результат вычисления подзапроса.

</p>
<p>

Предикат "x &lt;comp op&gt; ALL S" имеет значение true, если S пусто или значение предиката "x &lt;comp op&gt; s" равно true для каждого s, входящего в S. Предикат "x &lt;comp op&gt; ALL S" имеет значение false, если значение предиката "x &lt;comp op&gt; s" равно false хотя бы для одного s, входящего в S. В остальных случаях значение предиката "x &lt;comp op&gt; ALL S" равно unknown.

</p>
<p>

Предикат "x &lt;comp op&gt; SOME S" имеет значение false, если S пусто или значение предиката "x &lt;comp op&gt; s" равно false для каждого s, входящего в S. Предикат "x &lt;comp op&gt; SOME S" имеет значение true, если значение предиката "x &lt;comp op&gt; s" равно true хотя бы для одного s, входящего в S. В остальных случаях значение предиката "x &lt;comp op&gt; SOME S" равно unknown.

</p>
<p>

<b>Предикат exists

</b></p>
<p>

Предикат exists имеет следующий синтаксис:

</p>
<pre>&lt;exists predicate&gt; ::=

   EXISTS &lt;subquery&gt;</pre>

<p>

Значением этого предиката всегда является true или false, и это значение равно true тогда и только тогда, когда результат вычисления подзапроса не пуст.

</p>
<h5></h5>

<p>

Если в табличном выражении присутствует раздел GROUP BY, то следующим выполняется он. Синтаксис раздела GROUP BY следующий:

</p>
<pre>&lt;group by clause&gt; ::=

   GROUP BY &lt;column specification&gt;

   [{,&lt;column specification&gt;}...]</pre>

<p>

Если обозначить через R таблицу, являющуюся результатом предыдущего раздела (FROM или WHERE), то результатом раздела GROUP BY является разбиение R на множество групп строк, состоящего из минимального числа групп таких, что для каждого столбца из списка столбцов раздела GROUP BY во всех строках каждой группы, включающей более одной строки, значения этого столбца равны. Для обозначения результата раздела GROUP BY в стандарте используется термин "сгруппированная таблица".

</p>
<h5></h5>

<p>

Наконец, последним при вычислении табличного выражения используется раздел HAVING (если он присутствует). Синтаксис этого раздела следующий:

</p>
<pre>&lt;having clause&gt; ::=

   HAVING &lt;search condition&gt;</pre>

<p>

Раздел HAVING может осмысленно появиться в табличном выражении только в том случае, когда в нем присутствует раздел GROUP BY. Условие поиска этого раздела задает условие на группу строк сгруппированной таблицы. Формально раздел HAVING может присутствовать и в табличном выражении, не содержащем GROUP BY. В этом случае полагается, что результат вычисления предыдущих разделов представляет собой сгруппированную таблицу, состоящую из одной группы без выделенных столбцов группирования.

</p>
<p>

Условие поиска раздела HAVING строится по тем же синтаксическим правилам, что и условие поиска раздела WHERE, и может включать те же самые предикаты. Однако имеются специальные синтаксические ограничения по части использования в условии поиска спецификаций столбцов таблиц из раздела FROM данного табличного выражения. Эти ограничения следуют из того, что условие поиска раздела HAVING задает условие на целую группу, а не на индивидуальные строки.

</p>
<p>

Поэтому в арифметических выражениях предикатов, входящих в условие выборки раздела HAVING, прямо можно использовать только спецификации столбцов, указанных в качестве столбцов группирования в разделе GROUP BY. Остальные столбцы можно специфицировать только внутри спецификаций агрегатных функций COUNT, SUM, AVG, MIN и MAX, вычисляющих в данном случае некоторое агрегатное значение для всей группы строк. Аналогично обстоит дело с подзапросами, входящими в предикаты условия выборки раздела HAVING: если в подзапросе используется характеристика текущей группы, то она может задаваться только путем ссылки на столбцы группирования.

</p>
<p>

Результатом выполнения раздела HAVING является сгруппированная таблица, содержащая только те группы строк, для которых результат вычисления условия поиска есть true. В частности, если раздел HAVING присутствует в табличном выражении, не содержащем GROUP BY, то результатом его выполнения будет либо пустая таблица, либо результат выполнения предыдущих разделов табличного выражения, рассматриваемый как одна группа без столбцов группирования.



</p>
<p></p>
<center> ||  || <p>

</p>
<p></p>
</center>
</div>