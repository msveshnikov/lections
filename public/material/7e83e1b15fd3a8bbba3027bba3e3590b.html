# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 4. Типы данных</h2></center>

<p> 

</p>
<p> 

</p>
<p>Типы данных определяют основные возможности любого
языка. Кроме того, Java является строго
типизированным языком, а потому четкое понима­ние модели типов данных очень
помогает в написании качественных про­грамм. Лекция начинается с введения
понятия переменной, на примере кото­рой иллюстрируются особенности применения
типов в Java. Описывается раз­деление всех типов на простейшие и
ссылочные, операции над значениями различных типов, а также особый класс Class, который играет роль метаклас­са в Java.

</p>
<p> 

</p>
<p>Ключевые слова: простые типы данных, примитивные типы данных, объектные типы данных,
ссылочные типы данных, объявления, inte­ger, floating-point, boolean, overflow, underflow, reflection.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Java является строго типизированным языком. Это означает, что лю­бая переменная и любое
выражение имеют известный тип еще на момент компиляции. Такое строгое правило
позволяет выявлять многие ошибки уже во время
компиляции. Компилятор, найдя ошибку, указывает точное место (строку) и причину
ее возникновения, а динамические "баги" (от английского bugs) необходимо
сначала выявить с помощью тестирования (что может потребовать значительных усилий), а затем найти место в ко­де, которое их
породило. Поэтому четкое понимание модели типов дан­ных в Java очень помогает в написании качественных программ.

</p>
<p>Все типы данных разделяются на две группы. Первую
составляют 8 простых, или примитивных (от английского primitive), типов данных. Они подразделяются на три подгруппы:

</p>
<p>•  целочисленные

</p>
<p>-   
byte

</p>
<p>-    short -int

</p>
<p>-   
long

</p>
<p>—               char (также является
целочисленным типом)

</p>
<p>• дробные -float

</p>
<p>—               double

</p>
<p>•  булевский

</p>
<p>—               boolean

</p>
<p>8 ^-3440                                                        из








</p>
<p>Вторую группу составляют объектные, или ссылочные (от английско­го reference), типы данных. Это все классы, интерфейсы и массивы. В стан­дартных
библиотеках первых версий Java находилось
несколько сот классов и интерфейсов, сейчас их уже тысячи. Кроме стандартных,
написаны мно­гие и многие классы и интерфейсы, составляющие любую Java-программу.

</p>
<p>Иллюстрировать логику работы с типами данных проще всего на примере
переменных.

</p>
<p> 

</p>
<p>Переменные

</p>
<p>Переменные используются в программе для хранения данных. Любая
переменная имеет три базовых характеристики:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
имя;

</p>
<p>•   
тип;

</p>
<p>•   
значение.

</p>
<p>Имя уникально идентифицирует переменную и позволяет обра­щаться к ней в
программе. Тип описывает, какие величины может хранить переменная. Значение -
текущая величина, хранящаяся в переменной на данный момент.

</p>
<p>Работа с переменной всегда начинается с ее объявления (declara­tion). Конечно, оно
должно включать в себя имя объявляемой пере­менной. Как было сказано, в Java любая переменная имеет строгий тип, который также задается при
объявлении и никогда не меняется. Значение может быть указано сразу (это
называется инициализацией), а в большинстве случаев задание начальной величины
можно и отло­жить.

</p>
<p>Некоторые примеры объявления переменных примитивного типа int с инициализаторами и без таковых:

</p>
<p> 

</p>
<p>int а;

</p>
<p>int b = 0,
с = 3+2; int d = b+c; int е = а = 5;

</p>
<p> 

</p>
<p>Из примеров видно, что инициализатором может быть не только константа,
но и арифметическое выражение. Иногда это выражение мо­жет быть вычислено во
время компиляции (такое как 3+2), тогда компи­лятор сразу записывает результат. Иногда это действие
откладывается на момент выполнения программы (например, b+с). В последнем случае
не­скольким переменным присваивается одно и то же значение, однако объ­является
лишь первая из них (в данном примере е), остальные уже долж­ны существовать.

</p>
<p>Резюмируем: объявление переменных и возможная инициализация при
объявлении описываются следующим образом. Сначала указывается тип переменной,
затем ее имя и, если необходимо, инициализатор, кото­рый может быть константой
или выражением, вычисляемым во время компиляции или исполнения программы. В
частности, можно пользо­ваться уже объявленными переменными. Далее можно поставить запятую и объявить новую
переменную точно такого же типа.

</p>
<p>После объявления переменная может применяться в различных вы­ражениях, в
которых будет браться ее текущее значение. Также в любой щомент можно изменить значение, используя оператор присваивания, Ьримерно так же, как это делалось в инициализаторах.

</p>
<p>Кроме того, при объявлении переменной может быть использовано ^ключевое
слово final. Его указывают перед типом переменной, и тогда ее необходимо сразу
инициализировать и уже больше никогда не менять ее &#9632;начение. Таким
образом, final-переменные становятся чем-то вроде кон­стант, но на самом деле
некоторые инициализаторы могут вычисляться |олько во время исполнения
программы, генерируя различные значения.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Простейший пример
объявления final-переменной:

</p>
<p> 

</p>
<p>final double pi=3.1415;

</p>
<p> 

</p>
<p>Примитивные и ссылочные типы
данных

</p>
<p>Теперь на примере переменных можно проиллюстрировать различие Ёежду
примитивными и ссылочными типами данных. Рассмотрим при-|ер, когда объявляются
две переменные одного типа, приравниваются руг другу, а затем значение одной их
них изменяется. Что произойдет со &#9632;торой переменной?

</p>
<p>Возьмем простой тип int:

</p>
<p>int а=5; // объявляем первую переменную и
инициализируем ее int b=a; //
объявляем вторую переменную и приравниваем ее к первой а=3; // меняем значение
первой print(b); //
проверяем значение второй

</p>
<p>Здесь и далее мы считаем, что функция print(...) позволяет нам неко­торым
(неважно, каким именно) способом узнать значение ее аргумента (как правило, для этого используют функцию из стандартной библиотеки %stem.out.println(...), которая выводит
значение на системную консоль).

</p>
<p>В результате мы увидим, что значение переменной b не изменилось, Оно осталось равным 5. Это означает, что переменные простого типа хра­нят непосредственно свои значения и при приравнивании двух перемен­ных
происходит копирование данного значения. Чтобы еще раз подчерк­нуть эту
особенность, приведем еще один пример:

</p>
<p>byte b=3; int a=b;

</p>
<p> 

</p>
<p>В данном примере происходит преобразование типов (оно подробно
рассматривается в соответствующей лекции). Для нас сейчас важно кон­статировать,
что переменная b хранит значение 3 типа byte, а переменная а - значение 3 типа int. Это два разных значения, и во второй строке при присваивании произошло
копирование.

</p>
<p>Теперь рассмотрим ссылочный тип данных. Переменные таких ти­пов всегда
хранят ссылки на некоторые объекты. Рассмотрим для приме­ра класс, описывающий
точку на координатной плоскости с целочислен­ными координатами. Описание класса
— это отдельная тема, но в нашем простейшем случае оно тривиально:

</p>
<p>class Point { intx, у;

</p>
<p>}

</p>
<p> 

</p>
<p>Теперь составим пример, аналогичный приведенному выше для int-переменных,
считая, что выражение new Point(3,5)
создает новый объ­ект-точку
с координатами (3,5).

</p>
<p>Point р1 = new Point(3,5);

</p>
<p>Point р2=р1;

</p>
<p>р1.х=7;

</p>
<p>print(p2.x);

</p>
<p> 

</p>
<p>В третьей строке мы изменили горизонтальную координату точки, на которую
ссылалась переменная р1, и теперь нас интересует, как это сказалось на точке, на которую ссылается
переменная р2
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Проведя та­кой эксперимент, можно убедиться, что в этот раз мы увидим
обновлен­ное значение. То есть объектные переменные после приравнивания ос­таются
"связанными" друг с другом, изменения одной сказываются на другой.

</p>
<p>Таким образом, примитивные переменные являются действитель­ными
хранилищами данных. Каждая переменная имеет значение, не за­висящее от
остальных. Ссылочные же переменные хранят лишь ссылки на объекты, причем
различные переменные могут ссылаться на один и тот же объект, как это было в
нашем примере. В этом случае их можно сравнить с наблюдателями, которые с
разных позиций смотрят на один и тот же объект и одинаково видят все
происходящие с ним изменения. Ес­ли же один наблюдатель
сменит объект наблюдения, то он перестает ви­деть и изменения, происходящие с
прежним объектом:

</p>
<p>Point р1 = new Point(3,5);

</p>
<p>Point р2=р1;

</p>
<p>р1 = new Point(7,9);

</p>
<p>print(p2.x);

</p>
<p>В этом примере мы получим 3, то есть после третьей строки пере­менные р1 и р2 ссылаются на различные объекты и поэтому имеют раз­ные значения.

</p>
<p>Теперь легко понять смысл литерала null. Такое значение
может при­нять переменная любого ссылочного типа. Это означает, что ее ссылка
никуда не указывает, объект отсутствует. Соответственно, любая попытка
обратиться к объекту через такую переменную (например, вызвать метод или взять значение поля) приведет к ошибке.

</p>
<p>Также значение null можно передать в
качестве любого объектного аргумента при вызове функций (хотя на практике
многие методы счита­ют такое значение некорректным).

</p>
<p>Память в Java с точки зрения
программиста представляется не нуля­ми и единицами или набором байтов, а как
некое виртуальное простран­ство, в котором существуют объекты. И доступ к
памяти осуществляется не по физическому адресу или указателю, а лишь через
ссылки на объек­ты. Ссылка возвращается при создании объекта и далее может быть
сохра­нена в переменной, передана в качестве аргумента и т.д. Как уже говори­лось,
допускается наличие нескольких ссылок на один объект. Возможна и
противоположная ситуация — когда на какой-то объект не существует ни одной
ссылки. Такой объект уже недоступен программе и является "мусо­ром",
то есть без толку занимает аппаратные ресурсы. Для их освобожде­ния не
требуется никаких усилий. В состав любой виртуальной машины обязательно входит
автоматический сборщик мусора garbage collector — фоновый процесс,
который как раз и занимается уничтожением ненуж­ных объектов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Очень важно помнить, что объектная переменная, в отличие от при­митивной,
может иметь значение другого типа, не совпадающего с типом переменной.
Например, если тип переменной — некий класс, то перемен­ная может ссылаться на
объект, порожденный от наследника этого класса. Все случаи подобного
несовпадения будут рассмотрены в следующих раз­делах курса.

</p>
<p>Теперь рассмотрим примитивные и ссылочные типы данных более подробно.

</p>
<p>Примитивные
типы

</p>
<p>Как уже говорилось, существует 8 простых типов данных, которые делятся
на целочисленные (integer), дробные (floating-point) и булевские (boolean).

</p>
<p> 

</p>
<p>Целочисленные
типы

</p>
<p>Целочисленные типы — это byte, short, int, long, также к ним отно­сят и char. Первые четыре типа имеют длину 1, 2, 4 и 8 байт соответст­венно, длина char — 2 байта, это непосредственно следует из того, что все символы Java описываются стандартом Unicode. Длины типов при­ведены только для оценки областей значения. Как уже
говорилось, па­мять в Java представляется
виртуальной и вычислить, сколько физичес­ких ресурсов займет та или иная
переменная, так прямолинейно не по­лучится.

</p>
<p>4 основных типа являются знаковыми, char добавлен к целочислен­ным типам данных, так как с точки зрения JVM символ и его код — поня­тия взаимооднозначные. Конечно, код символа
всегда положительный, поэтому char — единственный беззнаковый
тип. Инициализировать его можно как символьным, так и целочисленным литералом.
Во всем ос­тальном char — полноценный числовой тип
данных, который может уча­ствовать, например, в арифметических действиях,
операциях сравнения и т.п. В таблице 4.1 сведены данные по всем разобранным
типам:



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="15">
 <tr>
  <td valign="top" align="left" height="15">
  <p>1
  </p>
</td>
 </tr>
</table>



<p>Обратите внимание, что int вмещает примерно 2 миллиарда, а потому
подходит во многих случаях, когда не требуются сверхбольшие числа. Чтобы
представить себе размеры типа long, укажем, что именно он используется в
Java для отсчета
времени. Как и во многих языках, время отсчитывается от
I---------------------------------------------------------------------------------------------------------------- —

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="146" valign="top">
  <p>Название типа
  </p>
</td>
  <td width="106" valign="top">
  <p>Длина (байты)
  </p>
</td>
  <td width="175" valign="top">
  <p>Область значений
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>byte
  </p>
</td>
  <td width="106" valign="top">
  <p>1
  </p>
</td>
  <td width="175" valign="top">
  <p>-128 .. 127
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>short
  </p>
</td>
  <td width="106" valign="top">
  <p>2
  </p>
</td>
  <td width="175" valign="top">
  <p>-32.768 .. 32.767
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>int
  </p>
</td>
  <td width="106" valign="top">
  <p>4
  </p>
</td>
  <td width="175" valign="top">
  <p>-2.147.483.648
  ..2.147.483.647
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>long
  </p>
</td>
  <td width="106" valign="top">
  <p>8
  </p>
</td>
  <td width="175" valign="top">
  <p>-9.223.372.036.854.775.808 ..
  9.223.372.036.854.775.807 (примерно 10")
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>char
  </p>
</td>
  <td width="106" valign="top">
  <p>2
  </p>
</td>
  <td width="175" valign="top">
  <p>\u0000'.. \uffiT, или0.. 65.535
  </p>
</td>
 </tr>
</table>

<p> 

</p>
<p>Табл. 4.1.
Целочисленные типы данных.

</p>
<p>1 января 1970 года
в миллисекундах. Так вот, вместимость long позволяет отсчитывать время на протяжении миллионов веков(!), причем как
в буду­щее, так и в прошлое.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Почему были выделены именно эти два типа, int и long? Дело в том, что
целочисленные литералы имеют тип int по умолчанию, или тип long, если стоит буква L или I. Именно
поэтому корректным литералом считает­ся только такое число, которое
укладывается в 4 или 8 байт, соответствен­но. Иначе компилятор сочтет это
ошибкой. Таким образом, следующие литералы являются корректными:

</p>
<p> 

</p>
<p>1

</p>
<p>-2147483648 2147483648L 0L

</p>
<p>111111111111111111L

</p>
<p>Над целочисленными аргументами можно производить следующие операции:

</p>
<p>•  операции сравнения
(возвращают булевское значение)

</p>
<p>•  &lt;, &lt;=, &gt;,
&gt;=

</p>
<p>—*, !

</p>
<p>•  числовые операции
(возвращают числовое значение)

</p>
<p>•   унарные операции + и -

</p>
<p>•   арифметические операции +,-,*,/,%

</p>
<p>•   операции инкремента и декремента (в префиксной и постфиксной форме): ++
и --

</p>
<p>•   операции битового сдвига &lt;&lt;,
», &gt;»

</p>
<p>•   битовые операции ~, &amp;, |, А

</p>
<p> 

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Операторы сравнения вполне очевидны и отдельно мы их рассмат­ривать не
будем. Их результат всегда булевского типа (true или false).

</p>
<p>Работа числовых операторов также понятна, к тому же пояснялась в
предыдущей лекции. Единственное уточнение можно сделать относи­тельно
операторов + и -, которые могут быть как бинарными (иметь два операнда), так и
унарными (иметь один операнд). Бинарные операнды являются операторами сложения
и вычитания, соответственно. Унарный оператор + возвращает значение, равное
аргументу (+х всегда равно х). Унарный оператор -, примененный к значению х,
возвращает результат, Равный 0-х. Неожиданный эффект имеет место в том случае, если
аргу­мент равен наименьшему возможному значению примитивного типа.

</p>
<p>int х=-2147483648;
// наименьшее возможное
значение типа int int у=-х;

</p>
<p>Теперь значение переменной у на самом деле равно не 2147483648,
поскольку такое число не
укладывается в область значений типа int, а в точности равно
значению х! Другими словами, в этом примере выражение -х==х истинно!

</p>
<p>Дело в том, что если при выполнении числовых операций над целы­ми
числами возникает переполнение и результат не может быть сохранен в данном
примитивном типе, то Java не создает никаких
ошибок. Вместо этого все старшие биты, которые превышают вместимость типа,
просто отбрасываются. Это может привести не только к потере точной абсолют­ной
величины результата, но даже к искажению его знака, если на месте знакового
бита окажется противоположное значение.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>int х= 300000; print(x*x);

</p>
<p>Результатом такого примера
будет: -194313216

</p>
<p>Возвращаясь к инвертированию числа -2147483648,
мы видим, что
математический результат равен в точности +23\
или, в двоичном форма­те, 10....0
(единица и 31 ноль). Но
тип int рассматривает первую единицу как знаковый бит, и результат получается
равным -2147483648.

</p>
<p>Таким образом, явное выписывание в коде литералов, которые слишком
велики для используемых типов, приводит к ошибке компиля­ции (см. лекцию 3).
Если же переполнение возникает в результате выпол­нения операции,
"лишние" биты просто отбрасываются.

</p>
<p>Подчеркнем, что выражение типа -5 не является целочисленным ли­тералом. На самом деле оно состоит из
литерала 5 и оператора -. Напом­ним, что некоторые литералы (например, 2147483648)
могут встречаться только в
сочетании с унарным оператором -.

</p>
<p>Кроме того, числовые операции в Java обладают еще одной особен­ностью. Хотя целочисленные типы имеют длину 8,
16, 32 и 64 бита, вы­числения проводятся только с 32-х и 64-х битной точностью.
А это значит, что перед вычислениями может потребоваться преобразовать тип
одного или нескольких операндов.

</p>
<p>Если хотя бы один аргумент операции имеет тип long, то все аргу­менты
приводятся к этому типу и результат операции также будет типа long. Вычисление будет
произведено с точностью в 64 бита, а более стар­шие биты, если таковые
появляются в результате, отбрасываются.

</p>
<p>Если же аргументов типа long нет, то вычисление
производится с точностью в 32 бита, и все аргументы преобразуются в int (это относится к byte, short, char). Результат также
имеет тип int. Все биты старше 32-го игнорируются.

</p>
<p>Никакого способа узнать, произошло ли переполнение, нет. Расши­рим
рассмотренный пример:

</p>
<p>int &#161;=300000;

</p>
<p>print(i*i); // умножение с точностью 32 бита long m=i;

</p>
<p>print(m*m); // умножение с точностью 64 бита

</p>
<p>print(1/(m-i)); // попробуем получить разность значений int и long

</p>
<p> 

</p>
<p>Результатом такого примера будет:

</p>
<p> 

</p>
<p>-194313216
90000000000

</p>
<p>затем мы получим ошибку деления на ноль, поскольку переменные i и m хоть и разных
типов, но хранят одинаковое математическое значение и их разность равна нулю.
Первое умножение производилось с точностью в 32 бита, более старшие биты были
отброшены. Второе — с точностью в 64 бита, ответ не исказился.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Вопрос приведения типов, и в том числе специальный оператор для такого
действия, подробно рассматривается в следующих лекциях. Однако здесь хотелось
бы отметить несколько примеров, ко­торые не столь очевидны и могут создать
проблемы при написании программ. Во-первых, подчеркнем, что результатом
операции с цело­численными аргументами всегда является целое число. А значит, в
следующем примере

</p>
<p> 

</p>
<p>double х= 1/2;

</p>
<p>Переменной х будет
присвоено значение 0, а не 0.5, как можно было бы ожидать. Подробно операции с дробными аргументами
рассматриваются Ниже, но чтобы получить значение 0.5, достаточно написать 1 ./2 (теперь первый аргумент дробный и результат не будет округлен).

</p>
<p>Как уже упоминалось, время в Java измеряется в миллисекундах. По­пробуем вычислить, сколько миллисекунд
содержится в неделе и в месяце:

</p>
<p>print( 1000*60*60*24*7); // вычисление для недели print( 1000*60*60*24*30); // вычисление для месяца








</p>
<p>Необходимо
перемножить количество миллисекунд в одной секунде (1000), секунд - в минуте
(60), минут - в часе (60), часов - в дне (24) и дней — в неделе и месяце (7 и
30, соответственно). Получаем:

</p>
<p>604800000
-1702967296

</p>
<p> 

</p>
<p>Очевидно, во втором вычислении произошло переполнение. Доста­точно
сделать последний аргумент величиной типа long:

</p>
<p>print(1000*60*60*24*30L); // вычисление для месяца

</p>
<p>Получаем правильный
результат:

</p>
<p>2592000000

</p>
<p>Подобные вычисления разумно переводить на 64-битную точ­ность не на
последней операции, а заранее, чтобы избежать перепол­нения.

</p>
<p>Понятно, что типы большей длины могут хранить больший спектр значений, а
потому Java не позволяет
присвоить переменной меньшего типа значение большего типа. Например, такие
строки вызовут ошибку компиляции:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции int х=1; byte b=x;

</p>
<p> 

</p>
<p>Хотя для программиста и очевидно, что переменная b должна полу­чить значение 1, что легко укладывается в тип byte, однако компилятор не может
вычислять значение переменной х при обработке второй строки, он знает лишь, что
ее тип — int.

</p>
<p>А вот менее очевидный
пример:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции byte b=1; byte c=b+1;

</p>
<p> 

</p>
<p>И здесь компилятор не сможет успешно завершить работу. При опе­рации
сложения значение переменной b будет преобразовано в тип int и таким же будет результат
сложения, а значит, его нельзя так просто при­своить переменной типа byte.

</p>
<p>Аналогично:

</p>
<p>//
пример вызовет ошибку компиляции int х=2; long у=3; int z=x+y;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Здесь результат сложения будет уже типа long. Точно так же некор­ректна
такая инициализация:

</p>
<p>//
пример вызовет ошибку компиляции byte b=5; byte с=-5;

</p>
<p>Даже унарный оператор "-" проводит вычисления с точностью не
меньше 32 бит.

</p>
<p>Хотя во всех случаях инициализация переменных приводилась толь­ко для
примера, а предметом рассмотрения были числовые операции, укажем корректный
способ преобразовать тип числового значения:

</p>
<p>byteb=1;

</p>
<p>byte c=(byte)-b;

</p>
<p>Итак, все числовые операторы возвращают результат типа int или long. Однако существует два
исключения.

</p>
<p>Первое из них — операторы инкрементации и декрементации. Их действие
заключается в прибавлении или вычитании единицы из значе­ния переменной, после
чего результат сохраняется в этой переменной и значение всей операции равно
значению переменной (до или после изме­нения, в зависимости от того, является
оператор префиксным или пост­фиксным). А значит, и тип значения совпадает с
типом переменной. (На самом деле, вычисления все равно производятся с точностью
минимум 32 бита, однако при присвоении переменной результата его тип
понижается.)

</p>
<p> 

</p>
<p>byte х=5;

</p>
<p>byte у1=х++; // на момент начала исполнения
х равен 5

</p>
<p>byte у2=х--; // на момент начала исполнения
х равен 6

</p>
<p>byte уЗ=++х; // на момент начала исполнения
х равен 5

</p>
<p>byte у4=--х; // на момент начала исполнения
х равен 6

</p>
<p>print(y1);

</p>
<p>print(y2);

</p>
<p>print(y3);

</p>
<p>print(y4);

</p>
<p>В результате получаем:

</p>
<p> 

</p>
<p>5 6 6 5

</p>
<p>Никаких проблем с присвоением результата операторов ++ и — пере­менным
типа byte. Завершая рассмотрение этих операторов, приведем еще один пример:

</p>
<p> 

</p>
<p>byte х=-128; print(-x);

</p>
<p>byte у= 127; print(++y);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>128 -128

</p>
<p>Этот пример иллюстрирует вопросы преобразования типов при вы­числениях и
случаи переполнения.

</p>
<p>Вторым исключением является оператор с условием ? :. Если второй и
третий операнды имеют одинаковый тип, то и результат операции будет такого же
типа.

</p>
<p> 

</p>
<p>byte х=2; byte у=3;

</p>
<p>byte z=(x&gt;y) ? х : у; // верно, х и у одинакового типа byte abs=(x&gt;0) ? х : -х; // неверно!

</p>
<p>Последняя строка неверна, так как третий аргумент содержит число­вую
операцию, стало быть, его тип int, а значит, и тип всей операции будет int, и присвоение
некорректно. Даже если второй аргумент имеет тип byte, а третий — short, значение будет типа
int.

</p>
<p>Наконец, рассмотрим оператор конкатенации со строкой. Оператор + может
принимать в качестве аргумента строковые величины
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Если од­ним из аргументов
является строка, а вторым — целое число, то число бу­дет преобразовано в текст
и строки объединятся.

</p>
<p>int х=1; print("x="+x);

</p>
<p>Результатом будет: х=1

</p>
<p>Обратите внимание
на следующий пример:

</p>
<p> 

</p>
<p>print(1+2+"text");
print("text"+1+2);

</p>
<p> 

</p>
<p>Его результатом будет:

</p>
<p>3text text12

</p>
<p>Отдельно рассмотрим работу с типом char. Значения этого
типа могут полноценно участвовать в числовых операциях:

</p>
<p>chard=10;

</p>
<p>char с2-А'; // латинская буква А (\u0041, код 65) int i=c1+c2-*B';

</p>
<p>Переменная і получит значение 9. Рассмотрим следующий пример:

</p>
<p> 

</p>
<p>char с-А';

</p>
<p>print(c);

</p>
<p>print(c+1);

</p>
<p>print("c="+c);

</p>
<p>ргіпі('с'+'='+с);

</p>
<p> 

</p>
<p>Его результатом будет:

</p>
<p> 

</p>
<p>А 66 с=А 225

</p>
<p>В первом случае в метод print было передано значение типа char, по­этому
отобразился символ. Во втором случае был передан результат сло­жения, то есть
число, и именно число появилось на экране. Далее при вожений со строкой тип char был преобразован в текст в виде символа.

</p>
<p>Наконец в последней
строке произошло сложение трех чисел: 'с' (код 99), '=' (код 61) и переменной с (т.е. код 'А' - 65).

</p>
<p>Для каждого примитивного типа существуют специальные вспомо­гательные
классы-обертки (wrapper classes). Для типов byte, short, int, long, char это Byte, Short, Integer, Long, Character. Эти классы содержат многие
полезные методы для работы с целочисленными значениями. На­пример,
преобразование из текста в число. Кроме того, есть класс Math, который хоть и предназначен
в основном для работы с дробными числа­ми, но также предоставляет некоторые
возможности и для целых.

</p>
<p>В заключение подчеркнем, что единственные операции с целыми числами, при
которых Java генерирует ошибки,-
это деление на ноль (операторы / и %).

</p>
<p> 

</p>
<p>Дробные типы

</p>
<p>Дробные типы — это float и double. Их длина - 4 и 8 байт, соответст­венно. Оба типа знаковые. Ниже в таблице сведены их
характеристики:

</p>
<p>Для целочисленных типов область значений задавалась верхней и нижней
границами, весьма близкими по модулю. Для дробных типов добавляется еще одно
ограничение — насколько можно приблизиться к нулю, другими словами - каково
наименьшее положительное нену­левое значение. Таким образом, нельзя задать
литерал заведомо боль­ший, чем позволяет соответствующий тип данных, это
приведет к ошибке overflow. И нельзя задать литерал, значение которого по моду­лю слишком мало для
данного типа, компилятор сгенерирует ошибку underflow.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции

</p>
<p>float f = 1e40f; //
значение слишком велико, overflow

</p>
<p></p>
<center><img width="449" height="158" src="http://kufas.ru/java.files/image012.png"></center>
double d =
1е-350; // значение слишком мало, underflow

<p>Напомним, что если в конце литерала стоит буква F или f, то литерал рассматривается как значение типа float. По умолчанию дробный литерал имеет тип double, при желании это можно подчеркнуть буквой D или d.

</p>
<p>Над дробными аргументами
можно производить следующие операции:

</p>
<p>•  операции сравнения
(возвращают булевское значение)

</p>
<p>• &lt;,&lt;=,
&gt;, &gt;=

</p>
<p> 

</p>
<p>•  числовые операции
(возвращают числовое значение)

</p>
<p>•   унарные операции + и -

</p>
<p>•   арифметические операции +, -, *, /, %

</p>
<p>•  
операции инкремента и
декремента (в префиксной и пост­фиксной форме): ++ и --

</p>
<p> 

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Практически все операторы действуют по тем же принципам, кото­рые
предусмотрены для целочисленных операторов (оператор деления с остатком %
рассматривался в предыдущей лекции, а операторы ++ и - - так­же увеличивают или
уменьшают значение переменной на единицу). Уточ­ним лишь, что операторы
сравнения корректно работают и в случае срав­нения целочисленных значений с
дробными. Таким образом, в основном необходимо рассмотреть вопросы переполнения
и преобразования типов при вычислениях.

</p>
<p>Для дробных вычислений появляется уже два типа переполнения — Overflow и underflow. Тем не менее, Java и здесь никак не
сообщает о возник­новении подобных ситуаций. Нет ни ошибок, ни других способов
обнару­жить их. Более того, даже деление на ноль не приводит к некорректной си­туации.
А значит, дробные вычисления вообще не порождают никаких ошибок.

</p>
<p>Такая свобода связана с наличием специальных значений дробного типа. Они
определяются спецификацией ШЕЕ 754 и уже перечислялись в лекции 3:

</p>
<p>•   положительная и отрицательная бесконечности (positive/negative infinity);

</p>
<p>•   значение "не число", Not-a-Number, сокращенно NaN;

</p>
<p>•   положительный и отрицательный нули.

</p>
<p>Все эти значения представлены как для типа float, так и для double. Положительную и отрицательную бесконечности можно получить следующим
образом:

</p>
<p>1 f/Of //
положительная бесконечность, тип float -1d/0d //отрицательная бесконечность, тип double

</p>
<p>Также в классах Float и Double определены константы POSITIVEJNFINITY и N EGATIVEJ N Fl NITY. Как видно из
примера, такие величины получаются при делении конечных величин на ноль.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Значение NaN можно получить,
например, в результате следующих действий:

</p>
<p> 

</p>
<p>0.0/0.0 // деление ноль на
ноль

</p>
<p>(1.0/0.0)*0.0 // умножение
бесконечности на ноль

</p>
<p>Эта величина также представлена константами NaN в классах Float и Double.

</p>
<p>Величины положительный и отрицательный ноль записываются очевидным
образом:

</p>
<p> 

</p>
<p>0.0 // дробный
литерал со значением положительного нуля +0.0 // унарная операция +, ее
значение - положительный ноль -0.0 // унарная операция -, ее значение -
отрицательный ноль

</p>
<p> 

</p>
<p>Все дробные значения строго упорядочены. Отрицательная беско­нечность
меньше любого другого дробного значения, положительная -больше. Значения +0.0 и
-0.0 считаются равными, то есть выражение 0.0==-0.0 истинно, а 0.0&gt;-0.0 —
ложно. Однако другие операторы разли­чают их, например, выражение 1.0/0.0 дает
положительную бесконеч­ность, а 1.0/-0.0 — отрицательную.

</p>
<p>Единственное исключение - значение NaN. Если хотя бы один
из ар­гументов операции сравнения равняется NaN, то результат
заведомо бу­дет false (для оператора !=
соответственно всегда true). Таким образом, единственное значение х, при котором выражение х!=х истинно,—
имен­но NaN.

</p>
<p>Возвращаемся к вопросу переполнения в числовых операциях. Если
получаемое значение слишком велико по модулю (overflow), то результа­том
будет бесконечность соответствующего знака.

</p>
<p> 

</p>
<p>print(1e20f*1e20f); print(-1e200*1e200);

</p>
<p> 

</p>
<p>В результате получаем:

</p>
<p>Infinity -Infinity

</p>
<p>Если результат, напротив, получается слишком мал (underflow), то он просто округляется до нуля. Так же поступают и в том случае,
когда ко­личество десятичных знаков превышает допустимое:

</p>
<p>print(1e-40f/1e10f);
// underflow для float

</p>
<p>print(-1 е-300/1 е100); // underflow
для double

</p>
<p>float f=1e-6f;

</p>
<p>print(f);

</p>
<p>f+=0.002f;

</p>
<p>print(f);

</p>
<p>f+=3;

</p>
<p>print(f);

</p>
<p>f+=4000;

</p>
<p>print(f);

</p>
<p>Результатом будет:

</p>
<p>0.0 -0.0

</p>
<p>1.0E-6 0.002001
3.002001 4003.002

</p>
<p>Как видно, в последней строке был утрачен 6-й разряд после десятич­ной
точки.

</p>
<p>Другой пример (из
спецификации языка Java):

</p>
<p> 

</p>
<p>double d
= 1е-305 * Math.PI;
print(d);

</p>
<p>for (int i = 0; i &lt; 4; i++) print(d /= 100000);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>3.141592653589793E-305

</p>
<p>3.1415926535898E-310

</p>
<p>3.141592653E-315

</p>
<p>3.142E-320

</p>
<p>0.0








</p>
<p>Таким образом, как и для целочисленных значений, явное выписыва­ние в коде литералов, которые слишком велики (overflow) или слишком








</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>малы (underflow) для используемых типов, приводит к ошибке компиля­ции (см. лекцию 3).
Если же переполнение возникает в результате выпол­нения операции, то
возвращается одно из специальных значений.

</p>
<p>Теперь перейдем к преобразованию типов. Если хотя бы один аргу­мент
имеет тип double, то значения всех аргументов приводятся к этому типу и результат
операции также будет иметь тип double. Вычисление бу­дет произведено с точностью в 64 бита.

</p>
<p>Если же аргументов типа double нет, а хотя бы один
аргумент имеет тип float, то все аргументы приводятся к float, вычисление
производится с точностью в 32 бита и результат имеет тип float.

</p>
<p>Эти утверждения верны и в случае, если один из аргументов цело­численный.
Если хотя бы один из аргументов имеет значение NaN, то и результатом
операции будет NaN.

</p>
<p>Еще раз рассмотрим простой
пример:

</p>
<p> 

</p>
<p>print(1/2); print(1/2.);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>О

</p>
<p>0.5

</p>
<p>Достаточно одного дробного
аргумента, чтобы результат операции также имел дробный тип. Более сложный
пример:

</p>
<p>int х=3;

</p>
<p>int у=5;

</p>
<p>print (х/у);

</p>
<p>print((double)x/y);

</p>
<p>print(1.0*x/y);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>0

</p>
<p>0.6 0.6

</p>
<p>В первый раз оба аргумента были целыми, поэтому в результате по­лучился
ноль. Однако поскольку оба операнда представлены перемен­ными, в этом примере
нельзя просто поставить десятичную точку и та­ким образом перевести вычисления
в дробный тип. Необходимо либо преобразовать один из аргументов (второй вывод
на экран), либо вста­вить еще одну фиктивную операцию с дробным аргументом
(последняя строка).

</p>
<p>Приведение типов подробно рассматривается в другой лекции, од­нако
обратим здесь внимание на несколько моментов.

</p>
<p>Во-первых, при приведении дробных значений к целым типам дробная часть
просто отбрасывается. Например, число 3.84 будет преоб­разовано в целое 3, а
-3.84 превратится в -3. Для математического округ­ления необходимо
воспользоваться методом класса Math.round(...).

</p>
<p>Во-вторых, при приведении значений int к типу float и при приведе­нии значений типа long к типу float и double возможны потери точности, несмотря на то, что эти дробные типы вмещают
гораздо большие числа, чем соответствующие целые. Рассмотрим следующий пример:

</p>
<p>long |=1111111111111_; float f = I; I = (long) f; print(l);

</p>
<p>Результатом будет:
111111110656

</p>
<p>Тип float не смог сохранить
все значащие разряды, хотя преобразо­вание от long к float произошло без
специального оператора в отличие от обратного перехода.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Для каждого примитивного типа существуют специальные вспо­могательные
классы-обертки (wrapper classes). Для типов float и double это Float и Double. Эти классы
содержат многие полезные методы для работы с дробными значениями. Например,
преобразование из текста в число.

</p>
<p>Кроме того, класс Math предоставляет большое количество методов Для операций над
дробными значениями, например, извлечение квадрат­ного корня, возведение в
любую степень, тригонометрические и другие. Также в этом классе определены
константы PI и основание натурального логарифма Е.

</p>
<p> 

</p>
<p>Булевский тип

</p>
<p>Булевский тип представлен всего одним типом boolean, который Может
хранить всего два возможных значения - true и false. Величины Именно этого типа получаются в результате операций сравнения.








</p>
<p> 








</p>
<p>130




</p>
<p>9«




</p>
<p>131








</p>
<p>Над булевскими аргументами можно производить следующие опера­ции:

</p>
<p>•  операции сравнения (возвращают булевское значение)

</p>
<p>"       , 
!

</p>
<p>•  логические операции
(возвращают булевское значение) . !

</p>
<p>-&amp;, |,А - &amp;&amp;, 11

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Операторы сравнения &amp;&amp; и 11 обсуждались в предыдущей лекции. В операторе с условием ? : первым
аргументом может быть только значение типа boolean. Также
допускается, чтобы второй и третий аргументы одно­временно имели булевский тип.

</p>
<p>Операция конкатенации со строкой превращает булевскую величи­ну в текст "true" или "false" в
зависимости от значения.

</p>
<p>Только булевские выражения допускаются для управления потоком
вычислений, например, в качестве критерия условного перехода if.

</p>
<p>Никакое число не может быть интерпретировано как булевское выра­жение.
Если предполагается, что ненулевое значение эквивалентно истине (по правилам
языка С), то необходимо записать х!=0. Ссылочные величи­ны можно преобразовывать в boolean выражением ref!=null.

</p>
<p> 

</p>
<p>Ссылочные ТИПЫ

</p>
<p>Итак, выражение ссылочного типа имеет значение либо null, либо ссылку,
указывающую на некоторый объект в виртуальной памяти JVM.

</p>
<p> 

</p>
<p>Объекты
и правила работы с ними

</p>
<p>Объект (object) - это экземпляр некоторого класса, или экземпляр массива. Массивы
будут подробно рассматриваться в соответствующей лекции. Класс — это описание
объектов одинаковой структуры, и если в программе такой класс используется, то
описание присутствует в единст­венном экземпляре
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Объектов этого класса может
не быть вовсе, а может быть создано сколь угодно много.

</p>
<p>Объекты всегда создаются с использованием ключевого слова new, причем одно слово
new порождает строго
один объект (или вовсе ни одного, если происходит ошибка). После ключевого
слова указывается имя класса, от которого мы собираемся породить объект.
Создание объекта всегда происходит через вызов одного из конструкторов класса
(их может быть несколько), поэтому в заключение ставятся скобки, в которых
перечисле­ны значения аргументов, передаваемых выбранному конструктору. В
приведенных выше примерах, когда создавались объекты типа Point, вы­ражение new Point (3,5) означало обращение к конструктору класса Point, у которого есть
два аргумента типа int. Кстати, обязательное объявление такого конструктора в упрощенном
объявлении класса отсутствовало. Объявление классов рассматривается в следующих
лекциях, однако приве­дем правильное определение Point:

</p>
<p>class Point { intx, у;

</p>
<p>I**

</p>
<p>*  Конструктор принимает 2 аргумента,

</p>
<p>*  которыми инициализирует поля объекта.

</p>
<p>7

</p>
<p>Point (int newx, int newy){ x=newx; y=newy;

</p>
<p>}

</p>
<p>}

</p>
<p>Если конструктор отработал успешно, то выражение new возвращает ссылку на созданный объект. Эту ссылку можно сохранить в
переменной, передать в качестве аргумента в какой-либо метод или использовать
дру­гим способом. JVM всегда занимается
подсчетом хранимых ссылок на каждый объект. Как только обнаруживается, что
ссылок больше нет, такой объект предназначается для уничтожения сборщиком
мусора (garbage col­lector). Восстановить ссылку на такой "потерянный" объект
невозможно.

</p>
<p> 

</p>
<p>Point p=new Point(1,2); // Создали
объект, получили на него ссылку

</p>
<p>Point р1=р; // теперь
есть 2 ссылки на точку (1,2) p=new Point(3,4); // осталась одна ссылка на точку (1,2) p1=null;

</p>
<p> 

</p>
<p>Ссылок на объект-точку (1,2) больше нет, доступ к нему утерян и он Вскоре будет уничтожен сборщиком мусора.

</p>
<p>Любой объект порождается только с применением ключевого сло­ва new. Единственное
исключение — экземпляры класса String. Запи­сывая любой строковый литерал, мы автоматически порождаем объект ^ого класса. Оператор конкатенации +, результатом которого является строка, также неявно порождает объекты без использования ключевого слова new.








</p>
<p>Рассмотрим пример: "abc"+"def"

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>При выполнении этого выражения будет создано три объекта класса String. Два объекта
порождаются строковыми литералами, третий будет представлять результат
конкатенации.

</p>
<p>Операция создания объекта - одна из самых ресурсоемких в Java. Поэтому следует
избегать ненужных порождений. Поскольку при рабо­те со строками их может
создаваться довольно много, компилятор, как правило, пытается оптимизировать
такие выражения. В рассмотренном примере, поскольку все операнды являются
константами времени ком­пиляции, компилятор сам осуществит конкатенацию и
вставит в код уже результат, сократив таким образом количество создаваемых
объек­тов до одного.

</p>
<p>Кроме того, в версии Java 1.1 была введена технология reflection, ко­торая позволяет обращаться к классам, методам и полям, используя
лишь их имя в текстовом виде. С ее помощью также можно создать объект без
ключевого слова new, однако эта технология довольно специфична, при­меняется в редких
случаях, а кроме того, довольно проста и потому в дан­ном курсе не
рассматривается. Все же приведем пример ее применения:

</p>
<p>Point р = null; try {

</p>
<p>// в следующей строке, используя лишь текстовое // имя класса Point, порождается
объект без // применения ключевого слова new р = (Point)Class.forName("Point").newlnstance(); } catch (Exception e) {// обработка ошибок System.out.println(e);

</p>
<p>}

</p>
<p>Объект всегда "помнит", от какого класса он был порожден. С
дру­гой стороны, как уже указывалось, можно ссылаться на объект, исполь­зуя
ссылку другого типа. Приведем пример, который будем еще много раз использовать.
Сначала опишем два класса, Parent и его наследник Child:

</p>
<p> 

</p>
<p>// Объявляем класс Parent

</p>
<p>class Parent {

</p>
<p>}

</p>
<p>// Объявляем класс Child и наследуем // его от класса Parent
class Child extends Parent { }

</p>
<p>Пока нам не нужно определять какие-либо поля или методы. Далее объявим
переменную одного типа и проинициализируем ее значением другого типа:

</p>
<p> 

</p>
<p>Parent р = newChild();

</p>
<p>Теперь переменная типа Parent указывает на
объект, порожденный от класса Child.

</p>
<p>Над ссылочными значениями можно производить следующие опе­рации:

</p>
<p>•   
обращение к полям и
методам объекта

</p>
<p>•   
оператор instanceof (возвращает
булевское значение)

</p>
<p>•   
операции сравнения == и !=
(возвращают булевское значение)

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Обращение к полям и методам объекта можно назвать основной операцией над
ссылочными величинами. Осуществляется она с помощью символа . (точка). Примеры
ее применения будут приводиться.

</p>
<p>Используя оператор instanceof, можно узнать, от какого класса про­изошел объект. Этот оператор имеет
два аргумента. Слева указывается ссылка на объект, а справа - имя типа, на
совместимость с которым про­веряется объект. Например:

</p>
<p>Parent р = new Child(); // проверяем
переменную р типа Parent // на совместимость
с типом Child print(p instanceof Child);

</p>
<p>Результатом будет true. Таким образом, оператор instanceof опирается не на тип
ссылки, а на свойства объекта, на который она ссылается. Но этот оператор
возвращает истинное значение не только для того типа, от которо­го был порожден
объект. Добавим к уже объявленным классам еще один:

</p>
<p> 

</p>
<p>// Объявляем новый класс и
наследуем

</p>
<p>// его от класса Child

</p>
<p>class
ChildOfChild extends Child {}








</p>
<p>Теперь заведем переменную нового типа:

</p>
<p> 

</p>
<p>Parent р = new ChildOfChildO; print(p instanceof Child);

</p>
<p> 

</p>
<p>В первой строке объявляется переменная типа Parent, которая иници­ализируется
ссылкой на объект, порожденный от ChildOfChild. Во второй строке оператор instanceof анализирует
совместимость ссылки типа Parent с классом Child, причем
задействованный объект не порожден ни от перво­го, ни от второго класса. Тем не
менее, оператор вернет true, поскольку класс, от которого этот объект порожден, наследуется от Child.

</p>
<p>Добавим еще один класс:

</p>
<p>class Child2 extends Parent { }

</p>
<p> 

</p>
<p>И снова объявим переменную типа Parent:

</p>
<p>Parent
p=newChild(); print(p instanceof Child); print(p instanceof Child2);

</p>
<p> 

</p>
<p>Переменная p имеет тип Parent, а значит, может
ссылаться на объек­ты типа Child или Child2. Оператор instanceof помогает
разобраться в си­туации:

</p>
<p> 

</p>
<p>true false

</p>
<p> 

</p>
<p>Для ссылки, равной null, оператор instanceof всегда вернет
значение false.

</p>
<p>С изучением свойств объектной модели Java мы будем возвращаться к алгоритму работы оператора instanceof.

</p>
<p>Операторы сравнения = и != проверяют равенство (или неравен­ство) объектных
величин именно по ссылке. Однако часто требуется альтернативное сравнение - по
значению. Сравнение по значению имеет дело с понятием состояние объекта. Сам
смысл этого выраже­ния рассматривается в ООП, что же касается реализации в Java, то со­стояние
объекта хранится в его полях. При сравнении по
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>ссылке ни тип объекта, ни
значения его полей не учитываются, true возвращает­ся только в том случае, если обе ссылки указывают на один и
тот же объект.

</p>
<p>Point
p1=new Point(2,3);

</p>
<p>Point
p2=p1;

</p>
<p>Point
p3=new Point(2,3);

</p>
<p>print(p1==p2);

</p>
<p>print(p1==p3);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>true false

</p>
<p>Первое сравнение оказалось истинным, так как переменная р2 ссы­лается на
тот же объект, что и р1. Второе же сравнение ложно, несмотря на то, что
переменная рЗ ссылается на объект-точку с точно такими же координатами. Однако
это другой объект, который был порожден другим выражением new.

</p>
<p>Если один из аргументов оператора = равен null, а другой - нет,
то значение такого выражения будет false. Если же оба
операнда null, то ре­зультат будет true.

</p>
<p>Для корректного сравнения по значению существует специальный метод equals, который будет
рассмотрен позже. Например, строки надо сравнивать следующим образом:

</p>
<p>String s = "abc"; s=s+1;

</p>
<p>print(s.equals("abc1 "));

</p>
<p>Операция с условием ? : работает как обычно и может
принимать второй и третий аргументы, если они оба одновременно ссылочного типа.
Результат такого оператора также будет иметь объектный тип.

</p>
<p>Как и простые типы, ссылочные величины можно складывать со строкой. Если
ссылка равна null, то к строке добавляется текст "null". Если Же
ссылка указывает на объект, то у него вызывается специальный метод (он будет
рассмотрен ниже, его имя toStringO) и текст, который он вер­нет, будет добавлен к строке.

</p>
<p> 

</p>
<p>Класс
Object

</p>
<p>В Java множественное
наследование отсутствует. Каждый класс Может иметь только одного родителя.
Таким образом, мы можем про­следить цепочку наследования от любого класса,
поднимаясь все выше. Существует класс, на котором такая цепочка всегда
заканчивается, это класс Object. Именно от него наследуются все классы, в объявлении которых явно не
указан другой родительский класс. А значит, любой класс напрямую, или через
своих родителей, является наследником Object. Отсюда следует,
что методы этого класса есть у любого объекта (поля в Object отсутствуют), а потому они представляют особенный интерес.

</p>
<p>Рассмотрим основные из
них.

</p>
<p> 

</p>
<p>getClassf)

</p>
<p>Этот метод возвращает объект класса Class, который описывает
класс, от которого был порожден этот объект. Класс Class будет рас­смотрен ниже. У него есть метод getNameO, возвращающий имя
класса:

</p>
<p>String s = "abc";
Class
cl=s.getClass(); print(cl.getNameO);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Результатом будет строка:

</p>
<p> 

</p>
<p>java.lang.String

</p>
<p>В отличие от оператора instanceof, метод getClass() всегда возвра­щает точно тот класс, от которого был порожден объект.

</p>
<p> 

</p>
<p>equalsO

</p>
<p>Этот метод имеет один аргумент типа Object и возвращает boolean. Как уже говорилось, equals( ) служит для сравнения объектов по значению, а не по ссылке.
Сравнивается состояние объекта, у которого вызывается этот метод, с
передаваемым аргументом.

</p>
<p>Point p1=new
Point(2,3); Point p2=new Point(2,3); print(p1.equals(p2)j;

</p>
<p>Результатом будет true.

</p>
<p>Поскольку сам Object не имеет полей, а
значит, и состояния, в этом классе метод equals возвращает результат сравнения по ссылке. Однако при написании нового
класса можно переопределить этот метод и описать правильный алгоритм сравнения
по значению (что и сделано в большин­стве стандартных классов). Соответственно,
в класс Point также необходи­мо
добавить переопределенный метод сравнения:

</p>
<p>public boolean
equals(Object о) {

</p>
<p>// Сначала необходимо убедиться, что переданный

</p>
<p>// объект совместим с типом Point

</p>
<p>if (о instanceof Point) {

</p>
<p>//Типы совместимы, можно провести преобразование

</p>
<p>Point р = (Point)o;

</p>
<p>// Возвращаем результат сравнения координат return р.х==х &amp;&amp; р.у==у;

</p>
<p>}

</p>
<p>// Если объект не совместим с Point, возвращаем false return false;

</p>
<p>}

</p>
<p>hashCodeO

</p>
<p>Данный метод возвращает значение int. Цель hashCodeO -представить любой
объект целым числом. Особенно эффективно это используется в хэш-таблицах (в Java есть стандартная реализация та­кого хранения данных, она будет
рассмотрена позже). Конечно, нель­зя потребовать, чтобы различные объекты
возвращали различные хэш-коды, но, по крайней мере, необходимо, чтобы объекты,
равные по значению (метод equals() возвращает true), возвращали одинако­вые хэш-коды.

</p>
<p>В классе Object этот метод
реализован на уровне JVM. Сама вирту­альная машина генерирует число хеш-кодов, основываясь на
расположе­нии объекта в памяти.

</p>
<p> 

</p>
<p>toStringf)

</p>
<p>Этот метод позволяет получить текстовое описание любого объек­та. Создавая
новый класс, данный метод можно переопределить и воз­вращать более подробное
описание. Для класса Object и его наследни­ков,
не переопределивших toStringO, метод возвращает следующее вы­ражение:

</p>
<p>getClass().getName()+"@"+hashCode()

</p>
<p>Метод getNameO класса Class уже приводился в пример, а хэш-код еШе дополнительно
обрабатывается специальной функцией для пред­ставления в шестнадцатеричном
формате.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Например:

</p>
<p> 

</p>
<p>print(new Objecto);








</p>
<p>Результатом будет: java.lang.Object@92d342

</p>
<p>В результате этот метод позволяет по текстовому описанию понять, от
какого класса был порожден объект и, благодаря хеш-коду, различать разные
объекты, созданные от одного класса.

</p>
<p>Именно этот метод вызывается при конвертации объекта в текст, когда он
передается в качестве аргумента оператору конкатенации строк.

</p>
<p> 

</p>
<p>finalizef)

</p>
<p>Данный метод вызывается при уничтожении объекта автоматичес­ким
сборщиком мусора (garbage collector). В классе Object он ничего не
делает, однако в классе-наследнике позволяет описать все действия, не­обходимые
для корректного удаления объекта, такие как закрытие со­единений с БД, сетевых
соединений, снятие блокировок на файлы и т.д. В обычном режиме напрямую этот
метод вызывать не нужно, он отрабо­тает автоматически. Если необходимо, можно
обратиться к нему явным образом.

</p>
<p>В методе finalize() нужно описывать только дополнительные действия, связанные с логикой
работы программы. Все необходимое для удаления объекта JVM сделает сама.

</p>
<p> 

</p>
<p>Класс
String

</p>
<p>Как уже указывалось, класс String занимает в Java особое положе­ние.
Экземпляры только этого класса можно создавать без использования ключевого
слова new. Каждый строковый литерал порождает экземпляр String, и это
единственный литерал (кроме null), имеющий объектный тип.

</p>
<p>Затем значение любого типа может быть приведено к строке с помо­щью
оператора конкатенации строк, который был рассмотрен для каждо­го типа, как
примитивного, так и объектного.

</p>
<p>Еще одним важным свойством данного класса является неизменяе­мость. Это
означает, что, породив объект, содержащий некое значение-строку, мы уже не можем
изменить данное значение - необходимо со­здать новый объект.

</p>
<p>String s="a"; s="b";

</p>
<p> 

</p>
<p>Во второй строке переменная сменила свое значение, но только создав
новый объект класса String.

</p>
<p>Поскольку каждый строковый литерал порождает новый объект, что есть очень
ресурсоемкая операция в Java, зачастую компилятор стремится оптимизировать эту работу.

</p>
<p>Во-первых, если используется несколько литералов с одинаковым значением,
для них будет создан один и тот же объект.

</p>
<p>String s1 = "abc"; String s2 = "abc"; String s3 = "a"+"bc";
print(s1==s2); print(s1==s3);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>true true

</p>
<p>To есть в случае, когда строка конструируется из констант, известных уже на
момент компиляции, оптимизатор также подставляет один и тот Же объект.

</p>
<p>Если же строка создается выражением, которое может быть вычис­лено
только во время исполнения программы, то оно будет порождать но­вый объект:

</p>
<p> 

</p>
<p>String
s1="abc"; String s2="ab"; print(s1==(s2+"c"));

</p>
<p>Результатом будет false, так как компилятор не может предсказать результат сложения значения
переменной с константой.

</p>
<p>В классе String определен метод intern(), который
возвращает один и тот же объект-строку для всех экземпляров, равных по
значению. То есть если для ссылок s1 и s2 верно выражение s1 .equals(s2), то верно и Sl.intern()==s2. intern().

</p>
<p>Разумеется, в классе переопределены методы equals() и hashCode(). Метод toStringO также переопределен и возвращает он сам объект-строку, 10
есть для любой ссылки s типа String, не равной null, верно выражение s~=s.toString().








</p>
<p>Класс
Class

</p>
<p>Наконец, последний класс,
который будет рассмотрен в этой лекции.

</p>
<p>Класс Class является
метаклассом для всех классов Java. Когда JVM загружает файл .class, который описывает
некоторый тип, в памяти со­здается объект класса Class, который будет
хранить это описание.

</p>
<p>Например, если в программе
есть строка

</p>
<p> 

</p>
<p>Point p=new Point(1,2);

</p>
<p> 

</p>
<p>то это означает, что в системе созданы следующие объекты:

</p>
<p>1. 
объект типа Point, описывающий точку
(1,2);

</p>
<p>2.  объект класса Class, описывающий класс Point;

</p>
<p>3.  объект класса Class, описывающий класс Object. Поскольку класс Point наследуется от Object, его описание
также необходимо;

</p>
<p>4.  объект класса Class, описывающий класс Class. Это обычный Java-класс, который должен быть загружен по общим правилам.

</p>
<p>Одно из применений класса Class уже было рассмотрено — исполь­зование метода getClass() класса Object. Если продолжить
последний пример с точкой:

</p>
<p> 

</p>
<p>Class cl=p.getClass(); // это объект №2 из списка Class cl2=cl.getClass(); // это объект
№4 из списка Class cl3=cl2.getClass(); // опять объект №4

</p>
<p> 

</p>
<p>Выражение cl2==cl3 верно.

</p>
<p>Другое применение класса Class также приводилось в
примере при­менения технологии reflection.

</p>
<p>Кроме прямого использования метакласса для хранения в памяти описания
классов, Java использует эти
объекты и для других целей, кото­рые будут рассмотрены ниже (статические
переменные, синхронизация статических методов и т.д.).

</p>
<p> 

</p>
<p>Заключение

</p>
<p>Типы данных - одна из ключевых тем курса. Невозможно написать ни одной
программы, не используя их. Вот список некоторых операций, где применяются
типы:

</p>
<p>•   
объявление типов;

</p>
<p>•   
создание объектов;

</p>
<p>•   
при объявлении полей — тип
поля;

</p>
<p>•   
при объявлении методов —
входные параметры, возвращаемое значение;

</p>
<p> 

</p>
<p>•   
при объявлении
конструкторов — входные параметры;

</p>
<p>•   
оператор приведения типов;

</p>
<p>•   
оператор instanceof;

</p>
<p>•   
объявление локальных
переменных;

</p>
<p>•   
многие другие — обработка
ошибок, import-выражения и т.д. Принципиальные различия между примитивными и
ссылочными

</p>
<p>типами данных будут
рассматриваться и дальше по ходу курса. Изучение объектной модели Java даст основу для более подробного изложения объ­ектных типов — обычных и
абстрактных классов, интерфейсов и масси­вов. После приведения типов будут
описаны связи между типом перемен­ной и типом ее значения.

</p>
<p>В обсуждении будущей версии Java 1.5 упоминаются темплейты (templates), которые существенно расширят понятия типа данных, если действительно
войдут в стандарт языка.

</p>
<p>В лекции было рассказано о том, что Java является строго типизиро­ванным языком, то есть тип всех переменных и
выражений определяется уже компилятором. Это позволяет существенно повысить
надежность и качество кода, а также делает необходимым понимание программистами
объектной модели.

</p>
<p>Все типы в Java делятся на две
группы — фиксированные простые, или примитивные, типы (8 типов) и
многочисленная группа объектных типов (классов). Примитивные типы действительно
являются хранили­щами данных своего типа. Ссылочные переменные хранят ссылку на
не­который объект совместимого типа. Они также могут принимать значе­ние null, не указывая ни на
какой объект. JVM подсчитывает
количество ссылок на каждый объект и активизирует механизм автоматической сбор­ки
мусора для удаления неиспользуемых объектов.

</p>
<p>Были рассмотрены переменные. Они характеризуются тремя основ­ными
параметрами - имя, тип и значение. Любая переменная должна быть объявлена и при
этом может быть инициализирована. Возможно ис­пользование модификатора final.

</p>
<p>Примитивные типы состоят из пяти целочисленных, включая сим­вольный тип,
двух дробных и одного булевского. Целочисленные литера­лы имеют ограничения,
связанные с типами данных. Были рассмотрены все операторы над примитивными
типами, тип возвращаемого значения и тонкости их использования.

</p>
<p>Затем изучались объекты, способы их создания и операторы, выполня­ющие над ними различные действия, в частности принцип работы оператора instanceof. Далее были рассмотрены самые главные классы в Java -Object, Class, String.








</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Каков будет результат следующего примера? byte b=3; int c=b; С++;

</p>
<p>print(++b==c);

</p>
<p>&#9633;          
true

</p>
<p>&#9633;          
false

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Каким
будет результат следующих действий?
1/2 1./2 1/2. 1./2.

</p>
<p>&#9633;          
все операции дадут 0.5

</p>
<p>&#9633;          
все операции дадут 0

</p>
<p>&#9633;          
0,0.5,0,0.5

</p>
<p>&#9633;          
0,0.5,0.5,0.5

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Эквивалентны
ли две приведенные ниже операции над
ссылочными переменными х1 и х2 (5отеС1азз2 - тип
переменной х2)?

</p>
<p>х1
тз1апсео!8отеС1азз2

</p>
<p>х1.деГС1а88().дет.№те().еяиа18(х2.деГС1а88().дет.№те())

</p>
<p>&#9633;          
да

</p>
<p>&#9633;          
нет








</p>
<p> 








</p>
<p>Курс




</p>
<p>Программирование
на Java








</p>
<p> 








</p>
<p>Вариант
2




</p>
<p>Вариант
3








</p>
<p> 








</p>
<p>1.       Каков
будет результат следующего примера?
Point р = new Point(1, 2);

</p>
<p>int а=р.х;

</p>
<p>р = new Point(3, 4); print(a);

</p>
<p>&#9633;       
1

</p>
<p>&#9633;          
2

</p>
<p>&#9633;          
3

</p>
<p>&#9633;          
4

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Каков
будет результат следующих действий?
double х=2./0;

</p>
<p>double у=-1/0.; print(x+y);

</p>
<p>&#9633;       
POSITIVEJNFINITY

</p>
<p>&#9633;          
о

</p>
<p>&#9633;       
NaN

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Могут
ли следующие выражения вернуть значения false?

</p>
<p>a)   x.toString() instanceof String

</p>
<p>b)  (x+"") instanceof String

</p>
<p>&#9633;        оба
выражения возвращают только true

</p>
<p>Г"!  
первое выражение вернет false, если
х равен null, второе
возвращает только true

</p>
<p>Г~|  
оба выражения вернут false, если
х равен null

</p>
<p>&#9633;        первое
выражение вернет null, если
х ссылается на объект, порожденный от класса с переопределенным методом toStringt),
который возвращает null, второе
выражение возвращает только true

</p>
<p>1.  
Каков будет результат следующего примера? Point р1 = new Point(3, 4); Point р2 = р1; р1.х=5;

</p>
<p>р1 = new Point(4, 4); print(p2.x-p1 .х);

</p>
<p>&#9633;    
-1

</p>
<p>&#9633;          
о

</p>
<p>&#9633;       
1

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Каким будет результат следующей строки (код символа восклицательного знака 33)?
print("Hello"+'!');

</p>
<p>&#9633;       
"Hello!"

</p>
<p>&#9633;       
"НеІІоЗЗ"

</p>
<p> 

</p>
<p> 

</p>
<p>Щ.   Каков
будет результат следующих действий? Point р1 = new Point(2, 3); Point р2 = new Point(2, 3); print(p1==p2); p2=p1; p1.x=3;
print(p1==p2);

</p>
<p>&#9633;       
true; true

</p>
<p>&#9633;       
true; false

</p>
<p>&#9633;       
false; true

</p>
<p>&#9633;       
false; false








</p>
<p>
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 4. Типы данных</h2></center>

<p> 

</p>
<p> 

</p>
<p>Типы данных определяют основные возможности любого
языка. Кроме того, Java является строго
типизированным языком, а потому четкое понима­ние модели типов данных очень
помогает в написании качественных про­грамм. Лекция начинается с введения
понятия переменной, на примере кото­рой иллюстрируются особенности применения
типов в Java. Описывается раз­деление всех типов на простейшие и
ссылочные, операции над значениями различных типов, а также особый класс Class, который играет роль метаклас­са в Java.

</p>
<p> 

</p>
<p>Ключевые слова: простые типы данных, примитивные типы данных, объектные типы данных,
ссылочные типы данных, объявления, inte­ger, floating-point, boolean, overflow, underflow, reflection.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Java является строго типизированным языком. Это означает, что лю­бая переменная и любое
выражение имеют известный тип еще на момент компиляции. Такое строгое правило
позволяет выявлять многие ошибки уже во время
компиляции. Компилятор, найдя ошибку, указывает точное место (строку) и причину
ее возникновения, а динамические "баги" (от английского bugs) необходимо
сначала выявить с помощью тестирования (что может потребовать значительных усилий), а затем найти место в ко­де, которое их
породило. Поэтому четкое понимание модели типов дан­ных в Java очень помогает в написании качественных программ.

</p>
<p>Все типы данных разделяются на две группы. Первую
составляют 8 простых, или примитивных (от английского primitive), типов данных. Они подразделяются на три подгруппы:

</p>
<p>•  целочисленные

</p>
<p>-   
byte

</p>
<p>-    short -int

</p>
<p>-   
long

</p>
<p>—               char (также является
целочисленным типом)

</p>
<p>• дробные -float

</p>
<p>—               double

</p>
<p>•  булевский

</p>
<p>—               boolean

</p>
<p>8 ^-3440                                                        из








</p>
<p>Вторую группу составляют объектные, или ссылочные (от английско­го reference), типы данных. Это все классы, интерфейсы и массивы. В стан­дартных
библиотеках первых версий Java находилось
несколько сот классов и интерфейсов, сейчас их уже тысячи. Кроме стандартных,
написаны мно­гие и многие классы и интерфейсы, составляющие любую Java-программу.

</p>
<p>Иллюстрировать логику работы с типами данных проще всего на примере
переменных.

</p>
<p> 

</p>
<p>Переменные

</p>
<p>Переменные используются в программе для хранения данных. Любая
переменная имеет три базовых характеристики:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
имя;

</p>
<p>•   
тип;

</p>
<p>•   
значение.

</p>
<p>Имя уникально идентифицирует переменную и позволяет обра­щаться к ней в
программе. Тип описывает, какие величины может хранить переменная. Значение -
текущая величина, хранящаяся в переменной на данный момент.

</p>
<p>Работа с переменной всегда начинается с ее объявления (declara­tion). Конечно, оно
должно включать в себя имя объявляемой пере­менной. Как было сказано, в Java любая переменная имеет строгий тип, который также задается при
объявлении и никогда не меняется. Значение может быть указано сразу (это
называется инициализацией), а в большинстве случаев задание начальной величины
можно и отло­жить.

</p>
<p>Некоторые примеры объявления переменных примитивного типа int с инициализаторами и без таковых:

</p>
<p> 

</p>
<p>int а;

</p>
<p>int b = 0,
с = 3+2; int d = b+c; int е = а = 5;

</p>
<p> 

</p>
<p>Из примеров видно, что инициализатором может быть не только константа,
но и арифметическое выражение. Иногда это выражение мо­жет быть вычислено во
время компиляции (такое как 3+2), тогда компи­лятор сразу записывает результат. Иногда это действие
откладывается на момент выполнения программы (например, b+с). В последнем случае
не­скольким переменным присваивается одно и то же значение, однако объ­является
лишь первая из них (в данном примере е), остальные уже долж­ны существовать.

</p>
<p>Резюмируем: объявление переменных и возможная инициализация при
объявлении описываются следующим образом. Сначала указывается тип переменной,
затем ее имя и, если необходимо, инициализатор, кото­рый может быть константой
или выражением, вычисляемым во время компиляции или исполнения программы. В
частности, можно пользо­ваться уже объявленными переменными. Далее можно поставить запятую и объявить новую
переменную точно такого же типа.

</p>
<p>После объявления переменная может применяться в различных вы­ражениях, в
которых будет браться ее текущее значение. Также в любой щомент можно изменить значение, используя оператор присваивания, Ьримерно так же, как это делалось в инициализаторах.

</p>
<p>Кроме того, при объявлении переменной может быть использовано ^ключевое
слово final. Его указывают перед типом переменной, и тогда ее необходимо сразу
инициализировать и уже больше никогда не менять ее &#9632;начение. Таким
образом, final-переменные становятся чем-то вроде кон­стант, но на самом деле
некоторые инициализаторы могут вычисляться |олько во время исполнения
программы, генерируя различные значения.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Простейший пример
объявления final-переменной:

</p>
<p> 

</p>
<p>final double pi=3.1415;

</p>
<p> 

</p>
<p>Примитивные и ссылочные типы
данных

</p>
<p>Теперь на примере переменных можно проиллюстрировать различие Ёежду
примитивными и ссылочными типами данных. Рассмотрим при-|ер, когда объявляются
две переменные одного типа, приравниваются руг другу, а затем значение одной их
них изменяется. Что произойдет со &#9632;торой переменной?

</p>
<p>Возьмем простой тип int:

</p>
<p>int а=5; // объявляем первую переменную и
инициализируем ее int b=a; //
объявляем вторую переменную и приравниваем ее к первой а=3; // меняем значение
первой print(b); //
проверяем значение второй

</p>
<p>Здесь и далее мы считаем, что функция print(...) позволяет нам неко­торым
(неважно, каким именно) способом узнать значение ее аргумента (как правило, для этого используют функцию из стандартной библиотеки %stem.out.println(...), которая выводит
значение на системную консоль).

</p>
<p>В результате мы увидим, что значение переменной b не изменилось, Оно осталось равным 5. Это означает, что переменные простого типа хра­нят непосредственно свои значения и при приравнивании двух перемен­ных
происходит копирование данного значения. Чтобы еще раз подчерк­нуть эту
особенность, приведем еще один пример:

</p>
<p>byte b=3; int a=b;

</p>
<p> 

</p>
<p>В данном примере происходит преобразование типов (оно подробно
рассматривается в соответствующей лекции). Для нас сейчас важно кон­статировать,
что переменная b хранит значение 3 типа byte, а переменная а - значение 3 типа int. Это два разных значения, и во второй строке при присваивании произошло
копирование.

</p>
<p>Теперь рассмотрим ссылочный тип данных. Переменные таких ти­пов всегда
хранят ссылки на некоторые объекты. Рассмотрим для приме­ра класс, описывающий
точку на координатной плоскости с целочислен­ными координатами. Описание класса
— это отдельная тема, но в нашем простейшем случае оно тривиально:

</p>
<p>class Point { intx, у;

</p>
<p>}

</p>
<p> 

</p>
<p>Теперь составим пример, аналогичный приведенному выше для int-переменных,
считая, что выражение new Point(3,5)
создает новый объ­ект-точку
с координатами (3,5).

</p>
<p>Point р1 = new Point(3,5);

</p>
<p>Point р2=р1;

</p>
<p>р1.х=7;

</p>
<p>print(p2.x);

</p>
<p> 

</p>
<p>В третьей строке мы изменили горизонтальную координату точки, на которую
ссылалась переменная р1, и теперь нас интересует, как это сказалось на точке, на которую ссылается
переменная р2
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Проведя та­кой эксперимент, можно убедиться, что в этот раз мы увидим
обновлен­ное значение. То есть объектные переменные после приравнивания ос­таются
"связанными" друг с другом, изменения одной сказываются на другой.

</p>
<p>Таким образом, примитивные переменные являются действитель­ными
хранилищами данных. Каждая переменная имеет значение, не за­висящее от
остальных. Ссылочные же переменные хранят лишь ссылки на объекты, причем
различные переменные могут ссылаться на один и тот же объект, как это было в
нашем примере. В этом случае их можно сравнить с наблюдателями, которые с
разных позиций смотрят на один и тот же объект и одинаково видят все
происходящие с ним изменения. Ес­ли же один наблюдатель
сменит объект наблюдения, то он перестает ви­деть и изменения, происходящие с
прежним объектом:

</p>
<p>Point р1 = new Point(3,5);

</p>
<p>Point р2=р1;

</p>
<p>р1 = new Point(7,9);

</p>
<p>print(p2.x);

</p>
<p>В этом примере мы получим 3, то есть после третьей строки пере­менные р1 и р2 ссылаются на различные объекты и поэтому имеют раз­ные значения.

</p>
<p>Теперь легко понять смысл литерала null. Такое значение
может при­нять переменная любого ссылочного типа. Это означает, что ее ссылка
никуда не указывает, объект отсутствует. Соответственно, любая попытка
обратиться к объекту через такую переменную (например, вызвать метод или взять значение поля) приведет к ошибке.

</p>
<p>Также значение null можно передать в
качестве любого объектного аргумента при вызове функций (хотя на практике
многие методы счита­ют такое значение некорректным).

</p>
<p>Память в Java с точки зрения
программиста представляется не нуля­ми и единицами или набором байтов, а как
некое виртуальное простран­ство, в котором существуют объекты. И доступ к
памяти осуществляется не по физическому адресу или указателю, а лишь через
ссылки на объек­ты. Ссылка возвращается при создании объекта и далее может быть
сохра­нена в переменной, передана в качестве аргумента и т.д. Как уже говори­лось,
допускается наличие нескольких ссылок на один объект. Возможна и
противоположная ситуация — когда на какой-то объект не существует ни одной
ссылки. Такой объект уже недоступен программе и является "мусо­ром",
то есть без толку занимает аппаратные ресурсы. Для их освобожде­ния не
требуется никаких усилий. В состав любой виртуальной машины обязательно входит
автоматический сборщик мусора garbage collector — фоновый процесс,
который как раз и занимается уничтожением ненуж­ных объектов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Очень важно помнить, что объектная переменная, в отличие от при­митивной,
может иметь значение другого типа, не совпадающего с типом переменной.
Например, если тип переменной — некий класс, то перемен­ная может ссылаться на
объект, порожденный от наследника этого класса. Все случаи подобного
несовпадения будут рассмотрены в следующих раз­делах курса.

</p>
<p>Теперь рассмотрим примитивные и ссылочные типы данных более подробно.

</p>
<p>Примитивные
типы

</p>
<p>Как уже говорилось, существует 8 простых типов данных, которые делятся
на целочисленные (integer), дробные (floating-point) и булевские (boolean).

</p>
<p> 

</p>
<p>Целочисленные
типы

</p>
<p>Целочисленные типы — это byte, short, int, long, также к ним отно­сят и char. Первые четыре типа имеют длину 1, 2, 4 и 8 байт соответст­венно, длина char — 2 байта, это непосредственно следует из того, что все символы Java описываются стандартом Unicode. Длины типов при­ведены только для оценки областей значения. Как уже
говорилось, па­мять в Java представляется
виртуальной и вычислить, сколько физичес­ких ресурсов займет та или иная
переменная, так прямолинейно не по­лучится.

</p>
<p>4 основных типа являются знаковыми, char добавлен к целочислен­ным типам данных, так как с точки зрения JVM символ и его код — поня­тия взаимооднозначные. Конечно, код символа
всегда положительный, поэтому char — единственный беззнаковый
тип. Инициализировать его можно как символьным, так и целочисленным литералом.
Во всем ос­тальном char — полноценный числовой тип
данных, который может уча­ствовать, например, в арифметических действиях,
операциях сравнения и т.п. В таблице 4.1 сведены данные по всем разобранным
типам:



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="15">
 <tr>
  <td valign="top" align="left" height="15">
  <p>1
  </p>
</td>
 </tr>
</table>



<p>Обратите внимание, что int вмещает примерно 2 миллиарда, а потому
подходит во многих случаях, когда не требуются сверхбольшие числа. Чтобы
представить себе размеры типа long, укажем, что именно он используется в
Java для отсчета
времени. Как и во многих языках, время отсчитывается от
I---------------------------------------------------------------------------------------------------------------- —

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="146" valign="top">
  <p>Название типа
  </p>
</td>
  <td width="106" valign="top">
  <p>Длина (байты)
  </p>
</td>
  <td width="175" valign="top">
  <p>Область значений
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>byte
  </p>
</td>
  <td width="106" valign="top">
  <p>1
  </p>
</td>
  <td width="175" valign="top">
  <p>-128 .. 127
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>short
  </p>
</td>
  <td width="106" valign="top">
  <p>2
  </p>
</td>
  <td width="175" valign="top">
  <p>-32.768 .. 32.767
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>int
  </p>
</td>
  <td width="106" valign="top">
  <p>4
  </p>
</td>
  <td width="175" valign="top">
  <p>-2.147.483.648
  ..2.147.483.647
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>long
  </p>
</td>
  <td width="106" valign="top">
  <p>8
  </p>
</td>
  <td width="175" valign="top">
  <p>-9.223.372.036.854.775.808 ..
  9.223.372.036.854.775.807 (примерно 10")
  </p>
</td>
 </tr>
 <tr>
  <td width="146" valign="top">
  <p>char
  </p>
</td>
  <td width="106" valign="top">
  <p>2
  </p>
</td>
  <td width="175" valign="top">
  <p>\u0000'.. \uffiT, или0.. 65.535
  </p>
</td>
 </tr>
</table>

<p> 

</p>
<p>Табл. 4.1.
Целочисленные типы данных.

</p>
<p>1 января 1970 года
в миллисекундах. Так вот, вместимость long позволяет отсчитывать время на протяжении миллионов веков(!), причем как
в буду­щее, так и в прошлое.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Почему были выделены именно эти два типа, int и long? Дело в том, что
целочисленные литералы имеют тип int по умолчанию, или тип long, если стоит буква L или I. Именно
поэтому корректным литералом считает­ся только такое число, которое
укладывается в 4 или 8 байт, соответствен­но. Иначе компилятор сочтет это
ошибкой. Таким образом, следующие литералы являются корректными:

</p>
<p> 

</p>
<p>1

</p>
<p>-2147483648 2147483648L 0L

</p>
<p>111111111111111111L

</p>
<p>Над целочисленными аргументами можно производить следующие операции:

</p>
<p>•  операции сравнения
(возвращают булевское значение)

</p>
<p>•  &lt;, &lt;=, &gt;,
&gt;=

</p>
<p>—*, !

</p>
<p>•  числовые операции
(возвращают числовое значение)

</p>
<p>•   унарные операции + и -

</p>
<p>•   арифметические операции +,-,*,/,%

</p>
<p>•   операции инкремента и декремента (в префиксной и постфиксной форме): ++
и --

</p>
<p>•   операции битового сдвига &lt;&lt;,
», &gt;»

</p>
<p>•   битовые операции ~, &amp;, |, А

</p>
<p> 

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Операторы сравнения вполне очевидны и отдельно мы их рассмат­ривать не
будем. Их результат всегда булевского типа (true или false).

</p>
<p>Работа числовых операторов также понятна, к тому же пояснялась в
предыдущей лекции. Единственное уточнение можно сделать относи­тельно
операторов + и -, которые могут быть как бинарными (иметь два операнда), так и
унарными (иметь один операнд). Бинарные операнды являются операторами сложения
и вычитания, соответственно. Унарный оператор + возвращает значение, равное
аргументу (+х всегда равно х). Унарный оператор -, примененный к значению х,
возвращает результат, Равный 0-х. Неожиданный эффект имеет место в том случае, если
аргу­мент равен наименьшему возможному значению примитивного типа.

</p>
<p>int х=-2147483648;
// наименьшее возможное
значение типа int int у=-х;

</p>
<p>Теперь значение переменной у на самом деле равно не 2147483648,
поскольку такое число не
укладывается в область значений типа int, а в точности равно
значению х! Другими словами, в этом примере выражение -х==х истинно!

</p>
<p>Дело в том, что если при выполнении числовых операций над целы­ми
числами возникает переполнение и результат не может быть сохранен в данном
примитивном типе, то Java не создает никаких
ошибок. Вместо этого все старшие биты, которые превышают вместимость типа,
просто отбрасываются. Это может привести не только к потере точной абсолют­ной
величины результата, но даже к искажению его знака, если на месте знакового
бита окажется противоположное значение.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>int х= 300000; print(x*x);

</p>
<p>Результатом такого примера
будет: -194313216

</p>
<p>Возвращаясь к инвертированию числа -2147483648,
мы видим, что
математический результат равен в точности +23\
или, в двоичном форма­те, 10....0
(единица и 31 ноль). Но
тип int рассматривает первую единицу как знаковый бит, и результат получается
равным -2147483648.

</p>
<p>Таким образом, явное выписывание в коде литералов, которые слишком
велики для используемых типов, приводит к ошибке компиля­ции (см. лекцию 3).
Если же переполнение возникает в результате выпол­нения операции,
"лишние" биты просто отбрасываются.

</p>
<p>Подчеркнем, что выражение типа -5 не является целочисленным ли­тералом. На самом деле оно состоит из
литерала 5 и оператора -. Напом­ним, что некоторые литералы (например, 2147483648)
могут встречаться только в
сочетании с унарным оператором -.

</p>
<p>Кроме того, числовые операции в Java обладают еще одной особен­ностью. Хотя целочисленные типы имеют длину 8,
16, 32 и 64 бита, вы­числения проводятся только с 32-х и 64-х битной точностью.
А это значит, что перед вычислениями может потребоваться преобразовать тип
одного или нескольких операндов.

</p>
<p>Если хотя бы один аргумент операции имеет тип long, то все аргу­менты
приводятся к этому типу и результат операции также будет типа long. Вычисление будет
произведено с точностью в 64 бита, а более стар­шие биты, если таковые
появляются в результате, отбрасываются.

</p>
<p>Если же аргументов типа long нет, то вычисление
производится с точностью в 32 бита, и все аргументы преобразуются в int (это относится к byte, short, char). Результат также
имеет тип int. Все биты старше 32-го игнорируются.

</p>
<p>Никакого способа узнать, произошло ли переполнение, нет. Расши­рим
рассмотренный пример:

</p>
<p>int &#161;=300000;

</p>
<p>print(i*i); // умножение с точностью 32 бита long m=i;

</p>
<p>print(m*m); // умножение с точностью 64 бита

</p>
<p>print(1/(m-i)); // попробуем получить разность значений int и long

</p>
<p> 

</p>
<p>Результатом такого примера будет:

</p>
<p> 

</p>
<p>-194313216
90000000000

</p>
<p>затем мы получим ошибку деления на ноль, поскольку переменные i и m хоть и разных
типов, но хранят одинаковое математическое значение и их разность равна нулю.
Первое умножение производилось с точностью в 32 бита, более старшие биты были
отброшены. Второе — с точностью в 64 бита, ответ не исказился.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Вопрос приведения типов, и в том числе специальный оператор для такого
действия, подробно рассматривается в следующих лекциях. Однако здесь хотелось
бы отметить несколько примеров, ко­торые не столь очевидны и могут создать
проблемы при написании программ. Во-первых, подчеркнем, что результатом
операции с цело­численными аргументами всегда является целое число. А значит, в
следующем примере

</p>
<p> 

</p>
<p>double х= 1/2;

</p>
<p>Переменной х будет
присвоено значение 0, а не 0.5, как можно было бы ожидать. Подробно операции с дробными аргументами
рассматриваются Ниже, но чтобы получить значение 0.5, достаточно написать 1 ./2 (теперь первый аргумент дробный и результат не будет округлен).

</p>
<p>Как уже упоминалось, время в Java измеряется в миллисекундах. По­пробуем вычислить, сколько миллисекунд
содержится в неделе и в месяце:

</p>
<p>print( 1000*60*60*24*7); // вычисление для недели print( 1000*60*60*24*30); // вычисление для месяца








</p>
<p>Необходимо
перемножить количество миллисекунд в одной секунде (1000), секунд - в минуте
(60), минут - в часе (60), часов - в дне (24) и дней — в неделе и месяце (7 и
30, соответственно). Получаем:

</p>
<p>604800000
-1702967296

</p>
<p> 

</p>
<p>Очевидно, во втором вычислении произошло переполнение. Доста­точно
сделать последний аргумент величиной типа long:

</p>
<p>print(1000*60*60*24*30L); // вычисление для месяца

</p>
<p>Получаем правильный
результат:

</p>
<p>2592000000

</p>
<p>Подобные вычисления разумно переводить на 64-битную точ­ность не на
последней операции, а заранее, чтобы избежать перепол­нения.

</p>
<p>Понятно, что типы большей длины могут хранить больший спектр значений, а
потому Java не позволяет
присвоить переменной меньшего типа значение большего типа. Например, такие
строки вызовут ошибку компиляции:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции int х=1; byte b=x;

</p>
<p> 

</p>
<p>Хотя для программиста и очевидно, что переменная b должна полу­чить значение 1, что легко укладывается в тип byte, однако компилятор не может
вычислять значение переменной х при обработке второй строки, он знает лишь, что
ее тип — int.

</p>
<p>А вот менее очевидный
пример:

</p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции byte b=1; byte c=b+1;

</p>
<p> 

</p>
<p>И здесь компилятор не сможет успешно завершить работу. При опе­рации
сложения значение переменной b будет преобразовано в тип int и таким же будет результат
сложения, а значит, его нельзя так просто при­своить переменной типа byte.

</p>
<p>Аналогично:

</p>
<p>//
пример вызовет ошибку компиляции int х=2; long у=3; int z=x+y;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Здесь результат сложения будет уже типа long. Точно так же некор­ректна
такая инициализация:

</p>
<p>//
пример вызовет ошибку компиляции byte b=5; byte с=-5;

</p>
<p>Даже унарный оператор "-" проводит вычисления с точностью не
меньше 32 бит.

</p>
<p>Хотя во всех случаях инициализация переменных приводилась толь­ко для
примера, а предметом рассмотрения были числовые операции, укажем корректный
способ преобразовать тип числового значения:

</p>
<p>byteb=1;

</p>
<p>byte c=(byte)-b;

</p>
<p>Итак, все числовые операторы возвращают результат типа int или long. Однако существует два
исключения.

</p>
<p>Первое из них — операторы инкрементации и декрементации. Их действие
заключается в прибавлении или вычитании единицы из значе­ния переменной, после
чего результат сохраняется в этой переменной и значение всей операции равно
значению переменной (до или после изме­нения, в зависимости от того, является
оператор префиксным или пост­фиксным). А значит, и тип значения совпадает с
типом переменной. (На самом деле, вычисления все равно производятся с точностью
минимум 32 бита, однако при присвоении переменной результата его тип
понижается.)

</p>
<p> 

</p>
<p>byte х=5;

</p>
<p>byte у1=х++; // на момент начала исполнения
х равен 5

</p>
<p>byte у2=х--; // на момент начала исполнения
х равен 6

</p>
<p>byte уЗ=++х; // на момент начала исполнения
х равен 5

</p>
<p>byte у4=--х; // на момент начала исполнения
х равен 6

</p>
<p>print(y1);

</p>
<p>print(y2);

</p>
<p>print(y3);

</p>
<p>print(y4);

</p>
<p>В результате получаем:

</p>
<p> 

</p>
<p>5 6 6 5

</p>
<p>Никаких проблем с присвоением результата операторов ++ и — пере­менным
типа byte. Завершая рассмотрение этих операторов, приведем еще один пример:

</p>
<p> 

</p>
<p>byte х=-128; print(-x);

</p>
<p>byte у= 127; print(++y);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>128 -128

</p>
<p>Этот пример иллюстрирует вопросы преобразования типов при вы­числениях и
случаи переполнения.

</p>
<p>Вторым исключением является оператор с условием ? :. Если второй и
третий операнды имеют одинаковый тип, то и результат операции будет такого же
типа.

</p>
<p> 

</p>
<p>byte х=2; byte у=3;

</p>
<p>byte z=(x&gt;y) ? х : у; // верно, х и у одинакового типа byte abs=(x&gt;0) ? х : -х; // неверно!

</p>
<p>Последняя строка неверна, так как третий аргумент содержит число­вую
операцию, стало быть, его тип int, а значит, и тип всей операции будет int, и присвоение
некорректно. Даже если второй аргумент имеет тип byte, а третий — short, значение будет типа
int.

</p>
<p>Наконец, рассмотрим оператор конкатенации со строкой. Оператор + может
принимать в качестве аргумента строковые величины
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Если од­ним из аргументов
является строка, а вторым — целое число, то число бу­дет преобразовано в текст
и строки объединятся.

</p>
<p>int х=1; print("x="+x);

</p>
<p>Результатом будет: х=1

</p>
<p>Обратите внимание
на следующий пример:

</p>
<p> 

</p>
<p>print(1+2+"text");
print("text"+1+2);

</p>
<p> 

</p>
<p>Его результатом будет:

</p>
<p>3text text12

</p>
<p>Отдельно рассмотрим работу с типом char. Значения этого
типа могут полноценно участвовать в числовых операциях:

</p>
<p>chard=10;

</p>
<p>char с2-А'; // латинская буква А (\u0041, код 65) int i=c1+c2-*B';

</p>
<p>Переменная і получит значение 9. Рассмотрим следующий пример:

</p>
<p> 

</p>
<p>char с-А';

</p>
<p>print(c);

</p>
<p>print(c+1);

</p>
<p>print("c="+c);

</p>
<p>ргіпі('с'+'='+с);

</p>
<p> 

</p>
<p>Его результатом будет:

</p>
<p> 

</p>
<p>А 66 с=А 225

</p>
<p>В первом случае в метод print было передано значение типа char, по­этому
отобразился символ. Во втором случае был передан результат сло­жения, то есть
число, и именно число появилось на экране. Далее при вожений со строкой тип char был преобразован в текст в виде символа.

</p>
<p>Наконец в последней
строке произошло сложение трех чисел: 'с' (код 99), '=' (код 61) и переменной с (т.е. код 'А' - 65).

</p>
<p>Для каждого примитивного типа существуют специальные вспомо­гательные
классы-обертки (wrapper classes). Для типов byte, short, int, long, char это Byte, Short, Integer, Long, Character. Эти классы содержат многие
полезные методы для работы с целочисленными значениями. На­пример,
преобразование из текста в число. Кроме того, есть класс Math, который хоть и предназначен
в основном для работы с дробными числа­ми, но также предоставляет некоторые
возможности и для целых.

</p>
<p>В заключение подчеркнем, что единственные операции с целыми числами, при
которых Java генерирует ошибки,-
это деление на ноль (операторы / и %).

</p>
<p> 

</p>
<p>Дробные типы

</p>
<p>Дробные типы — это float и double. Их длина - 4 и 8 байт, соответст­венно. Оба типа знаковые. Ниже в таблице сведены их
характеристики:

</p>
<p>Для целочисленных типов область значений задавалась верхней и нижней
границами, весьма близкими по модулю. Для дробных типов добавляется еще одно
ограничение — насколько можно приблизиться к нулю, другими словами - каково
наименьшее положительное нену­левое значение. Таким образом, нельзя задать
литерал заведомо боль­ший, чем позволяет соответствующий тип данных, это
приведет к ошибке overflow. И нельзя задать литерал, значение которого по моду­лю слишком мало для
данного типа, компилятор сгенерирует ошибку underflow.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>//
пример вызовет ошибку компиляции

</p>
<p>float f = 1e40f; //
значение слишком велико, overflow

</p>
<p></p>
<center><img width="449" height="158" src="http://kufas.ru/java.files/image012.png"></center>
double d =
1е-350; // значение слишком мало, underflow

<p>Напомним, что если в конце литерала стоит буква F или f, то литерал рассматривается как значение типа float. По умолчанию дробный литерал имеет тип double, при желании это можно подчеркнуть буквой D или d.

</p>
<p>Над дробными аргументами
можно производить следующие операции:

</p>
<p>•  операции сравнения
(возвращают булевское значение)

</p>
<p>• &lt;,&lt;=,
&gt;, &gt;=

</p>
<p> 

</p>
<p>•  числовые операции
(возвращают числовое значение)

</p>
<p>•   унарные операции + и -

</p>
<p>•   арифметические операции +, -, *, /, %

</p>
<p>•  
операции инкремента и
декремента (в префиксной и пост­фиксной форме): ++ и --

</p>
<p> 

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Практически все операторы действуют по тем же принципам, кото­рые
предусмотрены для целочисленных операторов (оператор деления с остатком %
рассматривался в предыдущей лекции, а операторы ++ и - - так­же увеличивают или
уменьшают значение переменной на единицу). Уточ­ним лишь, что операторы
сравнения корректно работают и в случае срав­нения целочисленных значений с
дробными. Таким образом, в основном необходимо рассмотреть вопросы переполнения
и преобразования типов при вычислениях.

</p>
<p>Для дробных вычислений появляется уже два типа переполнения — Overflow и underflow. Тем не менее, Java и здесь никак не
сообщает о возник­новении подобных ситуаций. Нет ни ошибок, ни других способов
обнару­жить их. Более того, даже деление на ноль не приводит к некорректной си­туации.
А значит, дробные вычисления вообще не порождают никаких ошибок.

</p>
<p>Такая свобода связана с наличием специальных значений дробного типа. Они
определяются спецификацией ШЕЕ 754 и уже перечислялись в лекции 3:

</p>
<p>•   положительная и отрицательная бесконечности (positive/negative infinity);

</p>
<p>•   значение "не число", Not-a-Number, сокращенно NaN;

</p>
<p>•   положительный и отрицательный нули.

</p>
<p>Все эти значения представлены как для типа float, так и для double. Положительную и отрицательную бесконечности можно получить следующим
образом:

</p>
<p>1 f/Of //
положительная бесконечность, тип float -1d/0d //отрицательная бесконечность, тип double

</p>
<p>Также в классах Float и Double определены константы POSITIVEJNFINITY и N EGATIVEJ N Fl NITY. Как видно из
примера, такие величины получаются при делении конечных величин на ноль.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Значение NaN можно получить,
например, в результате следующих действий:

</p>
<p> 

</p>
<p>0.0/0.0 // деление ноль на
ноль

</p>
<p>(1.0/0.0)*0.0 // умножение
бесконечности на ноль

</p>
<p>Эта величина также представлена константами NaN в классах Float и Double.

</p>
<p>Величины положительный и отрицательный ноль записываются очевидным
образом:

</p>
<p> 

</p>
<p>0.0 // дробный
литерал со значением положительного нуля +0.0 // унарная операция +, ее
значение - положительный ноль -0.0 // унарная операция -, ее значение -
отрицательный ноль

</p>
<p> 

</p>
<p>Все дробные значения строго упорядочены. Отрицательная беско­нечность
меньше любого другого дробного значения, положительная -больше. Значения +0.0 и
-0.0 считаются равными, то есть выражение 0.0==-0.0 истинно, а 0.0&gt;-0.0 —
ложно. Однако другие операторы разли­чают их, например, выражение 1.0/0.0 дает
положительную бесконеч­ность, а 1.0/-0.0 — отрицательную.

</p>
<p>Единственное исключение - значение NaN. Если хотя бы один
из ар­гументов операции сравнения равняется NaN, то результат
заведомо бу­дет false (для оператора !=
соответственно всегда true). Таким образом, единственное значение х, при котором выражение х!=х истинно,—
имен­но NaN.

</p>
<p>Возвращаемся к вопросу переполнения в числовых операциях. Если
получаемое значение слишком велико по модулю (overflow), то результа­том
будет бесконечность соответствующего знака.

</p>
<p> 

</p>
<p>print(1e20f*1e20f); print(-1e200*1e200);

</p>
<p> 

</p>
<p>В результате получаем:

</p>
<p>Infinity -Infinity

</p>
<p>Если результат, напротив, получается слишком мал (underflow), то он просто округляется до нуля. Так же поступают и в том случае,
когда ко­личество десятичных знаков превышает допустимое:

</p>
<p>print(1e-40f/1e10f);
// underflow для float

</p>
<p>print(-1 е-300/1 е100); // underflow
для double

</p>
<p>float f=1e-6f;

</p>
<p>print(f);

</p>
<p>f+=0.002f;

</p>
<p>print(f);

</p>
<p>f+=3;

</p>
<p>print(f);

</p>
<p>f+=4000;

</p>
<p>print(f);

</p>
<p>Результатом будет:

</p>
<p>0.0 -0.0

</p>
<p>1.0E-6 0.002001
3.002001 4003.002

</p>
<p>Как видно, в последней строке был утрачен 6-й разряд после десятич­ной
точки.

</p>
<p>Другой пример (из
спецификации языка Java):

</p>
<p> 

</p>
<p>double d
= 1е-305 * Math.PI;
print(d);

</p>
<p>for (int i = 0; i &lt; 4; i++) print(d /= 100000);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>3.141592653589793E-305

</p>
<p>3.1415926535898E-310

</p>
<p>3.141592653E-315

</p>
<p>3.142E-320

</p>
<p>0.0








</p>
<p>Таким образом, как и для целочисленных значений, явное выписыва­ние в коде литералов, которые слишком велики (overflow) или слишком








</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>малы (underflow) для используемых типов, приводит к ошибке компиля­ции (см. лекцию 3).
Если же переполнение возникает в результате выпол­нения операции, то
возвращается одно из специальных значений.

</p>
<p>Теперь перейдем к преобразованию типов. Если хотя бы один аргу­мент
имеет тип double, то значения всех аргументов приводятся к этому типу и результат
операции также будет иметь тип double. Вычисление бу­дет произведено с точностью в 64 бита.

</p>
<p>Если же аргументов типа double нет, а хотя бы один
аргумент имеет тип float, то все аргументы приводятся к float, вычисление
производится с точностью в 32 бита и результат имеет тип float.

</p>
<p>Эти утверждения верны и в случае, если один из аргументов цело­численный.
Если хотя бы один из аргументов имеет значение NaN, то и результатом
операции будет NaN.

</p>
<p>Еще раз рассмотрим простой
пример:

</p>
<p> 

</p>
<p>print(1/2); print(1/2.);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>О

</p>
<p>0.5

</p>
<p>Достаточно одного дробного
аргумента, чтобы результат операции также имел дробный тип. Более сложный
пример:

</p>
<p>int х=3;

</p>
<p>int у=5;

</p>
<p>print (х/у);

</p>
<p>print((double)x/y);

</p>
<p>print(1.0*x/y);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>0

</p>
<p>0.6 0.6

</p>
<p>В первый раз оба аргумента были целыми, поэтому в результате по­лучился
ноль. Однако поскольку оба операнда представлены перемен­ными, в этом примере
нельзя просто поставить десятичную точку и та­ким образом перевести вычисления
в дробный тип. Необходимо либо преобразовать один из аргументов (второй вывод
на экран), либо вста­вить еще одну фиктивную операцию с дробным аргументом
(последняя строка).

</p>
<p>Приведение типов подробно рассматривается в другой лекции, од­нако
обратим здесь внимание на несколько моментов.

</p>
<p>Во-первых, при приведении дробных значений к целым типам дробная часть
просто отбрасывается. Например, число 3.84 будет преоб­разовано в целое 3, а
-3.84 превратится в -3. Для математического округ­ления необходимо
воспользоваться методом класса Math.round(...).

</p>
<p>Во-вторых, при приведении значений int к типу float и при приведе­нии значений типа long к типу float и double возможны потери точности, несмотря на то, что эти дробные типы вмещают
гораздо большие числа, чем соответствующие целые. Рассмотрим следующий пример:

</p>
<p>long |=1111111111111_; float f = I; I = (long) f; print(l);

</p>
<p>Результатом будет:
111111110656

</p>
<p>Тип float не смог сохранить
все значащие разряды, хотя преобразо­вание от long к float произошло без
специального оператора в отличие от обратного перехода.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Для каждого примитивного типа существуют специальные вспо­могательные
классы-обертки (wrapper classes). Для типов float и double это Float и Double. Эти классы
содержат многие полезные методы для работы с дробными значениями. Например,
преобразование из текста в число.

</p>
<p>Кроме того, класс Math предоставляет большое количество методов Для операций над
дробными значениями, например, извлечение квадрат­ного корня, возведение в
любую степень, тригонометрические и другие. Также в этом классе определены
константы PI и основание натурального логарифма Е.

</p>
<p> 

</p>
<p>Булевский тип

</p>
<p>Булевский тип представлен всего одним типом boolean, который Может
хранить всего два возможных значения - true и false. Величины Именно этого типа получаются в результате операций сравнения.








</p>
<p> 








</p>
<p>130




</p>
<p>9«




</p>
<p>131








</p>
<p>Над булевскими аргументами можно производить следующие опера­ции:

</p>
<p>•  операции сравнения (возвращают булевское значение)

</p>
<p>"       , 
!

</p>
<p>•  логические операции
(возвращают булевское значение) . !

</p>
<p>-&amp;, |,А - &amp;&amp;, 11

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<p>Операторы сравнения &amp;&amp; и 11 обсуждались в предыдущей лекции. В операторе с условием ? : первым
аргументом может быть только значение типа boolean. Также
допускается, чтобы второй и третий аргументы одно­временно имели булевский тип.

</p>
<p>Операция конкатенации со строкой превращает булевскую величи­ну в текст "true" или "false" в
зависимости от значения.

</p>
<p>Только булевские выражения допускаются для управления потоком
вычислений, например, в качестве критерия условного перехода if.

</p>
<p>Никакое число не может быть интерпретировано как булевское выра­жение.
Если предполагается, что ненулевое значение эквивалентно истине (по правилам
языка С), то необходимо записать х!=0. Ссылочные величи­ны можно преобразовывать в boolean выражением ref!=null.

</p>
<p> 

</p>
<p>Ссылочные ТИПЫ

</p>
<p>Итак, выражение ссылочного типа имеет значение либо null, либо ссылку,
указывающую на некоторый объект в виртуальной памяти JVM.

</p>
<p> 

</p>
<p>Объекты
и правила работы с ними

</p>
<p>Объект (object) - это экземпляр некоторого класса, или экземпляр массива. Массивы
будут подробно рассматриваться в соответствующей лекции. Класс — это описание
объектов одинаковой структуры, и если в программе такой класс используется, то
описание присутствует в единст­венном экземпляре
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Объектов этого класса может
не быть вовсе, а может быть создано сколь угодно много.

</p>
<p>Объекты всегда создаются с использованием ключевого слова new, причем одно слово
new порождает строго
один объект (или вовсе ни одного, если происходит ошибка). После ключевого
слова указывается имя класса, от которого мы собираемся породить объект.
Создание объекта всегда происходит через вызов одного из конструкторов класса
(их может быть несколько), поэтому в заключение ставятся скобки, в которых
перечисле­ны значения аргументов, передаваемых выбранному конструктору. В
приведенных выше примерах, когда создавались объекты типа Point, вы­ражение new Point (3,5) означало обращение к конструктору класса Point, у которого есть
два аргумента типа int. Кстати, обязательное объявление такого конструктора в упрощенном
объявлении класса отсутствовало. Объявление классов рассматривается в следующих
лекциях, однако приве­дем правильное определение Point:

</p>
<p>class Point { intx, у;

</p>
<p>I**

</p>
<p>*  Конструктор принимает 2 аргумента,

</p>
<p>*  которыми инициализирует поля объекта.

</p>
<p>7

</p>
<p>Point (int newx, int newy){ x=newx; y=newy;

</p>
<p>}

</p>
<p>}

</p>
<p>Если конструктор отработал успешно, то выражение new возвращает ссылку на созданный объект. Эту ссылку можно сохранить в
переменной, передать в качестве аргумента в какой-либо метод или использовать
дру­гим способом. JVM всегда занимается
подсчетом хранимых ссылок на каждый объект. Как только обнаруживается, что
ссылок больше нет, такой объект предназначается для уничтожения сборщиком
мусора (garbage col­lector). Восстановить ссылку на такой "потерянный" объект
невозможно.

</p>
<p> 

</p>
<p>Point p=new Point(1,2); // Создали
объект, получили на него ссылку

</p>
<p>Point р1=р; // теперь
есть 2 ссылки на точку (1,2) p=new Point(3,4); // осталась одна ссылка на точку (1,2) p1=null;

</p>
<p> 

</p>
<p>Ссылок на объект-точку (1,2) больше нет, доступ к нему утерян и он Вскоре будет уничтожен сборщиком мусора.

</p>
<p>Любой объект порождается только с применением ключевого сло­ва new. Единственное
исключение — экземпляры класса String. Запи­сывая любой строковый литерал, мы автоматически порождаем объект ^ого класса. Оператор конкатенации +, результатом которого является строка, также неявно порождает объекты без использования ключевого слова new.








</p>
<p>Рассмотрим пример: "abc"+"def"

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>При выполнении этого выражения будет создано три объекта класса String. Два объекта
порождаются строковыми литералами, третий будет представлять результат
конкатенации.

</p>
<p>Операция создания объекта - одна из самых ресурсоемких в Java. Поэтому следует
избегать ненужных порождений. Поскольку при рабо­те со строками их может
создаваться довольно много, компилятор, как правило, пытается оптимизировать
такие выражения. В рассмотренном примере, поскольку все операнды являются
константами времени ком­пиляции, компилятор сам осуществит конкатенацию и
вставит в код уже результат, сократив таким образом количество создаваемых
объек­тов до одного.

</p>
<p>Кроме того, в версии Java 1.1 была введена технология reflection, ко­торая позволяет обращаться к классам, методам и полям, используя
лишь их имя в текстовом виде. С ее помощью также можно создать объект без
ключевого слова new, однако эта технология довольно специфична, при­меняется в редких
случаях, а кроме того, довольно проста и потому в дан­ном курсе не
рассматривается. Все же приведем пример ее применения:

</p>
<p>Point р = null; try {

</p>
<p>// в следующей строке, используя лишь текстовое // имя класса Point, порождается
объект без // применения ключевого слова new р = (Point)Class.forName("Point").newlnstance(); } catch (Exception e) {// обработка ошибок System.out.println(e);

</p>
<p>}

</p>
<p>Объект всегда "помнит", от какого класса он был порожден. С
дру­гой стороны, как уже указывалось, можно ссылаться на объект, исполь­зуя
ссылку другого типа. Приведем пример, который будем еще много раз использовать.
Сначала опишем два класса, Parent и его наследник Child:

</p>
<p> 

</p>
<p>// Объявляем класс Parent

</p>
<p>class Parent {

</p>
<p>}

</p>
<p>// Объявляем класс Child и наследуем // его от класса Parent
class Child extends Parent { }

</p>
<p>Пока нам не нужно определять какие-либо поля или методы. Далее объявим
переменную одного типа и проинициализируем ее значением другого типа:

</p>
<p> 

</p>
<p>Parent р = newChild();

</p>
<p>Теперь переменная типа Parent указывает на
объект, порожденный от класса Child.

</p>
<p>Над ссылочными значениями можно производить следующие опе­рации:

</p>
<p>•   
обращение к полям и
методам объекта

</p>
<p>•   
оператор instanceof (возвращает
булевское значение)

</p>
<p>•   
операции сравнения == и !=
(возвращают булевское значение)

</p>
<p>•   
оператор приведения типов

</p>
<p>•   
оператор с условием ? :

</p>
<p>•   
оператор конкатенации со
строкой +

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Обращение к полям и методам объекта можно назвать основной операцией над
ссылочными величинами. Осуществляется она с помощью символа . (точка). Примеры
ее применения будут приводиться.

</p>
<p>Используя оператор instanceof, можно узнать, от какого класса про­изошел объект. Этот оператор имеет
два аргумента. Слева указывается ссылка на объект, а справа - имя типа, на
совместимость с которым про­веряется объект. Например:

</p>
<p>Parent р = new Child(); // проверяем
переменную р типа Parent // на совместимость
с типом Child print(p instanceof Child);

</p>
<p>Результатом будет true. Таким образом, оператор instanceof опирается не на тип
ссылки, а на свойства объекта, на который она ссылается. Но этот оператор
возвращает истинное значение не только для того типа, от которо­го был порожден
объект. Добавим к уже объявленным классам еще один:

</p>
<p> 

</p>
<p>// Объявляем новый класс и
наследуем

</p>
<p>// его от класса Child

</p>
<p>class
ChildOfChild extends Child {}








</p>
<p>Теперь заведем переменную нового типа:

</p>
<p> 

</p>
<p>Parent р = new ChildOfChildO; print(p instanceof Child);

</p>
<p> 

</p>
<p>В первой строке объявляется переменная типа Parent, которая иници­ализируется
ссылкой на объект, порожденный от ChildOfChild. Во второй строке оператор instanceof анализирует
совместимость ссылки типа Parent с классом Child, причем
задействованный объект не порожден ни от перво­го, ни от второго класса. Тем не
менее, оператор вернет true, поскольку класс, от которого этот объект порожден, наследуется от Child.

</p>
<p>Добавим еще один класс:

</p>
<p>class Child2 extends Parent { }

</p>
<p> 

</p>
<p>И снова объявим переменную типа Parent:

</p>
<p>Parent
p=newChild(); print(p instanceof Child); print(p instanceof Child2);

</p>
<p> 

</p>
<p>Переменная p имеет тип Parent, а значит, может
ссылаться на объек­ты типа Child или Child2. Оператор instanceof помогает
разобраться в си­туации:

</p>
<p> 

</p>
<p>true false

</p>
<p> 

</p>
<p>Для ссылки, равной null, оператор instanceof всегда вернет
значение false.

</p>
<p>С изучением свойств объектной модели Java мы будем возвращаться к алгоритму работы оператора instanceof.

</p>
<p>Операторы сравнения = и != проверяют равенство (или неравен­ство) объектных
величин именно по ссылке. Однако часто требуется альтернативное сравнение - по
значению. Сравнение по значению имеет дело с понятием состояние объекта. Сам
смысл этого выраже­ния рассматривается в ООП, что же касается реализации в Java, то со­стояние
объекта хранится в его полях. При сравнении по
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>ссылке ни тип объекта, ни
значения его полей не учитываются, true возвращает­ся только в том случае, если обе ссылки указывают на один и
тот же объект.

</p>
<p>Point
p1=new Point(2,3);

</p>
<p>Point
p2=p1;

</p>
<p>Point
p3=new Point(2,3);

</p>
<p>print(p1==p2);

</p>
<p>print(p1==p3);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>true false

</p>
<p>Первое сравнение оказалось истинным, так как переменная р2 ссы­лается на
тот же объект, что и р1. Второе же сравнение ложно, несмотря на то, что
переменная рЗ ссылается на объект-точку с точно такими же координатами. Однако
это другой объект, который был порожден другим выражением new.

</p>
<p>Если один из аргументов оператора = равен null, а другой - нет,
то значение такого выражения будет false. Если же оба
операнда null, то ре­зультат будет true.

</p>
<p>Для корректного сравнения по значению существует специальный метод equals, который будет
рассмотрен позже. Например, строки надо сравнивать следующим образом:

</p>
<p>String s = "abc"; s=s+1;

</p>
<p>print(s.equals("abc1 "));

</p>
<p>Операция с условием ? : работает как обычно и может
принимать второй и третий аргументы, если они оба одновременно ссылочного типа.
Результат такого оператора также будет иметь объектный тип.

</p>
<p>Как и простые типы, ссылочные величины можно складывать со строкой. Если
ссылка равна null, то к строке добавляется текст "null". Если Же
ссылка указывает на объект, то у него вызывается специальный метод (он будет
рассмотрен ниже, его имя toStringO) и текст, который он вер­нет, будет добавлен к строке.

</p>
<p> 

</p>
<p>Класс
Object

</p>
<p>В Java множественное
наследование отсутствует. Каждый класс Может иметь только одного родителя.
Таким образом, мы можем про­следить цепочку наследования от любого класса,
поднимаясь все выше. Существует класс, на котором такая цепочка всегда
заканчивается, это класс Object. Именно от него наследуются все классы, в объявлении которых явно не
указан другой родительский класс. А значит, любой класс напрямую, или через
своих родителей, является наследником Object. Отсюда следует,
что методы этого класса есть у любого объекта (поля в Object отсутствуют), а потому они представляют особенный интерес.

</p>
<p>Рассмотрим основные из
них.

</p>
<p> 

</p>
<p>getClassf)

</p>
<p>Этот метод возвращает объект класса Class, который описывает
класс, от которого был порожден этот объект. Класс Class будет рас­смотрен ниже. У него есть метод getNameO, возвращающий имя
класса:

</p>
<p>String s = "abc";
Class
cl=s.getClass(); print(cl.getNameO);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Результатом будет строка:

</p>
<p> 

</p>
<p>java.lang.String

</p>
<p>В отличие от оператора instanceof, метод getClass() всегда возвра­щает точно тот класс, от которого был порожден объект.

</p>
<p> 

</p>
<p>equalsO

</p>
<p>Этот метод имеет один аргумент типа Object и возвращает boolean. Как уже говорилось, equals( ) служит для сравнения объектов по значению, а не по ссылке.
Сравнивается состояние объекта, у которого вызывается этот метод, с
передаваемым аргументом.

</p>
<p>Point p1=new
Point(2,3); Point p2=new Point(2,3); print(p1.equals(p2)j;

</p>
<p>Результатом будет true.

</p>
<p>Поскольку сам Object не имеет полей, а
значит, и состояния, в этом классе метод equals возвращает результат сравнения по ссылке. Однако при написании нового
класса можно переопределить этот метод и описать правильный алгоритм сравнения
по значению (что и сделано в большин­стве стандартных классов). Соответственно,
в класс Point также необходи­мо
добавить переопределенный метод сравнения:

</p>
<p>public boolean
equals(Object о) {

</p>
<p>// Сначала необходимо убедиться, что переданный

</p>
<p>// объект совместим с типом Point

</p>
<p>if (о instanceof Point) {

</p>
<p>//Типы совместимы, можно провести преобразование

</p>
<p>Point р = (Point)o;

</p>
<p>// Возвращаем результат сравнения координат return р.х==х &amp;&amp; р.у==у;

</p>
<p>}

</p>
<p>// Если объект не совместим с Point, возвращаем false return false;

</p>
<p>}

</p>
<p>hashCodeO

</p>
<p>Данный метод возвращает значение int. Цель hashCodeO -представить любой
объект целым числом. Особенно эффективно это используется в хэш-таблицах (в Java есть стандартная реализация та­кого хранения данных, она будет
рассмотрена позже). Конечно, нель­зя потребовать, чтобы различные объекты
возвращали различные хэш-коды, но, по крайней мере, необходимо, чтобы объекты,
равные по значению (метод equals() возвращает true), возвращали одинако­вые хэш-коды.

</p>
<p>В классе Object этот метод
реализован на уровне JVM. Сама вирту­альная машина генерирует число хеш-кодов, основываясь на
расположе­нии объекта в памяти.

</p>
<p> 

</p>
<p>toStringf)

</p>
<p>Этот метод позволяет получить текстовое описание любого объек­та. Создавая
новый класс, данный метод можно переопределить и воз­вращать более подробное
описание. Для класса Object и его наследни­ков,
не переопределивших toStringO, метод возвращает следующее вы­ражение:

</p>
<p>getClass().getName()+"@"+hashCode()

</p>
<p>Метод getNameO класса Class уже приводился в пример, а хэш-код еШе дополнительно
обрабатывается специальной функцией для пред­ставления в шестнадцатеричном
формате.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Например:

</p>
<p> 

</p>
<p>print(new Objecto);








</p>
<p>Результатом будет: java.lang.Object@92d342

</p>
<p>В результате этот метод позволяет по текстовому описанию понять, от
какого класса был порожден объект и, благодаря хеш-коду, различать разные
объекты, созданные от одного класса.

</p>
<p>Именно этот метод вызывается при конвертации объекта в текст, когда он
передается в качестве аргумента оператору конкатенации строк.

</p>
<p> 

</p>
<p>finalizef)

</p>
<p>Данный метод вызывается при уничтожении объекта автоматичес­ким
сборщиком мусора (garbage collector). В классе Object он ничего не
делает, однако в классе-наследнике позволяет описать все действия, не­обходимые
для корректного удаления объекта, такие как закрытие со­единений с БД, сетевых
соединений, снятие блокировок на файлы и т.д. В обычном режиме напрямую этот
метод вызывать не нужно, он отрабо­тает автоматически. Если необходимо, можно
обратиться к нему явным образом.

</p>
<p>В методе finalize() нужно описывать только дополнительные действия, связанные с логикой
работы программы. Все необходимое для удаления объекта JVM сделает сама.

</p>
<p> 

</p>
<p>Класс
String

</p>
<p>Как уже указывалось, класс String занимает в Java особое положе­ние.
Экземпляры только этого класса можно создавать без использования ключевого
слова new. Каждый строковый литерал порождает экземпляр String, и это
единственный литерал (кроме null), имеющий объектный тип.

</p>
<p>Затем значение любого типа может быть приведено к строке с помо­щью
оператора конкатенации строк, который был рассмотрен для каждо­го типа, как
примитивного, так и объектного.

</p>
<p>Еще одним важным свойством данного класса является неизменяе­мость. Это
означает, что, породив объект, содержащий некое значение-строку, мы уже не можем
изменить данное значение - необходимо со­здать новый объект.

</p>
<p>String s="a"; s="b";

</p>
<p> 

</p>
<p>Во второй строке переменная сменила свое значение, но только создав
новый объект класса String.

</p>
<p>Поскольку каждый строковый литерал порождает новый объект, что есть очень
ресурсоемкая операция в Java, зачастую компилятор стремится оптимизировать эту работу.

</p>
<p>Во-первых, если используется несколько литералов с одинаковым значением,
для них будет создан один и тот же объект.

</p>
<p>String s1 = "abc"; String s2 = "abc"; String s3 = "a"+"bc";
print(s1==s2); print(s1==s3);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>true true

</p>
<p>To есть в случае, когда строка конструируется из констант, известных уже на
момент компиляции, оптимизатор также подставляет один и тот Же объект.

</p>
<p>Если же строка создается выражением, которое может быть вычис­лено
только во время исполнения программы, то оно будет порождать но­вый объект:

</p>
<p> 

</p>
<p>String
s1="abc"; String s2="ab"; print(s1==(s2+"c"));

</p>
<p>Результатом будет false, так как компилятор не может предсказать результат сложения значения
переменной с константой.

</p>
<p>В классе String определен метод intern(), который
возвращает один и тот же объект-строку для всех экземпляров, равных по
значению. То есть если для ссылок s1 и s2 верно выражение s1 .equals(s2), то верно и Sl.intern()==s2. intern().

</p>
<p>Разумеется, в классе переопределены методы equals() и hashCode(). Метод toStringO также переопределен и возвращает он сам объект-строку, 10
есть для любой ссылки s типа String, не равной null, верно выражение s~=s.toString().








</p>
<p>Класс
Class

</p>
<p>Наконец, последний класс,
который будет рассмотрен в этой лекции.

</p>
<p>Класс Class является
метаклассом для всех классов Java. Когда JVM загружает файл .class, который описывает
некоторый тип, в памяти со­здается объект класса Class, который будет
хранить это описание.

</p>
<p>Например, если в программе
есть строка

</p>
<p> 

</p>
<p>Point p=new Point(1,2);

</p>
<p> 

</p>
<p>то это означает, что в системе созданы следующие объекты:

</p>
<p>1. 
объект типа Point, описывающий точку
(1,2);

</p>
<p>2.  объект класса Class, описывающий класс Point;

</p>
<p>3.  объект класса Class, описывающий класс Object. Поскольку класс Point наследуется от Object, его описание
также необходимо;

</p>
<p>4.  объект класса Class, описывающий класс Class. Это обычный Java-класс, который должен быть загружен по общим правилам.

</p>
<p>Одно из применений класса Class уже было рассмотрено — исполь­зование метода getClass() класса Object. Если продолжить
последний пример с точкой:

</p>
<p> 

</p>
<p>Class cl=p.getClass(); // это объект №2 из списка Class cl2=cl.getClass(); // это объект
№4 из списка Class cl3=cl2.getClass(); // опять объект №4

</p>
<p> 

</p>
<p>Выражение cl2==cl3 верно.

</p>
<p>Другое применение класса Class также приводилось в
примере при­менения технологии reflection.

</p>
<p>Кроме прямого использования метакласса для хранения в памяти описания
классов, Java использует эти
объекты и для других целей, кото­рые будут рассмотрены ниже (статические
переменные, синхронизация статических методов и т.д.).

</p>
<p> 

</p>
<p>Заключение

</p>
<p>Типы данных - одна из ключевых тем курса. Невозможно написать ни одной
программы, не используя их. Вот список некоторых операций, где применяются
типы:

</p>
<p>•   
объявление типов;

</p>
<p>•   
создание объектов;

</p>
<p>•   
при объявлении полей — тип
поля;

</p>
<p>•   
при объявлении методов —
входные параметры, возвращаемое значение;

</p>
<p> 

</p>
<p>•   
при объявлении
конструкторов — входные параметры;

</p>
<p>•   
оператор приведения типов;

</p>
<p>•   
оператор instanceof;

</p>
<p>•   
объявление локальных
переменных;

</p>
<p>•   
многие другие — обработка
ошибок, import-выражения и т.д. Принципиальные различия между примитивными и
ссылочными

</p>
<p>типами данных будут
рассматриваться и дальше по ходу курса. Изучение объектной модели Java даст основу для более подробного изложения объ­ектных типов — обычных и
абстрактных классов, интерфейсов и масси­вов. После приведения типов будут
описаны связи между типом перемен­ной и типом ее значения.

</p>
<p>В обсуждении будущей версии Java 1.5 упоминаются темплейты (templates), которые существенно расширят понятия типа данных, если действительно
войдут в стандарт языка.

</p>
<p>В лекции было рассказано о том, что Java является строго типизиро­ванным языком, то есть тип всех переменных и
выражений определяется уже компилятором. Это позволяет существенно повысить
надежность и качество кода, а также делает необходимым понимание программистами
объектной модели.

</p>
<p>Все типы в Java делятся на две
группы — фиксированные простые, или примитивные, типы (8 типов) и
многочисленная группа объектных типов (классов). Примитивные типы действительно
являются хранили­щами данных своего типа. Ссылочные переменные хранят ссылку на
не­который объект совместимого типа. Они также могут принимать значе­ние null, не указывая ни на
какой объект. JVM подсчитывает
количество ссылок на каждый объект и активизирует механизм автоматической сбор­ки
мусора для удаления неиспользуемых объектов.

</p>
<p>Были рассмотрены переменные. Они характеризуются тремя основ­ными
параметрами - имя, тип и значение. Любая переменная должна быть объявлена и при
этом может быть инициализирована. Возможно ис­пользование модификатора final.

</p>
<p>Примитивные типы состоят из пяти целочисленных, включая сим­вольный тип,
двух дробных и одного булевского. Целочисленные литера­лы имеют ограничения,
связанные с типами данных. Были рассмотрены все операторы над примитивными
типами, тип возвращаемого значения и тонкости их использования.

</p>
<p>Затем изучались объекты, способы их создания и операторы, выполня­ющие над ними различные действия, в частности принцип работы оператора instanceof. Далее были рассмотрены самые главные классы в Java -Object, Class, String.








</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Каков будет результат следующего примера? byte b=3; int c=b; С++;

</p>
<p>print(++b==c);

</p>
<p>&#9633;          
true

</p>
<p>&#9633;          
false

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Каким
будет результат следующих действий?
1/2 1./2 1/2. 1./2.

</p>
<p>&#9633;          
все операции дадут 0.5

</p>
<p>&#9633;          
все операции дадут 0

</p>
<p>&#9633;          
0,0.5,0,0.5

</p>
<p>&#9633;          
0,0.5,0.5,0.5

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Эквивалентны
ли две приведенные ниже операции над
ссылочными переменными х1 и х2 (5отеС1азз2 - тип
переменной х2)?

</p>
<p>х1
тз1апсео!8отеС1азз2

</p>
<p>х1.деГС1а88().дет.№те().еяиа18(х2.деГС1а88().дет.№те())

</p>
<p>&#9633;          
да

</p>
<p>&#9633;          
нет








</p>
<p> 








</p>
<p>Курс




</p>
<p>Программирование
на Java








</p>
<p> 








</p>
<p>Вариант
2




</p>
<p>Вариант
3








</p>
<p> 








</p>
<p>1.       Каков
будет результат следующего примера?
Point р = new Point(1, 2);

</p>
<p>int а=р.х;

</p>
<p>р = new Point(3, 4); print(a);

</p>
<p>&#9633;       
1

</p>
<p>&#9633;          
2

</p>
<p>&#9633;          
3

</p>
<p>&#9633;          
4

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Каков
будет результат следующих действий?
double х=2./0;

</p>
<p>double у=-1/0.; print(x+y);

</p>
<p>&#9633;       
POSITIVEJNFINITY

</p>
<p>&#9633;          
о

</p>
<p>&#9633;       
NaN

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Могут
ли следующие выражения вернуть значения false?

</p>
<p>a)   x.toString() instanceof String

</p>
<p>b)  (x+"") instanceof String

</p>
<p>&#9633;        оба
выражения возвращают только true

</p>
<p>Г"!  
первое выражение вернет false, если
х равен null, второе
возвращает только true

</p>
<p>Г~|  
оба выражения вернут false, если
х равен null

</p>
<p>&#9633;        первое
выражение вернет null, если
х ссылается на объект, порожденный от класса с переопределенным методом toStringt),
который возвращает null, второе
выражение возвращает только true

</p>
<p>1.  
Каков будет результат следующего примера? Point р1 = new Point(3, 4); Point р2 = р1; р1.х=5;

</p>
<p>р1 = new Point(4, 4); print(p2.x-p1 .х);

</p>
<p>&#9633;    
-1

</p>
<p>&#9633;          
о

</p>
<p>&#9633;       
1

</p>
<p> 

</p>
<p> 

</p>
<p>2.  
Каким будет результат следующей строки (код символа восклицательного знака 33)?
print("Hello"+'!');

</p>
<p>&#9633;       
"Hello!"

</p>
<p>&#9633;       
"НеІІоЗЗ"

</p>
<p> 

</p>
<p> 

</p>
<p>Щ.   Каков
будет результат следующих действий? Point р1 = new Point(2, 3); Point р2 = new Point(2, 3); print(p1==p2); p2=p1; p1.x=3;
print(p1==p2);

</p>
<p>&#9633;       
true; true

</p>
<p>&#9633;       
true; false

</p>
<p>&#9633;       
false; true

</p>
<p>&#9633;       
false; false








</p>
<p>
</p>
<center> 
</center>
    </div>