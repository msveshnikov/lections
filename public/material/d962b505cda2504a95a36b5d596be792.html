# encoding: windows-1251
<section>

<h1> Введение </h1>


<p>
Среди современных языков программирования язык C является одним из наиболее распространенных. Язык C универсален, однако наиболее эффективно его применение в задачах системного программирования – разработке трансляторов, операционных систем, инструментальных средств. Язык C хорошо зарекомендовал себя эффективностью, лаконичностью записи алгоритмов, логической стройностью программ. Во многих случаях программы, написанные на языке C, сравнимы по скорости с программами, написанными на Ассемблере, при этом они более наглядны и просты в сопровождении.


</p>
<p>
Язык C имеет ряд существенных особенностей, которые выделяют его среди других языков программирования. В значительной степени на формирование идеологии языка повлияла цель, которую ставили перед собой его создатели – обеспечение системного программиста удобным инструментальным языком, который мог бы заменить Ассемблер. В результате появился язык программирования высокого уровня, обеспечивающий необычайно легкий доступ к аппаратным средствам компьютера. С одной стороны, как и другие современные языки высокого уровня, язык C поддерживает полный набор конструкций структурного программирования, модульность, блочную структуру программы. С другой стороны, язык C имеет ряд низкоуровневых черт.


</p>
<p>
Перечислим некоторые особенности языка C.

</p>
<ul>
  <li> В языке C реализован ряд операций низкого уровня. Некоторые из таких операций напрямую соответствуют машинным командам, например,  или операции .
  </li>
<li>  отражают те же объекты, с которыми приходится иметь дело в программе на Ассемблере – байты, машинные слова и т.д. Несмотря на наличие в языке C развитых средств построения составных объектов (массивов и структур), в нем практически отсутствуют средства для работы с ними как с единым целым.
  </li>
<li> Язык C поддерживает механизм  на переменные и функции. Указатель – это переменная, предназначенная для хранения машинного адреса некоторой переменной или функции. Поддерживается арифметика указателей, что позволяет осуществлять непосредственный доступ и работу с адресами памяти практически так же легко, как на Ассемблере. Использование указателей позволяет создавать высокоэффективные программы, однако требует от программиста особой осторожности.
  </li>
<li> Как никакой другой язык программирования высокого уровня, язык C «доверяет» программисту. Даже в таком существенном вопросе, как , налагаются лишь незначительные ограничения. Однако это также требует от программиста осторожности и самоконтроля.
  </li>
<li> Несмотря на эффективность и мощность конструкция языка C, он относительно мал по объему. В нем отсутствуют встроенные операторы ввода/вывода, динамического распределения памяти, управления процессами и т.п., однако в системное окружение языка C входит библиотека стандартных функций, в которой реализованы подобные действия.
</li>
</ul>

<p>
Язык C++ – это язык программирования общего назначения, цель которого – сделать работу серьёзных программистов более приятным занятием. За исключением несущественных деталей, язык <span>C++</span> является надмножеством языка С. Помимо возможностей, предоставляемых языком С, язык <span>C++</span> обеспечивает гибкие и эффективные средства определения новых типов.

</p>
<p>
Язык программирования служит двум взаимосвязанным целям: он предоставляет программисту инструмент для описания подлежащих выполнению действий и набор концепций, которыми оперирует программист, обдумывая, что можно сделать. Первая цель в идеале требует языка, близкого к компьютеру, чтобы все важные элементы компьютера управлялись просто и эффективно способом, достаточно очевидным для программиста. Язык С создавался на основе именно от этой идеи. Вторая цель в идеале требует языка, близкого к решаемой задаче, чтобы концепции решения могли быть выражены понятно и непосредственно. Эта идея привела к пополнению языка С свойствами, превратившими его в язык <span>C++</span>.

</p>
<p>
Ключевое понятие в языке <span>C++</span> – <b>класс</b>. Классы обеспечивают сокрытие информации, гарантированную инициализацию данных, неявное преобразование определяемых пользователем типов, динамическое определение типа, контроль пользователя над управлением памятью и механизм перегрузки операторов. Язык <span>C++</span> предоставляет гораздо лучшие, чем язык С, средства для проверки типов и поддержки модульного программирования. Кроме того, язык содержит усовершенствования, непосредственно не связанные с классами, такие как: символические константы, встраивание функций в место вызова, параметры функций по умолчанию, перегруженные имена функций, операторы управления свободной памятью и ссылки. Язык <span>C++</span> сохраняет способность языка С эффективно работать с аппаратной частью на уровне битов, байтов, слов, адресов и т.д. Это позволяет реализовывать пользовательские типы с достаточной степенью эффективности.

</p></section><section id="l1_1">

<h1> 1. Алфавит </h1>

<p>
Множество символов языка C включает:

</p>
<ul>
  <li> прописные буквы латинского алфавита;
  </li>
<li> строчные буквы латинского алфавита;
  </li>
<li> арабские цифры;
  </li>
<li> разделители: <span class="sint">, . ; : ? ! ' " | / \ ~ _ ^ ( ) { } [ ] &lt; &gt; # % &amp; - = + *</span>
</li>
</ul>

<p>
Остальные символы могут быть использованы только в символьных строках, символьных константах и комментариях. Язык <span>C++</span> различает большие и маленькие буквы, таким образом, <i>name</i> и <i>Name</i> – <b>разные идентификаторы</b>.

</p></section><section id="l1_2">

<h1> 2. Литералы </h1>

<p>
Литералы в языке <span>C++</span> могут быть целые, вещественные, символьные и строковые.

</p>
<ul>
  <li> Целые:
  <ul>
    <li> десятичные: <span class="sint">10</span>, <span class="sint">132</span>, <span class="sint">-32179</span>;
    </li>
<li> восьмеричные (предваряются символом «0»): <span class="sint">010</span>, <span class="sint">0204</span>, <span class="sint">-076663</span>;
    </li>
<li> шестнадцатеричные (предваряются символами «0х»): <span class="sint">0хА</span>, <span class="sint">0x84</span>, <span class="sint">0x7db3</span>.
  </li>
</ul>
  </li>
<li> Вещественные: <span class="sint">15.75</span>, <span class="sint">1.575e1</span>, <span class="sint">.75</span>, <span class="sint">-.125</span>
  </li>
<li> Символьные: <span class="sint">'a'</span>, <span class="sint">'e'</span>, <span class="sint">'.'</span>, <span class="sint">'?'</span>, <span class="sint">'2'</span>.
  </li>
<li> Строковые: <span class="sint">"строка"</span>.
</li>
</ul>

</section><section id="l1_3">

<h1> 3. Комментарии </h1>


<p>
Комментарий – это последовательность символов, которая игнорируется компилятором языка 
<span>C++</span>. Комментарий имеет следующий вид: <span class="sint">/*&lt;символы&gt;*/</span>. Комментарии могут занимать несколько 
строк, но не могут быть вложенными. Кроме того, часть строки, следующая за символами <span class="sint">//</span>, также 
рассматривается как комментарий.

</p>
<p>
Разумное использование комментариев (и согласованное употребление отступов) может сделать чтение и понимание программы более приятным занятием. При неправильном использовании комментариев читабельность программы может, напротив, серьезно пострадать. Компилятор не понимает смысл комментариев, поэтому не существует способа проверить, что комментарий:

</p>
<ol>
  <li> содержателен;
  </li>
<li> имеет какое-то отношение к программе;
  </li>
<li> не устарел.
</li>
</ol>

<p>
Удачно подобранный и написанный набор комментариев является существенной частью хорошей программы. Написание «правильных» комментариев может оказаться не менее сложной задачей, чем написание самой программы.

</p></section><section id="l1_4">

<h1> 4. Типы данных языка C++ </h1>


<table>
<thead>
  <tr>
    <th> Имя
    </th>
<th> Размер
    </th>
<th> Представляемые значения
    </th>
<th> Диапазон

</th>
</tr>
</thead>
<tbody>
  <tr>
    <td> bool 
    </td>
<td> 1 байт 
    </td>
<td> логические 
    </td>
<td> false, true 
  
  </td>
</tr>
<tr>
    <td> (signed) char 
    </td>
<td> 1 байт 
    </td>
<td> символы  целые числа 
    </td>
<td>    от –128 до 127 
  
  </td>
</tr>
<tr>
    <td> wchar_t 
    </td>
<td> 2 байта 
    </td>
<td> символы Unicode 
    </td>
<td> от 0 до 65535
  
  </td>
</tr>
<tr>
    <td> (signed) short int 
    </td>
<td> 2 байта 
    </td>
<td> целые числа 
    </td>
<td> от -32768 до 32767 
  
  </td>
</tr>
<tr>
    <td> (signed) int 
    </td>
<td> зависит от реализации  (в последних компиляторах обычно 4 байта) 
    </td>
<td> целые числа 
    </td>
<td>  
  
   </td>
</tr>
<tr>
    <td> (signed) long int 
    </td>
<td> 4 байта 
    </td>
<td> целые числа 
    </td>
<td> от -2147483648 до 2147483647 
  
   </td>
</tr>
<tr>
    <td> (signed) long long int  (signed) __int64 (MS) 
    </td>
<td> 8 байт
    </td>
<td> целые числа 
    </td>
<td> от –9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 
  
  </td>
</tr>
<tr>
    <td> unsigned char 
    </td>
<td> 1 байт 
    </td>
<td> символы  целые числа 
    </td>
<td>    от 0 до 255
  
  </td>
</tr>
<tr>
    <td> unsigned short int 
    </td>
<td> 2 байта 
    </td>
<td> целые числа 
    </td>
<td> 0 до 65535 
  
  </td>
</tr>
<tr>
    <td> unsigned int 
    </td>
<td> зависит от реализации  (в последних компиляторах обычно 4 байта)
    </td>
<td> целые числа 
    </td>
<td>   
  
  </td>
</tr>
<tr>
    <td> unsigned long int 
    </td>
<td> 4 байта 
    </td>
<td> целые числа 
    </td>
<td> от 0 до 4294967295 
  
   </td>
</tr>
<tr>
    <td> (unsigned) long long int  (unsigned) __int64 (MS) 
    </td>
<td> 8 байт
    </td>
<td> целые числа 
    </td>
<td> от 0 до 18,446,744,073,709,551,615 
  
  </td>
</tr>
<tr>
    <td> float 
    </td>
<td> 4 байта 
    </td>
<td> вещественные числа 
    </td>
<td> от 1.175494351e–38  до 3.402823466e+38 
  
  </td>
</tr>
<tr>
    <td> double 
    </td>
<td> 8 байт 
    </td>
<td> вещественные числа 
    </td>
<td> от 2.2250738585072014e–308  до 1.7976931348623158e+308 
  
  </td>
</tr>
<tr>
    <td> long double 
    </td>
<td> зависит от реализации 
    </td>
<td> вещественные числа 
    </td>
<td>  
  
</td>
</tr>
</tbody>
</table>


<p id="l1_void">
В языке C++ также существуют перечислимый тип – , который является подмножеством целого типа, и пустой тип – <span class="type">void</span>, который имеет специальное назначение. Он используется для объявления функций, которые не возвращают никакого значения, а также для объявления  на значение типа <span class="type">void</span>. Такие указатели могут быть преобразованы к указателям на любой другой тип.

</p>
<p>
В языке С++ можно объявлять  и так называемые .

</p>
<p>
В языке C++ <b>нет специальных типов для массивов и строк</b>, которые представляются массивом символов.

</p>
<p id="l1_logic">
В языке С не существовало логического типа. Логические значения представлялись данными целого типа, при этом значение 0 соответствовало логическому значению <i>ложь</i>, а <b>все остальные целые значения</b> соответствовали логическому значению <i>истина</i>. В языке <span>С++</span> сохранена данная логика. По определению, <i>true</i> имеет значение 1 при преобразовании к целому типу, а <i>false</i> – значение 0. И наоборот, целые можно неявно преобразовать в логические значения: при этом ненулевые целые преобразуются в <i>true</i>, а ноль – в <i>false</i>. В любом месте, где требуется логическое значение, может стоять целочисленное выражение. В арифметических и логических выражениях логические значения преобразуются в целые, операции выполняются над преобразованными величинами.


</p>
<p>Указатель можно неявно преобразовать в логическое значение, при этом ненулевой указатель принимает значение <i>true</i>, нулевой – <i>false</i>.


</p>
<p>Такой подход позволяет вместо логической и целочисленной переменных объявлять только целочисленную, при этом значение переменной, равное 0, говорит об отсутствии некоторого признака у объекта, а остальные значения говорят о его наличии, и при этом несут какую-либо дополнительную информацию.


</p>
<p id="l1_default">
При выполнении бинарных операций производятся <b>преобразования по умолчанию</b> для приведения операндов к одному и тому же типу, который потом используется как тип результата:
</p>
<ol>
  <li> если один из операндов имеет тип <i>long double</i>, другой тоже преобразуется в <i>long double</i>;
    <ul>
      <li> иначе, если один операнд имеет тип <i>double</i>, то второй операнд преобразуется к типу <i>double</i>;
      </li>
<li> иначе, если один операнд имеет тип <i>float</i>, то второй операнд преобразуется к типу <i>float</i>;
      </li>
<li> иначе над обоими операндами производится интегральное продвижение, а именно: значения типов <i>char</i>, <i>signed char</i>, <i>unsigned char</i>, <i>short int</i> и <i>unsigned short int</i> преобразуются в <i>int</i>, если <i>int</i> может представить все значения исходных типов, в противном случае они преобразуются в <i>unsigned int</i>; <i>bool</i> преобразуется в <i>int</i>.
    </li>
</ul>
  </li>
<li> затем если один операнд имеет тип <i>unsigned long</i>, то второй операнд преобразуется к типу <i>unsigned long</i>;
    <ul>
      <li> иначе, если один из операндов относится к типу <i>long int</i>, а другой к типу <i>unsigned int</i>, то если <i>long int</i> может представить все значений типа <i>unsigned int</i>, <i>unsigned int</i> преобразуется в <i>long int</i>, иначе оба операнда преобразуются в <i>unsigned long int</i>;
      </li>
<li> иначе, если один операнд имеет тип <i>long int</i>, то второй операнд преобразуется к типу <i>long int</i>;
      </li>
<li> иначе, если один операнд имеет тип <i>unsigned int</i>, то второй операнд преобразуется к типу <i>unsigned int</i>;
      </li>
<li> иначе оба операнда имеют тип <i>int</i>.
    </li>
</ul>
</li>
</ol>

<p>
В языке С++ нет операций преобразования между символом и кодом символа, т.к. в оперативной памяти символ и так храниться в виде его кода. Поэтому можно к переменной, хранящей символ, прибавить 1 и получить следующий символ.

</p></section><section id="l1_5">
<h1> 5. Операции языка C++ </h1>


<p>
Данная таблица описывает операции языка <span>C++</span>. Операции разделены на группы, расположенные в порядке убывания приоритета операций.


</p>
<table>
<thead>
  <tr>
    <th> Знак операции 
    </th>
<th> Наименование 
    </th>
<th> Ассоциативность 

</th>
</tr>
</thead>
<tbody>
  <tr>
    <td>  
    </td>
<td> Разрешение области видимости 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>          
        
        
        
        
        
  
    </td>
<td> Первичные  
       Постфиксный инкремент и декремент 
       Преобразование с проверкой во время компиляции 
       Преобразование с проверкой во время выполенения 
       Преобразование без проверки 
       Константное преобразование 
  
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>                  
         
         
        
        
        
  
    </td>
<td> Унарные  
       Префиксный инкремент и декремент 
       Вычисление размера 
       Приведение типа 
       Выделение памяти 
       Освобождение памяти 
  
    </td>
<td> Справа налево 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Выбор члена класса 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> *    /     
    </td>
<td> Мультипликативные 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> +    - 
    </td>
<td> Аддитивные 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Сдвиг 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> &lt;    &gt;    &lt;=    &gt;= 
    </td>
<td> Отношение 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> ==    != 
    </td>
<td> Отношение 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Поразрядное И 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Поразрядное исключающее ИЛИ 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Поразрядное ИЛИ 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> &amp;&amp; 
    </td>
<td> Логическое И 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> || 
    </td>
<td> Логическое ИЛИ 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> 
    </td>
<td> Условная операция 
    </td>
<td> Справа налево 

  </td>
</tr>
<tr>
    <td> 
    </td>
<td> Простое и составное присваивания 
    </td>
<td> Справа налево 

  </td>
</tr>
<tr>
    <td>  
    </td>
<td> Генерация исключения 
    </td>
<td> Слева направо 

  </td>
</tr>
<tr>
    <td> 
    </td>
<td> Операция последовательного вычисления 
    </td>
<td> Слева направо 

</td>
</tr>
</tbody>
</table>


<p>
</p>
<ul>
  <li id="l1_domain">
<b>::</b> – операция разрешения области видимости. При повторном объявлении имени во вложенном блоке или классе предыдущие объявления оказываются <i>скрытыми</i>. Однако скрытое имя члена класса можно использовать, квалифицировать его именем класса при помощи операции разрешения области видимости. Скрытое глобальное имя можно использовать, если квалифицировать его унарной операцией разрешения области видимости.
  </li>
<li id="l1_parentesi_tonde">
<b>( )</b> – выражение в скобках (используется для изменения порядка вычисления) или вызов функции.
  </li>
<li id="l1_parentesi_quadre">
<b>[ ]</b> – индексное выражение, используется для работы с .
  </li>
<li id="l1_scelta">
<b>.</b> и <b> -&gt;</b> – выбор элемента, используются при работе с ,  и .
  </li>
<li id="l1_conversioni">Операции <b>static_cast</b> (преобразование с проверкой во время компиляции), <b>dynamic_cast</b> (преобразование с проверкой во время выполнения), <b>reinterpret_cast</b> (преобразование без проверки), <b>const_cast</b> (константное преобразование) осуществляют различные <i>преобразования типов</i>. Они имеют следующий синтаксис: <i>операция&lt;новый тип&gt;(выражение)</i>. Угловые скобки являются элементом синтаксиса. Операция <b>static_cast</b> осуществляет преобразование родственных типов, например, указателя на один тип к указателю на другой тип из той же иерархии классов, целый тип в перечисление или тип с плавающей точкой в интегральный. Операция <b>reinterpret_cast</b> управляет преобразованиями между несвязанными типами, например, целых в указатели или указателей в другие (несвязанные) указатели. Такое различие позволяет компилятору осуществлять минимальную проверку типов при использовании <b>static_cast</b>, а программисту – легче обнаружить опасные преобразования, представляемые <b>reinterpret_cast</b>. Преобразование <b>dynamic_cast</b> выполняется и проверяется на этапе выполнения. Преобразование <b>const_cast</b> аннулирует действие модификатора .
  </li>
<li id="l1_meno">
<b>-</b> – унарный минус.
  </li>
<li id="l1_complemento">
<b>~</b> – обратный код (см. ).
  </li>
<li id="l1_negazione">
<b>!</b> – логическое отрицание.
  </li>
<li id="l1_valore">
<b>*</b> – косвенная адресация (см. ).
  </li>
<li id="l1_indirizzo">
<b>&amp;</b> – адресация (см. ).
  </li>
<li id="l1_inc_dec"> Операции <b>++</b> и <b>--</b> инкрементируют (увеличивают на 1) и декрементируют (уменьшают на 1) свой операнд. Операнд должен иметь целый, вещественный тип или быть указателем. Операции инкремента и декремента могут записываться как перед своим операндом (префиксная форма записи), так и после него (постфиксная форма записи). При префиксной форме записи операнд сначала инкрементируется или декрементируется, а затем его новое значение участвует в дальнейшем вычислении выражения, содержащего данную операцию. При постфиксной форме записи операнд инкрементируется или декрементируется лишь после того, как его старое значение участвует в вычислении выражения. Таким образом, результатом операций инкремента и декремента является либо новое, либо старое значение операнда. Например, если переменная <var>i</var> = 0, то выражение <var>a</var>[++<var>i</var>] = 1 меняет элемент <var>a</var>[1], а выражение <var>a</var>[<var>i</var>++] = 1 меняет элемент <var>a</var>[0]. В обоих случая переменная <var>i</var> получает новое значение, равное 1.
  </li>
<li id="l1_sizeof">
<b>sizeof</b> – вычисление размера в байтах переменной или типа.
  </li>
<li id="l1_type_conv">
<b>Операция приведения типа</b> записывается следующим образом: (&lt;<i>новый тип</i>&gt;)&lt;<i>выражение</i>&gt;. Например, <span class="sint">(long int)n</span> приводит переменную <var>n</var> к типу <span class="type">long int</span>. При преобразовании типов надо помнить, что при преобразовании между знаковыми/беззнаковыми значениями и при преобразовании от типа с большей размерностью к типу с меньшей размерностью могут возникнуть ошибки. Более безопасным способом преобразования типов является использование операций <i>static_cast</i>, <i>dynamic_cast</i>, <i>reinterpret_cast</i> и <i>const_cast</i>.
  </li>
<li id="l1_resto">
<b>%</b> – остаток от деления.
  </li>
<li id="l1_condizionale"> В языке <span>C++</span> имеется одна тернарная операция – <b>условная операция</b>. Она имеет следующий синтаксис: &lt;<i>операнд 1</i>&gt; ? &lt;<i>операнд 2</i>&gt; : &lt;<i>операнд 3</i>&gt;. Если &lt;<i>операнд 1</i>&gt; имеет ненулевое значение, то вычисляется &lt;<i>операнд 2</i>&gt; и результатом условной операции является его значение. Если же &lt;<i>операнд 1</i>&gt; равен нулю, то вычисляется &lt;<i>операнд 3</i>&gt; и результатом является его значение. В любом случае вычисляется только один из операндов, &lt;<i>операнд 2</i>&gt; или &lt;<i>операнд 3</i>&gt;, но не оба.
  </li>
<li id="l1_semplice">
<b>Простое присваивание</b>. Операция простого присваивания обозначается знаком «=». Значение правого операнда присваивается левому операнду. Операция вырабатывает результат, который может быть далее использован в выражении. Результатом операции является присвоенное значение. Например, выражение <var>a</var> = <var>b</var> = <var>c</var> = 0 присваивает всем переменным значение 0, а в результате вычисления выражения <var>a</var> = (<var>b</var> = 3) + (<var>c</var> = 5) переменная <var>c</var> будет иметь значение 5, переменная <var>b</var> будет иметь значение 3, и переменная <var>a</var> будет иметь значение 8.
  </li>
<li id="l1_complesso">
<b>Составное присваивание</b>. Операция составного присваивания состоит из простой операции присваивания, скомбинированной с какой-либо другой бинарной операцией. При составном присваивании вначале выполняется действие, специфицированное бинарной операцией, а затем результат присваивается левому операнду. Оператор <var>n</var> += 5 эквивалентен оператору <var>n</var> = <var>n</var> + 5, но при этом первый оператор легче для понимания и выполняется быстрее.
  </li>
<li id="l1_calcolo_seq">
<b>Операция последовательного вычисления «,»</b> обычно используется для вычисления нескольких выражений в ситуациях, где по синтаксису допускается только одно выражение. Однако, запятая, разделяющая параметры функции, <i>не является</i> операцией последовательного вычисления.
</li>
</ul>

<p>
Порядок вычислений подвыражений внутри выражений не определён. В частности, не стоит предполагать, что выражения вычисляются слева направо.

</p>
<table>
  <tr>
    <td class="esempi">
<span class="chiavi">int</span> x = f(2) + g(3); </td>
    
    <td class="commenti">// Неизвестно, какая функция вызовется первой – <i>f()</i> или <i>g()</i> </td>
</tr>
</table>

<p>
При отсутствии ограничений на порядок вычислений можно сгенерировать более качественный код. Однако отсутствие ограничений на порядок вычислений может привести к неопределённым результатам.

</p>
<p id="l1_ordine">
Логические операции «И» и «ИЛИ»,  условная операция и операция последовательного вычисления гарантируют определенный <b>порядок вычисления своих операндов</b>. Условная операция вычисляет сначала свой первый операнд, а затем, в зависимости от его значения, либо второй, либо третий операнд. Логические операции также обеспечивают вычисление своих операндов слева направо, причём  логические операции вычисляют минимальное число операндов, необходимое для определения результата выражения. Таким образом, второй операнд выражения может вообще не вычисляться. Операция последовательного вычисления обеспечивает вычисление своих операндов по очереди, слева направо. Обратите внимание, что запятая в качестве указателя последовательности логически отличается от запятой, используемой в качестве разделителя параметров при вызове функций.

</p>
<table>
  <tr>
    <td class="esempi">f1(v[i], i++); f2((v[i], i++));</td>
    
    <td class="commenti">// Два параметра // Один параметр</td>
</tr>
</table>

<p>
Вызов функции <i>f1</i> осуществляется с двумя параметрами <i>v[i]</i> и <i>i++</i>, и порядок вычисления параметров не определён. Расчет на определённый порядок вычисления параметров является исключительно плохим стилем и приводит к непредсказуемому поведению программы. Вызов функции <i>f2</i> имеет один параметр – последовательность выражений, разделённых запятой. Порядок вычисления гарантирован, и вызов эквивалентен <i>f2(i++)</i>.

</p></section>