# encoding: windows-1251







<p>В этой лекции дается краткое представление о возможностях языка Python по обработке текстовой информации. Рассмотрены синтаксис и семантика регулярных выражений, а также некоторые вопросы использования Unicode.</p>
<p>Под обработкой текстов понимается анализ, преобразование, поиск, порождение текстовой информации. По большей части работа с естественными текстами не будет глубже, чем это возможно без систем искусственного интеллекта. Кроме того, здесь предполагается опустить рассмотрение обработки текстов посредством текстовых процессоров и редакторов, хотя некоторые из них (например, Cooledit) предоставляют возможность писать макрокоманды на Python.</p>
<p>Следует отметить, что для Python созданы также модули для работы с естественными языками, а также для лингвистических исследований. Хорошим учебным примером может служить nltk (the Natural Language Toolkit).</p>
<p>Стоит отметить проект PyParsing (сайт:http://pyparsing.sourceforge.net), с помощью которого можно организовать обработку текста по заданной грамматике.</p>
<p>Строки</p>
<p>Строки в языке Python являются типом данных, специально предназначенным для обработки текстовой информации. Строка может содержать произвольно длинный текст (ограниченный имеющейся памятью).</p>
<p>В новых версиях Python имеются два типа строк: обычные строки (последовательность байтов) и Unicode–строки (последовательность символов). В Unicode–строке каждый символ может занимать в памяти 2 или 4 байта, в зависимости от настроек периода компиляции. Четырехбайтовые знаки используются в основном для восточных языков.</p>
<p>Примечание:</p>
<p>В языке и стандартной библиотеке за некоторыми исключениями строки и Unicode–строки взаимозаменяемы, в собственных приложениях для совместимости с обоими видами строк следует избегать проверок на тип. Если это необходимо, можно проверять принадлежность базовому (для строк и Unicode–строк) типу с помощью isinstance(s, basestring).</p>
<p>При использовании Unicode–строк, следует мысленно принять точку зрения, относительно которой именно Unicode–представление является главным, а все остальные кодировки — лишь частные случаи представления текста, которые не могут передать всех символов. Без такой установки будет непонятно, почему преобразование из восьмибитной кодировки называется decode (декодирование). Для внешнего представления можно с успехом использовать кодировку UTF–8, хотя, конечно, это зависит от решаемых задач.</p>
<p>Кодировка Python–программы</p>
<p>Для того чтобы Unicode–литералы в Python–программе воспринимались интерпретатором правильно, необходимо указать кодировку в начале программы, записав в первой или второй строке примерно следующее (для Unix/Linux):</p>
<p>Листинг</p>
<p># -*- coding: koi8–r -*-</p>
<p>или (под Windows):</p>
<p>Листинг</p>
<p># -*- coding: cp1251 -*-</p>
<p>Могут быть и другие варианты:</p>
<p>Листинг</p>
<p># -*- coding: latin–1 -*-# -*- coding: utf–8 -*-# -*- coding: mac–cyrillic -*-# -*- coding: iso8859–5 -*-</p>
<p>Полный перечень кодировок (и их псевдонимов):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import encodings.aliases</p>
<p>&gt;&gt;&gt; print encodings.aliases.aliases</p>
<p>{'iso_ir_6': 'ascii', 'maccyrillic': 'mac_cyrillic',</p>
<p>'iso_celtic': 'iso8859_14', 'ebcdic_cp_wt': 'cp037',</p>
<p>'ibm500': 'cp500', …</p>
<p>Если кодировка не указана, то считается, что используется us–ascii. При этом интерпретатор Python будет выдавать предупреждения при запуске модуля:</p>
<p>Листинг</p>
<p>sys:1: DeprecationWarning: Non–ASCII character '\xf0' in file example.py</p>
<p>on line 2, but no encoding declared;</p>
<p>see http://www.python.org/peps/pep–0263.html for details</p>
<p>Строковые литералы</p>
<p>Строки можно задать в программе с помощью строковых литералов. Литералы записываются с использованием апострофов ', кавычек " или этих же символов, взятых трижды. Внутри литералов обратная косая черта имеет специальное значение. Она служит для ввода специальных символов и для указания символов через коды. Если перед строковым литералом поставлено r, обратная косая черта не имеет специального значения (r от английского слова raw, строка задается «как есть»). Unicode–литералы задаются с префиксом u. Вот несколько примеров:</p>
<p>Листинг</p>
<p>s1 = «строка 1»</p>
<p>s2 = r'\1\2'</p>
<p>s3 = ""«apple\ntree»"" # \n — символ перевода строки</p>
<p>s4 = ""«apple</p>
<p>tree»"" # строка в утроенных кавычках может иметь внутри переводы строк</p>
<p>s5 = '\x73\65'</p>
<p>u1 = u»Unicode literal»</p>
<p>u2 = u'\u0410\u0434\u0440\u0435\u0441'</p>
<p>Примечание:</p>
<p>Обратная косая черта не должна быть последним символом в литерале, то есть, «str\" вызовет синтаксическую ошибку.</p>
<p>Указание кодировки позволяет применять в Unicode–литералах указанную в начале программы кодировку. Если кодировка не указана, можно пользоваться только кодами символов, заданными через обратную косую черту.</p>
<p>Операции над строками</p>
<p>К операциям над строками, которые имеют специальную синтаксическую поддержку в языке, относятся, в частности конкатенация (склеивание) строк, повторение строки, форматирование:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print «A» + «B», «A»*5, "%s» % «A»</p>
<p>AB AAAAA A</p>
<p>В операции форматирования левый операнд является строкой формата, а правый может быть либо кортежем, либо словарем, либо некоторым значением другого типа:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print "%i» % 234</p>
<p>234</p>
<p>&gt;&gt;&gt; print "%i %s %3.2f» % (5, «ABC», 23.45678)</p>
<p>5 ABC 23.46</p>
<p>&gt;&gt;&gt; a = 123</p>
<p>&gt;&gt;&gt; b = [1, 2, 3]</p>
<p>&gt;&gt;&gt; print "%(a)i: %(b)s» % vars()</p>
<p>123: [1, 2, 3]</p>
<p>Операция форматирования</p>
<p>В строке формата кроме текста могут употребляться спецификации, регламентирующие формат выводимого значения. Спецификация имеет синтаксис</p>
<p>Листинг</p>
<p>"%" [ключ][флаг*][шир][.точность][длина_типа]спецификатор</p>
<p>ключ: «(" символ за исключением круглых скобок* ")»</p>
<p>флаг: «+» | «-» | пробел | "#" | «0»</p>
<p>шир: («1» … «9»)(«0» … «9»)* | "*"</p>
<p>точность: («1» … «9»)* | "*"</p>
<p>длина_типа: «a» … «z» | «A» … «Z»</p>
<p>спецификатор: «a» … «z» | «A» … «Z» | "%"</p>
<p>Где символы обозначают следующее:</p>
<p>Листинг</p>
<p>ключ</p>
<p>Ключ из словаря.</p>
<p>Листинг</p>
<p>флаги</p>
<p>Дополнительные свойства преобразования.</p>
<p>Листинг</p>
<p>шир</p>
<p>Минимальная ширина поля.</p>
<p>Листинг</p>
<p>точность</p>
<p>Точность (для чисел с плавающей запятой).</p>
<p>Листинг</p>
<p>длина_типа</p>
<p>Модификатор типа.</p>
<p>Листинг</p>
<p>спецификатор</p>
<p>Тип представления выводимого объекта.</p>
<p>В следующей таблице приведены некоторые наиболее употребительные значения для спецификации форматирования.</p>
<p>Символ Где применяется Что указывает</p>
<p>0 флаг Заполнение нулями слева</p>
<p>— флаг Выравнивание по левому краю</p>
<p>+ флаг Обязательный вывод знака числа</p>
<p>пробел флаг Использовать пробел на месте знака числа</p>
<p>d, i спецификатор Знаковое целое</p>
<p>u спецификатор Беззнаковое целое</p>
<p>o спецификатор Восьмеричное беззнаковое целое</p>
<p>x, X спецификатор Шестнадцатеричное беззнаковое целое (со строчными или прописными латинскими буквами)</p>
<p>e, E спецификатор Число с плавающей запятой в формате с экспонентой</p>
<p>f, F спецификатор Число с плавающей запятой</p>
<p>g, G спецификатор Число с плавающей точкой в более коротком написании (автоматически выбирается e или f)</p>
<p>с спецификатор Одиночный символ (целое число или односимвольная строка)</p>
<p>r спецификатор Любой объект, приведенный к строке функцией repr()</p>
<p>s спецификатор Любой объект, приведенный к строке функцией str()</p>
<p>% спецификатор Знак процента. Для задания одиночного процента необходимо записать %%</p>
<p>Индексы и срезы</p>
<p>Следует напомнить, что строки являются неизменчивыми последовательностями, поэтому к ним можно применять операции взятия элемента по индексу и срезы:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = «транспорт»</p>
<p>&gt;&gt;&gt; print s[0], s[-1]</p>
<p>т т</p>
<p>&gt;&gt;&gt; print s[-4:]</p>
<p>порт</p>
<p>&gt;&gt;&gt; print s[:5]</p>
<p>транс</p>
<p>&gt;&gt;&gt; print s[4:8]</p>
<p>спор</p>
<p>Примечание:</p>
<p>При выделении среза нумеруются не символы строки, а промежутки между ними.</p>
<p>Модуль string</p>
<p>До того как у строк появились методы, для операций над строками применялся модуль string. Приведенный пример демонстрирует, как вместо функции из string использовать метод (кстати, последнее более эффективно):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import string</p>
<p>&gt;&gt;&gt; s = «one,two,three»</p>
<p>&gt;&gt;&gt; print string.split(s, ",")</p>
<p>['one', 'two', 'three']</p>
<p>&gt;&gt;&gt; print s.split(",")</p>
<p>['one', 'two', 'three']</p>
<p>В версии Python 3.0 функции, которые доступны через методы, более не будут дублироваться в модуле string.</p>
<p>В Python 2.4 появилась альтернатива использованию операции форматирования: класс Template. Пример:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import string</p>
<p>&gt;&gt;&gt; tpl = string.Template("$a + $b = ${c}»)</p>
<p>&gt;&gt;&gt; a = 2</p>
<p>&gt;&gt;&gt; b = 3</p>
<p>&gt;&gt;&gt; c = a + b</p>
<p>&gt;&gt;&gt; print tpl.substitute(vars())</p>
<p>2 + 3 = 5</p>
<p>&gt;&gt;&gt; del c # удаляется имя c</p>
<p>&gt;&gt;&gt; print tpl.safe_substitute(vars())</p>
<p>2 + 3 = $c</p>
<p>&gt;&gt;&gt; print tpl.substitute(vars(), c=a+b)</p>
<p>2 + 3 = 5</p>
<p>&gt;&gt;&gt; print tpl.substitute(vars())</p>
<p>Traceback (most recent call last):</p>
<p>File "/home/rnd/tmp/Python–2.4b2/Lib/string.py», line 172, in substitute</p>
<p>return self.pattern.sub(convert, self.template)</p>
<p>File "/home/rnd/tmp/Python–2.4b2/Lib/string.py», line 162, in convert</p>
<p>val = mapping[named]</p>
<p>KeyError: 'c'</p>
<p>Объект–шаблон имеет два основных метода: substitute() и safe_substitute(). Значения для подстановки в шаблон берутся из словаря (vars() содержит словарь со значениями переменных) или из именованных фактических параметров. Если есть неоднозначность в задании ключа, можно использовать фигурные скобки при написании ключа в шаблоне.</p>
<p>Методы строк</p>
<p>В таблице ниже приведены некоторые наиболее употребительные методы объектов–строк и unicode–объектов.</p>
<p>Метод Описание</p>
<p>center(w) Центрирует строку в поле длины w</p>
<p>count(sub) Число вхождений строки sub в строке</p>
<p>encode([enc[, errors]]) Возвращает строку в кодировке enc. Параметр errors может принимать значения «strict» (по умолчанию), «ignore», «replace» или «xmlcharrefreplace»</p>
<p>endswith(suffix) Оканчивается ли строка на suffix</p>
<p>expandtabs([tabsize]) Заменяет символы табуляции на пробелы. По умолчанию tabsize=8</p>
<p>find(sub [,start [,end]]) Возвращает наименьший индекс, с которого начинается вхождение подстроки sub в строку. Параметры start и end ограничивают поиск окном start:end, но возвращаемый индекс соответствует исходной строке. Если подстрока не найдена, возвращается–1</p>
<p>index(sub[, start[, end]]) Аналогично find(), но возбуждает исключение ValueError в случае неудачи</p>
<p>alnum() Возвращает True, если строка содержит только буквы и цифры и имеет ненулевую длину. Иначе — False</p>
<p>isalpha() Возвращает True, если строка содержит только буквы и длина ненулевая</p>
<p>isdecimal() Возвращает True, если строка содержит только десятичные знаки (только для строк Unicode) и длина ненулевая</p>
<p>isdigit() Возвращает True, если содержит только цифры и длина ненулевая</p>
<p>islower() Возвращает True, если все буквы строчные (и их более одной), иначе — False</p>
<p>isnumeric() Возвращает True, если в строке только числовые знаки (только для Unicode)</p>
<p>isspace() Возвращает True, если строка состоит только из пробельных символов. Внимание! Для пустой строки возвращается False</p>
<p>join(seq) Соединение строк из последовательности seq через разделитель, заданный строкой</p>
<p>lower() Приводит строку к нижнему регистру букв</p>
<p>lstrip() Удаляет пробельные символы слева</p>
<p>replace(old, new[, n]) Возвращает копию строки, в которой подстроки old заменены new. Если задан параметр n, то заменяются только первые n вхождений</p>
<p>rstrip() Удаляет пробельные символы справа</p>
<p>split([sep[, n]]) Возвращает список подстрок, получающихся разбиением строки a разделителем sep. Параметр n определяет максимальное количество разбиений (слева)</p>
<p>startswith(prefix) Начинается ли строка с подстроки prefix</p>
<p>strip() Удаляет пробельные символы в начале и в конце строки</p>
<p>translate(table) Производит преобразование с помощью таблицы перекодировки table, содержащей словарь для перевода кодов в коды (или в None, чтобы удалить символ). Для Unicode–строк</p>
<p>translate(table[, dc]) То же, но для обычных строк. Вместо словаря — строка перекодировки на 256 символов, которую можно сформировать с помощью функции string.maketrans(). Необязательный параметр dc задает строку с символами, которые необходимо удалить</p>
<p>upper() Переводит буквы строки в верхний регистр</p>
<p>В следующем примере применяются методы split() и join() для разбиения строки в список (по разделителям) и обратное объединение списка строк в строку</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = «This is an example.»</p>
<p>&gt;&gt;&gt; lst = s.split(" ")</p>
<p>&gt;&gt;&gt; print lst</p>
<p>['This', 'is', 'an', 'example.']</p>
<p>&gt;&gt;&gt; s2 = "\n».join(lst)</p>
<p>&gt;&gt;&gt; print s2</p>
<p>This</p>
<p>is</p>
<p>an</p>
<p>example.</p>
<p>Для проверки того, оканчивается ли строка на определенное сочетание букв, можно применить метод endswith():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; filenames = [«file.txt», «image.jpg», «str.txt»]</p>
<p>&gt;&gt;&gt; for fn in filenames:</p>
<p>… if fn.lower().endswith(".txt»):</p>
<p>… print fn</p>
<p>…</p>
<p>file.txt</p>
<p>str.txt</p>
<p>Поиск в строке можно осуществить с помощью метода find(). Следующая программа выводит все функции, определенные в модуле оператором def:</p>
<p>Листинг</p>
<p>import string</p>
<p>text = open(string.__file__[: — 1]).read()</p>
<p>start = 0</p>
<p>while 1:</p>
<p>found = text.find(«def ", start)</p>
<p>if found == -1:</p>
<p>break</p>
<p>print text[found:found + 60].split(«(")[0]</p>
<p>start = found + 1</p>
<p>Важным для преобразования текстовой информации является метод replace(), который рассматривается ниже:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a = «Это текст , в котором встречаются запятые , поставленные не так.»</p>
<p>&gt;&gt;&gt; b = a.replace(" ,", ",")</p>
<p>&gt;&gt;&gt; print b</p>
<p>Это текст, в котором встречаются запятые, поставленные не так.</p>
<p>Рекомендации по эффективности</p>
<p>При работе с очень длинными строками или большим количеством строк, применяемые операции могут по–разному влиять на быстродействие программы.</p>
<p>Например, не рекомендуется многократно использовать операцию конкатенации для склеивания большого количества строк в одну. Лучше накапливать строки в списке, а затем с помощью join() собирать в одну строку:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; a = ""</p>
<p>&gt;&gt;&gt; for i in xrange(1000):</p>
<p>… a += str(i) # неэффективно!</p>
<p>…</p>
<p>&gt;&gt;&gt; a = "".join([str(i) for i in xrange(1000)]) # более эффективно</p>
<p>Конечно, если строка затем обрабатывается, можно применять итераторы, которые позволят свести использование памяти к минимуму.</p>
<p>Модуль StringIO</p>
<p>В некоторых случаях желательно работать со строкой как с файлом. Модуль StringIO как раз дает такую возможность.</p>
<p>Открытие «файла» производится вызовом StringIO(). При вызове без аргумента — создается новый «файл», при задании строки в качестве аргумента — «файл» открывается для чтения:</p>
<p>Листинг</p>
<p>import StringIO</p>
<p>my_string = «1234567890»</p>
<p>f1 = StringIO.StringIO()</p>
<p>f2 = StringIO.StringIO(my_string)</p>
<p>Далее с файлами f1 и f2 можно работать как с обычными файловыми объектами.</p>
<p>Для получения содержимого такого файла в виде строки применяется метод getvalue():</p>
<p>Листинг</p>
<p>f1.getvalue()</p>
<p>Противоположный вариант (представление файла на диске в виде строки) можно реализовать на платформах Unix и Windows с использованием модуля mmap. Здесь этот модуль рассматриваться не будет.</p>
<p>Модуль difflib</p>
<p>Для приблизительного сравнения двух строк в стандартной библиотеке предусмотрен модуль difflib.</p>
<p>Функция difflib.get_close_matches() позволяет выделить n близких строк к заданной строке:</p>
<p>Листинг</p>
<p>get_close_matches(word, possibilities, n=3, cutoff=0.6)</p>
<p>где</p>
<p>Листинг</p>
<p>word</p>
<p>Строка, к которой ищутся близкие строки.</p>
<p>Листинг</p>
<p>possibilities</p>
<p>Список возможных вариантов.</p>
<p>Листинг</p>
<p>n</p>
<p>Требуемое количество ближайших строк.</p>
<p>Листинг</p>
<p>cutoff</p>
<p>Коэффициент (из диапазона [0, 1]) необходимого уровня совпадения строк. Строки, которые при сравнении с word дают меньшее значение, игнорируются.</p>
<p>Следующий пример показывает функцию difflib.get_close_matches() в действии:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import unicodedata</p>
<p>&gt;&gt;&gt; names = [unicodedata.name(unicode(chr(i))) for i in range(40, 127)]</p>
<p>&gt;&gt;&gt; print difflib.get_close_matches(«LEFT BRACKET», names)</p>
<p>['LEFT CURLY BRACKET', 'LEFT SQUARE BRACKET']</p>
<p>В списке names — названия Unicode–символов с ASCII–кодами от 40 до 127.</p>
<p>Регулярные выражения</p>
<p>Рассмотренных стандартных возможностей для работы с текстом достаточно далеко не всегда. Например, в методах find() и replace() задается всего одна строка. В реальных задачах такая однозначность встречается довольно редко, чаще требуется найти или заменить строки, отвечающие некоторому шаблону.</p>
<p>Регулярные выражения (regular expressions) описывают множество строк, используя специальный язык, который сейчас и будет рассмотрен. (Строка, в которой задано регулярное выражение, будет называться шаблоном.)</p>
<p>Для работы с регулярными выражениями в Python используется модуль re. В следующем примере регулярное выражение помогает выделить из текста все числа:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import re</p>
<p>&gt;&gt;&gt; pattern = r»[0–9]+»</p>
<p>&gt;&gt;&gt; number_re = re.compile(pattern)</p>
<p>&gt;&gt;&gt; number_re.findall(«122 234 65435»)</p>
<p>['122', '234', '65435']</p>
<p>В этом примере шаблон pattern описывает множество строк, которые состоят из одного или более символов из набора «0», «1» , …, «9» . Функция re.compile() компилирует шаблон в специальный Regex–объект, который имеет несколько методов, в том числе метод findall() для получения списка всех непересекающихся вхождений строк, удовлетворяющих шаблону, в заданную строку.</p>
<p>То же самое можно было сделать и так:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import re</p>
<p>&gt;&gt;&gt; re.findall(r»[0–9]+», «122 234 65435»)</p>
<p>['122', '234', '65435']</p>
<p>Предварительная компиляция шаблона предпочтительнее при его частом использовании, особенно внутри цикла.</p>
<p>Примечание:</p>
<p>Следует заметить, что для задания шаблона использована необработанная строка. В данном примере она не требовалась, но в общем случае лучше записывать строковые литералы именно так, чтобы исключить влияние специальных последовательностей, записываемых через обратную косую черту.</p>
<p>Синтаксис регулярного выражения</p>
<p>Синтаксис регулярных выражений в Python почти такой же, как в Perl, grep и некоторых других инструментах. Часть символов (в основном буквы и цифры) обозначают сами себя. Строка удовлетворяет (соответствует) шаблону, если она входит во множество строк, которые этот шаблон описывает.</p>
<p>Здесь стоит также отметить, что различные операции используют шаблон по–разному. Так, search() ищет первое вхождение строки, удовлетворяющей шаблону, в заданной строке, а match() требует, чтобы строка удовлетворяла шаблону с самого начала.</p>
<p>Символы, имеющие специальное значение в записи регулярных выражений:</p>
<p>Символ Что обозначает в регулярном выражении</p>
<p>".» Любой символ</p>
<p>"^" Начало строки</p>
<p>"$" Конец строки</p>
<p>"*" Повторение фрагмента нуль или более раз (жадное)</p>
<p>«+» Повторение фрагмента один или более раз (жадное)</p>
<p>"?» Предыдущий фрагмент либо присутствует, либо отсутствует</p>
<p>«{m,n}» Повторение предыдущего фрагмента от m до n раз включительно (жадное)</p>
<p>«[…]» Любой символ из набора в скобках. Можно задавать диапазоны символов с идущими подряд кодами, например: a–z</p>
<p>«[^…]» Любой символ не из набора в скобках</p>
<p>"\" Обратная косая черта отменяет специальное значение следующего за ней символа</p>
<p>"|" Фрагмент справа или фрагмент слева</p>
<p>"*?» Повторение фрагмента нуль или более раз (не жадное)</p>
<p>«+?» Повторение фрагмента один или более раз (не жадное)</p>
<p>«{m,n}?» Повторение предыдущего фрагмента от m до n раз включительно (не жадное)</p>
<p>Если A и B — регулярные выражения, то их конкатенация AB является новым регулярным выражением, причем конкатенация строк a и b будет удовлетворять AB, если a удовлетворяет A и b удовлетворяет B. Можно считать, что конкатенация — основной способ составления регулярных выражений.</p>
<p>Скобки, описанные ниже, применяются для задания приоритетов и выделения групп (фрагментов текста, которые потом можно получить по номеру или из словаря, и даже сослаться в том же регулярном выражении).</p>
<p>Алгоритм, который сопоставляет строки с регулярным выражением, проверяет соответствие того или иного фрагмента строки регулярному выражению. Например, строка «a» соответствует регулярному выражению «[a–z]», строка «fruit» соответствует «fruit|vegetable», а вот строка «apple» не соответствует шаблону «pineapple».</p>
<p>В таблице ниже вместо регвыр может быть записано регулярное выражение, вместо имя — идентификатор, а флаги будут рассмотрены ниже.</p>
<p>Обозначение Описание</p>
<p>«(регвыр)» Обособляет регулярное выражение в скобках и выделяет группу</p>
<p>«(?:регвыр)» Обособляет регулярное выражение в скобках без выделения группы</p>
<p>«(?=регвыр)» Взгляд вперед: строка должна соответствовать заданному регулярному выражению, но дальнейшее сопоставление с шаблоном начнется с того же места</p>
<p>«(?!регвыр)» То же, но с отрицанием соответствия</p>
<p>«(?&lt;=регвыр)» Взгляд назад: строка должна соответствовать, если до этого момента соответствует регулярному выражению. Не занимает места в строке, к которой применяется шаблон. Параметр регвыр должен быть фиксированной длины (то есть, без «+» и "*")</p>
<p>«(?&lt;!регвыр)» То же, но с отрицанием соответствия</p>
<p>«(?P&lt;имя&gt;регвыр)» Выделяет именованную группу с именем имя</p>
<p>«(?P=имя)» Точно соответствует выделенной ранее именованной группе с именем имя</p>
<p>«(?#регвыр)» Комментарий (игнорируется)</p>
<p>«(?(имя)рв1|рв2)» Если группа с номером или именем имя оказалась определена, результатом будет сопоставление с рв1, иначе — c рв2. Часть |рв2 может отсутствовать</p>
<p>«(?флаг)» Задает флаг для всего данного регулярного выражения. Флаги необходимо задавать в начале шаблона</p>
<p>В таблице ниже описаны специальные последовательности, использующие обратную косую черту:</p>
<p>Последовательность Чему соответствует</p>
<p>"\1» — "\9» Группа с указанным номером. Группы нумеруются, начиная с 1</p>
<p>"\A» Промежуток перед началом всей строки (почти аналогично "^")</p>
<p>"\Z» Промежуток перед концом всей строки (почти аналогично "$")</p>
<p>"\b» Промежуток между символами перед словом или после него</p>
<p>"\B» Наоборот, не соответствует промежутку между символами на границе слова</p>
<p>"\d» Цифра. Аналогично «[0–9]»</p>
<p>"\s» Любой пробельный символ. Аналогично «[\t\n\r\f\v]»</p>
<p>"\S» Любой непробельный символ. Аналогично «[^\t\n\r\f\v]»</p>
<p>"\w» Любая цифра или буква (зависит от флага LOCALE)</p>
<p>"\W» Любой символ, не являющийся цифрой или буквой (зависит от флага LOCALE)</p>
<p>Флаги, используемые с регулярными выражениями:</p>
<p>Листинг</p>
<p>«(?i)», re.I, re.IGNORECASE</p>
<p>Сопоставление проводится без учета регистра букв.</p>
<p>Листинг</p>
<p>«(?L)», re.L, re.LOCALE</p>
<p>Влияет на определение буквы в "\w», "\W», "\b», "\B» в зависимости от текущей культурной среды (locale).</p>
<p>Листинг</p>
<p>«(?m)», re.M, re.MULTILINE</p>
<p>Если этот флаг задан, "^" и "$" соответствуют началу и концу любой строки.</p>
<p>Листинг</p>
<p>«(?s)», re.S, re.DOTALL</p>
<p>Если задан, ".» соответствует также и символу конца строки "\n».</p>
<p>Листинг</p>
<p>«(?x)», re.X, re.VERBOSE</p>
<p>Если задан, пробельные символы, не экранированные в шаблоне обратной косой чертой, являются незначащими, а все, что расположено после символа "#", — комментарии. Позволяет записывать регулярное выражение в несколько строк для улучшения его читаемости и записи комментариев.</p>
<p>Листинг</p>
<p>«(?u)», re.U, re.UNICODE</p>
<p>В шаблоне и в строке использован Unicode.</p>
<p>Методы объекта–шаблона</p>
<p>В результате успешной компиляции шаблона функцией re.compile() получается шаблон–объект (он именуется SRE_Pattern), который имеет несколько методов, некоторые из них будут рассмотрены. Как обычно, подробности и информация о дополнительных аргументах — в документации по Python.</p>
<p>Листинг</p>
<p>match(s)</p>
<p>Сопоставляет строку s с шаблоном, возвращая в случае удачного сопоставления объект с результатом сравнения (объект SRE_Match). В случае неудачи возвращает None. Сопоставление начинается от начала строки.</p>
<p>Листинг</p>
<p>search(s)</p>
<p>Аналогичен match(s), но ищет подходящую подстроку по всей строке s.</p>
<p>Листинг</p>
<p>split(s[, maxsplit=0])</p>
<p>Разбивает строку на подстроки, разделенные подстроками, заданными шаблоном. Если в шаблоне выделены группы, они попадут в результирующий список, перемежаясь с подстроками между разделителями. Если указан maxsplit, будет произведено не более maxsplit разбиений.</p>
<p>Листинг</p>
<p>findall(s)</p>
<p>Ищет все неперекрывающиеся подстроки s, удовлетворяющие шаблону.</p>
<p>Листинг</p>
<p>finditer(s)</p>
<p>Возвращает итератор по объектам с результатами сравнения для всех неперекрывающихся подстрок, удовлетворяющих шаблону.</p>
<p>Листинг</p>
<p>sub(repl, s)</p>
<p>Заменяет в строке s все (или только count, если он задан) вхождения неперекрывающихся подстрок, удовлетворяющих шаблону, на строку, заданную с помощью repl. В качестве replможет выступать строка или функция. Возвращает строку с выполненными заменами. В первом случае строка repl подставляется не просто так, а интерпретируется с заменой вхождений "\номер» на группу с соответствующим номером и вхождений "\g&lt;имя&gt;" на группу с номером или именем имя. В случае, когда repl — функция, ей передается объект с результатом каждого успешного сопоставления, а из нее возвращается строка для замены.</p>
<p>Листинг</p>
<p>subn(repl, s)</p>
<p>Аналогичен sub(), но возвращает кортеж из строки с выполненными заменами и числа замен.</p>
<p>В следующем примере строка разбивается на подстроки по заданному шаблону:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import re</p>
<p>&gt;&gt;&gt; delim_re = re.compile(r»[:,;]»)</p>
<p>&gt;&gt;&gt; text = «This,is;example»</p>
<p>&gt;&gt;&gt; print delim_re.split(text)</p>
<p>['This', 'is', 'example']</p>
<p>А теперь можно узнать, чем именно были разбиты строки:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; delim_re = re.compile(r»([:,;])»)</p>
<p>&gt;&gt;&gt; print delim_re.split(text)</p>
<p>['This', ',', 'is', ';', 'example']</p>
<p>Примеры шаблонов</p>
<p>Владение регулярными выражениями может существенно ускорить построение алгоритмов для обработки данных. Лучше всего познакомиться с шаблонами на конкретных примерах:</p>
<p>Листинг</p>
<p>r»\b\w+\b»</p>
<p>Соответствует слову из букв и знаков подчеркивания.</p>
<p>Листинг</p>
<p>r»[+-]?\d+»</p>
<p>Соответствует целому числу. Возможно, со знаком.</p>
<p>Листинг</p>
<p>r»\([+-]?\d+\)»</p>
<p>Число, стоящее в скобках. Скобки используются в самих регулярных выражениях, поэтому они экранируются "\".</p>
<p>Листинг</p>
<p>r»[a–cA–C]{2}»</p>
<p>Соответствует строке из двух букв «a», «b» или «c». Например, «Ac», «CC», «bc».</p>
<p>Листинг</p>
<p>r»aa|bb|cc|AA|BB|CC»</p>
<p>Строка из двух одинаковых букв.</p>
<p>Листинг</p>
<p>r»([a–cA–C])\1»</p>
<p>Строка из двух одинаковых букв, но шаблон задан с использованием групп</p>
<p>Листинг</p>
<p>r»aa|bb».</p>
<p>Соответствует «aa» или «bb»</p>
<p>Листинг</p>
<p>r»a(a|b)b»</p>
<p>Соответствует «aab» или «abb»</p>
<p>Листинг</p>
<p>r»^(?:\d{8}|\d{4}):\s*(.*)$"</p>
<p>Соответствует строке, которая начинается с набора из восьми или четырех цифр и двоеточия. Все, что идет после двоеточия и после следующих за ним пробелов, выделяется в группу с номером 1, тогда как набор цифр в группу не выделен.</p>
<p>Листинг</p>
<p>r»(\w+)=.*\b\1\b»</p>
<p>Слова слева и справа от знака равенства присутствуют. Операнд "\1» соответствует группе с номером 1, выделенной с помощью скобок.</p>
<p>Листинг</p>
<p>r»(?P&lt;var&gt;\w+)=.*\b(?P=var)\b»</p>
<p>То же самое, но теперь используется именованная группа var.</p>
<p>Листинг</p>
<p>r»\bregular(?=\s+expression)».</p>
<p>Соответствует слову «regular» только в том случае, если за ним после пробелов следует «expression»</p>
<p>Листинг</p>
<p>r»(?&lt;=regular )expression»</p>
<p>Соответствует слову «expression», перед которым стоит «regular»и один пробел.</p>
<p>Следует заметить, что примеры со взглядом назад могут сильно влиять на производительность, поэтому их не стоит использовать без особой необходимости.</p>
<p>Отладка регулярных выражений</p>
<p>Следующий небольшой сценарий позволяет отлаживать регулярное выражение, при условии, что есть пример строки, которой шаблон должен удовлетворять. Взят кусочек лога iptables, его необходимо разобрать для получения полей. Интересны строки, в которых после kernel: стоит PAY:, а в этих строках нужно получить дату, значения DST, LEN и DPT:</p>
<p>Листинг</p>
<p>import re</p>
<p>def debug_regex(regex, example):</p>
<p>«"«Отладка рег. выражения. Перед отладкой лучше убрать лишние скобки """</p>
<p>last_good = ""</p>
<p>for i in range(1, len(regex)):</p>
<p>try:</p>
<p>if re.compile(regex[:i]).match(example):</p>
<p>last_good = regex[:i]</p>
<p>except:</p>
<p>continue</p>
<p>return last_good</p>
<p>example = ""«Nov 27 15:57:59 lap kernel: PAY: IN=eth0 OUT=</p>
<p>MAC=00:50:da:d9:df:a2:00:00:1c:b0:c9:db:08:00 SRC=192.168.1.200 DST=192.168.1.115</p>
<p>LEN=1500 TOS=0x00 PREC=0x00 TTL=64 ID=31324 DF PROTO=TCP SPT=8080 DPT=1039</p>
<p>WINDOW=17520 RES=0x00 ACK PSH URGP=0»""</p>
<p>log_re = r»"«[A–Za–z]{3}\s+\d+\s+\d\d\d\d:\d\d) \S+ kernel: PAY: .+</p>
<p>DST=(?P&lt;dst&gt;\S+).* LEN=(?P&lt;len&gt;\d+).* DPT=(?P&lt;dpt&gt;\d+) """</p>
<p>print debug_regex(log_re, example)</p>
<p>Функция debug_regex() пробует сопоставлять пример с увеличивающимися порциями регулярного выражения и возвращает последнее удавшееся сопоставление:</p>
<p>Листинг</p>
<p>[A–Za–z]{3}\s+\d+\s+\d\d</p>
<p>Сразу видно, что не поставлен символ :.</p>
<p>Примеры применения регулярного выражения</p>
<p>Обработка лога</p>
<p>Предыдущий пример регулярного выражения позволит выделить из лога записи с определенной меткой и подать их в сокращенном виде:</p>
<p>Листинг</p>
<p>import re</p>
<p>log_re = re.compile(r»"«(?P&lt;date&gt;[A–Za–z]{3}\s+\d+\s+\d\d:\d\d:\d\d) \S+ kernel:</p>
<p>PAY: .+ DST=(?P&lt;dst&gt;\S+).* LEN=(?P&lt;len&gt;\d+).* DPT=(?P&lt;dpt&gt;\d+) """)</p>
<p>for line in open(«message.log»):</p>
<p>m = log_re.match(line)</p>
<p>if m:</p>
<p>print "%(date)s %(dst)s:%(dpt)s size=%(len)s» % m.groupdict()</p>
<p>В результате получается</p>
<p>Листинг</p>
<p>Nov 27 15:57:59 192.168.1.115:1039 size=1500</p>
<p>Nov 27 15:57:59 192.168.1.200:8080 size=40</p>
<p>Nov 27 15:57:59 192.168.1.115:1039 size=515</p>
<p>Nov 27 15:57:59 192.168.1.200:8080 size=40</p>
<p>Nov 27 15:57:59 192.168.1.115:1039 size=40</p>
<p>Nov 27 15:57:59 192.168.1.200:8080 size=40</p>
<p>Nov 27 15:57:59 192.168.1.115:1039 size=40</p>
<p>Анализ записи числа</p>
<p>Хороший пример регулярного выражения можно найти в модуле fpformat. Это регулярное выражение позволяет разобрать запись числа (в том виде, в каком числовой литерал принято записывать в Python):</p>
<p>Листинг</p>
<p>decoder = re.compile(r'^([-+]?)0*(\d*)((?:\.\d*)?)(([eE][-+]?\d+)?)$')</p>
<p># Следующие части числового литерала выделяются с помощью групп:</p>
<p># \0 — весь литерал</p>
<p># \1 — начальный знак или пусто</p>
<p># \2 — цифры слева от точки</p>
<p># \3 — дробная часть (пустая или начинается с точки)</p>
<p># \4 — показатель (пустой или начинается с 'e' или 'E')</p>
<p>Например:</p>
<p>Листинг</p>
<p>import re</p>
<p>decoder = re.compile(r'^([-+]?)0*(\d*)((?:\.\d*)?)((?:[eE][-+]?\d+)?)$')</p>
<p>print decoder.match(«12.234»).groups()</p>
<p>print decoder.match(" — 0.23e–7»).groups()</p>
<p>print decoder.match(«1e10»).groups()</p>
<p>Получим</p>
<p>Листинг</p>
<p>('', '12', '.234', '')</p>
<p>('-', '', '.23', 'e–7')</p>
<p>('', '1', '', 'e10')</p>
<p>Множественная замена</p>
<p>В некоторых приложениях требуется производить в тексте сразу несколько замен. Для решения этой задачи можно использовать метод sub() вместе со специальной функцией, которая и будет управлять заменами:</p>
<p>Листинг</p>
<p>import re</p>
<p>def multisub(subs_dict, text):</p>
<p>def _multisub(match_obj):</p>
<p>return str(subs_dict[match_obj.group()])</p>
<p>multisub_re = re.compile("|".join(subs_dict.keys()))</p>
<p>return multisub_re.sub(_multisub, text)</p>
<p>repl_dict = {'one': 1, 'two': 2, 'three': 3}</p>
<p>print multisub(repl_dict, «One, two, three»)</p>
<p>Будет выведено</p>
<p>Листинг</p>
<p>One, 2, 3</p>
<p>В качестве упражнения предлагается сделать версию, которая бы не учитывала регистр букв.</p>
<p>В приведенной программе вспомогательная функция _multisub() по полученному объекту с результатом сравнения возвращает значение из словаря с описаниями замен subs_dict.</p>
<p>Работа с несколькими файлами</p>
<p>Для упрощения работы с несколькими файлами можно использовать модуль fileinput. Он позволяет обработать в одном цикле строки всех указанных в командной строке файлов:</p>
<p>Листинг</p>
<p>import fileinput</p>
<p>for line in fileinput.input():</p>
<p>process(line)</p>
<p>В случае, когда файлов не задано, обрабатывается стандартный ввод.</p>
<p>Работа с Unicode</p>
<p>До появления Unicode символы в компьютере кодировались одним байтом (а то и только семью битами). Один байт охватывает диапазон кодов от 0 до 255 включительно, а это значит, что больше двух алфавитов, цифр, знаков пунктуации и некоторого набора специальных символов в одном байте не помещается. Каждый производитель использовал свою кодировку для одного и того же алфавита. Например, до настоящего времени дожили целых пять кодировок букв кириллицы, и каждый пользователь не раз видел в своем браузере или электронном письме пример несоответствия кодировок.</p>
<p>Стандарт Unicode — единая кодировка для символов всех языков мира. Это большое облегчение и некоторое неудобство одновременно. Плюс состоит в том, что в одной Unicode–строке помещаются символы совершенно различных языков. Минус же в том, что пользователи привыкли применять однобайтовые кодировки, большинство приложений ориентировано на них, во многих системах поддержка Unicode осуществляется лишь частично, так как требует огромной работы по разработке шрифтов. Правда, символы одной кодировки можно перевести в Unicode и обратно.</p>
<p>Здесь же следует заметить, что файлы по–прежнему принято считать последовательностью байтов, поэтому для хранения текста в файле в Unicode требуется использовать одну из транспортных кодировок Unicode (utf–7, utf–8, utf–16,…). В некоторых их этих кодировок имеет значение принятый на данной платформе порядок байтов (big–endian, старшие разряды в конце или little–endian, младшие в конце). Узнать порядок байтов можно, прочитав атрибут из модуля sys. На платформе Intel это выглядит так:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; sys.byteorder</p>
<p>'little'</p>
<p>Для исключения неоднозначности документ в Unicode может быть в самом начале снабжен BOM (byte–order mark — метка порядка байтов) - Unicode–символом с кодом 0xfeff. Для данной платформы строка байтов для BOM будет такой:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; codecs.BOM_LE</p>
<p>'\xff\xfe'</p>
<p>Для преобразования строки в Unicode необходимо знать, в какой кодировке закодирован текст. Предположим, что это cp1251. Тогда преобразовать текст в Unicode можно следующим способом:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = «Строка в cp1251»</p>
<p>&gt;&gt;&gt; s.decode(«cp1251»)</p>
<p>u'\u0421\u0442\u0440\u043e\u043a\u0430 \u0432 cp1251'</p>
<p>То же самое с помощью встроенной функции unicode():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; unicode(s, 'cp1251')</p>
<p>u'\u0421\u0442\u0440\u043e\u043a\u0430 \u0432 cp1251'</p>
<p>Одной из полезных функций этого модуля является функция codecs.open(), позволяющая открыть файл в другой кодировке:</p>
<p>Листинг</p>
<p>codecs.open(filename, mode[, enc[, errors[, buffer]]])</p>
<p>Здесь:</p>
<p>Листинг</p>
<p>filename</p>
<p>Имя файла.</p>
<p>Листинг</p>
<p>mode</p>
<p>Режим открытия файла</p>
<p>Листинг</p>
<p>enc</p>
<p>Кодировка.</p>
<p>Листинг</p>
<p>errors</p>
<p>Режим реагирования на ошибки кодировки ('strict' - возбуждать исключение, 'replace' - заменять отсутствующие символы, 'ignore' - игнорировать ошибки).</p>
<p>Листинг</p>
<p>buffer</p>
<p>Режим буферизации (0 — без буферизации, 1 — построчно, n — байт буфера).</p>
<p>Заключение</p>
<p>В этой лекции были рассмотрены основные типы для манипулирования текстом: строки и Unicode–строки. Достаточно подробно описаны регулярные выражения — один из наиболее эффективных механизмов для анализа текста. В конце приведены некоторые функции для работы с Unicode.</p>
<center><div align="center"></div></center>





