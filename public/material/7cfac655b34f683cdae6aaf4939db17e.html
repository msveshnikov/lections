# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 13. Пакет java.lang</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции рассматривается основная библиотека Java - java.lang. В дей содержатся классы Object и Class, классы-обертки для примитивных ти­пов, класс Math, классы для работы
со строками String и StringBuffer, систем-Hue классы System, Runtime и другие. В этом же
пакете находятся типы, уже рассматривавшиеся ранее,- для работы с
исключительными ситуациями и по­токами исполнения.








</p>
<p> 

</p>
<p>Введение

</p>
<p>В состав пакета java.lang входят классы,
составляющие основу для всех других, и поэтому он является наиболее важным из
всех, входящих в Java API. Поскольку без него не может обойтись ни один класс, каждый модуль
компиляции содержит неявное импортирование этого пакета (import java.lang.*;).

</p>
<p>Перечислим классы,
составляющие основу пакета.

</p>
<p>Object — является корневым
в иерархии классов.

</p>
<p>Class — экземпляры этого
класса являются описаниями объектных типов в памяти J VIVI.

</p>
<p>String — представляет
собой символьную строку, содержит средства работы с нею.

</p>
<p>StringBuffer — используется для
работы (создания) строк.

</p>
<p>Number — абстрактный
класс, являющийся суперклассом для классов-объектных оберток числовых
примитивных типов Java.

</p>
<p>Character — объектная обертка
для типа char.

</p>
<p>Boolean — объектная обертка
для типа boolean.

</p>
<p>Math — реализует набор базовых математических функций.

</p>
<p>Throwable — базовый класс для объектов, представляющих исключе­ния. Любое
исключение, которое может быть брошено и, соответственно, перехвачено блоком catch, должно быть
унаследовано от Throwable.

</p>
<p>Thread — позволяет
запускать и работать с потоками выполнения в Java. Runnable - может использоваться в сочетании с классом Thread для описания потоков выполнения.

</p>
<p>ThreadGroup — позволяет
объединять потоки в группу и произво­дить действия сразу над всеми потоками в
ней. Существуют ограничения 110 безопасности на манипуляции с
потоками из других групп.

</p>
<p>, System - содержит полезные
поля и методы для работы системного УРов'ня.

</p>
<p>• ,   Runtime — позволяет приложению взаимодействовать с окружением, Котором оно
запущено.








</p>
<p>Process — представляет интерфейс к внешней программе, запущенной при помощи Runtime.

</p>
<p>ClassLoader - отвечает за
загрузку описания классов в память JVM.

</p>
<p>SecurityManager — для обеспечения
безопасности накладывает огра­ничения на данную среду выполнения программ.

</p>
<p>Compiler - используется для
поддержки Just-in-Time компиляторов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Интерфейсы:

</p>
<p>Cloneable - должен быть
реализован объектами, которые планируется клонировать с помощью средств JVM;

</p>
<p>Comparable - позволяет
упорядочивать (сортировать, сравнивать) объекты каждого класса, реализующего
этот интерфейс.

</p>
<p> 

</p>
<p>Object

</p>
<p>Класс Object является базовым
для всех остальных классов. Он опре­деляет методы, которые поддерживаются любым
классом в Java.

</p>
<p>Метод public final native Class getClass() возвращает объект типа Class, соответствующий
классу объекта. Этот метод уже рассматривался в лекции 4.

</p>
<p>Метод public boolean equals(Object obj) определяет, являются ли объекты одинаковыми. Если оператор ==
проверяет равенство по ссылке (указывают на один и тот же объект), то метод equals() — равенство по
значению (состояния объектов одинаковы). Поскольку класс Object не содержит полей, реализация в нем этого метода такова, что значение true будет возвращено только в случае равенства по ссылке, то есть:

</p>
<p>public boolean equals(Object obj) { return
(this == obj);

</p>
<p>}

</p>
<p>В классах-наследниках этот метод при необходимости может быть
переопределен, чтобы поддержать расширенное состояние объекта (на­пример, если
добавилось поле, характеризующее состояние). Рассмотрим сравнение
объектов-оберток целых чисел (класс Integer). Оно должно по
всей логике возвращать значение true, если равны значения int чисел, ко­торые обернуты, даже если это два различных объекта.

</p>
<p>Метод equals() может быть переопределен любым способом (например, всегда возвращать false, или, наоборот, true) - компилятор,
конечно же, не будет проводить анализ реализации и давать рекоменда­ции. Однако
существуют соглашения, которые необходимо соблюдать, чтобы программа имела
предсказуемое поведение, в том числе и с точки зрения других программистов:

</p>
<p>•   
рефлексивность: для любой
объектной ссылки х, отличной от null, вызов x.equals(x) возвращает true;

</p>
<p>•   
симметричность: для любых
объектных ссылок х и у, вызов x.equals(y) возвращает true только в том
случае, если вызов y.equals(x) возвращает true;

</p>
<p>•   
транзитивность: для любых
объектных ссылок х, у и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, то вызов x.equals(z) должен вернуть true;

</p>
<p>•   
непротиворечивость: для
любых объектных ссылок х и у многократные последовательные вызовы x.equals(y) возвращают одно и
то же значение (либо всегда true, либо всегда false);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
для любой не равной null объектной ссылки х вызов x.equals(null) должен вернуть значение false.

</p>
<p>Пример:

</p>
<p> 

</p>
<p>package demo.lang; public class Rectangle { public int
sideA; public int sideB; public Rectangle(int x, int y) { super(); sideA = x;
sideB = y;

</p>
<p>}

</p>
<p>public boolean equals(Object obj) {

</p>
<p>if(!(obj
instanceof Rectangle)) return false; Rectangle ref = (Rectangle)obj;

</p>
<p>return
(((this.sideA==ref.sideA)&amp;&amp;(this.sideB==ref.sideB))11 (this.
sideA==ref.sideB)&amp;&amp;(this.sideB—ref. sideA));

</p>
<p>}

</p>
<p>public static void main(String[] args) { Rectangle
r1 = new Rectangle( 10,20); Rectangle r2 = new Rectangle( 10,10); Rectangle r3 =
new Rectangle(20,10); System, out. println("r1 .equals(r1) == " + П .equals(r1));
System, out. println("r1 .equals(r2) == " + r1 ,equals(r2)); System,
out. println("r1 .equals(r3) == " + r1 .equals(r3)); System, out.
println("r2.equals(r3) == " + r2.equals(r3)); System, out.
println("r1 .equals(null) == " + r1 .equals(null));

</p>
<p>}

</p>
<p>Запуск этой программы, очевидно, приведет к выводу на экран сле­дующего:

</p>
<p>rl.equals(rl) == true r1 ,equals(r2) == false
r1.equals(r3) == true r2.equals(r3) == false rl.equals(null) == false

</p>
<p> 

</p>
<p>В этом примере метод equals() у класса Rectangle был переопреде­лен
таким образом, чтобы прямоугольники были равны, если их можно наложить друг на
друга (геометрическое равенство).

</p>
<p>Большинство стандартных классов переопределяет этот метод, строго следуя
всем соглашениям.

</p>
<p>Метод public int
hashCode() возвращает хеш-код (hash code) для объекта.
Хеш-код — это целое число, которое сопоставляется с данным объектом. Оно
позволяет организовать хранение набора объектов с возможностью быстрой выборки
(стандартная реализация такого механизма присутствует в Java и будет описана в следующей лекции).

</p>
<p>Для этого метода также принят ряд соглашений, которым стоит следовать
при переопределении:

</p>
<p>•   
если два объекта
идентичны, то есть вызов метода equals(Object) возвращает true, то вызов метода hashCode() у каждого из этих двух объектов должен возвращать одно и то же
значение;

</p>
<p>•    во время одного запуска программы для одного объекта при вызове метода hashCode() должно
возвращаться одно и то же значение, ес­ли между этими вызовами не были
затронуты данные, используе­мые для проверки объектов на идентичность в методе equals()
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Это число не
обязательно должно быть одним и тем же при повторном запуске той же программы,
даже если все данные будут идентичны.

</p>
<p>В классе Object этот метод
реализован на уровне JVM. Сама виртуаль­ная машина генерирует хеш-код, основываясь на
расположении объекта в памяти. Это позволяет для различных объектов
(неравенство по ссылке) получать различные хеш-коды.

</p>
<p>В силу первого соглашения при переопределении метода equals() необходимо
переопределить также метод hashCode(). При этом нужно стремиться, во-первых, к тому, чтобы метод возвращал
значение как мож­но быстрее, иначе основная цель — быстрая выборка — не будет
достигну­та. Во-вторых, желательно для различных объектов, то есть метод equals(Object) возвращает false, генерировать
различные хеш-коды. В этом случае хеш-таблицы будут работать особенно эффективно. Однако,
понятно, что это не всегда возможно. Диапазон значений int — 2", а коли­чество
различных строк, или двумерных точек, с координатами типа int — заведомо больше.

</p>
<p>Большинство стандартных классов переопределяет этот метод, строго следуя
всем соглашениям.

</p>
<p>Метод public String toString() возвращает строковое представление объекта. В классе Object этот метод реализован следующим образом:

</p>
<p> 

</p>
<p>public String toString() {

</p>
<p>return
getClass().getName() + "@" + Integer.toHexSthng(hashCodeQ);

</p>
<p>}

</p>
<p>To есть возвращает строку, содержащую название класса объекта и его хеш-код
в шестнадцатеричном формате.

</p>
<p>В классах-наследниках этот метод может быть переопределен для получения
более наглядного описания объекта. Обычно это значения некоторых полей,
характеризующих экземпляр. Например, для книги это может быть название, автор и
количество страниц:

</p>
<p>package
demo.lang; public class Book {

</p>
<p>private String title;

</p>
<p>private String author;

</p>
<p>private int pagesNumber;

</p>
<p>public Book(String title, String author, int
pagesNumber) { super(); this.title = title; this.author = author;
this.pagesNumber = pagesNumber;

</p>
<p>}

</p>
<p>public static void main(String[] args) {

</p>
<p>Book book = new
Book("Java2", "Sun", 1000); System.out.println("object
is:" + book);

</p>
<p>}

</p>
<p>public String toString(){

</p>
<p>return "Book:" + title + "
(" + author + "," + pagesNumber + " pages)";

</p>
<p>}

</p>
<p>}

</p>
<p>При запуске этой программы на экран будет выведено следующее: object is: Book: Java2 ( Sun, 1000 pages )

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Большинство стандартных классов переопределяет этот метод. Экземпляры
класса String возвращают ссылку
на самих себя (this).

</p>
<p>Метод wait(), notify(), notifyAII() используются для поддержки много-поточности и были подробно
рассмотрены в лекции 12. Они определены с атрибутом final и не могут быть переопределены в классах-наследниках.

</p>
<p>Метод protected void finalize() throws Throwable вызывается Java-ма­шиной перед
тем, как garbage collector (сборщик мусора)
освободит память, занимаемую объектом. Этот метод уже подробно рассматривался в
лекции 4.

</p>
<p>Метод protected native Object clone() throws CloneNotSupportedException создает копию
объекта. Механизм клонирования подробно рассматри­вался в лекции 9.

</p>
<p> 

</p>
<p>Class

</p>
<p>В запущенной программе Java каждому классу
соответствует объект типа Class. Этот объект содержит информацию, необходимую для описа­ния класса —
поля, методы и т.д.

</p>
<p>Класс Class не имеет открытого
конструктора — объекты этого клас­са создаются автоматически Java-машиной по мере
загрузки описания классов из class-файлов. Получить экземпляр Class для конкретного класса можно с помощью метода forName():

</p>
<p>public static Class forName(String name, boolean initialize, ClassLoader loader) — возвращает объект Class, соответствующий клас­су, или интерфейсу, с названием, указанным в name (необходимо указы­вать полное название класса или интерфейса), используя
переданный за­грузчик классов. Если в качестве загрузчика классов loader передано зна­чение null, будет взят ClassLoader, который применялся для загрузки вы­зывающего класса. При этом класс
будет инициализирован, только если значение initialize равно true и класс не был инициализирован ранее.

</p>
<p>Зачастую проще и удобнее воспользоваться методом forName(), пе­редав только
название класса: public static Class forName(String className),— при этом будет использоваться загрузчик вызывающего класса и класс
будет инициализирован (если до этого не был).

</p>
<p>public Object newlnstance() — создает и возвращает объект класса, который представляется данным
экземпляром Class. Создание будет происходить с использованием конструктора без
параметров. Если такового в классе нет, будет брошено исключение InstantiationException. Это же исключение будет брошено, если объект Class соответствует абстрактному классу, интерфейсу, или какая-то другая
причина помешала созданию нового объекта.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Каждому методу, полю, конструктору класса также соответствуют объекты,
список которых можно получить вызовом соответствующих ме­тодов объекта Class: getMethods(), getFields(), getConstructors(), getDeclaredMethods() и т.д. В результате будут получены объекты, кото­рые отвечают за
поля, методы, конструкторы объекта. Их можно исполь­зовать для формирования
динамических вызовов Java - этот механизм
называется reflection. Необходимые классы содержатся в пакете java. lang. reflection.

</p>
<p>Рассмотрим пример
использования этой технологии:

</p>
<p>package
demo.lang; interface Vehicle { void go();

</p>
<p>}

</p>
<p>class Automobile implements Vehicle { public
void go() {

</p>
<p>System.out.println("Automobile go!");

</p>
<p>}

</p>
<p>}

</p>
<p>class Truck implements Vehicle { public
Truck(int i) { super();

</p>
<p>}

</p>
<p>public void go() {

</p>
<p>System.out.println("Truck go!");

</p>
<p>}

</p>
<p>}

</p>
<p>public class
VehicleStarter {

</p>
<p>public static void main(String[] args) { Vehicle
vehicle;

</p>
<p>String[] vehicleNames = {"demo.lang.Automobile",

</p>
<p>"demo.lang.Truck",
"demo.lang.Tank"}; for(int &#161;=0; KvehicleNames.length; i++) {

</p>
<p>try {

</p>
<p>String name = vehicleNames[i];
System.out.println("look for class for:" + name); Class aClass = Class.forName(name);
System.out.println("creating vehicle..."); vehicle = (Vehicle)aClass.newlnstance();
System.out.println("create vehicle:" +

</p>
<p>vehicle.getClass());
vehicle.go(); } catch(ClassNotFoundException e) { System.out.printlnf'Exception:"
+ e);

</p>
<p>} catch(lnstantiationException
e) {

</p>
<p>System.out.printlnf'Exception:
" + e);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Если запустить эту программу, на экран будет выведено следующее:

</p>
<p> 

</p>
<p>look for class
for: demo.lang.Automobile creating vehicle...

</p>
<p>create vehicle:
class demo.lang.Automobile Automobile go!

</p>
<p>look for class
for: demo.lang.Truck creating vehicle...

</p>
<p>Instantiation
exception: java.lang.InstantiationException

</p>
<p>look for class
for: demo.lang.Tank

</p>
<p>Class not
found: java.lang.ClassNotFoundException:

</p>
<p>demo.lang.Tank

</p>
<p> 

</p>
<p>В этом примере делается попытка создать с помощью reflection три объекта. Имена
классов, от которых они должны быть порождены, запи­саны в массив vehicleNames. Объект класса Automobile был успешно со­здан,
причем, дальнейшая работа с ним велась через интерфейс Vehicle
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Класс Truck был найден, но при попытке создания объекта было броше­но, а затем
обработано исключение java.lang.InstantiationException, по­скольку конструктор без параметров отсутствует. Класс java.lang.Tank определен не был и поэтому при попытке получить соответствующий ему
объект Class было выброшено
исключение java. lang.ClassNotFoundException.

</p>
<p> 

</p>
<p>Классы-обертки

</p>
<p>Во многих случаях предпочтительней работать именно с объектами, а не с
примитивными типами. Так, например, при использовании коллек­ций просто
необходимо значения примитивных типов представлять в ви­де объектов.

</p>
<p>Для этих целей и предназначены так называемые классы-обертки. Для
каждого примитивного типа Java существует свой
класс-обертка. Та­кой класс является неизменяемым (если необходим объект,
хранящий другое значение, его нужно создать заново), к тому же имеет атрибут final - от него нельзя наследовать класс. Все классы-обертки (кроме Void) ре­ализуют
интерфейс Serializable,
поэтому объекты любого
(кроме Void) класса-обертки могут быть сериализованы. Все классы-обертки содержат
статическое поле TYPE, ссылающееся на объект Class,
соответствующий
примитивному оборачиваемому типу.

</p>
<p>Также классы-обертки содержат статические методы для обеспече­ния
удобного манипулирования соответствующими примитивными ти­пами, например,
преобразование к строковому виду.

</p>
<p>В Таблице 13.1 приведены примитивные типы и соответствующие им
классы-обертки.

</p>
<p>При этом классы-обертки числовых типов Byte, Short, Integer, Long, Float, Double наследуются от одного класса - Number. В нем объявлены
методы, возвращающие числовое значение во всех числовых форматах Java (byte, short, int, long, float и double).

</p>
<p>Все классы-обертки реализуют интерфейс Comparable. Все классы-обертки числовых типов имеют метод equals(Object), сравнивающий примитивные значения объектов.

</p>
<p>Рассмотрим более подробно
некоторые из классов-оберток.

</p>
<p> 

</p>
<p>Integer

</p>
<p>Наиболее часто
используемые статические методы:

</p>
<p>•   
</p>
<center><img width="443" height="268" src="http://kufas.ru/java.files/image040.png"></center>
public static int parselnt(String s) - преобразует
строку, представ­ляющую десятичную запись целого числа, в int;

<p>•   
public static int parselnt(String s, int radix) - преобразует строку, представляющую запись целого числа в системе
счисления radix, в int.

</p>
<p>Оба метода могут
возбуждать исключение NumberFormatException, если строка, переданная на вход, содержит нецифровые символы
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Не
следует путать эти методы с другой парой похожих методов:

</p>
<p> 

</p>
<p>public static
Integer valueOf(String s)

</p>
<p>public static
Integer valueOf(String s, int radix)

</p>
<p>Данные методы выполняют аналогичную работу, только результат
представляют в виде объекта-обертки.

</p>
<p>Существует также два
конструктора для создания экземпляров

</p>
<p>класса Integer:

</p>
<p>•   lnteger(String s) - конструктор, принимающий в качестве пара­метра строку,
представляющую числовое значение.

</p>
<p>•   lnteger(int i) — конструктор,
принимающий числовое значение, pubic static String toString(int i) - используется для преобразования

</p>
<p>значения типа int в строку.

</p>
<p>Далее перечислены методы, преобразующие int в строковое восьме­ричное, двоичное и шестнадцатеричное представление:

</p>
<p>pubic static
String toOctalString(int i) - восьмеричное;

</p>
<p>pubic static
String toBinaryString(int i) - двоичное;

</p>
<p>pubic static
String toHexString(int i) - шестнадцатеричное.

</p>
<p>Имеется также две
статические константы:

</p>
<p>lnteger.MIN_VAL.UE - минимальное int значение;

</p>
<p>Integer. MAXVALUE - максимальное int значение.

</p>
<p>Аналогичные константы, описывающие границы соответствующих типов,
определены и для всех остальных классов-оберток числовых при­митивных типов.

</p>
<p>public int intValue() возвращает
значение примитивного типа для данного объекта Integer. Классы-обертки
остальных примитивных целочисленных типов — Byte, Short, Long — содержат анапогичныс методы и константы (определенные для
соответствующих типов: byte, short, long).

</p>
<p>Рассмотрим пример:

</p>
<p>public static void main(String[] args) { int
i = 1; byte b = 1;

</p>
<p>String value = "1000";

</p>
<p>Integer iObj = new Integer(i);

</p>
<p>Byte bObj = new Byte(b);

</p>
<p>System.out.println("while i==b is " + (i==b));

</p>
<p>System.out.println("iObj.equals(bObj) is " + iObj.equals(bObj));

</p>
<p>Long IObj = new Long(value);

</p>
<p>System, out. printlnflObj = " + IObj.toString());

</p>
<p>Long sum = new Long(IObj.longValue() + iObj.byteValue()
+

</p>
<p>bObj.shortValueO); System.out.printlnf'The
sum = " + sum.doubleValue());

</p>
<p>}

</p>
<p> 

</p>
<p>В данном примере произвольным образом используются различные варианты
классов-оберток и их методов. В результате выполнения на экран будет выведено
следующее:

</p>
<p> 

</p>
<p>while i==b is true ЎObj.equals(bObj) is false IObj = 1000 The sum = 1002.0

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Оставшиеся классы-обертки числовых типов, Float и Double, поми­мо описанного для целочисленных примитивных типов, дополнительно
содержат определения следующих констант (они подробно разбирались в лекции 4):

</p>
<p>NEGATIVEJNFINITY - отрицательная
бесконечность; POSITIVEJNFINITY- положительная бесконечность; NaN — нечисловое значение.

</p>
<p>Кроме того, другой смысл имеет значение MINVALUE - вместо на­именьшего значения оно представляет минимальное
положительное (строго &gt; 0) значение, которое может быть представлено этим примитив­ным типом.

</p>
<p>Кроме классов-оберток для примитивных числовых типов, таковые определены
и для остальных примитивных типов Java.

</p>
<p> 

</p>
<p>Character

</p>
<p>Реализует интерфейсы Comparable
и Serializable. Из конструкторов имеет только один, принимающий char в качестве параметра.

</p>
<p>Кроме стандартных методов equals(), hashCode(), toString(), содержит только
два нестатических метода:

</p>
<p>•   
public char charValue() — возвращает обернутое значение char;

</p>
<p>•   
public int compareTo(Character anotherCharacter) - сравнивает обернутые значения char как числа, то есть возвращает значение return this.value - anotherCharacter.value.

</p>
<p>Также для совместимости с интерфейсом Comparable метод compareТо() определен с параметром Object:

</p>
<p> 

</p>
<p>•  public Ўnt compareTo(Object о) - если переданный объект имеет тип Character, результат будет аналогичен вызову

</p>
<p>compareTo((Character)o), иначе будет брошено исключение ClassCastException, так как Character можно сравнивать только с Character.

</p>
<p> 

</p>
<p>Статических методов в классе Character довольно много, но все они просты и логика их работы понятна из
названия. Большинство из них -это методы, принимающие char и проверяющие
всевозможные свойства. Например:

</p>
<p> 

</p>
<p>public static
boolean isDigit(char с) - проверяет,
является ли cha/ цифрой.

</p>
<p>Эти методы возвращают значение истина или ложь, в соответствии е
тем, выполнен ли критерий проверки.                                                    '  '*

</p>
<p> 

</p>
<p>Boolean

</p>
<p>Представляет класс-обертку
для примитивного типа boolean.

</p>
<p>Реализует интерфейс java.io.Serializable
и во всем напоминает
аналогичные классы-обертки.

</p>
<p>Для получения примитивного значения используется метод booleanValue().

</p>
<p> 

</p>
<p>Void

</p>
<p>Этот класс-обертка, в отличие от остальных, не реализует интерфейс java.io.Serializable. Он не имеет открытого конструктора. Более того, экземпляр этого класса
вообще не может быть получен
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Он нужен только для получения ссылки на объект Class, соответствующий void. Эта ссылка
представлена статической константой ТУРЕ.

</p>
<p>Делая краткое заключение
по классам-оберткам, можно сказать,

</p>
<p>что:

</p>
<p>•   
каждый примитивный тип
имеет соответствующий класс-обертку;

</p>
<p>•   
все классы-обертки могут
быть сконструированы как с использова­нием примитивных типов, так и с
использованием String, за исклю­чением Character,
который может быть
сконструирован только по char;

</p>
<p>•   
классы-обертки могут
сравниваться с использованием метода equals();

</p>
<p>•   примитивные типы могут
быть извлечены из классов-оберток с помощью соответствующего метода xxxxValueO

</p>
<p>(например intValueO);

</p>
<p>•   
классы-обертки также
являются классами-утилитами, т.е. предо­ставляют набор статических методов для
работы с примитивными типами;

</p>
<p>•   
классы-обертки являются
неизменяемыми.

</p>
<p> 

</p>
<p>Math

</p>
<p>Класс Math состоит из набора статических методов, производящих наиболее популярные
математические вычисления, и двух констант, име­ющих
особое значение в
математике, - это число Пи и основание нату­рального логарифма. Часто этот
класс еще называют
классом-утилитой (Utility class). Так как все
методы класса статические, нет необходимости создавать экземпляр данного
класса, потому он и не имеет открытого конструктора. Нельзя также и
наследоваться от этого класса, так как он объявлен с модификатором final.

</p>
<p>Итак, константы определены
следующим образом:

</p>
<p> 

</p>
<p>public static
final double Matht.PI - задает число л ("пи");

</p>
<p>public static
final double Matht.E - основание натурального логарифма.

</p>
<p>В Таблице 13.2 приведены все методы класса и дано их краткое описание.

</p>
<p> 

</p>
<p>Строки

</p>
<p> 

</p>
<p>String

</p>
<p>Этот класс используется в Java для представления строк. Он облада­ет свойством неизменяемости. После того
как создан экземпляр этого
класса, его содержимое уже не может быть модифицировано.

</p>
<p>Существует много способов создать объект String. Наиболее про­стой,
если содержимое строки известно
на этапе компиляции, - написать текст в кавычках:

</p>
<p> 

</p>
<p>String abc = "abc";

</p>
<p>Можно использовать и различные варианты конструктора.
Наиболее Простой из них - конструктор, получающий на входе строковый литерал.








</p>
<p>Лекция 13




</p>
<p>Пакет
java.lang








</p>
<p></p>
<center><img width="435" height="702" src="http://kufas.ru/java.files/image041.png"></center>


<p>String s = new
String("immutable");

</p>
<p> 

</p>
<p>На первый взгляд, эти варианты создания строк отличаются только
синтаксисом. На самом же деле различие есть, хотя в большинстве случаев оно
несущественно. Рассмотрим пример:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>public class Test { public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Test
t = new Test(); String s1 = "Hello world !!!"; String s2 =
"Hello world !!!";

</p>
<p>System.out.printlnf'String's equally = " + (s1
.equals(s2))); System.out.printlnf'Strings are the same = " + (s1 ==s2));

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>В результате на консоль
будет выведено:

</p>
<p> 

</p>
<p>String's equally = true Strings are the same = true

</p>
<p> 

</p>
<p>Теперь несколько модифицируем код:

</p>
<p> 

</p>
<p>public class Test { public Test() {

</p>
<p>}

</p>
<p>public static void main(String[] args) { Testt
= newTest(); String s1 = "Hello world !!!"; String s2 = new
Stringf'Hello world !!!"); System.out.printlnf'String's equally = " +
(s1 .equals(s2))); System.out.printlnf'Strings are the same = " + (s1==s2));

</p>
<p>}

</p>
<p> 

</p>
<p> 

</p>
<p>В результате на консоль будет выведено:

</p>
<p> 

</p>
<p>String's equally = true Strings are the same = false








</p>
<p>Почему результат изменился? Дело в том, что создание нового объек­та -
это одна из самых трудоемких процедур в Java. Поэтому
компилятор стремится уменьшить их количество, если это не приводит к
непредсказу­емому поведению программы.

</p>
<p>В примере объявляются две переменных, которые инициализируются
одинаковым значением. Поскольку класс String неизменяемый, их значения всегда будут одинаковыми. Это позволяет
компилятору завести скрытую вспомогательную текстовую переменную, которая будет
хранить такое зна­чение, а все остальные переменные будут ссылаться на него же,
а не порож­дать новые объекты. В результате в первом варианте программы
создается лишь один объект String. Для большинства операций это несущественная разница. Исключение
составляют действия, которые привязаны к конкрет­ному объекту, а не к его
значению. Это метод equals, методы wait/notify.

</p>
<p>Во втором варианте указано динамическое обращение к конструкто­ру. В
этом случае компилятор уже не имеет возможности заниматься опти­мизацией и JVM во время исполнения программы действительно создаст второй объект с точно
таким же значением. Что мы и видим по результату выполнения примера.

</p>
<p>В Java для строк определен
оператор +. При использовании этого оператора производится конкатенация строк.
В классе String также опре­делен метод:

</p>
<p> 

</p>
<p>public String
concat(String s);

</p>
<p> 

</p>
<p>Он возвращает новый объект-строку, дополненный справа
строкой s. Рассмотрим другой пример.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public class
Test {

</p>
<p>public static void main(String[] args) { Testt
= newTest(); String s = " prefix !"; System.out.println(s); s = s.trim();
System, out. println(s); s = s.concat(" suffix"); System, out.
println(s);

</p>
<p>}

</p>
<p>}

</p>
<p>prefix ! prefix ! prefix ! suffix

</p>
<p>В данном случае может сложиться впечатление, что строку (объект String, на который
ссылается переменная s), можно изменять. В действи­тельности это не так. В результате
выполнения методов trim (отсечение пробелов
в начале и конце строки) и concat создаются новые
объекты-стро­ки и ссылка s начинает указывать
на новый объект-строку. Таким образом, меняется значение ссылки, объекты же
неизменяемы.

</p>
<p>Как уже отмечалось, строка состоит из двухбайтных Unicode-сим­волов. Однако
во многих случаях требуется работать со строкой как с набором байт (ввод/вывод,
работа с базой данных и т.д.). Преобразова­ние строки в последовательность
байтов производится следующими методами:

</p>
<p>•   byte[] getBytes() - возвращает последовательность байтов в ко­дировке, принятой по
умолчанию (как правило, зависит от настроек опе­рационной системы);

</p>
<p>•   byte[] getBytes(String encoding) - возвращает
последователь­ность байтов в указанной кодировке encoding.

</p>
<p>Для выполнения обратной операции (преобразования байтов в строку)
необходимо сконструировать новый объект-строку с помощью следующих методов:

</p>
<p>•    String(byte[] bytes) - создает строку
из последовательности байтов в кодировке, принятой по умолчанию;

</p>
<p>•    String(byte[] bytes, String ene) - создает строку из
последователь­ности байтов в указанной кодировке.

</p>
<p> 

</p>
<p>String Buffer

</p>
<p>Этот класс используется для создания и модификации строковых выражений,
которые после можно превратить в String. Он реализован на
основе массива char[], что позволяет, в отличие от String, модифициро­вать
его значение после создания объекта.

</p>
<p>Рассмотрим наиболее часто используемые конструкторы класса StringBuffer:

</p>
<p>•   
StringBuffer () - создает пустой StringBuffer;

</p>
<p>•   
StringBuffer(String s) - буфер заполняется указанным значением s;

</p>
<p>•    StringBuffer (int capacity) - создает
экземпляр класса StringBuffer с указанным
размером (длина char[]). Задание размера не означает, что нельзя будет оперировать строками
с большей длинной, чем указано в конструкторе. На самом деле этим гарантируется,
что при работе со строками меньшей длины дополнительное выделение памяти не
потребуется.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Разница между String и StringBuffer может быть
продемонстрирована на следующем примере:








</p>
<p>public class
Test {

</p>
<p>public static void main(String[] args) { Testt
= newTest(); String s = new String("ssssss"); StringBuffer sb = new
StringBufferf'bbbbbb"); s.concat("-aaa");
sb.append("-aaa"); System.out. println(s); System.out.println(sb);

</p>
<p>}

</p>
<p>}

</p>
<p>В результате на экран будет выведено следующее:

</p>
<p>ssssss bbbbbb-aaa

</p>
<p> 

</p>
<p>В данном примере можно заметить, что объект String остался неизменным, а объект StringBuffer изменился.

</p>
<p>Основные методы, используемые для модификации StringBuffer, это:

</p>
<p>•  public StringBuffer append(String str) - добавляет переданную строку str в буфер;

</p>
<p>•  public StringBuffer insert(int offset, String str) - вставка строки, начиная с позиции offset (пропустив offset символов).

</p>
<p>Стоит обратить внимание, что оба метода имеют варианты, принимающие в
качестве параметров различные примитивные типы Java вместо String. При использовании этих методов аргумент предварительно приводится к
строке (с помощью String.valueOf()).

</p>
<p>Еще один важный момент, связанный с этими методами, - они воз­вращают
сам объект, у которого вызываются. Благодаря этому, возможно их использование в
цепочке. Например:

</p>
<p>public static void main(String[] args) {

</p>
<p>StringBuffer sb = new StringBufferfabc");

</p>
<p>String str = sb.append("e").insert(4,"f").insert(3,"d").toString();

</p>
<p>System.out.println(str);

</p>
<p>}

</p>
<p>В результате на экран будет выведено: abcdef

</p>
<p>При передаче экземпляра класса StringBuffer в качестве
параметра метода следует помнить, что этот класс изменяемый:

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public static void main(String[] args) { Test
t = new Test();

</p>
<p>StringBuffer sb = new StringBufferf aaa"); System.
out.printlnf'Before = " + sb); t.doTest(sb);

</p>
<p>System, out. printlnfAfter = " + sb);

</p>
<p>}

</p>
<p>void doTest(StringBuffer theSb){
theSb.append("-bbb");

</p>
<p>}

</p>
<p>}

</p>
<p>В результате на экран будет выведено следующее:

</p>
<p> 

</p>
<p>Before = aaa After = aaa-bbb

</p>
<p>Поскольку все объекты передаются по ссылке, в методе doTest, при выполнении
операций с theSB, будет модифицирован объект, на который ссылается sb.

</p>
<p> 

</p>
<p>Системные классы

</p>
<p>Следующие классы, которые будут рассмотрены, обеспечивают взаимодействие
с внутренними механизмами JVM и средой исполнения
приложения:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
ClassLoader - загрузчик
классов; отвечает за загрузку описания классов в память JVM;

</p>
<p>•   
SecurityManager - менеджер
безопасности; содержит различные методы проверки допустимости запрашиваемой
операции;

</p>
<p>•   
System - содержит набор
полезных статических полей и методов;

</p>
<p>•   
Runtime - позволяет
приложению взаимодействовать со средой исполнения;

</p>
<p>•   
Process - представляет
интерфейс для взаимодействия с внешней программой, запущенной при помощи Runtime.








</p>
<p>ClassLoader

</p>
<p>Это абстрактный класс, ответственный за загрузку типов. По имени класса
или интерфейса он находит и загружает в память данные, которые составляют
определение типа. Обычно для этого используется простое правило: название типа
преобразуется в название class-файла, из которого и считывается вся необходимая информация.

</p>
<p>Каждый объект Class содержит ссылку на
объект ClassLoader, с по­мощью которого он был загружен.

</p>
<p>Для добавления альтернативного способа загрузки классов можно
реализовать свой загрузчик, унаследовав его от ClassLoader. Например, описание класса может загружаться через сетевое соединение.
Метод defineClass() преобразует массив байт в экземпляр класса Class. С помо­щью метода
newlnstance() могут быть получены экземпляры такого класса. В результате
загруженный класс становится полноценной частью исполня­емого Java-предложения.

</p>
<p>Для иллюстрации приведем пример, как может выглядеть простая реализация
загрузчика классов, использующего сетевое соединение:

</p>
<p> 

</p>
<p>class NetworkClassLoader extends ClassLoader
{ String host; int port;

</p>
<p>public NetworkClassLoader(String host, int
port) { this.host = host; this.port = port;

</p>
<p>}

</p>
<p>public Class findClass(String className) { byte[]
bytes = loadClassData(className); return defineClass(className, bytes, 0, bytes.length)

</p>
<p>}

</p>
<p>private byte[] loadClassData(String className) { byte[]
result = null;

</p>
<p>// open connection, load the class data return result;

</p>
<p>}

</p>
<p>}

</p>
<p>В этом примере только показано, что наследник загрузчика классов должен
определить и реализовать методы findClass() и loadClassData() для загрузки описания класса. Когда описание получено, массив байт пе­редается
в метод defineClass() для создания экземпляра Class. Для просто­ты в
примере приведен только шаблонный код, без реализации получения байт из
сетевого соединения.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Для получения экземпляров классов, загруженных с помощью этого
загрузчика, можно воспользоваться методом loadClass():

</p>
<p> 

</p>
<p>try {

</p>
<p>ClassLoader loader = new NetworkClassLoader(host,
port); Object main = loader.loadClass("Main").newlnstance(); } catch(ClassNotFoundException
e) {

</p>
<p>e.printStackTrace();
} catch(lnstantiationException e) {

</p>
<p>e.printStackTrace(); } catch(lllegalAccessException e) {

</p>
<p>e.printStackTrace();

</p>
<p>}

</p>
<p>Если такой класс не будет найден, будет брошено исключение ClassNotFoundException, если класс будет найден, но произойдет какая-либо ошибка при создании
объекта этого класса - будет брошено исклю­чение InstantiationException, и, наконец, если у вызывающего потока не имеется соответствующих прав
для создания экземпляров этого класса (что проверяется менеджером
безопасности), будет брошено исключение UlegalAccessException.

</p>
<p> 

</p>
<p> 

</p>
<p>SecurityManager - менеджер безопасности

</p>
<p>С помощью методов этого класса приложения перед выполнением потенциально
опасных операций проверяют, является ли операция допустимой в данном контексте.

</p>
<p>Класс SecurityManager содержит много
методов с именами, начи­нающимися с приставки check («проверить»). Эти методы вызываются из стандартных классов библиотек Java перед тем, как в них будут выполнены потенциально опасные операции.
Типичный вызов выглядит примерно следующим образом:

</p>
<p>SecurityManager security = System.getSecurityManager(); insecurity != null){ security.checkX(...);

</p>
<p>}

</p>
<p>где X - название
потенциально опасной операции: Access, Read, Write, Connect, Delete, Exec, Listen и т.д.

</p>
<p>Предотвращение вызова производится путем бросания исключения - SecurityException, если вызов операции не разрешен (кроме метода checkTopLevelWindow, который возвращает boolean значение).

</p>
<p>Для установки менеджера безопасности в качестве текущего вызывается
метод setSecurityManager() в классе System. Соответственно, для его получения нужно вызвать метод getSecurityManager().

</p>
<p>В большинстве случаев, если приложение запускается локально, будут
разрешены все действия, поскольку в системе SecurityManager отсутствует.
Предполагается, что запускаемому локально приложению можно полностью доверять.
Если же приложение может быть опасно (например, его код был загружен из сети,
как это происходит
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>в случае апплетов), то менеджер безопасности выставляется и
его уже нельзя убрать или заменить (попытки вызовут SecurityException). Он контролирует работу с локальной файловой системой, сетевыми
соединениями, потоками исполнения и т.д.

</p>
<p> 

</p>
<p>System

</p>
<p>Класс System содержит набор
полезных статических методов и полей. Экземпляр этого класса не может быть
создан или получен.

</p>
<p>Пожалуй, наиболее широко используемой возможностью, предостав­ляемой System, является
стандартный вывод, доступный через перемен­ную System.out. Ее тип — PrintStream (потоки данных
будут подробно рас­сматриваться в лекции 15). Стандартный вывод можно
перенаправить в другой поток (файл, массив байт и т.д., главное, чтобы это был
объект PrintStream):

</p>
<p>public static void main(String[] args) { System.out.println("Study
Java"); try{

</p>
<p>PrintStream print = new PrintStream(new

</p>
<p>FileOutputStream("d:\\file2.txt"));
System.setOut(print); System.out.println("Study well"); } catch(FileNotFoundException
e) { e. pri ntStackTrace();

</p>
<p>}

</p>
<p>}

</p>
<p>При запуске этого кода на экран будет выведено только Study Java

</p>
<p>И в файл "d:\file2.txt" будет записано Study well

</p>
<p>Аналогично могут быть
перенаправлены стандартный ввод System.in

</p>
<p>-    вызовом System.setln(lnputStream) и поток вывода сообщений об ошибках System.err - вызовом System.setErr(PrintStream) (по умолча­нию все потоки - in, out, err — работают с консолью приложения).

</p>
<p>Следующие методы класса System позволяют работать
с некоторыми параметрами системы:

</p>
<p>•    public static void runFinalizersOnExit(boolean value) - определяет, будет ли производиться вызов метода finalizeO у всех объектов (у кого еще не вызывался), когда выполнение программы
будет окончено (по умолчанию выставлено значение false);

</p>
<p>•   
public static native long currentTimeMillis() - возвращает текущее время; это время представляется как количество
миллисекунд, прошедших с I января 1970 года;

</p>
<p>•    public static String getProperty(String key) - возвращает значение свойства с именем key.

</p>
<p>Чтобы получить все свойства, определенные в системе, можно вос­пользоваться
следующим методом:

</p>
<p>•  public static java.util.Properties getProperties()
- возвращает объект java.util.Properties, в котором содержатся значения всех определенных системных свойств.

</p>
<p>Метод arrayCopy(Object source,
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>int srcPos, Object target, inttrgPos, int length) предоставляет возможность быстрого копирования содержимого одного
массива в другой. Первый параметр задает исходный массив, второй

</p>
<p>— номер позиции, начиная с
которого брать элементы для копирования. Третий параметр - массив-«получатель»,
четвертый - номер позиции в нем, начиная с которого будут записываться
скопированные элементы. Нако­нец, последний параметр задает количество
элементов, которые надо скопировать. Оба массива должны быть созданы, иметь
совместимые ти­пы и достаточную длину, иначе будут сгенерированы
соответствующие исключения.

</p>
<p> 

</p>
<p>Runtime

</p>
<p>Во время исполнения приложению Java сопоставляется экземпляр класса Runtime. Этот объект
позволяет взаимодействовать с окружением, в котором запущена Java-программа.
Получить его можно с помощью статического метода Runtime.getRuntime().

</p>
<p>Объект этого класса:

</p>
<p>•   
public void exit(int status) - осуществляет завершение программы с кодом завершения status (при использовании этого метода особое внимание нужно уделить обработке
исключений — выход будет осуществлен моментально и в конструкциях try-catch-finally управ­ление в finally передано не будет);

</p>
<p>•   
public native void gc() - сигнализирует сборщику мусора о необ­ходимости запуска;

</p>
<p>•   
public void runFinalization() - производит запуск выполнения ме­тодов finalize() у всех объектов,
этого ожидающих;

</p>
<p>•   
public native long freeMemory() - возвращает количество свобод­ной памяти, доступной приложению JVM. В некоторых
случаях это количество может быть увеличено, если вызвать у объекта Runtime метод дс();

</p>
<p>•   
public native long totalMemory() - возвращает суммарное количе­ство памяти, выделенное Java-машине. Это
количество может из­меняться даже в течение одного запуска, что зависит от
реализа­ции платформы, на которой запущена Java-машина. Также не
сто­ит закладываться на объем памяти, занимаемой одним определен­ным объектом,
- эта величина тоже зависит от реализации Java-машины;

</p>
<p>•   
public void loadLibrary(String libname) - загружает библиотеку с указанным именем.

</p>
<p>Обычно загрузка библиотек производится следующим образом: в классе,
использующем native реализации методов,
добавляется статичес­кий инициализатор, например:

</p>
<p> 

</p>
<p>static { System.loadLibraryC'LibFile");}

</p>
<p> 

</p>
<p>Таким образом, когда класс будет загружен и инициализирован, необходимый
код для реализации native методов также будет
загружен
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Если будет произведено несколько вызовов загрузки библиотеки с одним и тем же именем, произведен
будет только первый, а все остальные будут проигнорированы.

</p>
<p>•   
public void load(String filename) - подгружает файл с указанным названием в качестве библиотеки. В
принципе, этот метод работа­ет так же, как и метод loadLibrary(), только принимает в качестве параметра именно название файла, а не
библиотеки, тем самым позволяя загрузить любой файл с native кодом;

</p>
<p>•   
public Process exec(String command) - в отдельном процессе за­пускает команду, представленную переданной
строкой. Возвраща­емый объект Process может быть
использован для взаимодействия с этим процессом.

</p>
<p>Process

</p>
<p>Объекты этого класса получаются вызовом метода ехес() у
объекта Runtime, запускающего отдельный процесс. Объект класса Process мо­жет использоваться для управления процессом и получения информации о
нем.

</p>
<p>Process - абстрактный класс, определяющий, какие методы должны присутствовать в
реализациях для конкретных платформ. Объекты класса Process:

</p>
<p>•    public InputStream getlnputStream() - дает возможность получать поток ввода процесса;

</p>
<p>•    getErrorStream(), getOutputStream() - методы, аналогичные getlnputStream(), но получающие, соответственно, стандартные потоки сообщений об
ошибках и вывода;

</p>
<p>•    public void destroy() — уничтожает
процесс; все подпроцессы, запущенные из него, также будут уничтожены;

</p>
<p>•    public int exitValueQ - возвращает код завершения процесса; по соглашению, код завершения,
равный 0, означает нормальное завершение;

</p>
<p>•    public int waitFor() - вынуждает текущий поток выполнения при­остановиться до тех пор, пока
не будет завершен процесс, пред­ставленный этим экземпляром Process; возвращает
значение кода завершения процесса.

</p>
<p>Даже если в приложении Java не будет ни одной
ссылки на объект Process, процесс не будет уничтожен и будет продолжать асинхронно вы­полняться
до своего завершения. Спецификацией не оговаривается меха­низм, с помощью
которого будет выделяться процессорное время на вы­полнение процессов Process и потоков Java. Поэтому при проектирова­нии программ не стоит полагаться ни на какой
из них, так как различные Java-машины могут демонстрировать различное поведение.

</p>
<p> 

</p>
<p> 

</p>
<p>Потоки исполнения

</p>
<p>Многопоточная архитектура в Java была подробно рассмотрена в лекции 12. Остановимся более подробно на
методах применяемых классов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Runnable

</p>
<p>Runnable — это интерфейс, содержащий один-единственный метод без параметров: run().

</p>
<p>Thread

</p>
<p>Объекты этого класса представляют возможность запускать и управлять
потоками исполнения.

</p>
<p>Итак, для управления
потоками в классе Thread предусмотрены следующие методы:

</p>
<p>•   
public void
start() — производит запуск нового
потока;

</p>
<p>•    public final void join() — если поток А вызывает этот метод у объекта Thread, представляющего
поток В (threadB.join()), то выполнение потока А приостанавливается до тех пор, пока не закончит
выпол­нение поток В;

</p>
<p>•   
public static void
yield() — поток, из которого
вызван этот метод, временно приостанавливается, чтобы дать возможность выпол­няться
другим потокам;

</p>
<p>•   
public static void
sleep(long millis) — поток, из которого
вызван этот метод, перейдет в состояние "сна" на указанное количество
миллисекунд, после чего сможет продолжить выполнение. При этом нужно учесть,
что через время millis миллисекунд этому потоку может быть выделено процессорное время, а
может, ему придется и подождать немного дольше. Можно сказать, что поток
продолжит выполнение не раньше, чем через время millis миллисекунд.

</p>
<p>Существует еще несколько методов, которые объявлены deprecated и рекомендуется их избегать. Это: suspend() — временно прекратить выпол­нение, resume() - продолжить выполнение (приостановленное вызовом suspend()), stop() - остановить выполнение потока.

</p>
<p>При вызове метода stop() в потоке, который представляет этот объ­ект Thread, будет брошена
ошибка ThreadDeath. Этот класс унаследован от Error. Если ошибка не
будет обработана в программе и, соответственно, произойдет прекращение работы
потока, сообщение о ненормальном за­вершении выведено не будет, так как такое
завершение рассматривается как нормальное. Если же в программе эта ошибка
обрабатывается (напри­мер, для проведения каких-то дополнительных действий
перед закрытием потока), то очень важно позаботиться о том, чтобы эта же ошибка
была брошена дальше, чтобы поток действительно закончил свое выполнение. Класс ThreadDeath специально унаследован от Error, а не от Exception, так как очень часто используется перехват всех исключений класса Exception, что не позволит корректно остановить поток.

</p>
<p>Также Thread позволяет
выставлять такие свойства потока, как:

</p>
<p>•    Name — значение типа String, которое можно
использовать для более наглядного обращения с потоками в группе;

</p>
<p>•    Daemon — выполнение
программы не будет прекращено до тех пор, пока выполняется хотя бы один не daemon поток;

</p>
<p>• Priority - определяет приоритет потока. В классе Thread определе­ны
константы, задающие минимальное и максимальное значения для приоритетов
потока,- MINPRIORITYm MAXPRIORITY, а также значение приоритета по умолчанию — NORM__PRIORITY. Эти свойства могут быть изменены только до того момента, когда поток
будет запущен, то есть вызван метод start() объекта Thread.

</p>
<p>Получить эти значения можно, конечно же, в любой момент жизни потока — и
после его запуска, и после прекращения выполнения. Также можно узнать, в каком
состоянии сейчас находится поток: вызовом методов isAlive() — выполняется ли еще, islnterrupted()
- прерван ли.

</p>
<p> 

</p>
<p>ThreadGroup

</p>
<p>Для того, чтобы отдельный поток не мог начать останавливать и пре­рывать
все потоки подряд, введено понятие группы. Поток может оказы­вать влияние
только на потоки, которые находятся в одной с ним группе. Группу потоков
представляет класс ThreadGroup. Такая организация поз­воляет защитить потоки от нежелательного внешнего
воздействия. Группа потоков может содержать другие группы, что позволяет
организовать все потоки и группы в иерархическое дерево, в котором каждый
объект ThreadGroup, за исключением корневого, имеет родителя.

</p>
<p>Класс ThreadGroup обладает методами для изменениях свойств всех входящих в него потоков,
таких, как приоритет, daemon и т.д. Метод list() позволяет получить список потоков.

</p>
<p> 

</p>
<p>Исключения

</p>
<p>Подробно механизм использования исключений описан в лекции 10. Здесь
остановимся только на том, что базовым классом для всех исключений является
класс Throwable. Любой класс, который планируется использовать как исключение, должен
явным или неявным образом наследоваться от него. Класс Throwable, а также наиболее значимые его наследники - классы Error, Exception, RuntimeException, — содержатся именно в пакете java.lang.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции мы рассказали о назначении и возможностях классов,
представленных в пакете java.lang. Как Вы теперь знаете, пакет java.lang автоматически импортируется во все Java программы и
содержит фунда­ментальные классы и интерфейсы, которые составляют основу для
других пакетов Java.

</p>
<p>Были рассмотрены все
наиболее важные классы пакета java.lang:








</p>
<p>•  Object, Class — основные классы, представляющие объект и класс объектов;

</p>
<p>•  классы-обертки (Wrapper классы) — служат
для представления примитивных значений в виде объектов, так как многие классы
работают именно с объектами;

</p>
<p>•    Math — класс, предоставляющий набор статических методов, реа­лизующих базовые
математические функции;

</p>
<p>•   
String и StringBuffer — классы для работы
со строками;

</p>
<p>•  System, Runtime, Process, ClassLoader, SecurityManager - сис­темные
классы, помогающие взаимодействовать с программным окружением (System, Runtime, Process), загружать классы
в JVM (ClassLoader) и управлять безопасностью (SecurityManager);

</p>
<p>•  Thread, ThreadGroup, Runnable - типы,
обеспечивающие работу с потоками исполнения в Java;

</p>
<p>•  Throwable, Error, Exception, RuntimeException - базовые классы для всех исключений.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>I   
В чем особенность класса-обертки для void?

</p>
<p>р|  
никаких отличительных особенностей нет

</p>
<p>pi   этот
класс, в отличие от остальных классов-оберток, не реализует

</p>
<p>интерфейс java.io.Serializable PI   он
не имеет открытого конструктора. Более того, экземпляр

</p>
<p>этого
класса вообще не может быть получен Q   в пакете java.lang отсутствует
класс java.lang.Void

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Какие
модификаторы присутствуют в определении класса
Math?

</p>
<p>D   Public Q   abstract

</p>
<p>&#9633;          
final

</p>
<p>&#9633;          
static

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Какой
класс используется для представления модифици-
руемых строк?

</p>
<p>&#9633;       String

</p>
<p>П   StringTokenizer

</p>
<p>&#9633;       
StringBuffer

</p>
<p>&#9633;       
StringEditable

</p>
<p>&#9633;        EditableString








</p>
<p> 








</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.       Классы
каких базовых исключений определены в пакете
java.lang?

</p>
<p>&#9633;       
Throwable

</p>
<p>&#9633;       
Error

</p>
<p>&#9633;       
Exception

</p>
<p>[~l   RuntimeException

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Какие
утверждения относительно клонирования верны?

</p>
<p>Г~|  
если клонирование производится встроенным методом Object.clone(), то такие классы необходимо
специальным образом помечать, указывая, что они реализуют интерфейс Cloneable

</p>
<p>П   для
клонирования классов, в которых переопределен метод clone() собственным образом, можно
обойтись без интерфейса Cloneable

</p>
<p>П   если
производится попытка клонирования объекта, не реализующего интерфейс Cloneable, ошибка возникнет еще на этапе
компиляции

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Какие классы и интерфейсы, необходимые для поддержки многопоточности,
определены в пакете java.lang?

</p>
<p>&#9633;       
Thread

</p>
<p>&#9633;       
Runnable

</p>
<p>Q   Threadlterator

</p>
<p>&#9633;       ThreadException П   RunnableException

</p>
<p> 

</p>
<p> 

</p>
<p>2.   Какие утверждения относительно использования
метода newlnstance()
объектов типа Class для создания экземпляров
соответствующего класса верны?

</p>
<p>|~1   вызов этого метода создает объект
класса, который представляется данным экземпляром Class

</p>
<p>1~1   создание
будет происходить с помощью вызова конструктора без параметров

</p>
<p>Г")   класс
не должен быть абстрактным








</p>
<p> 








</p>
<p>3.   Для каких примитивных типов Java существуют
классы-обертки?

</p>
<p>[~|  
для всех примитивных типов, включая void

</p>
<p>|~|  
для всех примитивных типов, кроме void

</p>
<p>Г"|   только
для числовых (byte, int, short, float, double) и
void

</p>
<p>3.   Если в классе переопределяется метод т.о5тппд(), какой еще метод
необходимо переопределить для корректного использования объектов этого класса в
хэш-таблицах?

</p>
<p>&#9633;       
ециа^О

</p>
<p>&#9633;       
(таэИСойеО

</p>
<p>&#9633;       
никакой








</p>
<p>
</p>
<center> 
</center>
    </div>