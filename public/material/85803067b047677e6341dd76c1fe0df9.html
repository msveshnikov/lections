# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 7. Преобразование типов</h2></center>

<p> 

</p>
<p>Эта лекция посвящена вопросам преобразования типов.
Поскольку Java _ язык строго
типизированный, компилятор и виртуальная машина всегда следят за работой с
типами, гарантируя надежность выполнения программы. Однако во многих случаях то
или иное преобразование необходимо осущест­вить для реализации логики
программы. С другой стороны, некоторые безо­пасные переходы между типами Java позволяет осуществлять неявным для разработчика
образом, что может привести к неверному пониманию работы программы.

</p>
<p>В лекции рассматриваются все виды преобразований, а
затем все ситу­ации в программе, где они могут применяться. В заключение
приводится на­чало классификации типов переменных и типов значений, которые они
мо­гут хранить. Этот вопрос будет подробнее рассматриваться в следующих лекциях.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Как уже говорилось, Java является строго
типизированным языком, а это означает, что каждое выражение и каждая переменная имеет строго
определенный тип уже на момент компиляции. Тип устанавливается на основе
структуры применяемых выражений и типов литералов, перемен­ных и методов,
используемых в этих выражениях.

</p>
<p>Например:

</p>
<p>long а=3; а = 5+'А'+а;

</p>
<p>print("a="+Math.round(a/2F));

</p>
<p> 

</p>
<p>Рассмотрим, как в этом примере компилятор устанавливает тип каждого выражения и какие преобразования (conversion) типов необходи­мо осуществить при каждом действии.

</p>
<p>•   
В первой строке литерал 3
имеет тип по умолчанию, то есть int. При присвоении этого значения переменной типа long необходимо провести преобразование.

</p>
<p>•    Во второй строке сначала производится сложение значений типа int и char. Второй аргумент
будет преобразован так, чтобы опера­ция проводилось с точностью в 32 бита.
Второй оператор сложения опять потребует преобразования, так как наличие
переменной а увеличивает точность до 64 бит.








</p>
<p>•  В третьей строке сначала будет выполнена операция деления, для чего
значение long надо будет привести
к типу float, так как второй операнд - дробный литерал. Результат будет передан в
метод Math.round, который
произведет математическое округление и вернет целочисленный результат типа int. Это значение
необходимо преобразовать в текст, чтобы осуществить дальнейшую конкатена­цию
строк. Как будет показано ниже, эта операция проводится в два этапа - сначала
простой тип приводится к объектному классу-&amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>обертке" (в данном случае
int к Integer), а затем у полученного объ­екта вызывается метод toString(), что дает
преобразование к стро­ке.

</p>
<p>Данный пример показывает, что даже простые строки могут содер­жать
многочисленные преобразования, зачастую незаметные для разра­ботчика. Часто
бывают и такие случаи, когда программисту необходимо явно изменить тип
некоторого выражения или переменной, например, чтобы воспользоваться подходящим
методом или конструктором.

</p>
<p>Вспомним уже рассмотренный
пример:

</p>
<p>byte b=1;

</p>
<p>byte c=(byte)-b;

</p>
<p>int i=c;

</p>
<p> 

</p>
<p>Здесь во второй строке необходимо провести явное преобразование, чтобы
присвоить значение типа byte переменной типа int. В третьей же строке обратное приведение производится автоматически,
неявным для разработчика образом.

</p>
<p>Рассмотрим сначала, какие переходы между различными типами можно
осуществить.

</p>
<p> 

</p>
<p>Виды приведений

</p>
<p>В Java предусмотрено семь видов приведений:

</p>
<p>•   
тождественное (identity);

</p>
<p>•   
расширение примитивного
типа (widening primitive);

</p>
<p>•   
сужение примитивного типа (narrowing primitive);

</p>
<p>•   
расширение объектного типа
(widening reference);

</p>
<p>•   
сужение объектного типа (narrowing reference);

</p>
<p>•   
преобразование к строке (String);

</p>
<p>•   запрещенные преобразования (forbidden). Рассмотрим их по отдельности.

</p>
<p>Тождественное
преобразование

</p>
<p>Самым простым является тождественное преобразование. В Java пре­образование выражения любого типа к точно такому же типу всегда допу­стимо
и успешно выполняется.

</p>
<p>Зачем нужно тождественное приведение? Есть две причины для to­po, чтобы выделить
такое преобразование в особый вид.

</p>
<p>Во-первых, с теоретической точки зрения теперь можно утверждать, что
любой тип в Java может участвовать в преобразовании, хотя бы в тож­дественном. Например,
примитивный тип boolean нельзя привести ни
к какому другому типу, кроме него самого.

</p>
<p>Во-вторых, иногда в Java могут встречаться
такие выражения, как длинный последовательный вызов методов:

</p>
<p>print(getCity().getStreet().getHouse().getFlat().getRoom());

</p>
<p>При исполнении такого выражения сначала вызывается первый ме­тод getCity(). Можно
предположить, что возвращаемым значением будет объект класса City. У этого объекта
далее будет вызван следующий метод getStreet(). Чтобы узнать, значение какого типа он вернет, необходимо посмотреть
описание класса City. У этого значения будет вызван следую­щий метод (getHouse()), и так далее
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Чтобы узнать результирующий тип всего выражения, необходимо
просмотреть описание каждого метода и класса.

</p>
<p>Компилятор без труда справится с такой задачей, однако разработ­чику
будет нелегко проследить всю цепочку. В этом случае можно вос­пользоваться
тождественным преобразованием, выполнив приведение к точно такому же типу. Это
ничего не изменит в структуре программы, но значительно облегчит чтение кода:

</p>
<p>print((MyFlatlmpl)(getCity().getStreet().getHouse().getFlat()));

</p>
<p> 

</p>
<p> 

</p>
<p>Преобразование
примитивных типов (расширение и сужение)



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>простой тип, расширение
  </p>
</td>
 </tr>
</table>



<p>Очевидно, что следующие четыре вида приведений легко представ­ляются в
виде таблицы 7.1.



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="15">
 <tr>
  <td valign="top" align="left" height="15">
  <p>Простой тип, сужение
  </p>
</td>
 </tr>
</table>



<p> 

</p>
<p>ссылочный тип, расширение

</p>
<p>ссылочный тип, сужение








</p>
<p> 

</p>
<p>Табл. 7.1. Виды приведений.








</p>
<p>Что все это означает? Начнем по порядку. Для простых типов расши­рение
означает, что осуществляется переход от менее емкого типа к более емкому.
Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразования безопасны в том смысле, что новый
тип всегда га­рантированно вмещает в себя все данные, которые хранились в
старом типе, и таким образом не происходит потери данных. Именно поэтому
компилятор осуществляет его сам, незаметно для разработчика:

</p>
<p> 

</p>
<p>byte b=3; int a=b;

</p>
<p> 

</p>
<p>В последней строке значение переменной b типа byte будет преобра­зовано
к типу переменной а (то есть, int) автоматически, никаких специ­альных действий для этого предпринимать не
нужно.

</p>
<p>Следующие 19
преобразований являются расширяющими:

</p>
<p>•    от byte к short, int, long,
float, double

</p>
<p>•    от short к int, long,
float, double

</p>
<p>•    от char к int, long,
float, double

</p>
<p>•    от int к long, float, double

</p>
<p>•   
от long к float, double

</p>
<p>•   
от float к double

</p>
<p>Обратите внимание, что нельзя провести преобразование к типу char от типов меньшей или равной длины (byte, short), или, наоборот, к short от char без потери данных.
Это связано с тем, что char, в отличие от осталь­ных целочисленных типов, является беззнаковым.

</p>
<p>Тем не менее, следует помнить, что даже при расширении данные все-таки
могут быть в особых случаях искажены. Они уже рассматривались в предыдущей
лекции, это приведение значений int к типу float и приведение
значений типа long к типу float или double. Хотя эти дробные типы вмеша­ют гораздо большие числа, чем
соответствующие целые, но у них меньше значащих разрядов.

</p>
<p>Повторим этот пример:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>long
a=111111111111L; float f = a; a = (long) f; print(a);

</p>
<p>Результатом будет: 111111110656

</p>
<p>Обратное преобразование — сужение — означает, что переход осуще­ствляется
от более емкого типа к менее емкому. При таком преобразова­ли есть риск потерять
данные. Например, если число типа int было боль­ше 127,
то при приведении его к byte значения битов старше восьмого бу­дут потеряны. В Java такое
преобразование должно совершаться явным образом, т.е. программист в коде должен
явно указать, что он намеревает­ся осуществить такое преобразование и готов
потерять данные.

</p>
<p>Следующие 23
преобразования являются сужающими:

</p>
<p>•   
от byte к char

</p>
<p>•   
от short к byte, char

</p>
<p>•   
от char к byte, short

</p>
<p>•    от int к byte, short, char

</p>
<p>•    от long к byte,
short, char, int

</p>
<p>•    от float к byte, short, char, int, long

</p>
<p>•    от double к byte, short, char, int, long, float

</p>
<p>При сужении целочисленного типа к более узкому целочисленному все
старшие биты, не попадающие в новый тип, просто отбрасываются. Не производится
никакого округления или других действий для получе­ния более корректного
результата:

</p>
<p> 

</p>
<p>print((byte)383);
print((byte)384); print((byte)-384);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>127

</p>
<p>-128

</p>
<p>-128

</p>
<p> 

</p>
<p>Видно, что знаковый бит при сужении не оказал никакого влияния, так как
был просто отброшен — результат приведения обратных чисел (384 и -384) оказался
одинаковым. Следовательно, может быть потеряно Не только
точное абсолютное значение, но и знак величины.

</p>
<p>Это верно и для типа char:

</p>
<p>char с=40000; Pn'nt((short)c);

</p>
<p>Результатом будет:

</p>
<p>-25536

</p>
<p>Сужение дробного типа до целочисленного является более сложной
процедурой. Она проводится в два этапа.

</p>
<p>На первом шаге дробное значение преобразуется в long, если целе­вым
типом является long, или в int - в противном случае (целевой тип byte, short, char или int). Для этого исходное дробное число сначала ма­тематически округляется в
сторону нуля, то есть дробная часть просто от­брасывается.

</p>
<p>Например, число 3,84 будет округлено до 3, а -3,84 превратится в -3. При
этом могут возникнуть особые случаи:

</p>
<p>•   
если исходное дробное
значение является NaN, то результатом первого шага будет 0 выбранного типа (т.е. int или long);

</p>
<p>•   
если исходное дробное
значение является положительной или от­рицательной бесконечностью, то
результатом первого шага будет, соответственно, максимально или минимально
возможное значе­ние для выбранного типа (т.е. для int или long);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
наконец, если дробное
значение было конечной величиной, но в результате округления получилось слишком
большое по модулю число для выбранного типа (т.е. для int или long), то, как и в пре­дыдущем
пункте, результатом первого шага будет, соответственно, максимально или
минимально возможное значение этого типа. Если же результат округления
укладывается в диапазон значений выбранного типа, то он и будет результатом
первого шага.

</p>
<p>На втором шаге производится дальнейшее сужение от выбранного
целочисленного типа к целевому, если таковое требуется, то есть может иметь
место дополнительное преобразование от int к byte, short или char.

</p>
<p>Проиллюстрируем описанный алгоритм преобразованием от беско­нечности ко
всем целочисленным типам:

</p>
<p>float
fmin = Float. NEGATIVEJNFINITY; float fmax = Float.POSITIVEJNFINITY;
printflong: " + (long)fmin +     + (long)fmax); printfint: " + (int)fmin
+     + (int)fmax); print("short: " + (short)fmin +     + (short)fmax);
print("char: " + (int)(char)fmin +     + (int)(char)fmax); print("byte:
" + (byte)fmin +     + (byte)fmax);

</p>
<p>Результатом будет:

</p>
<p>long: -9223372036854775808. .9223372036854775807 int: -2147483648..2147483647
short: 0..-1 char: 0..65535 byte: 0..-1

</p>
<p>Значения long и int вполне очевидны -
дробные бесконечности Преобразовались в, соответственно, минимально и
максимально воз­можные значения этих типов. Результат для следующих трех типов /short, char, byte) есть, по сути,
дальнейшее сужение значений, полу­ченных для int, согласно второму
шагу процедуры преобразования. А делается это, как было описано, просто за счет
отбрасывания старших битов. Вспомним, что минимально возможное значение в
битовом ви­де представляется как 1000..000 (всего 32 бита для int, то есть единица и
31 ноль). Максимально возможное - 1111.. 111 (32 единицы). Отбра­сывая старшие
биты, получаем для отрицательной бесконечности ре­зультат 0, одинаковый для
всех трех типов. Для положительной же бес­конечности получаем результат, все
биты которого равняются 1. Для знаковых типов byte и short такая комбинация
рассматривается как -1, а для беззнакового char - как максимально возможное значение, то есть 65535.

</p>
<p>Может сложиться впечатление, что для char приведение дает точное значение. Однако это был частный случай -
отбрасывание битов в боль­шинстве случаев все же дает искажение. Например,
сужение дробного значения 2 миллиарда:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>float f=2e9f ;

</p>
<p>print((int)(char)f);

</p>
<p>print((int)(char)-f);

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>37888 27648

</p>
<p>Обратите внимание на двойное приведение для значений типа char в двух последних примерах. Понятно, что преобразование от char к int не приводит к потере точности, но позволяет распечатывать не символ, а
его числовой код, что более удобно для анализа.

</p>
<p>В заключение еще раз обратим внимание на то, что примитивные значения
типа boolean могут участвовать
только в тождественных преоб­разованиях.

</p>
<p> 

</p>
<p>Преобразование
ссылочных типов (расширение и сужение)

</p>
<p>Переходим к ссылочным типам. Преобразование объектных типов
&#9632;"Учите всего иллюстрируется с помощью дерева наследования.
Рассмотрим Небольшой пример наследования:








</p>
<p>// Объявляем класс Parent class Parent { intx;

</p>
<p>}

</p>
<p>// Объявляем класс Child и наследуем // его от класса Parent class Child extends Parent { int у;

</p>
<p>}

</p>
<p>// Объявляем второго
наследника // класса Parent - класс Child2 class Child2 extends Parent { int z;

</p>
<p>}

</p>
<p>В каждом классе объявлено поле с уникальным именем. Будем рас­сматривать
это поле как пример набора уникальных свойств, присущих некоторому объектному
типу.

</p>
<p>Три объявленных класса могут порождать три вида объектов. Объ­екты
класса Parent обладают только
одним полем х, а значит, только ссылки типа Parent могут ссылаться на такие объекты. Объекты класса Child обладают полем у и полем х, полученным по наследству от класса Parent. Стало быть, на
такие объекты могут указывать ссылки типа Child или Parent. Второй случай уже иллюстрировался следующим примером:

</p>
<p> 

</p>
<p>Parent р = new Child();

</p>
<p> 

</p>
<p>Обратите внимание, что с помощью такой ссылки р можно обра­щаться лишь к
полю х созданного объекта. Поле у недоступно, так как компилятор, проверяя
корректность выражения р.у, не может предуга­дать, что ссылка р будет указывать
на объект типа Child во время испол­нения
программы. Он анализирует лишь тип самой переменной, а она объявлена как Parent, но в этом классе
нет поля у, что и вызовет ошибку компиляции.

</p>
<p>Аналогично, объекты класса Child2 обладают полем z и полем х, по­лученным по наследству от класса Parent. Значит, на такие
объекты могут указывать ссылки типа Child2 или Parent.

</p>
<p>Таким образом, ссылки типа Parent могут указывать на объект любо­го из трех рассматриваемых типов, а
ссылки типа Child и Child2 - только

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>224

</p>
<p>jja объекты точно такого
же типа. Теперь можно перейти к преобразова­нию ссылочных типов на основе такого дерева наследования.

</p>
<p>Расширение означает переход от более конкретного типа к менее
конкретному, т.е. переход от детей к родителям. В нашем примере преоб­разование
от любого наследника (Child, Child2) к родителю (Parent) есть расширение, переход к более общему типу. Подобно случаю с
примитив­ными типами, этот переход производится самой JVM при необходимости и незаметен для разработчика, то есть не
требует никаких дополнительных усилий, так как он всегда проходит успешно:
всегда можно обращаться к объекту* порожденному от наследника, по типу его
родителя.

</p>
<p>Parent p1-new
Child(); Parent p2=new Child2();

</p>
<p>В обеих строках переменным типа Parent присваивается значение другого типа, а значит, происходит
преобразование. Поскольку это рас­ширение, оно производится автоматически и
всегда успешно.

</p>
<p>Обратите внимание, что при подобном преобразовании с самим объектом
ничего не происходит. Несмотря на то, что, например, поле у класса Child теперь недоступно, это не означает, что оно исчезло. Такое существенное
изменение структуры объекта невозможно. Он был порож­ден от класса Child и сохраняет все его свойства. Изменился лишь тип ссылки, через которую
идет обращение к объекту. Эту ситуацию можно условно сравнить с рассматриванием
некоего предмета через подзорную трубу. Если перейти от трубы с большим
увеличением к более слабой, то видимых деталей станет меньше, но сам предмет,
конечно, никак от это­го не изменится.

</p>
<p>Следующие преобразования являются
расширяющими:

</p>
<p>•    от класса А к классу В, если А наследуется от В (важным частным случаем является преобразование от
любого ссылочного типа к Object);

</p>
<p>•   
от null-типа к любому
объектному типу.

</p>
<p>Второй случай
иллюстрируется следующим примером:

</p>
<p> 

</p>
<p>Parent p=null;

</p>
<p>Пустая ссылка null не обладает
каким-либо конкретным ссылочным ™пом, поэтому иногда говорят о специальном null-типе. Однако на
прак-^е важно, что такое значение можно прозрачно преобразовать к любому 0&amp;ьектному
типу.

</p>
<p>С изучением остальных ссылочных типов (интерфейсов и массивов) список
будет расширяться.

</p>
<p>15 ^ 3440                                                      2 25








</p>
<p>Обратный переход, то есть движение по дереву наследования вниз,ц
наследникам, является сужением. Например, для рассматриваемого слу
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> чая,
переход от ссылки типа Parent, которая может ссылаться на объекты трех классов, к ссылке типа Child, которая может
ссылаться на объекты лишь одного из трех классов, очевидно, является сужением.
Такой пере, ход может оказаться невозможным. Если ссылка типа Parent ссылается на объект типа Parent или Child2, то переход к Child невозможен, ведь в обоих случаях объект не обладает полем у, которое
объявлено в классе Child. Поэтому при сужении разработчику необходимо явным образом указывать на
то, что необходимо попытаться провести такое преобразова­ние. JVM во время исполнения проверит корректность перехода. Если он возможен,
преобразование будет проведено. Если же нет - возникнет ошибка.

</p>
<p> 

</p>
<p>Parent p=new Child();

</p>
<p>Child c=(Child)p; // преобразование будет успешным. Parent p2=new Child2();

</p>
<p>Child c2=(Child)p2; // во время исполнения возникнет ошибка!

</p>
<p> 

</p>
<p>Чтобы проверить, возможен ли желаемый переход, можно восполь­зоваться
оператором instanceof:

</p>
<p> 

</p>
<p>Parent p=new
Child(); if (p instanceof Child) { Child с = (Child)p;

</p>
<p>}

</p>
<p>Parent
p2=newChild2(); if (p2 instanceof Child) { Child с = (Child)p2;

</p>
<p>}

</p>
<p>Parent p3=new
Parent(); if (p3 instanceof Child) { Child с = (Child)p3;

</p>
<p>}

</p>
<p>В данном примере ошибок не возникнет. Первое преобразование возможно, и
оно будет осуществлено. Во втором и третьем случаях условия операторов if не сработают и попыток некорректного перехода не будет.

</p>
<p>На данный момент можно назвать лишь одно сужающее преобраз0'
вание:

</p>
<p>• от класса А к классу В,
если В наследуется от А (важным частным слУ48' ем является сужение
типа Object до любого другого
ссылочного типа)-

</p>
<p>С изучением остальных ссылочных типов (интерфейсов и массивов) эТоТ
список будет расширяться.

</p>
<p> 

</p>
<p>Преобразование
к строке

</p>
<p>Это преобразование уже не раз упоминалось. Любой тип может быть Приведен
к строке, т.е. к экземпляру класса String. Такое
преобразование является исключительным в силу того, что охватывает абсолютно
все ти­пы, в том числе и boolean, про который говорилось, что он не может уча­ствовать ни в каком другом
приведении, кроме тождественного.

</p>
<p>Напомним, как
преобразуются различные типы.

</p>
<p>•   
Числовые типы записываются
в текстовом виде без потери точно­сти представления. Формально такое
преобразование происходит в два этапа. Сначала на основе примитивного значения
порожда­ется экземпляр соответствующего класса-&amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>обертки", а затем у
него вызывается метод toString(). Но поскольку эти действия снаружи незаметны, многие JVM оптимизируют их и преобразуют прими­тивные значения в текст напрямую.

</p>
<p>•    Булевская величина приводится к строке "true" или "false" в зави­симости
от значения.

</p>
<p>•    Для объектных величин вызывается метод toString(). Если метод
возвращает null, то результатом будет строка "null".

</p>
<p>•   
Для null-значения
генерируется строка "null".

</p>
<p> 

</p>
<p>Запрещенные
преобразования

</p>
<p>Не все переходы между произвольными типами допустимы. Напри­мер, к
запрещенным преобразованиям относятся: переходы от любого ссылочного типа к
примитивному, от примитивного - к ссылочному (кро­ме преобразований к строке).
Уже упоминавшийся пример — тип boolean

</p>
<p>-  
нельзя привести ни к
какому другому типу, кроме boolean (как обычно

</p>
<p>-  
за исключением приведения
к строке). Затем, невозможно привести ДРУГ к другу типы, находящиеся не на
одной, а на соседних ветвях дерева наследования. В примере, который
рассматривался для иллюстрации пре­образований ссылочных типов, переход от Child к Child2 запрещен. В са­мом деле, ссылка типа Child может указывать на
объекты, порожденные ^лько от класса Child или его наследников. Это исключает вероятность того, что объект будет
совместим с типом Child2.

</p>
<p>Этим список запрещенных
преобразований не исчерпывается. Он Сольно велик, и в то же время все варианты достаточно очевидны, по-jj^y подробно рассматриваться не будут. Желающие могут получить
пол-информацию из спецификации.








</p>
<p>Разумеется, попытка осуществить запрещенное преобразование ць,
зовет ошибку компиляции.

</p>
<p> 

</p>
<p>Применение приведений

</p>
<p>Теперь, когда рассмотрены
все виды преобразований, перейдем к ситуациям в коде, где могут
встретиться или потребоваться приведения. Такие ситуации могут быть
сгруппированы следующим образом.

</p>
<p>•   
Присвоение значений
переменным (assignment). Не все переходы допустимы при таком преобразовании - ограничения
выбраны та­ким образом, чтобы не могла возникнуть ошибочная ситуация.

</p>
<p>•   
Вызов метода. Это
преобразование применяется к аргументам вы­зываемого метода или конструктора.
Допускаются почти те же пе­реходы, что и для присвоения значений. Такое приведение никогда не порождает ошибок. Так же приведение осуществляется при воз­вращении
значения из метода.

</p>
<p>•   
Явное приведение
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В этом
случае явно указывается, к какому типу требуется привести исходное значение.
Допускаются все виды пре­образований, кроме приведений к строке и запрещенных. Может возникать ошибка времени исполнения программы.

</p>
<p>•   
Оператор конкатенации
производит преобразование к строке своих аргументов.

</p>
<p>•   
Числовое расширение (numeric promotion). Числовые операции могут потребовать изменения типа аргумента(ов). Это
преобразо­вание имеет особое название — расширение (promotion), так как выбор целевого типа может зависеть не только от исходного
значе­ния, но и от второго аргумента операции.

</p>
<p>Рассмотрим все случаи
более подробно.

</p>
<p> 

</p>
<p>Присвоение
значений

</p>
<p>Такие ситуации неоднократно применялись в этой лекции для иллю­страции
видов преобразования. Приведение может потребоваться, если переменной одного
типа присваивается значение другого типа. Возможны следующие комбинации.

</p>
<p>Если сочетание этих двух типов образует запрещенное приведение возникнет
ошибка. Например, примитивные значения нельзя присваи­вать объектным
переменным, включая следующие примеры:

</p>
<p> 

</p>
<p>// пример вызовет ошибку
компиляции

</p>
<p> 

</p>
<p>//
примитивное значение нельзя // присвоить объектной переменной

</p>
<p>228

</p>
<p>parent р = 3;

</p>
<p>//
приведение к классу-"обертке" также запрещено Long a=5L;

</p>
<p>//
универсальное приведение к строке // возможно только для оператора + String s=true;

</p>
<p>Далее, если сочетание этих двух типов образует расширение (прими­тивных
или ссылочных типов), то оно будет осуществлено автоматичес­ки, неявным для
разработчика образом:

</p>
<p>int &#161;=10; long a=i;

</p>
<p>Child с = new Child(); Parent p=c;

</p>
<p>Если же сочетание оказывается сужением, то возникает ошибка компиляции,
такой переход не может быть проведен неявно:

</p>
<p>// пример вызовет ошибку компиляции int &#161;=10;

</p>
<p>short s=i; // ошибка! сужение!

</p>
<p>Parent р = new Child();

</p>
<p>Child c=p; // ошибка! сужение!

</p>
<p>Как уже упоминалось, в подобных случаях необходимо выполнять
преобразование явно:

</p>
<p>int i=10; short s=(int)i; Parent p =
new Child(); Child c=(Child)p;

</p>
<p>Более подробно явное
сужение рассматривается ниже. Здесь может вызвать удивление следующая ситуация,
которая не по­рождает ошибок компиляции:

</p>
<p>byte b=1; short s=2+3; char c=(byte)5+'a';








</p>
<p> 

</p>
<p>В первой строке переменной типа byte присваивается
значение цело, численного литерала типа int, что является
сужением. Во второй строке переменной типа short присваивается
результат сложения двух литералов типа int, а тип этой суммы
также int
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Наконец, в третьей строке перемен­ной типа char присваивается результат сложения числа 5, приведенного к типу byte, и символьного
литерала.

</p>
<p>Однако все эти примеры корректны. Для удобства разработчика компилятор
проводит дополнительный анализ при присвоении значе­ний переменным типа byte, short и char. Если таким переменным при­сваивается величина типа byte, short, char или int, причем ее значение может быть получено уже на момент компиляции, и
оказывается, что это значение укладывается в диапазон типа переменной, то
явного приведе­ния не требуется. Если бы такой возможности не было, пришлось бы
пи­сать так:

</p>
<p> 

</p>
<p>byte
b=(byte)1 ; // преобразование
необязательно short
s=(short)(2+3); // преобразование
необязательно char c=(char)((byte)5+'a'); // преобразование необязательно

</p>
<p>// преобразование
необходимо, так как // число 200 не укладывается в тип byte byte b2=(byte)200;

</p>
<p> 

</p>
<p> 

</p>
<p>Вызов
метода

</p>
<p>Это приведение возникает в случае, когда вызывается метод с объяв­ленными
параметрами одних типов, а при вызове передаются аргументы других типов.
Объявление методов рассматривается в следующих лекциях курса, однако такой
простой пример вполне понятен:

</p>
<p> 

</p>
<p>// объявление метода с параметром типа long void calculate(long I) {

</p>
<p> 

</p>
<p>}

</p>
<p>void main() { calculated);

</p>
<p>}

</p>
<p>Как видно, при вызове метода передается значение типа int, а ч&#163; long, как определено в объявлении
этого метода.

</p>
<p>sP^-                                                —=-------------- !— ---------- =--------- ц

</p>
<p>Здесь компилятор предпринимает те же шаги, что и при приведении в
процессе присвоения значений переменным. Если типы образуют за­прещенное
преобразование, возникнет ошибка.

</p>
<p>// пример вызовет ошибку компиляции

</p>
<p>void calculate(long а) {

</p>
<p> 

</p>
<p>}

</p>
<p>void main() {

</p>
<p>calculate(new Long(5)); // здесь будет ошибка

</p>
<p>}

</p>
<p>Если сужение, то компилятор не сможет осуществить приведение и
потребуются явные указания.

</p>
<p>void calculate(int а) { }

</p>
<p>void main() { long a=5;

</p>
<p>// calculate(a); // сужение! так будет ошибка. calculate((int)a);
// корректный вызов

</p>
<p>}

</p>
<p>Наконец, в случае расширения, компилятор осуществит приведение сам, как
и было показано в примере в начале этого раздела.

</p>
<p>Надо отметить, что, в отличие от ситуации присвоения, при вызове Методов
компилятор не производит преобразований примитивных значе­ний от byte, short, char или int к byte, short или char. Это привело бы к Усложнению работы с перегруженными методами.
Например:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>// пример вызовет ошибку компиляции

</p>
<p>// объявляем
перегруженные методы // с аргументами (byte, int) и (short, short) int m(byte a, int b) {return a+b;} int m(short a, short b) {return a-b;}

</p>
<p> 

</p>
<p>void main() {

</p>
<p>print(m(12, 2)); // ошибка компиляции!








</p>
<p>В этом примере компилятор выдаст ошибку, так как при вызове аргу. менты
имеют тип (int, int), а метода с такими параметрами нет. Если бы компилятор проводил
преобразование для целых величин, подобно ситуа­ции с присвоением значений, то
пример стал бы корректным, но пришлось бы прилагать дополнительные усилия,
чтобы указать, какой из двух воз­можных перегруженных методов хотелось бы
вызвать.

</p>
<p>Аналогичное преобразование потребуется при возвращении значения из
метода, если тип результата и заявленный тип возвращаемого значения не
совпадают.

</p>
<p>long get() { return 5;

</p>
<p>}

</p>
<p>Хотя в выражении return указан целочисленный литерал типа int, во всех местах, где
будет вызван этот метод, будет получено значение типа long. Для такого
преобразования действуют те же правила, что и для при­своения значения.

</p>
<p>В заключение рассмотрим пример, включающий в себя все рассмот­ренные
случаи преобразования:

</p>
<p>short get(Parent р) {

</p>
<p>return 5+'А'; // приведение при возвращении значения

</p>
<p>}

</p>
<p>void maino {

</p>
<p>long а = // приведение
при присвоении значения get(new
ChildO); // приведение при вызове
метода

</p>
<p>}

</p>
<p> 

</p>
<p> 

</p>
<p>Явное
приведение

</p>
<p>Явное приведение уже многократно использовалось в примерах-При таком
преобразовании слева от выражения, тип значения которого необходимо
преобразовать, в круглых скобках указывается целевой тип. Если преобразование
пройдет успешно, то результат будет точно указан­ного типа. Примеры:

</p>
<p> 

</p>
<p>(Ьуте)5

</p>
<p>(Рагепт)пе\л/ СЫЩ)

</p>
<p>(Р1а^детСпу().дет3^ееф.деШои5е().дегР1а1()

</p>
<p>Если комбинация типов образует запрещенное преобразование, розникает
ошибка компиляции. Допускаются тождественные преобразо­вания, расширения
простых и объектных типов, сужения простых и объ­ектных типов. Первые три
всегда выполняются успешно. Последние два щогут стать причиной ошибки
исполнения, если значения оказались несо­вместимыми. Как следствие, выражение null всегда может быть успешно дреобразовано к любому ссылочному типу.

</p>
<p>Но можно найти способ все-таки закодировать запрещенное преоб­разование.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Child c^new Child();

</p>
<p>// Child2 c2=(Child2)c; // запрещенное преобразование Parent p=c; // расширение Child2 c2=(Child2)p; // сужение

</p>
<p>Такой код будет успешно скомпилирован, однако, разумеется, при
исполнении он всегда будет генерировать ошибку в последней строке.
"Обманывать" компилятор смысла нет.

</p>
<p> 

</p>
<p>Оператор
конкатенации строк

</p>
<p>Этот оператор уже рассматривался достаточно подробно. Если обо­ими его
аргументами являются строки, то происходит обычная конкате­нация. Если же тип String имеет лишь один из аргументов, то второй не­обходимо преобразовать в
текст. Это единственная операция, при кото­рой производится универсальное
приведение любого значения к типу String.

</p>
<p>Это одно из свойств, выделяющих класс String из общего ряда. Правила преобразования уже были подробно описаны в этой
лекции, а оператор конкатенации рассматривался в лекции "Типы
данных". Небольшой пример:

</p>
<p> 

</p>
<p>int &#161;=1;

</p>
<p>double
d=i/2.; String
s="text";

</p>
<p>print("i="+i+", d="+d+",
s="+s); Результатом будет: i=1, d=0.5, s=text

</p>
<p>Числовое
расширение

</p>
<p>Наконец, последний вид преобразований применяется при число­вых
операциях, когда требуется привести аргумент(ы) к типу длиной в 32 или 64 бита
для проведения вычислений. Таким образом, при числовом расширении
осуществляется только расширение примитивных типов.

</p>
<p>Различают унарное и
бинарное числовое расширение.

</p>
<p> 

</p>
<p>Унарное числовое расширение

</p>
<p>Это преобразование расширяет примитивные типы byte, short или char до типов int по правилам
расширения примитивных типов.

</p>
<p>Унарное числовое расширение может выполняться при следующих операциях:

</p>
<p>•   
унарные операции + и -;

</p>
<p>•   
битовое отрицание ~;

</p>
<p>•   
операции битового сдвига
«, &gt;&gt;, &gt;&gt;&gt;.

</p>
<p>Операторы сдвига имеют два аргумента, но они расширяются неза­висимо
друг от друга, поэтому данное преобразование является унарным. Таким образом,
результат выражения 5«3L имеет тип int. Вообще, ре­зультат операторов сдвига всегда имеет тип int или long.

</p>
<p>Примеры работы всех этих операторов с учетом расширения подробно
рассматривались в предыдущих лекциях.

</p>
<p> 

</p>
<p>Бинарное числовое расширение

</p>
<p>Это преобразование расширяет все примитивные числовые типы,
кроме double, до типов int, long, float, double по правилам
расширения примитивных типов. Бинарное числовое расширение происходит при
числовых операторах,
имеющих два аргумента, по следующим правилам:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   
если любой из аргументов
имеет тип double, то и второй приводит­ся к double;

</p>
<p>•   
иначе, если любой из
аргументов имеет тип float, то и второй при­водится к float;

</p>
<p>•   
иначе, если любой из
аргументов имеет тип long, то и второй при­водится к long;

</p>
<p>•   
иначе оба аргумента
приводятся к int.

</p>
<p>Бинарное числовое расширение может выполняться при следующих операциях:

</p>
<p>•   
арифметические операции +,
-, *, /, %;

</p>
<p>•   
операции сравнения &lt;,
&lt;=, &gt;, &gt;=, ==, !=;

</p>
<p>•   
битовые операции &amp;, |,
Л;

</p>
<p>•   
в некоторых случаях для
операции с условием ? :.

</p>
<p>Примеры работы всех этих операторов с учетом расширения подроб­но
рассматривались в предыдущих лекциях.

</p>
<p>Тип переменной и тип ее значения

</p>
<p>Теперь, когда были подробно рассмотрены все примеры преобразо­ваний,
нужно вернуться к вопросу переменной и ее значений.

</p>
<p>Как уже говорилось, переменная определяется тремя базовыми харак­теристиками:
имя, тип, значение. Имя дается произвольным образом и ни­как не сказывается на
свойствах переменной. А вот значение всегда имеет некоторый тип, не обязательно
совпадающий с типом самой переменной. Поэтому необходимо рассмотреть все
возможные типы переменных и вы­яснить, значения каких типов они могут иметь.

</p>
<p>Начнем с переменных примитивных типов. Поскольку эти перемен­ные
действительно хранят само значение, то их тип всегда точно совпадает с типом
значения.

</p>
<p>Проиллюстрируем это
правило на примере:

</p>
<p> 

</p>
<p>byte b=3; char с='А'+3; long m=b+c; double d=m-3F ;

</p>
<p>Здесь переменная b будет хранить
значение типа byte после сужения целочисленного литерала типа int. Переменная с
будет хранить тип char после того, как
компилятор осуществит сужающее преобразование ре­зультата суммирования, который
будет иметь тип int. Для переменной m выполнится
расширение результата суммирования типа от int к типу long. Наконец, переменная
d будет хранить значение типа double, получивше­еся в
результате расширения результата разности, который имеет тип float.

</p>
<p>Переходим к ссылочным типам. Во-первых, значение любой пере­менной
такого типа - ссылка, которая может указывать лишь на объекты, порожденные от
тех или иных классов, и далее обсуждаются только свой­ства данных классов.
(Также объекты могут порождаться от массивов, эта тема рассматривается в
отдельной лекции.)

</p>
<p>Кроме того, ссылочная переменная любого типа может иметь значе­ние null. Большинство
действий над такой переменной, например, обра­щение к полям или методам,
приведет к ошибке.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Итак, какова связь между типом ссылочной переменной и ее значе-Ния?
Здесь главное ограничение - проверка компилятора, который сле­дит, чтобы все действия,
выполняющиеся над объектом, были корректны, компилятор не может предугадать, на
объект какого класса будет реально

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="484" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="443" height="226" src="http://kufas.ru/java.files/image013.png"></center></td>
 </tr>
</table>




<p>ссылаться та или иная переменная. Все, чем он располагает, - тип самой
переменной. Именно его и использует компилятор для проверок. А значит, все
допустимые значения переменной должны гарантированно обладать свойствами,
определенными в классе-типе этой переменной. Такую га­рантию дает только
наследование. Отсюда получаем правило: ссылочная переменная типа А может
указывать на объекты, порожденные от самого типа А или его наследников.

</p>
<p> 

</p>
<p>Point р = new Point();

</p>
<p> 

</p>
<p>В этом примере переменная и ее значение одинакового типа, поэто­му над
объектом можно совершать все возможные для данного класса действия.

</p>
<p> 

</p>
<p>Parent р = new Child();

</p>
<p> 

</p>
<p>Такое присвоение корректно, так как класс Child порожден от Parent. Однако теперь допустимые действия над переменной р, а значит, над объ­ектом,
только что созданным на основе класса Child, ограничены возмож­ностями
класса Parent. Например, если в классе Child определен некий но­вый метод newChildMethod(), то попытка его вызвать p.newChildMethod() будет порождать ошибку компиляции Необходимо подчеркнуть, что ника­ких
изменений с самим объектом не происходит, ограничение порождает­ся используемым
способом доступа к этому объекту - переменной типа Parent.

</p>
<p>Чтобы показать, что объект не потерял никаких свойств, произведем
следующее обращение:

</p>
<p> 

</p>
<p>((Child)p).newChildMethod();

</p>
<p> 

</p>
<p>Здесь в начале проводится явное сужение к типу Child. Во время ис­полнения
программы JVM проверит, совместим
ли тип объекта, на кото­рый ссылается переменная р, с типом Child. В нашем случае
это именно так. В результате получается ссылка типа Child, поэтому
становится допу­стимым вызов метода newChildMethod(), который вызывается у объекта, созданного в предыдущей строке.

</p>
<p>Обратим внимание на важный частный случай - переменная типа Object может ссылаться на объекты любого типа.

</p>
<p>В дальнейшем, с изучением новых типов (абстрактных классов, ин­терфейсов,
массивов) этот список будет продолжаться, а пока коротко обобщим то, что было
рассмотрено в данном разделе.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены правила работы с типами данных в строго типизированном языке Java. Поскольку
компилятор строго от­слеживает тип каждой переменной и каждого выражения, в
случае изме­нения этого типа необходимо четко понимать, какие действия допусти­мы,
а какие нет, с точки зрения компилятора и виртуальной машины.

</p>
<p>Были рассмотрены все виды приведения типов в Java, то есть переход ОТ одного типа к другому. Они разбиваются на 7 групп, начиная с
тождест­венного и заканчивая запрещенными. Основные 4 вида определяются
су­жающими или расширяющими переходами между простыми или ссылоч­ными типами.
Важно помнить, что при явном сужении числовых
типов старшие биты просто отбрасываются, что порой приводит к неожиданно­му результату. Что касается преобразования
ссылочных значений, то здесь Действует правило - преобразование никогда не
порождает новых и не из­меняет существующих объектов. Меняется лишь способ
работы с ними. ,1    Особенным в Java является
преобразование к строке.

</p>
<p>Затем были рассмотрены все ситуации в программе, где могут про­исходить преобразования типов.
Прежде всего, это присвоение значений, Когда преобразование зачастую происходит незаметно для программиста. Вызов метода во многом похож на инициализацию. Явное
приведение Позволяет осуществить желаемый
переход в том случае, когда компилятор
Не позволяет сделать это неявно. Преобразование при
выполнении чис­ловых операций оказывает существенное влияние на результат.

</p>
<p>В заключение была рассмотрена связь между типом переменной и ^Ипом ее значения.








</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1,   Корректен ли следующий пример кода, и если да, то
сколько преобразований будет произведено при его исполнении? byte Ь=1; long m=-b; Object о="="; print("m"+o+m);

</p>
<p>&#9633;       
не корректен

</p>
<p>&#9633;       
корректен, 4 преобразования

</p>
<p>&#9633;       
корректен, 5 преобразований

</p>
<p>&#9633;       
корректен, 6 преобразований

</p>
<p> 

</p>
<p> 

</p>
<p>2.   Верны ли следующие выражения для переменной а" дробного типа? (5ЬоП)с!==(5Г10г1)(т1)о: (Ш1)&lt;1»(1п1)(1опд)&lt;1

</p>
<p>&#9633;       
первое верное, второе верное

</p>
<p>&#9633;       
да, нет

</p>
<p>&#9633; нет,
да
П нет, нет

</p>
<p> 

</p>
<p> 

</p>
<p>3.   Какие значения не могут участвовать в
преобразовании к строке?

</p>
<p>П   выражения примитивного типа П   выражения ссылочного типа П   значение null П   все могут








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0" align="left">
 <tr>
  <td width="268" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="86" height="47" src="http://kufas.ru/java.files/image014.png" alt="Подпись:  "></center></td>
 </tr>
</table>




<p> 

</p>
<p>Вариант 2




</p>
<p>

</p>
<p> 

</p>
<p>Вариант 3








</p>
<p> 








</p>
<p>1.  
Корректен ли следующий пример? Если нет, то в каких строках какие ошибки будут
сгенерированы? byte b=100-100; byte Ь=100+100; byte b=100* 100;

</p>
<p>&#9633;       пример
корректен

</p>
<p>П   пример
некорректен, ошибки во второй и третьей строках

</p>
<p>&#9633;       пример
некорректен, ошибка в третьей строке

</p>
<p>Для каких значений числовой
переменной х будет верно следующее выражение?

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="28" valign="top">
  <p>х==
  </p>
</td>
  <td width="113" valign="top">
  <p>-X
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>0
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>-2147483648 (-23')
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>(byte)(-128)
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>0.0
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>-0.0
  </p>
</td>
 </tr>
 <tr>
  <td width="28" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="113" valign="top">
  <p>NaN
  </p>
</td>
 </tr>
</table>








<p>2.   Корректны ли следующие преобразования? Object о = (String)null; String s = о;

</p>
<p>П     корректно

</p>
<p>П     некорректно,
ошибка в первой строке

</p>
<p>П     некорректно,
ошибка во второй строке

</p>
<p>&#9633;       некорректно,
ошибки в обеих строках

</p>
<p> 

</p>
<p> 

</p>
<p>3.  
Какое значение появится на консоли после выполнения следующего кода? charс=65; print(c); print(-t-c); print("="+c);

</p>
<p>&#9633;          
65, 66, =66

</p>
<p>&#9633;          
А, В, =В

</p>
<p>&#9633;          
А, 65, =А

</p>
<p>&#9633;          
А, А, =А

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Пусть классы Wolf и Rabbit являются наследниками класса
Animal. Корректен ли следующий пример?

</p>
<p>Wolf w = new Wolf (); Animal a = (Animal)w; Rabbit r = (Rabbit)a;

</p>
<p>&#9633;       
пример не будет откомпилирован

</p>
<p>&#9633;       
пример будет откомпилирован, но
возникнет ошибка времени исполнения

</p>
<p>&#9633;       
пример полностью корректен

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Значение какого типа будет
хранить переменная после
инициализации?

</p>
<p>byte b= 1+2;

</p>
<p>&#9633;       
byte

</p>
<p>&#9633;       
short

</p>
<p>&#9633;       
int








</p>
<p> 








</p>
<p>240




</p>
<p>16-3440








</p>
<p>
</p>
<center> 
</center>
    </div>