# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция
2. Основы объектно-ориентированного программирования</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции излагается основная концепция
объектно-ориентирован­ного подхода (ООП) к проектированию программного
обеспечения. Поскольку в Java почти все типы (за
исключением восьми простейших) являются объектны­ми, владение ООП становится
необходимым условием для успешного примене­ния языка. Лекция имеет вводный,
обзорный характер. Для более детального изучения предлагается список
дополнительной литературы и Internet-ресурсов.

</p>
<p> 

</p>
<p>Ключевые слова: блок-схема, объектно-ориентированное програм­мирование, ООП, объект, состояние, поведение, уникальность, класс, UML, конструктор,
деструктор, инкапсуляция, модульность, наследование, класс-предок, суперкласс,
класс-потомок, подкласс, полиморфизм, перегруженная функция, перегрузка,
ассоциация, метакласс.

</p>
<p> 

</p>
<p>Методология
процедурно-ориентированного программирования

</p>
<p>Появление первых электронных вычислительных машин, или
компью­теров, ознаменовало новый этап в развитии техники вычислений. Казалось,
достаточно разработать последовательность элементарных действий, каж­дое из
которых можно преобразовать в понятные компьютеру инструкции, и любая
вычислительная задача будет решена. Эта идея оказалась настоль­ко
жизнеспособной, что долгое время доминировала над всем процессом разработки
программ. Появились специализированные языки программи­рования, созданные для
разработки программ, предназначенных для ре­шения вычислительных задач.
Примерами таких языков могут служить FOCAL (FOrmula CALculator) и FORTRAN
(FORmula TRANslator).

</p>
<p>Основой такой методологии разработки программ являлась
проце­дурная, или алгоритмическая, организация структуры программного ко­да.
Это было настолько естественно для решения вычислительных задач, То
целесообразность такого подхода ни у кого не вызывала сомнений. Исходным в
данной методологии было понятие алгоритма. Алгоритм — ^o способ решения вычислительных и других задач, точно описываю­щий
определенную последовательность действий, которые необходимо выполнить для
достижения заданной цели. Примерами алгоритмов явля­ется хорошо известные
правила нахождения корней квадратного уравне­ния или линейной системы
уравнений.








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="481" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="452" height="457" src="http://kufas.ru/java.files/image005.png"></center></td>
 </tr>
</table>


При увеличении объемов программ для упрощения их
разработки по­явилась необходимость разбивать большие задачи на подзадачи
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В языках программирования возникло и закрепилось новое понятие процедуры.
Ис­пользование процедур позволило разбивать большие задачи на подзадачи и таким
образом упростило написание больших программ. Кроме того, про­цедурный подход
позволил уменьшить объем программного кода за счет написания часто используемых
кусков кода в виде процедур и их примене­ния в различных частях программы.

</p>
<p>Как и алгоритм, процедура представляет собой законченную последо­вательность
действий или операций, направленных на решение отдельной задачи. В языках программирования появилась специальная синтаксичес­кая
конструкция, которая также получила название процедуры. Например, на языке Pascal описание процедуры
выглядит следующим образом:

</p>
<p> 

</p>
<p>Procedure printGreeting(name: String) Begin

</p>
<p>Print("Hello,
");

</p>
<p>PrintLn(s); End;

</p>
<p>Назначение данной процедуры — вывести на экран приветствие Hello, Name, где Name передается в процедуру в качестве входного параметра.

</p>
<p>Со временем
вычислительные задачи становились все сложнее, а зна­чит, и решающие их
программы увеличивались в размерах. Их разработка превратилась в серьезную
проблему. Когда программа становится все боль­ше, ее приходится разделять на
все более мелкие фрагменты. Основой для такого разбиения как раз и стала
процедурная декомпозиция, при которой отдельные части программы, или модули,
представляли собой совокупность процедур для решения одной или нескольких
задач. Одна из основных осо­бенностей процедурного программирования заключается
в том, что оно позволило создавать библиотеки подпрограмм (процедур), которые
можно было бы использовать повторно в различных проектах или в рамках одного
проекта. При процедурном подходе для визуального представления алгорит­ма
выполнения программы применяется так называемая блок-схема. Соот­ветствующая
система графических обозначений была зафиксирована в ГОСТ 19.701-90. Пример
блок-схемы изображен на рисунке (рис. 2.1).

</p>
<p>Появление и интенсивное использование условных операторов и опе­ратора
безусловного перехода стало предметом острых дискуссий среди специалистов по
программированию. Дело в том, что бесконтрольное при­менение в программе
оператора безусловного перехода goto может замет­но осложнить понимание кода. Такие запутанные
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>программы
сравнивали с порцией спагетти (bowl of
spaghetti), имея в виду многочисленные
перехо­да от одного фрагмента программы к другому, или, что еще
хуже, возврат % конечных операторов программы к начальным. Ситуация
казалась на-ТОМгько драматичной, что многие предлагали исключить оператор goto из языков программирования. Именно с
этого времени отсутствие безуслов­ных переходов стали считать хорошим стилем программирования.

</p>
<p>Дальнейшее увеличение программных систем способствовало фор­мированию
новой точки зрения на процесс разработки программ и нали­чия программных кодов, которая получила название методологии структурного
программирования. Ее основой является процедурная де­композиция предметной
области решаемой задачи и организация отдель­ных модулей в виде совокупности процедур. В рамках этой методологии п°лучило развитие нисходящее проектирование программ, или проекти­рование
"сверху вниз". Пик популярности идей структурного программи­рования
приходится на конец 70-х — начало 80-х годов.

</p>
<p>В этот период основным показателем сложности разработки программ
считался ее размер. Вполне серьезно обсуждались такие оценки сложности
программ, как количество строк программного кода. Правда, при этом дела­лись
некоторые предположения относительно синтаксиса самих строк, ко­торые должны
были соответствовать определенным требованиям. Напри­мер, каждая строка кода
должна была содержать не более одного оператора. Общая трудоемкость разработки
программ оценивалась специальной едини­цей измерения —
"человеко-месяц", или "человеко-год". А профессионализм
программиста напрямую связывался с количеством строк программного ко­да,
который он мог написать и отладить в течение, скажем, месяца.

</p>
<p> 

</p>
<p>Методология объектно-ориентированного программирования

</p>
<p>Увеличение размеров программ приводило к необходимости привле­чения
большего числа программистов, что, в свою очередь, потребовало дополнительных
ресурсов для организации их согласованной работы. В пронессе разработки
приложений заказчик зачастую изменял функцио­нальные требования, что еще более
усложняло процесс создания про­граммного обеспечения.

</p>
<p>Но не менее важными оказались качественные изменения, связан­ные со
смещением акцента использования компьютеров
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В эпоху "боль­ших машин"
основными потребителями программного обеспечения были такие крупные заказчики,
как большие производственные предприятия, финансовые компании, государственные
учреждения. Стоимость таких вычислительных устройств для небольших предприятий
и организаций была слишком высока.

</p>
<p>Позже появились персональные компьютеры, которые имели гораз­до меньшую
стоимость и были значительно компактнее. Это позволило широко использовать их в
малом и среднем бизнесе. Основными задачами в этой области являются обработка
данных и манипулирование ими, по­этому вычислительные и
расчетно-алгоритмические задачи с появлением персональных компьютеров отошли на
второй план.

</p>
<p>Как показала практика, традиционные методы процедурного про­граммирования
не способны справиться ни с нарастающей сложностью программ и их разработки, ни
с необходимостью повышения их надежно­сти. Во второй половине 80-х годов
возникла настоятельная потребность в новой методологии программирования,
которая была бы способна ре­шить весь этот комплекс проблем. Ею стало
объектно-ориентированное программирование (ООП).

</p>
<p>После составления технического задания начинается этап проекти­рования,
или дизайна, будущей системы. Объектно-ориентированный подход к проектированию
основан на представлении предметной области задачи в виде множества моделей для
независимой от языка разработки программной системы на основе ее прагматики.

</p>
<p>Последний термин нуждается в пояснении. Прагматика определяется целью
разработки программной системы, например, обслуживание клиен-» тов банка,
управление работой аэропорта, обслуживание чемпионата мира t, по футболу и т.п. В формулировке цели участвуют предметы и понятия ре­ального
мира, имеющие отношение к создаваемой системе (см. рисунок 2.2 f |3]). При объектно-ориентированном подходе эти предметы и понятия за­меняются
моделями, т.е. определенными формальными конструкциями.

</p>
<p></p>
<center><img border="0" width="444" height="215" src="http://kufas.ru/java.files/image006.jpg"></center>

<p> 

</p>
<p>Рис. 2.2. Семантика (смысл программы с точки зрения выполняю­щего ее компьютера) и
прагматика (смысл программы с точки зре­ния ее пользователей) [3].

</p>
<p>Модель содержит не все
признаки и свойства представляемого ею едмета или понятия, а только те, которые
существенны для разрабаты-емой программной системы. Таким образом, модель
"беднее", а следо-|тельно, проще представляемого ею предмета или
понятия.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Простота модели по
отношению к реальному предмету позволяет делать ее формальной. Благодаря такому
характеру моделей при разра-гке можно четко выделить все зависимости и операции
над ними в со-



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0">
 <tr>
  <td valign="top" align="left">
  <p>^
  </p>
</td>
 </tr>
</table>



<p>аваемой программной
системе. Это упрощает как разработку и изучение „ Кализ) моделей, так и их
реализацию на компьютере.

</p>
<p>Объектно-ориентированный подход помогает справиться с такими проблемами,
как:

</p>
<p>•   
уменьшение сложности
программного обеспечения;

</p>
<p>•   
повышение надежности
программного обеспечения;

</p>
<p>•    обеспечение возможности модификации отдельных компонентов программного
обеспечения без изменения остальных его компо­нентов;

</p>
<p>•    обеспечение возможности повторного использования отдельных компонентов
программного обеспечения.

</p>
<p>Более детально преимущества и недостатки объектно-ориентирован­ного
программирования будут рассмотрены в конце лекции, так как для их понимания
необходимо знание основных понятий и положений ООП.

</p>
<p>Систематическое применение объектно-ориентированного подхода позволяет
разрабатывать хорошо структурированные, надежные в экс­плуатации, достаточно
просто модифицируемые программные системы. Этим объясняется интерес
программистов к объектно-ориентированному подходу и объектно-ориентированным
языкам программирования. ООП является одним из наиболее интенсивно развивающихся
направлений теоретического и прикладного программирования.

</p>
<p> 

</p>
<p>Объекты

</p>
<p>По определению будем называть объектом понятие, абстракцию или любой
предмет с четко очерченными границами, имеющий смысл в контексте
рассматриваемой прикладной проблемы. Введение объектов преследует две цели:

</p>
<p>•   
понимание прикладной
задачи (проблемы);

</p>
<p>•   
введение основы для
реализации на компьютере.

</p>
<p>Примеры объектов:
форточка, Банк "Империал", Петр Сидоров, дело № 7461, сберкнижка и
т.д.

</p>
<p>Каждый объект имеет определенное время жизни. В процессе выпол­нения
программы, или функционирования какой-либо реальной систе­мы, могут создаваться
новые объекты и уничтожаться уже существующие.

</p>
<p>Гради Буч дает следующее
определение объекта:

</p>
<p>Объект — это мыслимая или реальная сущность, обладающая харак­терным
поведением и отличительными характеристиками и являющаяся важной в предметной
области [2].

</p>
<p>Каждый объект имеет состояние, обладает четко определенным пове­дением и
уникальной идентичностью.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Состояние

</p>
<p>Рассмотрим пример. Любой человек может находиться в некотором положении
(состоянии): стоять, сидеть, лежать, и — в то же время совер­шать какие либо
действия.

</p>
<p>Например, человек может прыгать, если он стоит, и не может — если он
лежит, для этого ему потребуется сначала встать. Также в объектно­ориентированном
программировании состояние объекта может опреде­ляться наличием или отсутствием
связей между моделируемым объектом и другими объектами. Более подробно все
возможные связи между объек­тами будут рассмотрены в разделе "Типы
отношений между классами".

</p>
<p>Например, если у человека есть удочка (у него есть связь с объектом
"Удочка"), он может ловить рыбу, а если удочки нет, то такое действие
не­возможно. Из этих примеров видно, что набор действий, которые может
совершать человек, зависит от параметров объекта, его моделирующего.

</p>
<p>Для рассмотренных выше примеров такими характеристиками, или атрибутами,
объекта "Человек" являются:

</p>
<p>•   
текущее положение человека
(стоит, сидит, лежит);

</p>
<p>•   
наличие удочки (есть или
нет).

</p>
<p>В конкретной задаче могут появиться и другие свойства, например,
физическое состояние, здоровье (больной человек обычно не прыгает).

</p>
<p>Состояние (state) - совокупный результат поведения объекта: одно из стабильных условий,
в которых объект может существовать, охаракте­ризованных количественно; в любой
момент времени состояние объекта включает в себя перечень (обычно статический)
свойств объекта и теку­щие значения (обычно динамические) этих свойств [2].

</p>
<p> 

</p>
<p>Поведение

</p>
<p>Для каждого объекта существует определенный набор действий, которые с
ним можно произвести. Например, возможные действия с некоторым файлом
операционной системы ПК:

</p>
<p>•   
создать;

</p>
<p>•   
открыть;

</p>
<p>•   
читать из файла;

</p>
<p>•   
писать в файл;

</p>
<p>•   
закрыть;

</p>
<p>•   
удалить.

</p>
<p>Результат выполнения действий зависит от состояния объекта на мо­мент
совершения действия, т.е. нельзя, например, удалить файл, если он открыт
кем-либо (заблокирован). В то же время действия могут менять внутреннее
состояние объекта - при открытии или закрытии файла свой­ство
"открыт" принимает значения "да" или "нет",
соответственно.

</p>
<p>Программа, написанная с использованием ООП, обычно состоит из Множества
объектов, и все эти объекты взаимодействуют между собой, обычно говорят, что
взаимодействие между объектами в программе про­исходит посредством передачи
сообщений между ними.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>^ В терминологии
объектно-ориентированного подхода понятия "дейст­ве ,
"сообщение" и "метод" являются синонимами. Т.е. выражения
"выпол­нить действие над объектом", "вызвать метод объекта"
и "послать сообщение объекту для выполнения какого-либо действия"
эквивалентны. Последняя фраза появилась из следующей модели. Программу,
построенную по техно­логии ООП, можно представить себе как виртуальное
пространство, запол­ненное объектами, которые условно "живут"
некоторой жизнью. Их актив­ность проявляется в том, что они вызывают друг у
друга методы, или посы­лают друг другу сообщения. Внешний интерфейс объекта,
или набор его ме­тодов,— это описание того, какие сообщения он может принимать.

</p>
<p>Поведение (behavior) — действия и реакции объекта, выраженные в терминах передачи
сообщений и изменения состояния; видимая извне и воспроизводимая активность
объекта [2].

</p>
<p> 

</p>
<p>Уникальность

</p>
<p>Уникальность - это то, что отличает объект от других объектов. На­пример,
у вас может быть несколько одинаковых монет. Даже если абсо­лютно все их
свойства (атрибуты) одинаковы (год выпуска, номинал и т.д.) и при этом вы
можете использовать их независимо друг от друга, они по-прежнему остаются
разными монетами.

</p>
<p>В машинном
представлении под параметром уникальности объекта чаще всего понимается адрес
размещения объекта в памяти.

</p>
<p>Identity (уникальность)
объекта состоит в том, что всегда можно оп­ределить, указывают две ссылки на
один и тот же объект или на разные объекты. При этом два объекта могут во всем
быть похожими, их образ в памяти может представляться одинаковыми последовательностями бай­тов,
но, тем не менее, их Identity может быть
различна.

</p>
<p>Наиболее распространенной ошибкой является понимание уни­кальности как
имени ссылки на объект. Это неверно, т.к. на один объект может указывать
несколько ссылок, и ссылки могут менять свои значения (ссылаться на другие
объекты).

</p>
<p>Итак, уникальность (identity) - свойство
объекта; то, что отличает его от других объектов (автор не согласен с переводом
русского издания [2], поэтому здесь приводится авторский перевод).

</p>
<p> 

</p>
<p>Классы

</p>
<p>Все монеты из предыдущего примера принадлежат одному и тому же классу
объектов (именно с этим связана их одинаковость)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Номинальная стоимость монеты,
металл, из которого она изготовлена, форма - это ат­рибуты класса. Совокупность
атрибутов и их значений характеризует объ­ект. Наряду с термином
"атрибут" часто используют термины "свойство" и
"поле", которые в объектно-ориентированном программировании явля­ются
синонимами.

</p>
<p>Все объекты одного и того же класса описываются одинаковыми на­борами
атрибутов. Однако объединение объектов в классы определяется не наборами
атрибутов, а семантикой. Так, например, объекты "конюш­ня" и
"лошадь" могут иметь одинаковые атрибуты: цена и возраст. При этом
они могут относиться к одному классу, если рассматриваются в зада­че просто как
товар, либо к разным классам, если в рамках поставленной задачи будут
использоваться по-разному, т.е. над ними будут совершаться различные действия.

</p>
<p>Объединение объектов в классы позволяет рассмотреть задачу в бо­лее
общей постановке. Класс имеет имя (например, "лошадь"), которое относится
ко всем объектам этого класса. Кроме того, в классе вводятся имена атрибутов,
которые определены для объектов. В этом смысле опи­сание класса аналогично
описанию типа структуры или записи (record), широко
применяющихся в процедурном программировании; при этом каждый объект имеет тот
же смысл, что и экземпляр структуры (перемен­ная или константа соответствующего
типа).

</p>
<p>Формально класс - это шаблон поведения объектов определенного типа с
заданными параметрами, определяющими состояние. Все экземп­ляры одного класса
(объекты, порожденные от одного класса) имеют один и тот же набор свойств и
общее поведение, то есть одинаково реаги­руют на одинаковые сообщения

</p>
<p></p>
<center><img border="0" width="132" height="122" src="http://kufas.ru/java.files/image007.jpg"></center>

<p>^ В соответствии с UML (Unified Modeling Language - унифицирован­ный
язык моделирования), класс имеет следующее графическое представ­ление.

</p>
<p>Класс изображается в виде прямоугольника, состоящего из трех час­тей. В
верхней части помещается название класса, в средней - свойства объектов класса,
в нижней - действия, которые можно выполнять с объ­ектами данного класса
(методы).

</p>
<p>Каждый класс также может иметь специальные методы, которые ав­томатически
вызываются при создании и уничтожении объектов этого Класса:

</p>
<p>•  
конструктор (constructor) - выполняется при создании объектов;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•  
деструктор (destructor) - выполняется при уничтожении объектов.

</p>
<p>Обычно конструктор и деструктор имеют специальный синтаксис, который
может отличаться от синтаксиса, используемого для написания обычных методов
класса.

</p>
<p> 

</p>
<p>Инкапсуляция

</p>
<p>Инкапсуляция (encapsulation) — это сокрытие реализации класса и отделение его внутреннего
представления от внешнего (интерфейса). При использовании
объектно-ориентированного подхода не принято применять прямой доступ к
свойствам какого-либо класса из методов других классов. Для доступа к свойствам
класса принято задействовать специальные методы этого класса для получения и
изменения его свойств.

</p>
<p>Внутри объекта данные и методы могут обладать различной степенью
открытости (или доступности). Степени доступности, принятые в языке Java, подробно будут
рассмотрены лекции 6. Они позволяют более тонко управлять свойством
инкапсуляции.

</p>
<p>Открытые члены класса составляют внешний интерфейс объекта. Это та
функциональность, которая доступна другим классам. Закрытыми обычно объявляются
все свойства класса, а также вспомогательные методы, которые являются деталями
реализации и от которых не должны зависеть другие части системы.

</p>
<p>Благодаря сокрытию реализации за внешним интерфейсом класса можно менять
внутреннюю логику отдельного класса, не меняя код осталь­ных компонентов
системы. Это свойство называется модульность.

</p>
<p>Обеспечение доступа к свойствам класса только через его методы так­же
дает ряд преимуществ. Во-первых, так гораздо проще контролировать корректные
значения полей, ведь прямое обращение к свойствам отслежи­вать невозможно, а
значит, им могут присвоить некорректные значения.

</p>
<p>Во-вторых, не
составит труда изменить способ хранения данных. Ес­ли информация станет
храниться не в памяти, а в долговременном храни­лище, таком как файловая
система или база данных, потребуется изменить лишь ряд методов одного класса, а
не вводить эту функциональность во все части системы.

</p>
<p>Наконец, программный код, написанный с использованием данно­го принципа,
легче отлаживать. Для того, чтобы узнать, кто и когда изме­нил свойство
интересующего нас объекта, достаточно добавить вывод от­ладочной информации в
тот метод объекта, посредством которого осуще­ствляется доступ к свойству этого
объекта. При использовании прямого до­ступа к свойствам объектов программисту
пришлось бы добавлять вывод отладочной информации во все участки кода, где
используется интересую­щий нас объект.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Наследование

</p>
<p>Наследование (inheritance) — это отношение между классами, при ко­тором класс использует структуру или поведение другого класса (одиноч­ное наследование), или других (множественное наследование) классов. Наследование вводит иерархию "общее/частное", в которой подкласс на­следует от одного или нескольких более общих суперклассов. Подклассы обычно дополняют или переопределяют унаследованную структуру и по­ведение.

</p>
<p>В качестве примера можно рассмотреть задачу, в которой необходи­мо
реализовать классы "Легковой автомобиль" и "Грузовой
автомобиль". Очевидно, эти два класса имеют общую функциональность. Так, оба они имеют 4
колеса, двигатель, могут перемещаться и т.д. Всеми этими
свой-ствами обладает любой автомобиль, независимо от того, грузовой он или двгковой, 5- или 12-местный. Разумно вынести эти общие свойства и функциональность
в отдельный класс, например, "Автомобиль" и насле­довать от него классы "Легковой автомобиль" и "Грузовой
автомобиль", чтобы избежать повторного написания одного и того же кода в разных классах.

</p>
<p></p>
<center><img border="0" width="387" height="153" src="http://kufas.ru/java.files/image008.jpg"></center>

<p>Отношение обобщения обозначается сплошной линией с треуголь­ной стрелкой на конце. Стрелка указывает на более общий класс (класс-Иредок
или суперкласс), а ее отсутствие - на более специальный класс (класс-потомок
или подкласс).

</p>
<p>Использование наследования способствует уменьшению количества кода,
созданного для описания схожих сущностей, а также способствует НагШсанию
более эффективного и гибкого кода.

</p>
<p>В рассмотренном примере применено одиночное наследование. Не­который
класс также может наследовать свойства и поведение сразу не-сКольких
классов. Наиболее популярным примером применения множе-СТвенного
наследования является проектирование системы учета товаров в зоомагазине.

</p>
<p>Все животные в зоомагазине являются наследниками класса "Живот­ное",
а также наследниками класса "Товар". Т.е. все они имеют возраст, нуж­даются
в пище и воде и в то же время имеют цену и могут быть проданы.

</p>
<p>Множественное наследование на диаграмме изображается точно так же, как
одиночное, за исключением того, что линии наследования соеди­няют класс-потомок
сразу с несколькими суперклассами.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Не все объектно-ориентированные языки программирования содер­жат
языковые конструкции для описания множественного наследования.

</p>
<p>В языке Java множественное
наследование имеет ограниченную под­держку через интерфейсы и будет рассмотрено
в лекции 8.

</p>
<p> 

</p>
<p>Полиморфизм

</p>
<p>Полиморфизм является одним из фундаментальных понятий в объ­ектно-ориентированном
программировании наряду с наследованием и инкапсуляцией. Слово
"полиморфизм" греческого происхождения и оз­начает "имеющий
много форм". Чтобы понять, что оно означает приме­нительно к
объектно-ориентированному программированию, рассмот­рим пример.

</p>
<p>Предположим, мы хотим создать векторный графический редактор, в котором
нам нужно описать в виде классов набор графических прими­тивов - Point, Line, Circle, Box и т.д. У каждого из этих классов определим метод draw для отображения соответствующего примитива на экране.

</p>
<p>Очевидно, придется написать код, который при необходимости ото­бразить
рисунок будет последовательно перебирать все примитивы, на момент отрисовки
находящиеся на экране, и вызывать метод draw у каж­дого из них. Человек, незнакомый с полиморфизмом, вероятнее всего,
создаст несколько массивов (отдельный массив для каждого типа прими­тивов) и
напишет код, который последовательно переберет элементы из каждого массива и
вызовет у каждого элемента метод draw. В результате
получится примерно следующий код:

</p>
<p> 

</p>
<p>//создание пустого массива, который может содержать //объекты Pointe максимальным
объемом 1000 Point[] р = new Point[1000];

</p>
<p>Line[] I   = new Line[ 1000]; Circlef] c= new
Circle[1000]; Box[]b = new Box[1000];

</p>
<p> 

</p>
<p>//предположим, в этом
месте происходит заполнение

</p>
<p>// всех массивов
соответствующими объектами

</p>
<p> 

</p>
<p>1ог(Ы \ = 0;\&lt;
р.\епдт;\++) { //цикл с перебором
всех ячеек массива.

</p>
<p>//вызов метода draw() в случае,

</p>
<p>// если ячейка не пустая.

</p>
<p>1т(р[1]!=пШ1) p.draw();

</p>
<p>}

</p>
<p>тогО'т I = 0; |" &lt; 1.1епдтх1;1++) {
1т(1[1]!=пи11) 1.с1гауу();

</p>
<p>}

</p>
<p>1ог(\Ш \-0;\&lt;
с.1епд№;1++)
{ №(с[1]!=пи11)
c.draw();

</p>
<p>}

</p>
<p>1ог(\п\. I = 0; 1
&lt; Ь.1епдтп;!++)
{ |т(Ь[ф=пи11)
b.draw();

</p>
<p>}

</p>
<p> 

</p>
<p>Недостатком написанного выше кода является дублирование практи­чески
идентичного кода для отображения каждого типа примитивов. Также неудобно то, что
при дальнейшей модернизации нашего графического ре­дактора и добавлении
возможности рисовать новые типы графических примитивов, например Text, Star и т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>д., при таком подходе придется менять существующий код и добавлять в
него определения новых массивов, а так­же обработку содержащихся в них
элементов.

</p>
<p>Используя полиморфизм, мы можем значительно упростить реали­зацию
подобной функциональности. Прежде всего, создадим общий ро­дительский класс для
всех наших классов. Пусть таким классом будет Point. В результате
получим иерархию классов, которая изображена на рисунке 2.3.

</p>
<p>У каждого из дочерних классов метод draw переопределен таким об­разом, чтобы отображать экземпляры каждого класса
соответствующим образом.

</p>
<p>Для описанной выше иерархии классов, используя полиморфизм, можно
написать следующий код:

</p>
<p> 

</p>
<p>Point р[] = new Point[
1000]; Р[0] = new Circle();








</p>
<p>курс




</p>
<p>Программирование
на Java




</p>
<p>Лекция
2_____________________ Основы
объектно-ориентированного программирования








</p>
<p> 








</p>
<p>р[1] = new Point(); р[2] = new Вох(); р[3] = new Une();

</p>
<p>for(int i = 0; i &lt; p.length;i++) { if(p[i]!=null) p.draw();

</p>
<p>}

</p>
<p> 

</p>
<p>В описанном выше примере массив р[] может содержать любые объ­екты, порожденные от наследников класса Point. При вызове какого-либо метода у любого из элементов этого массива будет
выполнен метод того объекта, который содержится в ячейке массива. Например,
если в ячейке р[0] находится объект Circle, то при вызове метода draw следующим образом:

</p>
<p> 

</p>
<p>p[0].draw()

</p>
<p>нарисуется круг, а не точка.

</p>
<p>В заключение приведем
формальное определение полиморфизма.

</p>
<p>Полиморфизм (polymorphism) - положение теории типов, согласно которому имена (например,
переменных) могут обозначать объекты раз­ных (но имеющих общего родителя)
классов. Следовательно, любой объ­ект, обозначаемый полиморфным именем, может
по-своему реагировать на некий общий набор операций [2].

</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="31" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="398" height="205" src="http://kufas.ru/java.files/image009.png"></center></td>
 </tr>
</table>


В процедурном программировании тоже существует понятие
полимор­физма, которое отличается от рассмотренного механизма в ООП. Процедур­ный
полиморфизм предполагает возможность создания нескольких проце­дур или функций
с одним и тем же именем, но разным количеством или раз­личными типами
передаваемых параметров. Такие одноименные функции называются перегруженными, а
само явление - перегрузкой (overloading). Перегрузка функций существует и в ООП и называется перегрузкой методов.

<p>Примером использования перегрузки
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>методов в языке Java может служить класс
PrinrWriter, который применяется, в частности, для вывода сообщений на консоль. Этот
класс имеет множество методов printin, ко­торые различаются типами и/или количеством входных параметров. Вот
лишь несколько из них:

</p>
<p>void printlnO                           //
переход на новую строку

</p>
<p>void println(boolean х)   // выводит значение
булевской

</p>
<p>// переменной (true или false) void println(String х)    
// выводит строку - значение

</p>
<p>//текстового
параметра.

</p>
<p>Определенные сложности возникают при вызове перегруженных методов. В Java существуют
специальные правила, которые позволяют решать эту проблему. Они будут
рассмотрены в соответствующей лекции.

</p>
<p> 

</p>
<p>Типы отношений между классами

</p>
<p>Как правило, любая программа, написанная на объектно-ориенти­рованном
языке, представляет собой некоторый набор связанных между собой классов. Можно
провести аналогию между написанием программы и строительством дома. Подобно
тому, как стена складывается из кирпичей, компьютерная программа с
использованием ООП строится из классов. Причем эти классы должны иметь
представление друг о друге, для того что­бы сообща выполнять
поставленную задачу.

</p>
<p>Возможны следующие связи между классами в рамках объектной модели
(приводятся лишь наиболее простые и часто используемые виды связей, подробное
их рассмотрение выходит за рамки этой ознакомитель­ной лекции):

</p>
<p>•   
агрегация (Aggregation);

</p>
<p>•   
ассоциация (Association);

</p>
<p>•   
наследование (Inheritance);

</p>
<p>•   
метаклассы (Metaclass).

</p>
<p> 

</p>
<p>Агрегация

</p>
<p>Отношение между классами типа "содержит" (contain) или "состоит из называется агрегацией, или включением. Например,
если аквариум Наполнен водой и в нем плавают рыбки, то можно сказать, что аквариум агрегирует в
себе воду и рыбок.








</p>
<p></p>
<center><img border="0" width="397" height="72" src="http://kufas.ru/java.files/image010.jpg"></center>

<p>Такое отношение включения, или агрегации (aggregation), изобража­ется линией с ромбиком на стороне того класса, который
выступает в ка­честве владельца, или контейнера. Необязательное название
отношения записывается посередине линии.

</p>
<p>В нашем примере отношение contain является
двунаправленным. Объект класса Aquarium содержит несколько
объектов Fish. В то же вре­мя каждая рыбка "знает", в каком именно аквариуме
она живет. Каждый класс имеет свою роль в агрегации, которая указывает, какое
место зани­мает класс в данном отношении. Имя роли не является обязательным
элементом обозначений и может отсутствовать на диаграмме
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В примере можно видеть роль home класса Aquarium (аквариум является домом
для рыбок), а также роль inhabitants класса Fish (рыбки являются обитателя­ми
аквариума). Название роли обычно совпадает с названием соответст­вующего поля в
классе. Изображение такого поля на диаграмме излишне, если уже указано имя
роли. Т.е. в данном случае класс Aquarium будет иметь свойство
(поле) inhabitants, а класс Fish - свойство home.

</p>
<p>Число объектов, участвующих в отношении, записывается рядом с именем
роли. Запись "0..п" означает "от нуля до бесконечности". Приняты также
обозначения:

</p>
<p>•   "1
..п" — от единицы до
бесконечности;

</p>
<p>•   
"О" - ноль;

</p>
<p>•   "
1 " — один;

</p>
<p>•   "п"
— фиксированное
количество;

</p>
<p>•   "0..
1 " — ноль или один.

</p>
<p>Код, описывающий рассмотренную модель и явление агрегации, может
выглядеть, например, следующим образом:

</p>
<p>//
определение класса Fish public class Fish {

</p>
<p>//
определения поля home (ссылка на объект Aquarium)

</p>
<p>private Aquarium home;

</p>
<p>public Fish() { }

</p>
<p>}

</p>
<p>// определение класса Aquarium public class Aquarium {

</p>
<p>// определения поля inhabitants (массив ссылок на объекты Fish) private Fish inhabitants[]; public Aquarium() { }

</p>
<p>}

</p>
<p> 

</p>
<p>Ассоциация

</p>
<p>Если объекты одного класса ссылаются на один или более объектов другого
класса, но ни в ту, ни в другую сторону отношение между объек­тами не носит
характера "владения", или контейнеризации, такое отно­шение называют
ассоциацией (association). Отношение ассоциации изоб­ражается так же, как и отношение агрегации,
но линия, связывающая классы,— простая, без ромбика.



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Computer
  </p>
</td>
 </tr>
</table>





<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Programmer
  </p>
</td>
 </tr>
</table>



<p>В качестве примера можно рассмотреть программиста и его компью­тер. Между
этими двумя объектами нет агрегации, но существует четкая взаимосвязь. Так,
всегда можно установить, за какими компьютерами ра­ботает какой-либо
программист, а также какие люди пользуются отдельно взятым компьютером. В рассмотренном примере имеет место ассоциация
"многие-ко-многим".



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Computerт
  </p>
</td>
 </tr>
</table>





<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>0..n
  </p>
</td>
 </tr>
</table>



<p>-programmers   -computers

</p>
<p>Programmerт I 0 n

</p>
<p> 

</p>
<p>В данном случае между экземплярами классов Programmer и Computer в обе стороны используется
отношение "0..п", т.к. програм­мист, в принципе, может не работать с компьютером (если он
теоретик Или на пенсии). В свою очередь, компьютер может никем не использовать­ся (если он новый и
еще не установлен).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Код, соответствующий рассмотренному примеру, будет, например, следующим:

</p>
<p>public class Programmer {

</p>
<p>private Computer computers[];

</p>
<p>public Programmerт {

</p>
<p>}

</p>
<p>}

</p>
<p>public class Computer {

</p>
<p>private Programmer programmers[];

</p>
<p>public Computerт {

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Наследование

</p>
<p>Наследование является важным случаем отношений между двумя или более
классами. Подробно оно рассматривалось выше.

</p>
<p> 

</p>
<p>Метаклассы

</p>
<p>Итак, любой объект имеет структуру, состоящую из полей и методов.
Объекты, имеющие одинаковую структуру и семантику, описываются од­ним классом,
который и является, по сути, определением структуры объек­тов, порожденных от
него.

</p>
<p>В свою очередь, каждый класс, или описание, всегда имеет строгий шаблон,
задаваемый языком программирования или выбранной объект­ной моделью. Он
определяет, например, допустимо ли множественное наследование, какие существуют
ограничения на именование классов, как описываются поля и методы, набор
существующих типов данных и многое другое. Таким образом, класс можно
рассматривать как объект, у которого есть свойства (имя, список полей и их
типы, список методов, список аргументов для каждого метода и т.д.). Также класс
может обладать поведением, то есть поддерживать методы. А раз для любого
объекта су­ществует шаблон, описывающий свойства и поведение этого объекта,
значит, его можно определить и для класса. Такой шаблон, задающий раз­личные
классы, называется метаклассом.

</p>
<p>Чтобы представить себе, что такое метакласс, рассмотрим пример не­кой
бюрократической организации. Будем считать, что все классы в такой системе
представляют собой строгие инструкции, которые описывают, что нужно сделать,
чтобы породить новый объект (например, нанять нового служащего или открыть
новый отдел). Как и полагается классам, они опи­сывают все свойства новых
объектов (например, зарплату и профессио­нальный уровень для сотрудников,
площадь и имущество для отделов) и их поведение (обязанности служащих и функции
подразделений).

</p>
<p>В свою очередь,
написание новой инструкции можно строго регла­ментировать. Скажем, необходимо
использовать специальный бланк, при­держиваться правил оформления и заполнить
все обязательные поля (на­пример, номер инструкции и фамилии ответственных
работников). Такая "инструкция инструкций" и будет представлять собой
метакласс в ООП.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Итак, объекты порождаются от классов, а классы — от метакласса. Он, как
правило, в системе только один. Но существуют языки програм­мирования, в
которых можно создавать и использовать собственные мета­классы, например язык Python. В частности,
функциональность мета­класса может быть следующая: при формировании класса он
будет про­сматривать список всех методов в классе и, если имя метода имеет вид set_XXX или get_XXX, автоматически создавать поле с именем XXX, если такого не существует.

</p>
<p>Поскольку метакласс сам является классом, то нет никакого смысла в
создании "мета-мета-классов".

</p>
<p>В языке Java также есть метакласс. Это класс, который так и называ­ется — Class (описывает классы),
он располагается в основной библиоте­ке java.lang. Виртуальная машина использует его по прямому назначе­нию. Когда
загружается очередной .class-файл, содержащий описание нового класса, JVM порождает объект
класса Class, который будет хра­нить его структуру. Таким образом, Java использует
концепцию метаклас­са в самых практических целях. С помощью Class реализована поддерж­ка
статических (static) полей и методов. Наконец, этот класс содержит ряд методов, полезных
для разработчиков. Они будут рассмотрены в сле­дующих лекциях.

</p>
<p> 

</p>
<p>Достоинства ООП

</p>
<p>От любой методики разработки программного обеспечения мы ждем, что она
поможет нам в решении наших задач. Но одной из самых Значительных проблем
проектирования является сложность. Чем больше И сложнее программная
система, тем важнее разбить ее на небольшие, четко очерченные части. Чтобы
справиться со сложностью, необходимо абстрагироваться от деталей. В этом смысле
классы представляют собой весьма удобный инструмент.

</p>
<p>•  
Классы позволяют проводить
конструирование из полезных ком­понентов, обладающих простыми инструментами,
что позволяет абстрагироваться от деталей реализации.

</p>
<p>•  
Данные и операции над ними
образуют определенную сущность, и они не разносятся по всей программе, как
нередко бывает в случае процедурного программирования, а описываются вместе.
Локали­зация кода и данных улучшает наглядность и удобство сопровож­дения
программного обеспечения.

</p>
<p>•  
Инкапсуляция позволяет
привнести свойство модульности, что об­легчает распараллеливание выполнения
задачи между несколькими исполнителями и обновление версий отдельных
компонентов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>ООП дает возможность создавать расширяемые системы. Это одно Из основных достоинств
ООП, и именно оно отличает данный подход от традиционных методов
программирования. Расширяемость означает, что существующую систему можно
заставить работать с новыми компонента­ми, причем без внесения в нее каких-либо
изменений. Компоненты мо­гут быть добавлены на этапе исполнения программы.

</p>
<p>Полиморфизм оказывается полезным преимущественно в следую­щих ситуациях.

</p>
<p>•  Обработка разнородных
структур данных.

</p>
<p>Программы могут
работать, не различая вида объектов, что существен­но упрощает код. Новые виды
могут быть добавлены в любой момент.

</p>
<p>•  Изменение поведения во
время исполнения.

</p>
<p>На этапе исполнения
один объект может быть заменен другим, что позволяет легко, без изменения кода,
адаптировать алгоритм в за­висимости от того, какой используется объект.

</p>
<p>•  Реализация работы с
наследниками.

</p>
<p>Алгоритмы можно
обобщить настолько, что они уже смогут рабо­тать более чем с одним видом
объектов.

</p>
<p>•  Создание
"каркаса" (framework).

</p>
<p>Независимые от
приложения части предметной области могут быть реализованы в виде набора
универсальных классов, или каркаса (framework), и в дальнейшем расширены за счет добавле­ния частей, специфичных для
конкретного приложения. Часто многоразового использования программного
обеспечения не удается добиться из-за того, что существующие компоненты уже не
отве­чают новым требованиям. ООП помогает этого достичь без нарушения работы
уже имеющихся клиентов, что позволяет извлечь максимум из многоразового
использования компонентов.

</p>
<p>•   
Сокращается время на
разработку, которое может быть отдано дру­гим задачам.

</p>
<p>•   
Компоненты многоразового использования
обычно содержат го­раздо меньше ошибок, чем вновь разработанные, ведь они уже
не раз подвергались проверке.

</p>
<p>•   
Когда некий компонент
используется сразу несколькими клиента­ми, улучшения, вносимые в его код,
одновременно оказывают по­ложительное влияние и на множество работающих с ним
программ.

</p>
<p>•   Если программа опирается на стандартные компоненты, ее структура и
пользовательский интерфейс становятся более уни­фицированными, что облегчает ее
понимание и упрощает ис­пользование.

</p>
<p> 

</p>
<p>Недостатки ООП

</p>
<p>Документирование классов - задача более трудная, чем это было в слу­чае
процедур и модулей
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Поскольку любой метод может быть переопреде­лен, в
документации должно говориться не только о том, что делает данный метод, но и о
том, в каком контексте он вызывается. Ведь переопределен­ные методы обычно
вызываются не клиентом, а самим каркасом. Таким образом, программист должен
знать, какие условия выполняются, когда вызывается данный метод. Для
абстрактных методов, которые пусты, в документации должно говориться о том, для
каких целей предполагается использовать переопределяемый метод.

</p>
<p>В сложных иерархиях классов поля и методы обычно наследуются с разных
уровней. И не всегда легко определить, какие поля и методы фак­тически
относятся к данному классу. Для получения такой информации нужны специальные
инструменты, вроде навигаторов классов. Если кон­кретный класс расширяется, то
каждый метод обычно сокращают перед передачей сообщения базовому классу.
Реализация операции, таким об­разом, рассредоточивается по нескольким классам,
и чтобы понять, как она работает, нам приходится внимательно просматривать весь
код.

</p>
<p>Методы, как правило, короче процедур, поскольку они осуществляют только
одну операцию над данными, зато их намного больше. В коротких методах легче
разобраться, но они неудобны тем, что код для обработки со­общения иногда
"размазан" по многим маленьким методам.

</p>
<p>Инкапсуляцией данных не следует злоупотреблять. Чем больше ло­гики и
данных скрыто в недрах класса, тем сложнее его расширять. От­правной точкой
здесь должно быть не то, что клиентам не разрешается знать о тех или иных
данных, а то, что клиентам для работы с классом этих данных знать не требуется.

</p>
<p>Многие считают, что ООП является неэффективным. Как же обстоит де­ло в
действительности? Мы должны проводить четкую грань между неэффек­тивностью на
этапе выполнения, неэффективностью в смысле распределения памяти и
неэффективностью, связанной с излишней универсализацией.

</p>
<p>1. Неэффективность на этапе выполнения. В языках типа Smalltalk со­общения
интерпретируются во время выполнения программы путем осуществления их поиска в
одной или нескольких таблицах и за счет выбора подходящего метода. Конечно, это
медленный процесс. И да­же при использовании наилучших методов оптимизации Smalltalk-программы в десять раз медленнее оптимизированных С-программ. В
гибридных языках типа Oberon-2, Object Pascal и С++ отправка
сообщения приводит лишь к вызову через указатель процедурной переменной. На
некоторых машинах сообщения выполняются лишь на 10% медленнее, чем обычные
процедурные вызовы. И по­скольку сообщения встречаются в программе гораздо реже
других операций, их воздействие на время выполнения влияния практи­чески не
оказывает.

</p>
<p>Однако существует
другой фактор, который влияет на время выпол­нения: это инкапсуляция данных.
Рекомендуется не предоставлять прямой доступ к полям класса, а выполнять каждую
операцию над данными через методы. Такая схема приводит к необходимости вы­полнения
процедурного вызова каждый раз при доступе к данным. Однако если инкапсуляция
используется только там, где она необ­ходима (т.е. в тех случаях, когда это
становится преимуществом), то замедление вполне приемлемое.

</p>
<p>2. 
Неэффективность в смысле
распределения памяти. Динамическое связывание и проверка типа на этапе
выполнения требуют по ходу работы информации о типе объекта. Такая информация
хранится в дескрипторе типа и он выделяется один на кл&amp;сс. Каждый объект
имеет невидимый указатель на дескриптор типа для своего класса. Таким образом,
в объектно-ориентированных программах необхо­димая дополнительная память выражается
в одном указателе для объекта и в одном дескрипторе типа для класса.

</p>
<p>3. 
Излишняя универсальность.
Неэффективность также может озна­чать, что в программе реализованы избыточные
возможности. В библиотечном классе часто содержится больше методов, чем это
реально необходимо. А поскольку лишние методы не могут быть удалены, они
становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на
размере кода.

</p>
<p>Одно из возможных
решений — строить базовый класс с минималь­ным числом методов, а затем уже
реализовывать различные расши­рения этого класса, которые позволят нарастить
функциональность. Другой подход — дать компоновщику возможность удалять лиш­ние
методы. Такие интеллектуальные компоновщики уже сущест­вуют для различных
языков и операционных систем. Но нельзя утверждать, что ООП неэффективно. Если
классы исполь­зуются лишь там, где это действительно необходимо, то потеря
эффектив­ности из-за повышенного расхода памяти и меньшей производительности
незначительна. Кроме того, надежность программного обеспечения и быс­трота его
написания часто бывает важнее, чем производительность.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции мы рассказали об объектно-ориентированном подхо­де к
разработке ПО, а также о том, что послужило предпосылками к его появлению и
сделало его популярным. Были рассмотрены ключевые по­нятия ООП - объект и
класс. Далее были описаны основные свойства объектной модели - инкапсуляции,
наследование, полиморфизм. Основ­ными видами отношений между классами являются
наследование, ассоци­ация, агрегация, метакласс. Также были описаны правила
изображения классов и связей между ними на языке ТЛМЬ.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>1.      Почему объектно-ориентированное
программирование
пришло на смену процедурному программированию?

</p>
<p>&#9633;       программы,
написанные с использованием ООП, выполняются на компьютере быстрее

</p>
<p>&#9633;       использование
ООП позволяет создавать не зависящие от платформы программы

</p>
<p>&#9633;       
ООП позволяет уменьшить
сложность создаваемого ПО

</p>
<p>&#9633;       
ООП позволяет увеличить
надежность создаваемого ПО

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Что
используется для описания поведения объекта?

</p>
<p>&#9633;        поля
П   методы

</p>
<p>П   наследование

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Инкапсуляция
- это:

</p>
<p>&#9633;       объединение
данных и обрабатывающего
их программного кода в одной логической структуре (классе)

</p>
<p>&#9633;       сокрытие
реализации класса и отделение его внутреннего представления от внешнего
интерфейса

</p>
<p>&#9633;       одно
из базовых понятий ООП, которое позволяет расширять функциональность программы,
не расширяя объектную модель этой программы








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="489" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="437" height="269" src="http://kufas.ru/java.files/image011.png"></center></td>
 </tr>
</table>


Вариант 2

<p> 

</p>
<p> 

</p>
<p>1.       Что
из перечисленного является классами,
а что - объектами (отметьте классы):

</p>
<p>П      яблоко

</p>
<p>П      Иван
Сидорович Петров

</p>
<p>П      легковой
автомобиль

</p>
<p>&#9633;       страховое
свидетельство №113-043-429-18

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Зачем
нужен полиморфизм?

</p>
<p>П   полиморфизм
используется для написания общего кода,

</p>
<p>который
будет одинаково работать с разными типами данных (объектами разных классов),
при условии, что классы, от которых созданы эти объекты, имеют общего предка

</p>
<p>П   полиморфизм
позволяет создавать в одном классе несколько методов с одинаковыми именами, но
с разным набором параметров

</p>
<p>П   полиморфизм
необходим в любой программе, использующей ООП. Без него невозможно написать
программу на объектноориентированном языке программирования

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Метакласс
- это:

</p>
<p>П   базовый
класс в дереве наследования. Все потомки этого класса расширяют или замещают
его функциональность

</p>
<p>П   некоторый
шаблон, который описывает свойства и поведение класса, подобно тому, как класс
описывает свойства и поведение объекта

</p>
<p>П   класс,
от которого наследуются все классы в дереве наследования. Любой из классов в
программе обязательно является наследником этого класса (пример java.lang.Object)

</p>
<p>2.   Что из перечисленного является в классе «Лифт»
внешним интерфейсом:

</p>
<p>&#9633;       кнопки
управления П    разводка проводов

</p>
<p>&#9633;      
реакция на нажатие какой-либо
кнопки П                количество людей в лифте

</p>
<p>П   марка металла, из которого изготовлен
трос

</p>
<p> 

</p>
<p>3&gt;   Множественным наследованием
называют:

</p>
<p>П   ситуацию, когда у некоторого класса
есть более чем один непосредственный наследник

</p>
<p>О   наследование, в котором участвует
множество классов (более двух)

</p>
<p>О   отношение наследования, при котором
класс-наследник расширяет или дополняет функциональность нескольких базовых
классов








</p>
<p>—==

</p>
<p>
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<center><h2>Лекция
2. Основы объектно-ориентированного программирования</h2></center>

<p> 

</p>
<p> 

</p>
<p>В этой лекции излагается основная концепция
объектно-ориентирован­ного подхода (ООП) к проектированию программного
обеспечения. Поскольку в Java почти все типы (за
исключением восьми простейших) являются объектны­ми, владение ООП становится
необходимым условием для успешного примене­ния языка. Лекция имеет вводный,
обзорный характер. Для более детального изучения предлагается список
дополнительной литературы и Internet-ресурсов.

</p>
<p> 

</p>
<p>Ключевые слова: блок-схема, объектно-ориентированное програм­мирование, ООП, объект, состояние, поведение, уникальность, класс, UML, конструктор,
деструктор, инкапсуляция, модульность, наследование, класс-предок, суперкласс,
класс-потомок, подкласс, полиморфизм, перегруженная функция, перегрузка,
ассоциация, метакласс.

</p>
<p> 

</p>
<p>Методология
процедурно-ориентированного программирования

</p>
<p>Появление первых электронных вычислительных машин, или
компью­теров, ознаменовало новый этап в развитии техники вычислений. Казалось,
достаточно разработать последовательность элементарных действий, каж­дое из
которых можно преобразовать в понятные компьютеру инструкции, и любая
вычислительная задача будет решена. Эта идея оказалась настоль­ко
жизнеспособной, что долгое время доминировала над всем процессом разработки
программ. Появились специализированные языки программи­рования, созданные для
разработки программ, предназначенных для ре­шения вычислительных задач.
Примерами таких языков могут служить FOCAL (FOrmula CALculator) и FORTRAN
(FORmula TRANslator).

</p>
<p>Основой такой методологии разработки программ являлась
проце­дурная, или алгоритмическая, организация структуры программного ко­да.
Это было настолько естественно для решения вычислительных задач, То
целесообразность такого подхода ни у кого не вызывала сомнений. Исходным в
данной методологии было понятие алгоритма. Алгоритм — ^o способ решения вычислительных и других задач, точно описываю­щий
определенную последовательность действий, которые необходимо выполнить для
достижения заданной цели. Примерами алгоритмов явля­ется хорошо известные
правила нахождения корней квадратного уравне­ния или линейной системы
уравнений.








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="481" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="452" height="457" src="http://kufas.ru/java.files/image005.png"></center></td>
 </tr>
</table>


При увеличении объемов программ для упрощения их
разработки по­явилась необходимость разбивать большие задачи на подзадачи
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В языках программирования возникло и закрепилось новое понятие процедуры.
Ис­пользование процедур позволило разбивать большие задачи на подзадачи и таким
образом упростило написание больших программ. Кроме того, про­цедурный подход
позволил уменьшить объем программного кода за счет написания часто используемых
кусков кода в виде процедур и их примене­ния в различных частях программы.

</p>
<p>Как и алгоритм, процедура представляет собой законченную последо­вательность
действий или операций, направленных на решение отдельной задачи. В языках программирования появилась специальная синтаксичес­кая
конструкция, которая также получила название процедуры. Например, на языке Pascal описание процедуры
выглядит следующим образом:

</p>
<p> 

</p>
<p>Procedure printGreeting(name: String) Begin

</p>
<p>Print("Hello,
");

</p>
<p>PrintLn(s); End;

</p>
<p>Назначение данной процедуры — вывести на экран приветствие Hello, Name, где Name передается в процедуру в качестве входного параметра.

</p>
<p>Со временем
вычислительные задачи становились все сложнее, а зна­чит, и решающие их
программы увеличивались в размерах. Их разработка превратилась в серьезную
проблему. Когда программа становится все боль­ше, ее приходится разделять на
все более мелкие фрагменты. Основой для такого разбиения как раз и стала
процедурная декомпозиция, при которой отдельные части программы, или модули,
представляли собой совокупность процедур для решения одной или нескольких
задач. Одна из основных осо­бенностей процедурного программирования заключается
в том, что оно позволило создавать библиотеки подпрограмм (процедур), которые
можно было бы использовать повторно в различных проектах или в рамках одного
проекта. При процедурном подходе для визуального представления алгорит­ма
выполнения программы применяется так называемая блок-схема. Соот­ветствующая
система графических обозначений была зафиксирована в ГОСТ 19.701-90. Пример
блок-схемы изображен на рисунке (рис. 2.1).

</p>
<p>Появление и интенсивное использование условных операторов и опе­ратора
безусловного перехода стало предметом острых дискуссий среди специалистов по
программированию. Дело в том, что бесконтрольное при­менение в программе
оператора безусловного перехода goto может замет­но осложнить понимание кода. Такие запутанные
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>программы
сравнивали с порцией спагетти (bowl of
spaghetti), имея в виду многочисленные
перехо­да от одного фрагмента программы к другому, или, что еще
хуже, возврат % конечных операторов программы к начальным. Ситуация
казалась на-ТОМгько драматичной, что многие предлагали исключить оператор goto из языков программирования. Именно с
этого времени отсутствие безуслов­ных переходов стали считать хорошим стилем программирования.

</p>
<p>Дальнейшее увеличение программных систем способствовало фор­мированию
новой точки зрения на процесс разработки программ и нали­чия программных кодов, которая получила название методологии структурного
программирования. Ее основой является процедурная де­композиция предметной
области решаемой задачи и организация отдель­ных модулей в виде совокупности процедур. В рамках этой методологии п°лучило развитие нисходящее проектирование программ, или проекти­рование
"сверху вниз". Пик популярности идей структурного программи­рования
приходится на конец 70-х — начало 80-х годов.

</p>
<p>В этот период основным показателем сложности разработки программ
считался ее размер. Вполне серьезно обсуждались такие оценки сложности
программ, как количество строк программного кода. Правда, при этом дела­лись
некоторые предположения относительно синтаксиса самих строк, ко­торые должны
были соответствовать определенным требованиям. Напри­мер, каждая строка кода
должна была содержать не более одного оператора. Общая трудоемкость разработки
программ оценивалась специальной едини­цей измерения —
"человеко-месяц", или "человеко-год". А профессионализм
программиста напрямую связывался с количеством строк программного ко­да,
который он мог написать и отладить в течение, скажем, месяца.

</p>
<p> 

</p>
<p>Методология объектно-ориентированного программирования

</p>
<p>Увеличение размеров программ приводило к необходимости привле­чения
большего числа программистов, что, в свою очередь, потребовало дополнительных
ресурсов для организации их согласованной работы. В пронессе разработки
приложений заказчик зачастую изменял функцио­нальные требования, что еще более
усложняло процесс создания про­граммного обеспечения.

</p>
<p>Но не менее важными оказались качественные изменения, связан­ные со
смещением акцента использования компьютеров
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В эпоху "боль­ших машин"
основными потребителями программного обеспечения были такие крупные заказчики,
как большие производственные предприятия, финансовые компании, государственные
учреждения. Стоимость таких вычислительных устройств для небольших предприятий
и организаций была слишком высока.

</p>
<p>Позже появились персональные компьютеры, которые имели гораз­до меньшую
стоимость и были значительно компактнее. Это позволило широко использовать их в
малом и среднем бизнесе. Основными задачами в этой области являются обработка
данных и манипулирование ими, по­этому вычислительные и
расчетно-алгоритмические задачи с появлением персональных компьютеров отошли на
второй план.

</p>
<p>Как показала практика, традиционные методы процедурного про­граммирования
не способны справиться ни с нарастающей сложностью программ и их разработки, ни
с необходимостью повышения их надежно­сти. Во второй половине 80-х годов
возникла настоятельная потребность в новой методологии программирования,
которая была бы способна ре­шить весь этот комплекс проблем. Ею стало
объектно-ориентированное программирование (ООП).

</p>
<p>После составления технического задания начинается этап проекти­рования,
или дизайна, будущей системы. Объектно-ориентированный подход к проектированию
основан на представлении предметной области задачи в виде множества моделей для
независимой от языка разработки программной системы на основе ее прагматики.

</p>
<p>Последний термин нуждается в пояснении. Прагматика определяется целью
разработки программной системы, например, обслуживание клиен-» тов банка,
управление работой аэропорта, обслуживание чемпионата мира t, по футболу и т.п. В формулировке цели участвуют предметы и понятия ре­ального
мира, имеющие отношение к создаваемой системе (см. рисунок 2.2 f |3]). При объектно-ориентированном подходе эти предметы и понятия за­меняются
моделями, т.е. определенными формальными конструкциями.

</p>
<p></p>
<center><img border="0" width="444" height="215" src="http://kufas.ru/java.files/image006.jpg"></center>

<p> 

</p>
<p>Рис. 2.2. Семантика (смысл программы с точки зрения выполняю­щего ее компьютера) и
прагматика (смысл программы с точки зре­ния ее пользователей) [3].

</p>
<p>Модель содержит не все
признаки и свойства представляемого ею едмета или понятия, а только те, которые
существенны для разрабаты-емой программной системы. Таким образом, модель
"беднее", а следо-|тельно, проще представляемого ею предмета или
понятия.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Простота модели по
отношению к реальному предмету позволяет делать ее формальной. Благодаря такому
характеру моделей при разра-гке можно четко выделить все зависимости и операции
над ними в со-



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0">
 <tr>
  <td valign="top" align="left">
  <p>^
  </p>
</td>
 </tr>
</table>



<p>аваемой программной
системе. Это упрощает как разработку и изучение „ Кализ) моделей, так и их
реализацию на компьютере.

</p>
<p>Объектно-ориентированный подход помогает справиться с такими проблемами,
как:

</p>
<p>•   
уменьшение сложности
программного обеспечения;

</p>
<p>•   
повышение надежности
программного обеспечения;

</p>
<p>•    обеспечение возможности модификации отдельных компонентов программного
обеспечения без изменения остальных его компо­нентов;

</p>
<p>•    обеспечение возможности повторного использования отдельных компонентов
программного обеспечения.

</p>
<p>Более детально преимущества и недостатки объектно-ориентирован­ного
программирования будут рассмотрены в конце лекции, так как для их понимания
необходимо знание основных понятий и положений ООП.

</p>
<p>Систематическое применение объектно-ориентированного подхода позволяет
разрабатывать хорошо структурированные, надежные в экс­плуатации, достаточно
просто модифицируемые программные системы. Этим объясняется интерес
программистов к объектно-ориентированному подходу и объектно-ориентированным
языкам программирования. ООП является одним из наиболее интенсивно развивающихся
направлений теоретического и прикладного программирования.

</p>
<p> 

</p>
<p>Объекты

</p>
<p>По определению будем называть объектом понятие, абстракцию или любой
предмет с четко очерченными границами, имеющий смысл в контексте
рассматриваемой прикладной проблемы. Введение объектов преследует две цели:

</p>
<p>•   
понимание прикладной
задачи (проблемы);

</p>
<p>•   
введение основы для
реализации на компьютере.

</p>
<p>Примеры объектов:
форточка, Банк "Империал", Петр Сидоров, дело № 7461, сберкнижка и
т.д.

</p>
<p>Каждый объект имеет определенное время жизни. В процессе выпол­нения
программы, или функционирования какой-либо реальной систе­мы, могут создаваться
новые объекты и уничтожаться уже существующие.

</p>
<p>Гради Буч дает следующее
определение объекта:

</p>
<p>Объект — это мыслимая или реальная сущность, обладающая харак­терным
поведением и отличительными характеристиками и являющаяся важной в предметной
области [2].

</p>
<p>Каждый объект имеет состояние, обладает четко определенным пове­дением и
уникальной идентичностью.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Состояние

</p>
<p>Рассмотрим пример. Любой человек может находиться в некотором положении
(состоянии): стоять, сидеть, лежать, и — в то же время совер­шать какие либо
действия.

</p>
<p>Например, человек может прыгать, если он стоит, и не может — если он
лежит, для этого ему потребуется сначала встать. Также в объектно­ориентированном
программировании состояние объекта может опреде­ляться наличием или отсутствием
связей между моделируемым объектом и другими объектами. Более подробно все
возможные связи между объек­тами будут рассмотрены в разделе "Типы
отношений между классами".

</p>
<p>Например, если у человека есть удочка (у него есть связь с объектом
"Удочка"), он может ловить рыбу, а если удочки нет, то такое действие
не­возможно. Из этих примеров видно, что набор действий, которые может
совершать человек, зависит от параметров объекта, его моделирующего.

</p>
<p>Для рассмотренных выше примеров такими характеристиками, или атрибутами,
объекта "Человек" являются:

</p>
<p>•   
текущее положение человека
(стоит, сидит, лежит);

</p>
<p>•   
наличие удочки (есть или
нет).

</p>
<p>В конкретной задаче могут появиться и другие свойства, например,
физическое состояние, здоровье (больной человек обычно не прыгает).

</p>
<p>Состояние (state) - совокупный результат поведения объекта: одно из стабильных условий,
в которых объект может существовать, охаракте­ризованных количественно; в любой
момент времени состояние объекта включает в себя перечень (обычно статический)
свойств объекта и теку­щие значения (обычно динамические) этих свойств [2].

</p>
<p> 

</p>
<p>Поведение

</p>
<p>Для каждого объекта существует определенный набор действий, которые с
ним можно произвести. Например, возможные действия с некоторым файлом
операционной системы ПК:

</p>
<p>•   
создать;

</p>
<p>•   
открыть;

</p>
<p>•   
читать из файла;

</p>
<p>•   
писать в файл;

</p>
<p>•   
закрыть;

</p>
<p>•   
удалить.

</p>
<p>Результат выполнения действий зависит от состояния объекта на мо­мент
совершения действия, т.е. нельзя, например, удалить файл, если он открыт
кем-либо (заблокирован). В то же время действия могут менять внутреннее
состояние объекта - при открытии или закрытии файла свой­ство
"открыт" принимает значения "да" или "нет",
соответственно.

</p>
<p>Программа, написанная с использованием ООП, обычно состоит из Множества
объектов, и все эти объекты взаимодействуют между собой, обычно говорят, что
взаимодействие между объектами в программе про­исходит посредством передачи
сообщений между ними.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>^ В терминологии
объектно-ориентированного подхода понятия "дейст­ве ,
"сообщение" и "метод" являются синонимами. Т.е. выражения
"выпол­нить действие над объектом", "вызвать метод объекта"
и "послать сообщение объекту для выполнения какого-либо действия"
эквивалентны. Последняя фраза появилась из следующей модели. Программу,
построенную по техно­логии ООП, можно представить себе как виртуальное
пространство, запол­ненное объектами, которые условно "живут"
некоторой жизнью. Их актив­ность проявляется в том, что они вызывают друг у
друга методы, или посы­лают друг другу сообщения. Внешний интерфейс объекта,
или набор его ме­тодов,— это описание того, какие сообщения он может принимать.

</p>
<p>Поведение (behavior) — действия и реакции объекта, выраженные в терминах передачи
сообщений и изменения состояния; видимая извне и воспроизводимая активность
объекта [2].

</p>
<p> 

</p>
<p>Уникальность

</p>
<p>Уникальность - это то, что отличает объект от других объектов. На­пример,
у вас может быть несколько одинаковых монет. Даже если абсо­лютно все их
свойства (атрибуты) одинаковы (год выпуска, номинал и т.д.) и при этом вы
можете использовать их независимо друг от друга, они по-прежнему остаются
разными монетами.

</p>
<p>В машинном
представлении под параметром уникальности объекта чаще всего понимается адрес
размещения объекта в памяти.

</p>
<p>Identity (уникальность)
объекта состоит в том, что всегда можно оп­ределить, указывают две ссылки на
один и тот же объект или на разные объекты. При этом два объекта могут во всем
быть похожими, их образ в памяти может представляться одинаковыми последовательностями бай­тов,
но, тем не менее, их Identity может быть
различна.

</p>
<p>Наиболее распространенной ошибкой является понимание уни­кальности как
имени ссылки на объект. Это неверно, т.к. на один объект может указывать
несколько ссылок, и ссылки могут менять свои значения (ссылаться на другие
объекты).

</p>
<p>Итак, уникальность (identity) - свойство
объекта; то, что отличает его от других объектов (автор не согласен с переводом
русского издания [2], поэтому здесь приводится авторский перевод).

</p>
<p> 

</p>
<p>Классы

</p>
<p>Все монеты из предыдущего примера принадлежат одному и тому же классу
объектов (именно с этим связана их одинаковость)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Номинальная стоимость монеты,
металл, из которого она изготовлена, форма - это ат­рибуты класса. Совокупность
атрибутов и их значений характеризует объ­ект. Наряду с термином
"атрибут" часто используют термины "свойство" и
"поле", которые в объектно-ориентированном программировании явля­ются
синонимами.

</p>
<p>Все объекты одного и того же класса описываются одинаковыми на­борами
атрибутов. Однако объединение объектов в классы определяется не наборами
атрибутов, а семантикой. Так, например, объекты "конюш­ня" и
"лошадь" могут иметь одинаковые атрибуты: цена и возраст. При этом
они могут относиться к одному классу, если рассматриваются в зада­че просто как
товар, либо к разным классам, если в рамках поставленной задачи будут
использоваться по-разному, т.е. над ними будут совершаться различные действия.

</p>
<p>Объединение объектов в классы позволяет рассмотреть задачу в бо­лее
общей постановке. Класс имеет имя (например, "лошадь"), которое относится
ко всем объектам этого класса. Кроме того, в классе вводятся имена атрибутов,
которые определены для объектов. В этом смысле опи­сание класса аналогично
описанию типа структуры или записи (record), широко
применяющихся в процедурном программировании; при этом каждый объект имеет тот
же смысл, что и экземпляр структуры (перемен­ная или константа соответствующего
типа).

</p>
<p>Формально класс - это шаблон поведения объектов определенного типа с
заданными параметрами, определяющими состояние. Все экземп­ляры одного класса
(объекты, порожденные от одного класса) имеют один и тот же набор свойств и
общее поведение, то есть одинаково реаги­руют на одинаковые сообщения

</p>
<p></p>
<center><img border="0" width="132" height="122" src="http://kufas.ru/java.files/image007.jpg"></center>

<p>^ В соответствии с UML (Unified Modeling Language - унифицирован­ный
язык моделирования), класс имеет следующее графическое представ­ление.

</p>
<p>Класс изображается в виде прямоугольника, состоящего из трех час­тей. В
верхней части помещается название класса, в средней - свойства объектов класса,
в нижней - действия, которые можно выполнять с объ­ектами данного класса
(методы).

</p>
<p>Каждый класс также может иметь специальные методы, которые ав­томатически
вызываются при создании и уничтожении объектов этого Класса:

</p>
<p>•  
конструктор (constructor) - выполняется при создании объектов;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•  
деструктор (destructor) - выполняется при уничтожении объектов.

</p>
<p>Обычно конструктор и деструктор имеют специальный синтаксис, который
может отличаться от синтаксиса, используемого для написания обычных методов
класса.

</p>
<p> 

</p>
<p>Инкапсуляция

</p>
<p>Инкапсуляция (encapsulation) — это сокрытие реализации класса и отделение его внутреннего
представления от внешнего (интерфейса). При использовании
объектно-ориентированного подхода не принято применять прямой доступ к
свойствам какого-либо класса из методов других классов. Для доступа к свойствам
класса принято задействовать специальные методы этого класса для получения и
изменения его свойств.

</p>
<p>Внутри объекта данные и методы могут обладать различной степенью
открытости (или доступности). Степени доступности, принятые в языке Java, подробно будут
рассмотрены лекции 6. Они позволяют более тонко управлять свойством
инкапсуляции.

</p>
<p>Открытые члены класса составляют внешний интерфейс объекта. Это та
функциональность, которая доступна другим классам. Закрытыми обычно объявляются
все свойства класса, а также вспомогательные методы, которые являются деталями
реализации и от которых не должны зависеть другие части системы.

</p>
<p>Благодаря сокрытию реализации за внешним интерфейсом класса можно менять
внутреннюю логику отдельного класса, не меняя код осталь­ных компонентов
системы. Это свойство называется модульность.

</p>
<p>Обеспечение доступа к свойствам класса только через его методы так­же
дает ряд преимуществ. Во-первых, так гораздо проще контролировать корректные
значения полей, ведь прямое обращение к свойствам отслежи­вать невозможно, а
значит, им могут присвоить некорректные значения.

</p>
<p>Во-вторых, не
составит труда изменить способ хранения данных. Ес­ли информация станет
храниться не в памяти, а в долговременном храни­лище, таком как файловая
система или база данных, потребуется изменить лишь ряд методов одного класса, а
не вводить эту функциональность во все части системы.

</p>
<p>Наконец, программный код, написанный с использованием данно­го принципа,
легче отлаживать. Для того, чтобы узнать, кто и когда изме­нил свойство
интересующего нас объекта, достаточно добавить вывод от­ладочной информации в
тот метод объекта, посредством которого осуще­ствляется доступ к свойству этого
объекта. При использовании прямого до­ступа к свойствам объектов программисту
пришлось бы добавлять вывод отладочной информации во все участки кода, где
используется интересую­щий нас объект.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Наследование

</p>
<p>Наследование (inheritance) — это отношение между классами, при ко­тором класс использует структуру или поведение другого класса (одиноч­ное наследование), или других (множественное наследование) классов. Наследование вводит иерархию "общее/частное", в которой подкласс на­следует от одного или нескольких более общих суперклассов. Подклассы обычно дополняют или переопределяют унаследованную структуру и по­ведение.

</p>
<p>В качестве примера можно рассмотреть задачу, в которой необходи­мо
реализовать классы "Легковой автомобиль" и "Грузовой
автомобиль". Очевидно, эти два класса имеют общую функциональность. Так, оба они имеют 4
колеса, двигатель, могут перемещаться и т.д. Всеми этими
свой-ствами обладает любой автомобиль, независимо от того, грузовой он или двгковой, 5- или 12-местный. Разумно вынести эти общие свойства и функциональность
в отдельный класс, например, "Автомобиль" и насле­довать от него классы "Легковой автомобиль" и "Грузовой
автомобиль", чтобы избежать повторного написания одного и того же кода в разных классах.

</p>
<p></p>
<center><img border="0" width="387" height="153" src="http://kufas.ru/java.files/image008.jpg"></center>

<p>Отношение обобщения обозначается сплошной линией с треуголь­ной стрелкой на конце. Стрелка указывает на более общий класс (класс-Иредок
или суперкласс), а ее отсутствие - на более специальный класс (класс-потомок
или подкласс).

</p>
<p>Использование наследования способствует уменьшению количества кода,
созданного для описания схожих сущностей, а также способствует НагШсанию
более эффективного и гибкого кода.

</p>
<p>В рассмотренном примере применено одиночное наследование. Не­который
класс также может наследовать свойства и поведение сразу не-сКольких
классов. Наиболее популярным примером применения множе-СТвенного
наследования является проектирование системы учета товаров в зоомагазине.

</p>
<p>Все животные в зоомагазине являются наследниками класса "Живот­ное",
а также наследниками класса "Товар". Т.е. все они имеют возраст, нуж­даются
в пище и воде и в то же время имеют цену и могут быть проданы.

</p>
<p>Множественное наследование на диаграмме изображается точно так же, как
одиночное, за исключением того, что линии наследования соеди­няют класс-потомок
сразу с несколькими суперклассами.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Не все объектно-ориентированные языки программирования содер­жат
языковые конструкции для описания множественного наследования.

</p>
<p>В языке Java множественное
наследование имеет ограниченную под­держку через интерфейсы и будет рассмотрено
в лекции 8.

</p>
<p> 

</p>
<p>Полиморфизм

</p>
<p>Полиморфизм является одним из фундаментальных понятий в объ­ектно-ориентированном
программировании наряду с наследованием и инкапсуляцией. Слово
"полиморфизм" греческого происхождения и оз­начает "имеющий
много форм". Чтобы понять, что оно означает приме­нительно к
объектно-ориентированному программированию, рассмот­рим пример.

</p>
<p>Предположим, мы хотим создать векторный графический редактор, в котором
нам нужно описать в виде классов набор графических прими­тивов - Point, Line, Circle, Box и т.д. У каждого из этих классов определим метод draw для отображения соответствующего примитива на экране.

</p>
<p>Очевидно, придется написать код, который при необходимости ото­бразить
рисунок будет последовательно перебирать все примитивы, на момент отрисовки
находящиеся на экране, и вызывать метод draw у каж­дого из них. Человек, незнакомый с полиморфизмом, вероятнее всего,
создаст несколько массивов (отдельный массив для каждого типа прими­тивов) и
напишет код, который последовательно переберет элементы из каждого массива и
вызовет у каждого элемента метод draw. В результате
получится примерно следующий код:

</p>
<p> 

</p>
<p>//создание пустого массива, который может содержать //объекты Pointe максимальным
объемом 1000 Point[] р = new Point[1000];

</p>
<p>Line[] I   = new Line[ 1000]; Circlef] c= new
Circle[1000]; Box[]b = new Box[1000];

</p>
<p> 

</p>
<p>//предположим, в этом
месте происходит заполнение

</p>
<p>// всех массивов
соответствующими объектами

</p>
<p> 

</p>
<p>1ог(Ы \ = 0;\&lt;
р.\епдт;\++) { //цикл с перебором
всех ячеек массива.

</p>
<p>//вызов метода draw() в случае,

</p>
<p>// если ячейка не пустая.

</p>
<p>1т(р[1]!=пШ1) p.draw();

</p>
<p>}

</p>
<p>тогО'т I = 0; |" &lt; 1.1епдтх1;1++) {
1т(1[1]!=пи11) 1.с1гауу();

</p>
<p>}

</p>
<p>1ог(\Ш \-0;\&lt;
с.1епд№;1++)
{ №(с[1]!=пи11)
c.draw();

</p>
<p>}

</p>
<p>1ог(\п\. I = 0; 1
&lt; Ь.1епдтп;!++)
{ |т(Ь[ф=пи11)
b.draw();

</p>
<p>}

</p>
<p> 

</p>
<p>Недостатком написанного выше кода является дублирование практи­чески
идентичного кода для отображения каждого типа примитивов. Также неудобно то, что
при дальнейшей модернизации нашего графического ре­дактора и добавлении
возможности рисовать новые типы графических примитивов, например Text, Star и т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>д., при таком подходе придется менять существующий код и добавлять в
него определения новых массивов, а так­же обработку содержащихся в них
элементов.

</p>
<p>Используя полиморфизм, мы можем значительно упростить реали­зацию
подобной функциональности. Прежде всего, создадим общий ро­дительский класс для
всех наших классов. Пусть таким классом будет Point. В результате
получим иерархию классов, которая изображена на рисунке 2.3.

</p>
<p>У каждого из дочерних классов метод draw переопределен таким об­разом, чтобы отображать экземпляры каждого класса
соответствующим образом.

</p>
<p>Для описанной выше иерархии классов, используя полиморфизм, можно
написать следующий код:

</p>
<p> 

</p>
<p>Point р[] = new Point[
1000]; Р[0] = new Circle();








</p>
<p>курс




</p>
<p>Программирование
на Java




</p>
<p>Лекция
2_____________________ Основы
объектно-ориентированного программирования








</p>
<p> 








</p>
<p>р[1] = new Point(); р[2] = new Вох(); р[3] = new Une();

</p>
<p>for(int i = 0; i &lt; p.length;i++) { if(p[i]!=null) p.draw();

</p>
<p>}

</p>
<p> 

</p>
<p>В описанном выше примере массив р[] может содержать любые объ­екты, порожденные от наследников класса Point. При вызове какого-либо метода у любого из элементов этого массива будет
выполнен метод того объекта, который содержится в ячейке массива. Например,
если в ячейке р[0] находится объект Circle, то при вызове метода draw следующим образом:

</p>
<p> 

</p>
<p>p[0].draw()

</p>
<p>нарисуется круг, а не точка.

</p>
<p>В заключение приведем
формальное определение полиморфизма.

</p>
<p>Полиморфизм (polymorphism) - положение теории типов, согласно которому имена (например,
переменных) могут обозначать объекты раз­ных (но имеющих общего родителя)
классов. Следовательно, любой объ­ект, обозначаемый полиморфным именем, может
по-своему реагировать на некий общий набор операций [2].

</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="31" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="398" height="205" src="http://kufas.ru/java.files/image009.png"></center></td>
 </tr>
</table>


В процедурном программировании тоже существует понятие
полимор­физма, которое отличается от рассмотренного механизма в ООП. Процедур­ный
полиморфизм предполагает возможность создания нескольких проце­дур или функций
с одним и тем же именем, но разным количеством или раз­личными типами
передаваемых параметров. Такие одноименные функции называются перегруженными, а
само явление - перегрузкой (overloading). Перегрузка функций существует и в ООП и называется перегрузкой методов.

<p>Примером использования перегрузки
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>методов в языке Java может служить класс
PrinrWriter, который применяется, в частности, для вывода сообщений на консоль. Этот
класс имеет множество методов printin, ко­торые различаются типами и/или количеством входных параметров. Вот
лишь несколько из них:

</p>
<p>void printlnO                           //
переход на новую строку

</p>
<p>void println(boolean х)   // выводит значение
булевской

</p>
<p>// переменной (true или false) void println(String х)    
// выводит строку - значение

</p>
<p>//текстового
параметра.

</p>
<p>Определенные сложности возникают при вызове перегруженных методов. В Java существуют
специальные правила, которые позволяют решать эту проблему. Они будут
рассмотрены в соответствующей лекции.

</p>
<p> 

</p>
<p>Типы отношений между классами

</p>
<p>Как правило, любая программа, написанная на объектно-ориенти­рованном
языке, представляет собой некоторый набор связанных между собой классов. Можно
провести аналогию между написанием программы и строительством дома. Подобно
тому, как стена складывается из кирпичей, компьютерная программа с
использованием ООП строится из классов. Причем эти классы должны иметь
представление друг о друге, для того что­бы сообща выполнять
поставленную задачу.

</p>
<p>Возможны следующие связи между классами в рамках объектной модели
(приводятся лишь наиболее простые и часто используемые виды связей, подробное
их рассмотрение выходит за рамки этой ознакомитель­ной лекции):

</p>
<p>•   
агрегация (Aggregation);

</p>
<p>•   
ассоциация (Association);

</p>
<p>•   
наследование (Inheritance);

</p>
<p>•   
метаклассы (Metaclass).

</p>
<p> 

</p>
<p>Агрегация

</p>
<p>Отношение между классами типа "содержит" (contain) или "состоит из называется агрегацией, или включением. Например,
если аквариум Наполнен водой и в нем плавают рыбки, то можно сказать, что аквариум агрегирует в
себе воду и рыбок.








</p>
<p></p>
<center><img border="0" width="397" height="72" src="http://kufas.ru/java.files/image010.jpg"></center>

<p>Такое отношение включения, или агрегации (aggregation), изобража­ется линией с ромбиком на стороне того класса, который
выступает в ка­честве владельца, или контейнера. Необязательное название
отношения записывается посередине линии.

</p>
<p>В нашем примере отношение contain является
двунаправленным. Объект класса Aquarium содержит несколько
объектов Fish. В то же вре­мя каждая рыбка "знает", в каком именно аквариуме
она живет. Каждый класс имеет свою роль в агрегации, которая указывает, какое
место зани­мает класс в данном отношении. Имя роли не является обязательным
элементом обозначений и может отсутствовать на диаграмме
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В примере можно видеть роль home класса Aquarium (аквариум является домом
для рыбок), а также роль inhabitants класса Fish (рыбки являются обитателя­ми
аквариума). Название роли обычно совпадает с названием соответст­вующего поля в
классе. Изображение такого поля на диаграмме излишне, если уже указано имя
роли. Т.е. в данном случае класс Aquarium будет иметь свойство
(поле) inhabitants, а класс Fish - свойство home.

</p>
<p>Число объектов, участвующих в отношении, записывается рядом с именем
роли. Запись "0..п" означает "от нуля до бесконечности". Приняты также
обозначения:

</p>
<p>•   "1
..п" — от единицы до
бесконечности;

</p>
<p>•   
"О" - ноль;

</p>
<p>•   "
1 " — один;

</p>
<p>•   "п"
— фиксированное
количество;

</p>
<p>•   "0..
1 " — ноль или один.

</p>
<p>Код, описывающий рассмотренную модель и явление агрегации, может
выглядеть, например, следующим образом:

</p>
<p>//
определение класса Fish public class Fish {

</p>
<p>//
определения поля home (ссылка на объект Aquarium)

</p>
<p>private Aquarium home;

</p>
<p>public Fish() { }

</p>
<p>}

</p>
<p>// определение класса Aquarium public class Aquarium {

</p>
<p>// определения поля inhabitants (массив ссылок на объекты Fish) private Fish inhabitants[]; public Aquarium() { }

</p>
<p>}

</p>
<p> 

</p>
<p>Ассоциация

</p>
<p>Если объекты одного класса ссылаются на один или более объектов другого
класса, но ни в ту, ни в другую сторону отношение между объек­тами не носит
характера "владения", или контейнеризации, такое отно­шение называют
ассоциацией (association). Отношение ассоциации изоб­ражается так же, как и отношение агрегации,
но линия, связывающая классы,— простая, без ромбика.



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Computer
  </p>
</td>
 </tr>
</table>





<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Programmer
  </p>
</td>
 </tr>
</table>



<p>В качестве примера можно рассмотреть программиста и его компью­тер. Между
этими двумя объектами нет агрегации, но существует четкая взаимосвязь. Так,
всегда можно установить, за какими компьютерами ра­ботает какой-либо
программист, а также какие люди пользуются отдельно взятым компьютером. В рассмотренном примере имеет место ассоциация
"многие-ко-многим".



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>Computerт
  </p>
</td>
 </tr>
</table>





<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="14">
 <tr>
  <td valign="top" align="left" height="14">
  <p>0..n
  </p>
</td>
 </tr>
</table>



<p>-programmers   -computers

</p>
<p>Programmerт I 0 n

</p>
<p> 

</p>
<p>В данном случае между экземплярами классов Programmer и Computer в обе стороны используется
отношение "0..п", т.к. програм­мист, в принципе, может не работать с компьютером (если он
теоретик Или на пенсии). В свою очередь, компьютер может никем не использовать­ся (если он новый и
еще не установлен).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Код, соответствующий рассмотренному примеру, будет, например, следующим:

</p>
<p>public class Programmer {

</p>
<p>private Computer computers[];

</p>
<p>public Programmerт {

</p>
<p>}

</p>
<p>}

</p>
<p>public class Computer {

</p>
<p>private Programmer programmers[];

</p>
<p>public Computerт {

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Наследование

</p>
<p>Наследование является важным случаем отношений между двумя или более
классами. Подробно оно рассматривалось выше.

</p>
<p> 

</p>
<p>Метаклассы

</p>
<p>Итак, любой объект имеет структуру, состоящую из полей и методов.
Объекты, имеющие одинаковую структуру и семантику, описываются од­ним классом,
который и является, по сути, определением структуры объек­тов, порожденных от
него.

</p>
<p>В свою очередь, каждый класс, или описание, всегда имеет строгий шаблон,
задаваемый языком программирования или выбранной объект­ной моделью. Он
определяет, например, допустимо ли множественное наследование, какие существуют
ограничения на именование классов, как описываются поля и методы, набор
существующих типов данных и многое другое. Таким образом, класс можно
рассматривать как объект, у которого есть свойства (имя, список полей и их
типы, список методов, список аргументов для каждого метода и т.д.). Также класс
может обладать поведением, то есть поддерживать методы. А раз для любого
объекта су­ществует шаблон, описывающий свойства и поведение этого объекта,
значит, его можно определить и для класса. Такой шаблон, задающий раз­личные
классы, называется метаклассом.

</p>
<p>Чтобы представить себе, что такое метакласс, рассмотрим пример не­кой
бюрократической организации. Будем считать, что все классы в такой системе
представляют собой строгие инструкции, которые описывают, что нужно сделать,
чтобы породить новый объект (например, нанять нового служащего или открыть
новый отдел). Как и полагается классам, они опи­сывают все свойства новых
объектов (например, зарплату и профессио­нальный уровень для сотрудников,
площадь и имущество для отделов) и их поведение (обязанности служащих и функции
подразделений).

</p>
<p>В свою очередь,
написание новой инструкции можно строго регла­ментировать. Скажем, необходимо
использовать специальный бланк, при­держиваться правил оформления и заполнить
все обязательные поля (на­пример, номер инструкции и фамилии ответственных
работников). Такая "инструкция инструкций" и будет представлять собой
метакласс в ООП.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Итак, объекты порождаются от классов, а классы — от метакласса. Он, как
правило, в системе только один. Но существуют языки програм­мирования, в
которых можно создавать и использовать собственные мета­классы, например язык Python. В частности,
функциональность мета­класса может быть следующая: при формировании класса он
будет про­сматривать список всех методов в классе и, если имя метода имеет вид set_XXX или get_XXX, автоматически создавать поле с именем XXX, если такого не существует.

</p>
<p>Поскольку метакласс сам является классом, то нет никакого смысла в
создании "мета-мета-классов".

</p>
<p>В языке Java также есть метакласс. Это класс, который так и называ­ется — Class (описывает классы),
он располагается в основной библиоте­ке java.lang. Виртуальная машина использует его по прямому назначе­нию. Когда
загружается очередной .class-файл, содержащий описание нового класса, JVM порождает объект
класса Class, который будет хра­нить его структуру. Таким образом, Java использует
концепцию метаклас­са в самых практических целях. С помощью Class реализована поддерж­ка
статических (static) полей и методов. Наконец, этот класс содержит ряд методов, полезных
для разработчиков. Они будут рассмотрены в сле­дующих лекциях.

</p>
<p> 

</p>
<p>Достоинства ООП

</p>
<p>От любой методики разработки программного обеспечения мы ждем, что она
поможет нам в решении наших задач. Но одной из самых Значительных проблем
проектирования является сложность. Чем больше И сложнее программная
система, тем важнее разбить ее на небольшие, четко очерченные части. Чтобы
справиться со сложностью, необходимо абстрагироваться от деталей. В этом смысле
классы представляют собой весьма удобный инструмент.

</p>
<p>•  
Классы позволяют проводить
конструирование из полезных ком­понентов, обладающих простыми инструментами,
что позволяет абстрагироваться от деталей реализации.

</p>
<p>•  
Данные и операции над ними
образуют определенную сущность, и они не разносятся по всей программе, как
нередко бывает в случае процедурного программирования, а описываются вместе.
Локали­зация кода и данных улучшает наглядность и удобство сопровож­дения
программного обеспечения.

</p>
<p>•  
Инкапсуляция позволяет
привнести свойство модульности, что об­легчает распараллеливание выполнения
задачи между несколькими исполнителями и обновление версий отдельных
компонентов.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>ООП дает возможность создавать расширяемые системы. Это одно Из основных достоинств
ООП, и именно оно отличает данный подход от традиционных методов
программирования. Расширяемость означает, что существующую систему можно
заставить работать с новыми компонента­ми, причем без внесения в нее каких-либо
изменений. Компоненты мо­гут быть добавлены на этапе исполнения программы.

</p>
<p>Полиморфизм оказывается полезным преимущественно в следую­щих ситуациях.

</p>
<p>•  Обработка разнородных
структур данных.

</p>
<p>Программы могут
работать, не различая вида объектов, что существен­но упрощает код. Новые виды
могут быть добавлены в любой момент.

</p>
<p>•  Изменение поведения во
время исполнения.

</p>
<p>На этапе исполнения
один объект может быть заменен другим, что позволяет легко, без изменения кода,
адаптировать алгоритм в за­висимости от того, какой используется объект.

</p>
<p>•  Реализация работы с
наследниками.

</p>
<p>Алгоритмы можно
обобщить настолько, что они уже смогут рабо­тать более чем с одним видом
объектов.

</p>
<p>•  Создание
"каркаса" (framework).

</p>
<p>Независимые от
приложения части предметной области могут быть реализованы в виде набора
универсальных классов, или каркаса (framework), и в дальнейшем расширены за счет добавле­ния частей, специфичных для
конкретного приложения. Часто многоразового использования программного
обеспечения не удается добиться из-за того, что существующие компоненты уже не
отве­чают новым требованиям. ООП помогает этого достичь без нарушения работы
уже имеющихся клиентов, что позволяет извлечь максимум из многоразового
использования компонентов.

</p>
<p>•   
Сокращается время на
разработку, которое может быть отдано дру­гим задачам.

</p>
<p>•   
Компоненты многоразового использования
обычно содержат го­раздо меньше ошибок, чем вновь разработанные, ведь они уже
не раз подвергались проверке.

</p>
<p>•   
Когда некий компонент
используется сразу несколькими клиента­ми, улучшения, вносимые в его код,
одновременно оказывают по­ложительное влияние и на множество работающих с ним
программ.

</p>
<p>•   Если программа опирается на стандартные компоненты, ее структура и
пользовательский интерфейс становятся более уни­фицированными, что облегчает ее
понимание и упрощает ис­пользование.

</p>
<p> 

</p>
<p>Недостатки ООП

</p>
<p>Документирование классов - задача более трудная, чем это было в слу­чае
процедур и модулей
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Поскольку любой метод может быть переопреде­лен, в
документации должно говориться не только о том, что делает данный метод, но и о
том, в каком контексте он вызывается. Ведь переопределен­ные методы обычно
вызываются не клиентом, а самим каркасом. Таким образом, программист должен
знать, какие условия выполняются, когда вызывается данный метод. Для
абстрактных методов, которые пусты, в документации должно говориться о том, для
каких целей предполагается использовать переопределяемый метод.

</p>
<p>В сложных иерархиях классов поля и методы обычно наследуются с разных
уровней. И не всегда легко определить, какие поля и методы фак­тически
относятся к данному классу. Для получения такой информации нужны специальные
инструменты, вроде навигаторов классов. Если кон­кретный класс расширяется, то
каждый метод обычно сокращают перед передачей сообщения базовому классу.
Реализация операции, таким об­разом, рассредоточивается по нескольким классам,
и чтобы понять, как она работает, нам приходится внимательно просматривать весь
код.

</p>
<p>Методы, как правило, короче процедур, поскольку они осуществляют только
одну операцию над данными, зато их намного больше. В коротких методах легче
разобраться, но они неудобны тем, что код для обработки со­общения иногда
"размазан" по многим маленьким методам.

</p>
<p>Инкапсуляцией данных не следует злоупотреблять. Чем больше ло­гики и
данных скрыто в недрах класса, тем сложнее его расширять. От­правной точкой
здесь должно быть не то, что клиентам не разрешается знать о тех или иных
данных, а то, что клиентам для работы с классом этих данных знать не требуется.

</p>
<p>Многие считают, что ООП является неэффективным. Как же обстоит де­ло в
действительности? Мы должны проводить четкую грань между неэффек­тивностью на
этапе выполнения, неэффективностью в смысле распределения памяти и
неэффективностью, связанной с излишней универсализацией.

</p>
<p>1. Неэффективность на этапе выполнения. В языках типа Smalltalk со­общения
интерпретируются во время выполнения программы путем осуществления их поиска в
одной или нескольких таблицах и за счет выбора подходящего метода. Конечно, это
медленный процесс. И да­же при использовании наилучших методов оптимизации Smalltalk-программы в десять раз медленнее оптимизированных С-программ. В
гибридных языках типа Oberon-2, Object Pascal и С++ отправка
сообщения приводит лишь к вызову через указатель процедурной переменной. На
некоторых машинах сообщения выполняются лишь на 10% медленнее, чем обычные
процедурные вызовы. И по­скольку сообщения встречаются в программе гораздо реже
других операций, их воздействие на время выполнения влияния практи­чески не
оказывает.

</p>
<p>Однако существует
другой фактор, который влияет на время выпол­нения: это инкапсуляция данных.
Рекомендуется не предоставлять прямой доступ к полям класса, а выполнять каждую
операцию над данными через методы. Такая схема приводит к необходимости вы­полнения
процедурного вызова каждый раз при доступе к данным. Однако если инкапсуляция
используется только там, где она необ­ходима (т.е. в тех случаях, когда это
становится преимуществом), то замедление вполне приемлемое.

</p>
<p>2. 
Неэффективность в смысле
распределения памяти. Динамическое связывание и проверка типа на этапе
выполнения требуют по ходу работы информации о типе объекта. Такая информация
хранится в дескрипторе типа и он выделяется один на кл&amp;сс. Каждый объект
имеет невидимый указатель на дескриптор типа для своего класса. Таким образом,
в объектно-ориентированных программах необхо­димая дополнительная память выражается
в одном указателе для объекта и в одном дескрипторе типа для класса.

</p>
<p>3. 
Излишняя универсальность.
Неэффективность также может озна­чать, что в программе реализованы избыточные
возможности. В библиотечном классе часто содержится больше методов, чем это
реально необходимо. А поскольку лишние методы не могут быть удалены, они
становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на
размере кода.

</p>
<p>Одно из возможных
решений — строить базовый класс с минималь­ным числом методов, а затем уже
реализовывать различные расши­рения этого класса, которые позволят нарастить
функциональность. Другой подход — дать компоновщику возможность удалять лиш­ние
методы. Такие интеллектуальные компоновщики уже сущест­вуют для различных
языков и операционных систем. Но нельзя утверждать, что ООП неэффективно. Если
классы исполь­зуются лишь там, где это действительно необходимо, то потеря
эффектив­ности из-за повышенного расхода памяти и меньшей производительности
незначительна. Кроме того, надежность программного обеспечения и быс­трота его
написания часто бывает важнее, чем производительность.

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции мы рассказали об объектно-ориентированном подхо­де к
разработке ПО, а также о том, что послужило предпосылками к его появлению и
сделало его популярным. Были рассмотрены ключевые по­нятия ООП - объект и
класс. Далее были описаны основные свойства объектной модели - инкапсуляции,
наследование, полиморфизм. Основ­ными видами отношений между классами являются
наследование, ассоци­ация, агрегация, метакласс. Также были описаны правила
изображения классов и связей между ними на языке ТЛМЬ.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>1.      Почему объектно-ориентированное
программирование
пришло на смену процедурному программированию?

</p>
<p>&#9633;       программы,
написанные с использованием ООП, выполняются на компьютере быстрее

</p>
<p>&#9633;       использование
ООП позволяет создавать не зависящие от платформы программы

</p>
<p>&#9633;       
ООП позволяет уменьшить
сложность создаваемого ПО

</p>
<p>&#9633;       
ООП позволяет увеличить
надежность создаваемого ПО

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Что
используется для описания поведения объекта?

</p>
<p>&#9633;        поля
П   методы

</p>
<p>П   наследование

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Инкапсуляция
- это:

</p>
<p>&#9633;       объединение
данных и обрабатывающего
их программного кода в одной логической структуре (классе)

</p>
<p>&#9633;       сокрытие
реализации класса и отделение его внутреннего представления от внешнего
интерфейса

</p>
<p>&#9633;       одно
из базовых понятий ООП, которое позволяет расширять функциональность программы,
не расширяя объектную модель этой программы








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="489" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="437" height="269" src="http://kufas.ru/java.files/image011.png"></center></td>
 </tr>
</table>


Вариант 2

<p> 

</p>
<p> 

</p>
<p>1.       Что
из перечисленного является классами,
а что - объектами (отметьте классы):

</p>
<p>П      яблоко

</p>
<p>П      Иван
Сидорович Петров

</p>
<p>П      легковой
автомобиль

</p>
<p>&#9633;       страховое
свидетельство №113-043-429-18

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Зачем
нужен полиморфизм?

</p>
<p>П   полиморфизм
используется для написания общего кода,

</p>
<p>который
будет одинаково работать с разными типами данных (объектами разных классов),
при условии, что классы, от которых созданы эти объекты, имеют общего предка

</p>
<p>П   полиморфизм
позволяет создавать в одном классе несколько методов с одинаковыми именами, но
с разным набором параметров

</p>
<p>П   полиморфизм
необходим в любой программе, использующей ООП. Без него невозможно написать
программу на объектноориентированном языке программирования

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Метакласс
- это:

</p>
<p>П   базовый
класс в дереве наследования. Все потомки этого класса расширяют или замещают
его функциональность

</p>
<p>П   некоторый
шаблон, который описывает свойства и поведение класса, подобно тому, как класс
описывает свойства и поведение объекта

</p>
<p>П   класс,
от которого наследуются все классы в дереве наследования. Любой из классов в
программе обязательно является наследником этого класса (пример java.lang.Object)

</p>
<p>2.   Что из перечисленного является в классе «Лифт»
внешним интерфейсом:

</p>
<p>&#9633;       кнопки
управления П    разводка проводов

</p>
<p>&#9633;      
реакция на нажатие какой-либо
кнопки П                количество людей в лифте

</p>
<p>П   марка металла, из которого изготовлен
трос

</p>
<p> 

</p>
<p>3&gt;   Множественным наследованием
называют:

</p>
<p>П   ситуацию, когда у некоторого класса
есть более чем один непосредственный наследник

</p>
<p>О   наследование, в котором участвует
множество классов (более двух)

</p>
<p>О   отношение наследования, при котором
класс-наследник расширяет или дополняет функциональность нескольких базовых
классов








</p>
<p>—==

</p>
<p>
</p>
<center> 
</center>
    </div>