# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 8. Объектная модель в Java</h2></center>

<p> 

</p>
<p> 

</p>
<p>Эта лекция является некоторым отступлением от
рассмотрения техни­ческих особенностей Java и посвящена в основном изучению ключевых свойств
объектной модели Java, таких как статические элементы, абстракт­ные методы и
классы, интерфейсы, являющиеся альтернативой множествен­ного наследования. Без
этих мощных конструкций язык Java был бы неспо­собен решать серьезные задачи.

</p>
<p>В заключение рассматриваются принципы работы
полиморфизма для нолей н методов, статических и динамических. Уточняется
классификация типов переменных и типов значений, которые они могут хранить.

</p>
<p> 

</p>
<p>Ключевые слова: предопределение, реализация, интерфейс, "скрывающее"
объявление.

</p>
<p> 

</p>
<p>Статические элементы

</p>
<p>До этого момента под полями объекта мы всегда понимали
значения, которые имеют смысл только в контексте некоторого экземпляра класса.
Например:

</p>
<p>class Human {

</p>
<p>private String name;

</p>
<p>}

</p>
<p>Прежде, чем обратиться к полю name, необходимо
получить ссылку на экземпляр класса Human, невозможно узнать
имя вообще, оно всегда Принадлежит какому-то конкретному человеку.

</p>
<p>Но бывают данные и иного характера. Предположим,
необходимо хранить количество всех людей (экземпляров класса Human, существую-•Чих в системе). Понятно, что общее число людей не является характери­стикой какого-то одного человека, оно относится ко всему типу в целом, ^сюда
появляется название "поле класса", в отличие от "поля
объекта". Объявляются такие поля с помощью модификатора static:

</p>
<p> 

</p>
<p>class Human {

</p>
<p>public static int totalCount;

</p>
<p>}

</p>
<p> 

</p>
<p>Чтобы обратиться к такому
полю, ссылка на объект не требуется, °лне достаточно имени класса:








</p>
<p> 

</p>
<p>Humans.totalCount++; // рождение еще одного человека

</p>
<p> 

</p>
<p>Для удобства разрешено обращаться к статическим полям и через ссылки:

</p>
<p> 

</p>
<p>Human h = new
Human(); h.totalCount=100;

</p>
<p> 

</p>
<p>Однако такое обращение конвертируется компилятором. Он исполь­зует тип
ссылки, в данном случае переменная h объявлена как Human, по­этому последняя строка будет неявно преобразована в:

</p>
<p> 

</p>
<p>Human. totalCount=100;

</p>
<p> 

</p>
<p>В этом можно убедиться на
следующем примере:

</p>
<p>Human h = null;
h.totalCount+=10;

</p>
<p> 

</p>
<p>Значение ссылки равно null, но это не имеет значения в силу описан­ной конвертации. Данный код
успешно скомпилируется и корректно ис­полнится. Таким образом, в следующем
примере

</p>
<p> 

</p>
<p>Human hi - new
Human(), h2 = new Human();

</p>
<p>Human.
totalCount=5;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>h1.totalCount++;

</p>
<p>System.
out.println(h2.totalCount);

</p>
<p> 

</p>
<p>все обращения к переменной totalCount приводят к одному
единственно­му полю, и результатом работы такой программы будет 6. Это поле будет существовать в единственном экземпляре независимо от
того, сколько объектов было порождено от данного класса и был ли вообще создан
хоть один объект.

</p>
<p>Аналогично объявляются
статические методы.

</p>
<p> 

</p>
<p>class Human {

</p>
<p>private static int totalCount;

</p>
<p> 

</p>
<p>public static int getTotalCount() { return
totalCount;

</p>
<p> 

</p>
<p>}

</p>
<p>Для вызова статического метода ссылки на объект не требуется. Human. getTotalCountO;

</p>
<p>Хотя для удобства обращения через ссылку разрешены, но принима­ется во
внимание только тип ссылки:

</p>
<p>Human h=null;

</p>
<p>h. getTotalCountO; //два эквивалентных обращения к Human.getTotalCountO; // одному и тому же методу

</p>
<p>Хотя приведенный пример технически корректен, все же использо­вание
ссылки на объект для обращения к статическим полям и методам не рекомендуется,
поскольку это усложняет код.

</p>
<p>Обращение к статическому полю является корректным независимо оттого,
были ли порождены объекты от этого класса и в каком количестве. Например,
стартовый метод main() запускается до того, как программа создаст хотя бы один объект.

</p>
<p>Кроме полей и методов, статическими могут быть инициализаторы. Они также
называются инициализаторами класса, в отличие от инициа­лизаторов объекта,
рассматривавшихся ранее. Их код выполняется один раз во время загрузки класса в
память виртуальной машины. Их запись начинается с модификатора static:

</p>
<p>class Human { static {

</p>
<p>System, out. printlnfClass loaded");

</p>
<p>}

</p>
<p>}

</p>
<p>Если объявление статического поля совмещается с его инициализа­цией, то
поле инициализируется также однократно при загрузке класса. На объявление и
применение статических полей накладываются те же ог­раничения, что и для
динамических,— нельзя использовать поле в иници­ализаторах других полей или в
инициализаторах класса до того, как это Поле объявлено:

</p>
<p> 

</p>
<p>class Test { static int a; static { a=5;

</p>
<p>// b=7; // Нельзя использовать до объявления!

</p>
<p>}

</p>
<p>static int b=a;

</p>
<p>}

</p>
<p>Это правило распространяется только на обращения к полям по про­стому
имени. Если использовать составное имя, то обращаться к полю можно будет раньше
(выше в тексте программы), чем оно будет объявлено:

</p>
<p> 

</p>
<p>class Test {

</p>
<p>static int
b=Test.a; static int a=3; static {

</p>
<p>System.out.printlnf'a-'+a+", b="+b);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>}

</p>
<p>Если класс будет загружен в систему, на консоли появится текст: а=3, Ь=0

</p>
<p>Видно, что поле b при инициализации получило значение по умол­чанию поля а, т.е. 0. Затем
полю а было присвоено значение 3.

</p>
<p>Статические поля также могут быть объявлены как final, это означает, что
они должны быть проинициализированы строго один раз и затем уже больше не
менять своего значения. Аналогично, статические методы могут быть объявлены как
final, а это означает, что их нельзя перекрывать в классах-наследниках.

</p>
<p>Для инициализации статических полей можно пользоваться стати­ческими
методами и нельзя обращаться к динамическим. Вводят специаль­ные понятия —
статический и динамический контексты. К статическому контексту относят
статические методы, статические инициализаторы, инициализаторы статических
полей. Все остальные части кода имеют ди­намический контекст.

</p>
<p>При выполнении кода в динамическом контексте всегда есть объект, с
которым идет работа в данный момент. Например, для динамического метода это
объект, у которого он был вызван, и так далее.

</p>
<p>Напротив, со статическим контекстом ассоциированных объектов нет.
Например, как уже указывалось, стартовый метод main() вызывается в тот
момент, когда ни один объект еще не создан. При обращении к ста­тическому
методу, например, MyClass.staticMethod(), также может не быть ни одного экземпляра MyClass. Обращаться к
статическим метода' класса Math можно, а создавать его экземпляры нельзя.

</p>
<p>А раз нет ассоциированных объектов, то и пользоваться динамичес­кими
конструкциями нельзя. Можно только ссылаться на статические целя и вызывать
статические методы. Либо обращаться к объектам через ссылки на них, полученные
в результате вызова конструктора или в каче­стве аргумента метода и т.п.

</p>
<p>class Test {

</p>
<p>public void processo { }

</p>
<p>public
static void main(String s[]) {

</p>
<p>// process(); - ошибка! у какого объекта его вызывать?

</p>
<p> 

</p>
<p>Test test = new Test();

</p>
<p>test.process(); // так правильно

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p> 

</p>
<p>Ключевые слова this и super

</p>
<p>Эти ключевые слова уже упоминались, рассматривались и некоторые случаи
их применения. Здесь они будут описаны более подробно.

</p>
<p>Если выполнение кода происходит в динамическом контексте, то должен быть
объект, ассоциированный с ним. В этом случае ключевое слово this возвращает ссылку на данный объект:

</p>
<p>class Test {

</p>
<p>public Object getThis() {

</p>
<p>return this; // Проверим, куда указывает эта ссылка

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>public static void main(String s[]) { Testt
= newTest();

</p>
<p>System.out.println(t.getThis()==t); // Сравнение

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом работы
программы будет: true

</p>
<p>То есть внутри методов слово this возвращает ссылку на объект, у ко-ТоРого этот метод вызван.
Оно необходимо, если нужно передать аргумент, РаЬный ссылке на
данный объект, в какой-нибудь метод.

</p>
<p>class Human {

</p>
<p>public static void register(Human h) {

</p>
<p>System.out.println(h.name+" is registered.");

</p>
<p>}

</p>
<p>private String name; public Human (String s) { name = s;

</p>
<p>register(this); // саморегистрация

</p>
<p>}

</p>
<p> 

</p>
<p>public static void main(String s[]) { new
Human("John");

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет: John is
registered.

</p>
<p>Другое применение this рассматривалось в
случае "затемняющих" объявлений:

</p>
<p> 

</p>
<p>class Human {

</p>
<p>private
String name;

</p>
<p> 

</p>
<p>public void setName(String name) { this.name=name;

</p>
<p>}

</p>
<p>}

</p>
<p>Слово this можно использовать
для обращения к полям, которые объявляются ниже:

</p>
<p> 

</p>
<p>class Test {

</p>
<p>// int b=a; нельзя обращаться к необъявленному полю! int
b=this.a; int а=5; {

</p>
<p>System.out.println("a="+a+",
b="+b);

</p>
<p>}

</p>
<p>public
static void main(String s[]) {

</p>
<p>newTest();

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом работы
программы будет: а=5,Ь=0

</p>
<p>Все происходит так же, как и для статических полей — b получает значение по умолчанию для а, т.е. ноль, а затем а
инициализируется зна­чением 5.

</p>
<p>Наконец, слово this применяется в
конструкторах для явного вызова впервой строке другого конструктора этого же
класса. Там же может при­меняться и слово super, только уже для
обращения к конструктору роди­тельского класса.

</p>
<p>Другие применения слова super также связаны с
обращением к роди­тельскому классу объекта. Например, оно может потребоваться в
случае переопределения (overriding) родительского метода.

</p>
<p>Переопределением называют объявление метода, сигнатура которо­го
совпадает с одним из методов родительского класса.

</p>
<p> 

</p>
<p>class Parent {

</p>
<p>public int getValue() { return 5;

</p>
<p>}

</p>
<p>}

</p>
<p>class Child extends Parent { // Переопределение метода public
int getValue() { return 3;

</p>
<p>}

</p>
<p> 

</p>
<p>public static void main(String s[]) { Child с = new Child();

</p>
<p>// пример вызова переопределенного метода System.our.println(c.getValue());

</p>
<p>}

</p>
<p>Вызов переопределенного метода использует механизм полимор­физма, который
подробно рассматривается в конце этой лекции. Однако ясно, что результатом
выполнения примера будет значение 3.
Невозможно, используя
ссылку типа Child, получить из метода getVaue() значение 5, родительский метод перекрыт и уже недоступен.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Иногда при переопределении бывает полезно воспользоваться ре­зультатом
работы родительского метода. Предположим, он делал сложные вычисления, а
переопределенный метод должен вернуть округленный ре­зультат этих вычислений.
Понятно, что гораздо удобнее обратиться к роди­тельскому методу, чем заново
описывать весь алгоритм. Здесь применяется слово super. Из класса
наследника с его помощью можно обращаться к переопределенным методам родителя:

</p>
<p> 

</p>
<p>class Parent {

</p>
<p>public int
getValue() { return 5;

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>class Child
extends Parent {

</p>
<p> 

</p>
<p>// переопределение метода public int getValue() {

</p>
<p>// обращение к методу родителя

</p>
<p>return super.getValue()+1;

</p>
<p>}

</p>
<p>public static void main(String s[]) { Childc =
newChild(); System.our.println(c.getValue());

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом работы
программы будет значение 6.

</p>
<p>Обращаться с помощью ключевого слова super к переопределенному методу родителя родителя, т.е. на два уровня
наследования вверх, невоз­можно. Если родительский класс переопределил
функциональность своего родителя, значит, она не будет доступна его наследникам.

</p>
<p>Поскольку ключевые слова this и super требуют наличия ассоцииро­ванного объекта, т.е. динамического контекста,
использование их в стати­ческом контексте запрещено.

</p>
<p>Ключевое слово abstract

</p>
<p>Следующее важное понятие, которое необходимо рассмотреть,— ключевое
слово abstract.

</p>
<p>Иногда имеет смысл описать только заголовок метода, без его тела, Л
таким образом объявить, что данный метод будет существовать в этом классе.
Реализацию этого метода, то есть его тело, можно описать позже.

</p>
<p>Рассмотрим пример. Предположим, необходимо создать набор гра­фических
элементов, неважно, каких именно. Например, они могут пред­ставлять собой
геометрические фигуры - круг, квадрат, звезда и т.д.; или элементы
пользовательского интерфейса — кнопки, поля ввода и т.д. Сей­час это не имеет
решающего значения. Кроме того, существует специаль­ный контейнер, который
занимается их отрисовкой. Понятно, что внеш­ний вид каждой компоненты уникален,
а значит, соответствующий метод (назовем его paint()) будет
реализован в разных элементах по-разному.

</p>
<p>Но в то же время у компонент может быть много общего. Например, любая из
них занимает некоторую прямоугольную область контейнера
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Сложные контуры фигуры
необходимо вписать в прямоугольник, чтобы можно было анализировать перекрытия,
проверять, не вылезает ли ком­понент за границы контейнера, и т.д. Каждая
фигура может иметь цвет, которым ее надо рисовать, может быть видимой, или
невидимой и т.д. Очевидно, что полезно создать родительский класс для всех
компонент и один раз объявить в нем все общие свойства, чтобы каждая компонента
лишь наследовала их.

</p>
<p>Но как поступить с методом отрисовки? Ведь родительский класс не
представляет собой какую-либо фигуру, у него нет визуального пред­ставления.
Можно объявить метод paint() в каждой компоненте незави­симо. Но тогда контейнер должен будет
обладать сложной функциональ­ностью, чтобы анализировать, какая именно
компонента сейчас обраба­тывается, выполнять приведение типа и только после
этого вызывать нужный метод.

</p>
<p>Именно здесь удобно объявить абстрактный метод в родительском Классе. У
него нет внешнего вида, но известно, что он есть у каждого на­следника. Поэтому
заголовок метода описывается в родительском классе, тело метода у каждого
наследника свое, а контейнер может спокойно Пользоваться только базовым типом,
не делая никаких приведений.

</p>
<p>Приведем упрощенный
пример:

</p>
<p>// Базовая арифметическая
операция abstract class Operation {

</p>
<p>public abstract int calculate(int
a, int b);








</p>
<p>Курс




</p>
<p>Программирование
на Ja^




</p>
<p>ПекЦияД




</p>
<p>Объектная модель в Java








</p>
<p>// Сложение class
Addition {

</p>
<p>public int calculate(int a, int b) { return a+b;

</p>
<p>}

</p>
<p>}

</p>
<p>// Вычитание class
Subtraction {

</p>
<p>public int calculate(int a, int b) { return a-b;

</p>
<p>}

</p>
<p>}

</p>
<p>class Test {

</p>
<p>public static
void main(String s[]) { Operation
o1 = new Addition(); Operation o2 = new Subtraction();

</p>
<p>o1.calculate(2, 3); o2.calculate(3, 5);

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Видно, что выполнения операций сложения и вычитания в методе main() записываются
одинаково.

</p>
<p>Обратите внимание - поскольку абстрактный метод не имеет тела, после
описания его заголовка ставится точка с запятой. А раз у него нет тела, то к
нему нельзя обращаться, пока его наследники не опишут реали­зацию. Это
означает, что нельзя создавать экземпляры класса, у которого есть абстрактные
методы. Такой класс сам объявляется абстрактным.

</p>
<p>Класс может быть абстрактным и в том случае, если у него нет абстрактных
методов, но должен быть абстрактным, если такие методы есть. Разработчик может
указать ключевое слово abstract в списке
модификаторов класса, если хочет запретить создание эк­земпляров этого класса
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>
Классы-наследники должны реализовать (implements) все абстрактные методы (если они есть) своего абст­рактного родителя,
чтобы их можно было объявлять неабстракт­ными и порождать от них экземпляры.

</p>
<p>Конечно, класс не может быть одновременно abstract и final. Это же верно и для методов. Кроме того, абстрактный метод не может
быть private, native, static.

</p>
<p>Сам класс может без ограничений пользоваться своими абстрактны­ми
методами.

</p>
<p>abstract class
Test {

</p>
<p>public abstract int getX();
public abstract int getY(); pulic double getLength() {

</p>
<p>return
Math.sqrt(getX()*getX()+getY()*getY());

</p>
<p>}

</p>
<p>}

</p>
<p>Это корректно, поскольку метод getl_ength() может быть
вызван только у объекта. Объект может быть порожден только от неабстрактного
класса, который является наследником от Test, и должен был реализовать
все абстрактные методы.

</p>
<p>По этой же причине можно объявлять переменные типа абстрактный класс.
Они могут иметь значение null или ссылаться на
объект, порожден­ный от неабстрактного наследника этого класса.

</p>
<p> 

</p>
<p>Интерфейсы

</p>
<p>Концепция абстрактных методов позволяет предложить альтернативу
множественному наследованию. В Java класс может иметь
только одного родителя, поскольку при множественном наследовании могут
возникать конфликты, которые запутывают объектную модель. Например, если у класса есть два родителя, которые имеют одинаковый метод с различной ре­ализацией, то какой из них унаследует новый класс? И как будет работать
Функциональность родительского класса, который лишился своего метода?

</p>
<p>Все эти проблемы не возникают в том случае, если наследуются только абстрактные методы от нескольких
родителей. Даже если унасле­довано несколько одинаковых методов, все равно у них нет реализации и Можно один раз описать тело метода, которое будет использоваться при Вызове любого из этих методов.

</p>
<p>Именно так устроены интерфейсы в Java. От них нельзя
порождать объекты, но другие классы могут реализовывать их.

</p>
<p> 

</p>
<p>Объявление интерфейсов

</p>
<p>Объявление интерфейсов очень похоже на упрощенное объявление Классов.

</p>
<p>^ Оно начинается с
заголовка. Сначала указываются модификаторы. Нтерфейс Может быть объявлен
как public и тогда он будет
доступен для °&amp;то использования, либо модификатор доступа может не указываться,








</p>
<p>в этом случае интерфейс доступен только для типов своего пакета
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Моди­фикатор
abstract для интерфейса не требуется, поскольку все интерфейсы являются
абстрактными. Его можно указать, но делать этого не рекомен­дуется, чтобы не
загромождать код.

</p>
<p>Далее записывается
ключевое слово interface и имя интерфейса.

</p>
<p>После этого может следовать ключевое слово extends и список интер­фейсов,
от которых будет наследоваться объявляемый интерфейс. Родитель­ских типов может
быть много, главное, чтобы не было повторений и чтобы отношение наследования не
образовывало циклической зависимости.

</p>
<p>Наследование интерфейсов действительно очень гибкое. Так, если есть два
интерфейса, А и В, причем В наследуется от А, то новый интер­фейс С может
наследоваться от них обоих. Впрочем, понятно, что указа­ние наследования от А
является избыточным, все элементы этого интер­фейса и так будут получены по
наследству через интерфейс В.

</p>
<p>Затем в фигурных скобках
записывается тело интерфейса.

</p>
<p>public interface
Drawble extends Colorable, Resizable { }

</p>
<p>Тело интерфейса состоит из объявления элементов, то есть полей-констант
и абстрактных методов.

</p>
<p>Все поля интерфейса должны быть public final static, так что эти мо­дификаторы указывать необязательно и даже нежелательно,
чтобы не за­громождать код. Поскольку поля объявляются финальными, необходимо
их сразу инициализировать.

</p>
<p>public interface Directions { int RIGTH=1 ; int LETFT=2; int UP=3; int DOWN=4;

</p>
<p>}

</p>
<p>Все методы интерфейса являются public abstract и эти модификато­ры также необязательны.

</p>
<p>public interface Moveable { void
moveRightO; void moveLeft(); void moveUp(); void moveDown();

</p>
<p>}

</p>
<p>Как мы видим, описание интерфейса гораздо проще, чем объявление класса.

</p>
<p>Реализация
интерфейса

</p>
<p>Каждый класс может реализовывать любые доступные интерфейсы. Цри этом в
классе должны быть реализованы все абстрактные методы, появившиеся при
наследовании от интерфейсов или родительского класса, чтобы новый класс мог
быть объявлен неабстрактным.

</p>
<p>Если из разных источников наследуются методы с одинаковой сиг­натурой,
то достаточно один раз описать реализацию и она будет приме­няться для всех
этих методов. Однако если у них различное возвращаемое значение, то возникает
конфликт:

</p>
<p>interface А { int getValue();

</p>
<p>}

</p>
<p>interface В {

</p>
<p>double getValue();

</p>
<p>}

</p>
<p>Если попытаться объявить класс, реализующий оба эти интерфейса, то
возникнет ошибка компиляции
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В классе оказывается два разных ме­тода с
одинаковой сигнатурой, что является неразрешимым конфликтом. Это единственное
ограничение на набор интерфейсов, которые может ре­ализовывать класс.

</p>
<p>Подобный конфликт с
полями-константами не столь критичен:

</p>
<p> 

</p>
<p>interface А { int value=3;

</p>
<p>}

</p>
<p>interface В {

</p>
<p>double value=5.4;

</p>
<p>}

</p>
<p>class С implements A, В {

</p>
<p>public static void main(String s[]) { Cc = new
C();

</p>
<p>// System.out.println(c.value);
- ошибка! System.out.println(((A)c).value);
System.out.println(((B)c).value);

</p>
<p>}

</p>
<p>}

</p>
<p>Как видно из примера, обращаться к такому полю через
сам класс Нельзя, компилятор не сможет понять, какое из двух полей
нужно ис­








</p>
<p> 

</p>
<p>пользовать. Но можно с помощью явного приведения сослаться на одн0 из
них.

</p>
<p>Итак, если имя интерфейса указано после implements в объявлении
класса, то класс реализует этот интерфейс. Наследники данного кл также
реализуют интерфейс, поскольку им достаются по наследству его элементы.

</p>
<p>Если интерфейс А наследуется от интерфейса В, а класс реализует А, то
считается, что интерфейс В также реализуется этим классом по той же причине — все элементы передаются по наследству в два этапа — сначала
интерфейсу А, затем классу.

</p>
<p>Наконец, если класс С1 наследуется от класса С2, класс С2 реализует
интерфейс А1, а интерфейс А1 наследуется от интерфейса А2, то класс С1 также
реализует интерфейс А2.

</p>
<p>Все это позволяет утверждать, что переменные типа интерфейс так­же
допустимы. Они могут иметь значение null, или ссылаться на
объекты, порожденные от классов, реализующих этот интерфейс. Поскольку объ­екты
порождаются только от классов, а все они наследуются от Object, это означает, что
значения типа интерфейс обладают всеми элементами класса Object.

</p>
<p> 

</p>
<p>Применение
интерфейсов

</p>
<p>До сих пор интерфейсы рассматривались с технической точки зрения — как
их объявлять, какие конфликты могут возникать, как их разрешать. Однако важно
понимать, как применяются интерфейсы с концептуальной точки зрения.

</p>
<p>Распространенное мнение, что интерфейс — это полностью абстракт­ный
класс, в целом верно, но оно не отражает всех преимуществ, которые дают
интерфейсы объектной модели. Как уже отмечалось, множествен­ное наследование
порождает ряд конфликтов, но отказ от него, хоть и де­лает язык проще, но не
устраняет ситуации, в которых требуются подобные подходы.

</p>
<p>Возьмем в качестве примера дерева наследования классификацию живых
организмов
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Известно, что растения и животные принадлежат к разным царствам.
Основным различием между ними является то, что рас­тения поглощают
неорганические элементы, а животные питаются органи­ческими веществами.
Животные делятся на две большие группы — птицы и млекопитающие. Предположим,
что на основе этой классификации пост­роено дерево наследования, в каждом
классе определены элементы с учетом наследования от родительских классов.

</p>
<p>Рассмотрим такое свойство живого организма, как способность пи­таться
насекомыми. Очевидно, что это свойство нельзя приписать всей

</p>
<p>^К1дИя
8____________________________________________ Объектная модель в Java

</p>
<p>             _

</p>
<p>группе птиц, или млекопитающих, а тем более растений. Но существуют
^дставители каждой из названных групп, которые этим свойством обла­дают, - для
растений это росянка, для птиц, например, ласточки, а для мле­копитающих -
муравьеды. Причем, очевидно, "реализовано" это свойство у каждого
вида совсем по-разному.

</p>
<p>Можно было бы объявить соответствующий метод (скажем, consumelnsect(lnsect))
у каждого представителя
независимо. Но если за­дача состоит в моделировании, например, зоопарка, то
однотипную про­цедуру _ кормление насекомыми - пришлось бы описывать
для каждого вида отдельно, что существенно осложнило бы код, причем без
какой-либо пользы.

</p>
<p>Java предлагает другое решение. Объявляется интерфейс InsectConsumer:

</p>
<p>public interface InsectConsumer { void
consumelnsect(lnsect i);

</p>
<p>}

</p>
<p>Его реализуют все подходящие животные и растения:

</p>
<p> 

</p>
<p>// росянка расширяет класс растение

</p>
<p>public class Sundew extends Plant implements
InsectConsumer { public void consumelnsect(lnsect i) {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>// ласточка расширяет класс птица

</p>
<p>public class Swallow extends Bird implements
InsectConsumer { public void consumelnsect(lnsect i) {

</p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>// муравьед расширяет класс млекопитающее public class AntEater extends Mammal implements
InsectConsumer {

</p>
<p>public void
consumelnsect(lnsect i) {

</p>
<p> 

</p>
<p>}

</p>
<p>}








</p>
<p>В результате в классе, моделирующем служащего зоопарка, можно объявить
соответствующий метод:

</p>
<p> 

</p>
<p>// служащий, отвечающий за кормление, расширяет класс служащий class FeedWorker extends Worker {

</p>
<p> 

</p>
<p>// с помощью этого метода можно накормить

</p>
<p>// и росянку, и ласточку, и муравьеда

</p>
<p>public void feedOnlnsects(lnsectConsumer consumer) {

</p>
<p> 

</p>
<p>consumer.consumelnsect(insect);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>}

</p>
<p>}

</p>
<p>В результате удалось свести работу с одним свойством
трех разнород­ных классов в одно место, сделать код более универсальным.
Обратите внимание, что при добавлении еще одного насекомоядного такая модель
зоопарка не потребует никаких изменений, чтобы обслуживать новый вид, в отличие
от первоначального громоздкого решения. Благодаря введению интерфейса удалось
отделить классы, реализующие его (живые организ­мы) и использующие его
(служащий зоопарка). После любых изменений этих классов при условии сохранения
интерфейса их взаимодействие не нарушится.

</p>
<p>Данный пример иллюстрирует, как интерфейсы предоставляют аль­тернативный,
более строгий и гибкий подход вместо множественного на­следования.

</p>
<p> 

</p>
<p>Полиморфизм

</p>
<p>Ранее были рассмотрены правила объявления классов с учетом их
наследования. В этой лекции было введено понятие переопределенного метода.
Однако полиморфизм требует более глубокого изучения. При объявлении одноименных
полей или методов с совпадающими сигнату­рами происходит перекрытие элементов
из родительского и наследую­щего класса. Рассмотрим, как функционируют классы и
объекты в таких ситуациях.

</p>
<p> 

</p>
<p>Поля

</p>
<p>Начнем с полей, которые могут быть статическими или динамичес­кими.
Рассмотрим пример:

</p>
<p>class Parent { int a=2;

</p>
<p>}

</p>
<p>class Child extends Parent { int a=3;

</p>
<p>}

</p>
<p>Прежде всего, нужно сказать, что такое объявление корректно. На­следники
могут объявлять поля с любыми именами, даже совпадающими с родительскими.
Затем, необходимо понять, как два одноименных поля будут сосуществовать.
Действительно, объекты класса Child будут содер­жать
сразу две переменных, а поскольку они могут отличаться не только значением, но
и типом (ведь это два независимых поля), именно компи­лятор будет определять,
какое из значений использовать. Компилятор может опираться только на тип
ссылки, с помощью которой происходит обращение к полю:

</p>
<p>Child с = new Child(); System.out.println(c.а); Parent p = с; System.out.println(p.a);

</p>
<p>Обе ссылки указывают на один и тот же объект,
порожденный от класса Child, но одна из них имеет такой же тип, а другая - Parent. Отсюда следуют и
результаты:

</p>
<p>3 2

</p>
<p>Объявление поля в классе-наследнике "скрыло" родительское
поле. Данное объявление так и называется — "скрывающим" (hiding). Это осо­бый случай перекрытия областей
видимости, отличный от &amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>затеняющего" (shadowing) и "заслоняющего" (obscuring) объявлений. Тем не менее, ро­дительское поле продолжает существовать.
К нему можно обратиться и явно:

</p>
<p> 

</p>
<p>class Child
extends Parent {

</p>
<p>int a=3; // скрывающее объявление

</p>
<p>int
b=((Parent)this).a; // более громоздкое
объявление

</p>
<p>int c=super.a; // более простое








</p>
<p>Переменные b и с получат
значение, хранящееся в родительском по­ле а. Хотя выражение с super более простое, оно не позволит обратиться на два уровня вверх по дереву
наследования. А ведь вполне возможно, что в родительском классе это поле также
было скрывающим и в родителе ро­дителя хранится еще одно значение. К нему можно
обратиться явным приведением, как это делается для Ь.

</p>
<p>Рассмотрим следующий
пример:

</p>
<p>class Parent { int х=0;

</p>
<p>public void
printXQ { System.out.println(x);

</p>
<p>}

</p>
<p>}

</p>
<p>class Child extends Parent { int x=-1;

</p>
<p>}

</p>
<p>Каков будет
результат следующих строк? newChild().printX();

</p>
<p>Значение какого поля будет распечатано? Метод вызывается с помо­щью
ссылки типа Child, но это не сыграет никакой роли. Вызывается метод, определенный в
классе Parent, и компилятор, конечно, расценил обращение к полю х в этом методе
именно как к полю класса Parent. Поэтому результа­том будет 0.

</p>
<p>Перейдем к статическим
полям. На самом деле, для них проблем и конфликтов, связанных с полиморфизмом,
не существует. Рассмотрим пример:

</p>
<p>class Parent { static int a=2;

</p>
<p>}

</p>
<p>class Child extends Parent { static int a=3;

</p>
<p>}

</p>
<p>Каков будет результат
следующих строк?

</p>
<p>Child с = new Child(); System.out.println(c.а); Parent p = c;
System.out.println(p.a);

</p>
<p>Нужно вспомнить, как компилятор обрабатывает обращения к ста-^еским
полям через ссылочные значения. Неважно, на какой объект указывает ссылка.
Более того, она может быть даже равна null. Все опре­деляется
типом ссылки.

</p>
<p>Поэтому рассматриваемый
пример эквивалентен:

</p>
<p>Systems. out.println(Child. а) Systems. out.println(Parent.a)

</p>
<p> 

</p>
<p>А его результат сомнений уже не вызывает:

</p>
<p> 

</p>
<p>3 2

</p>
<p>Можно привести следующее пояснение. Статическое поле принад­лежит
классу, а не объекту. В результате появление классов-наследников со скрывающими
(hiding) объявлениями никак не сказывается на работе с исходным полем.
Компилятор всегда может определить, через ссылку какого типа происходит
обращение к нему.

</p>
<p>Обратите внимание на
следующий пример:

</p>
<p> 

</p>
<p>class
Parent { static int a;

</p>
<p>}

</p>
<p>class Child extends Parent { }

</p>
<p>Каков будет результат следующих строк?

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Child.а=10; Parent. а=5;

</p>
<p>System.
out.println(Child. а);

</p>
<p>В этом примере поле а не было скрыто и передалось по наследству классу Child. Однако результат
показывает, что это все же одно поле:

</p>
<p> 

</p>
<p>5

</p>
<p>Несмотря на то, что к полю класса идут обращения через разные классы,
переменная всего одна.

</p>
<p>Итак, наследники могут объявлять поля с именами, совпадающими с
Родительскими полями. Такие объявления называют скрывающими.

</p>
<p>261








</p>
<p>При этом объекты
будут содержать оба значения, а компилятор будет каждый раз определять, с каким
из них надо работать.

</p>
<p> 

</p>
<p>Методы

</p>
<p>Рассмотрим случай переопределения (overriding) методов:

</p>
<p>class Parent {

</p>
<p>public int getValue() { return 0;

</p>
<p>}

</p>
<p>}

</p>
<p>class Child extends Parent { public int getValue()
{ return 1;

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>И строки, демонстрирующие работу с этими методами:

</p>
<p>Child с = new Child();

</p>
<p>System.out.println(c.getValue());

</p>
<p>Parent p = c;

</p>
<p>System.out.println(p.getValue());

</p>
<p>Результатом будет:

</p>
<p>1 1

</p>
<p> 

</p>
<p>Можно видеть, что родительский метод полностью перекрыт, значе­ние 0
никак нельзя получить через ссылку, указывающую на объект класса Child. В этом ключевая
особенность полиморфизма — наследники могут изменять родительское поведение,
даже если обращение к ним произво­дится по ссылке родительского типа. Напомним,
что, хотя старый метод снаружи уже недоступен, внутри класса-наследника к нему
все же можно обратиться с помощью super.

</p>
<p>Рассмотрим более сложный пример:

</p>
<p>class Parent {

</p>
<p>public int getValue() { return 0;

</p>
<p>public void print() {

</p>
<p>System, out. println(getValue());

</p>
<p>}

</p>
<p>}

</p>
<p>class Child extends Parent { public int getValue() { return
1;

</p>
<p>}

</p>
<p>}

</p>
<p>Что появится на консоли после выполнения следующих строк?

</p>
<p> 

</p>
<p>Parent р = new Child();
p.print();

</p>
<p> 

</p>
<p>С помощью ссылки типа Parent вызывается метод print(), объявлен­ный в
классе Parent. Из этого метода делается обращение к getValue(), которое в
классе Parent возвращает 0. Но
компилятор уже не может пред­сказать, к динамическому методу какого класса
произойдет обращение во время работы программы. Это определяет виртуальная
машина на основе объекта, на который указывает ссылка. И раз этот объект
порожден от Child, то существует лишь один метод getValue().

</p>
<p>Результатом работы примера будет:

</p>
<p> 

</p>
<p>1

</p>
<p> 

</p>
<p>Данный пример демонстрирует, что переопределение методов долж­но
производиться с осторожностью. Если слишком сильно изменить логи­ку их работы,
нарушить принятые соглашения (например,
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>начать возвра­щать null в качестве значения ссылочного типа, если родительский метод такого не
допускал), это может привести к сбоям в работе родительского класса, а значит,
объекта наследника. Более того, существуют и некоторые обязательные
ограничения.

</p>
<p>Вспомним, что заголовок метода состоит из модификаторов, воз-вРащаемого
значения, сигнатуры и throws-выражения. Сигнатура (имя и набор аргументов) остается неизменной, если
говорить о пере­определении. Возвращаемое значение также не может меняться,
ина-Че это приведет к появлению двух разных методов с одинаковыми
сиг-Натурами.

</p>
<p>Рассмотрим модификаторы доступа.








</p>
<p> 

</p>
<p> 

</p>
<p>class Parent {

</p>
<p>protected int getValueO { return 0;

</p>
<p>}

</p>
<p>}

</p>
<p>class Child
extends Parent {

</p>
<p>/* ??? 7 protected int getValueO { return 1;

</p>
<p>}

</p>
<p>}

</p>
<p>Пусть родительский метод был объявлен как protected.
Понято, что метод
наследника можно оставить с таким же уровнем доступа, но можно ли его расширить
(public), или сузить (доступ по умолчанию)? Несколько строк для проверки:

</p>
<p> 

</p>
<p>Parent р = new Child(); p.getValue();

</p>
<p> 

</p>
<p>Обращение к методу осуществляется с помощью ссылки типа Parent. Именно компилятор
выполняет проверку уровня доступа, и он будет ори­ентироваться на родительский
класс. Но ссылка-то указывает на объект, порожденный от Child, и по правилам
полиморфизма исполняться будет метод именно этого класса. А значит, доступ к
переопределенному методу не может быть более ограниченным, чем к исходному.
Итак, методы с до­ступом по умолчанию можно переопределять с таким же доступом,
либо protected или public. Protected-методы переопределяются такими же, или public, а для public менять модификатор доступа и вовсе нельзя.

</p>
<p>Что касается private-методов, то они определены только внутри класса, снаружи не видны, а
потому наследники могут без ограничений объявлять методы с такими же
сигнатурами и произвольными возвраща­емыми значениями, модификаторами доступа и
т.д.

</p>
<p>Аналогичные ограничения накладываются и на throws-выражение, которое
будет рассмотрено в следующих лекциях.

</p>
<p>Если абстрактный метод переопределяется неабстрактным, то гово­рят, что
он его реализовал (implements). Как ни странно, абстрактный ме­тод может переопределить другой
абстрактный, или даже неабстрактный, метод. В первом случае такое действие
может иметь смысл только при из­менении модификатора доступа (расширении), либо
throws-выражения. Во втором случае полностью утрачивается старая реализация
метода, что может потребоваться в особенных случаях.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Объектная
модель в Java

</p>
<p>-- _                  —  -        —-- 

</p>
<p>Перейдем к статическим методам. Рассмотрим пример:

</p>
<p> 

</p>
<p>class Parent {

</p>
<p>static public int getValue() { return 0;

</p>
<p>}

</p>
<p>}

</p>
<p>class Child extends Parent { static public
int getValue() { return 1;

</p>
<p>}

</p>
<p>}

</p>
<p>И строки, демонстрирующие работу с этими методами:

</p>
<p> 

</p>
<p>Child с = new Child();

</p>
<p>System.out.println(c.getValue());

</p>
<p>Parent p = c;

</p>
<p>System. out.println(p.getValue());

</p>
<p>Аналогично случаю со статическими переменными, вспоминаем ал­горитм
обработки компилятором таких обращений к статическим элемен­там и получаем, что
код эквивалентен следующим строкам:

</p>
<p>System.
out.println(Child.getValue()); System.out.println(Parent.getValue());

</p>
<p> 

</p>
<p>Результатом будет:

</p>
<p> 

</p>
<p>1 О

</p>
<p>То есть статические методы, подобно статическим полям, принадле­жат
классу и появление наследников на них не сказывается.

</p>
<p>Статические методы не могут перекрывать обычные, и наоборот.

</p>
<p> 

</p>
<p>Полиморфизм и объекты

</p>
<p>В заключение рассмотрим несколько особенностей,
вытекающих из свойств полиморфизма.








</p>
<p>Во-первых, теперь можно точно сформулировать, что является элемен. тами
ссылочного типа. Ссылочный тип обладает следующими элементами:

</p>
<p>•   
непосредственно
объявленными в его теле;

</p>
<p>•   
объявленными в его
родительском классе и реализуемых интер. фейсах, кроме:

</p>
<p> 

</p>
<p>-     
private-элементов;

</p>
<p>-     
"скрытых" элементов
(полей и статических методов, скрытых одноименными элементами);

</p>
<p>-     
переопределенных
(динамических) методов.

</p>
<p>Во-вторых, продолжим рассматривать взаимосвязь типа переменной и типов
ее возможных значений. К случаям, описанным в предыдущей лекции, добавляются
еще два. Переменная типа абстрактный класс может ссылаться на объекты,
порожденные неабстрактным наследником этого класса. Переменная типа интерфейс
может ссылаться на объекты, по­рожденные от класса, реализующего данный
интерфейс.

</p>
<p>Сведем эти данные в таблицу.

</p>
<p></p>
<center><img width="430" height="267" src="http://kufas.ru/java.files/image015.png"></center>
Таким образом, Java предоставляет гибкую и мощную модель объек­тов, позволяющую
проектировать самые сложные системы. Необходимо хорошо разбираться в ее
основных свойствах и механизмах — наследова­ние, статические элементы,
абстрактные элементы, интерфейсы, поли­морфизм, разграничения доступа и другие.
Все они позволяют избегать дублирующего кода, облегчают
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>развитие системы,
добавление новых воз­можностей и изменение старых, помогают обеспечивать
минимальную связность между частями системы, то есть повышают модульность.
Также

</p>
<p>ia4Hbie технические решения можно многократно использовать в раз­личных
системах, сокращая и упрощая процесс их создания.

</p>
<p>Для достижения таких важных целей требуется не только знание java, но и владение
объектно-ориентированным подходом, основными способами проектирования систем и
проверки качества архитектурных решений. Платформа Java является основой и весьма удобным инстру­ментом для применения всех этих
технологий.

</p>
<p>Заключение

</p>
<p>В этой лекции были рассмотрены особенности объектной модели java. Это, во-первых,
статические элементы, позволяющие использовать интерфейс класса без создания
объектов. Нужно помнить, что, хотя дтя об­ращения к статическим элементам можно
задействовать ссылочную пере­менную, на самом деле ее значение не используется,
компилятор основыва­ется только на ее типе.

</p>
<p>Для правильной работы со статическими элементами вводятся по­нятия
статического и динамического контекста.

</p>
<p>Далее рассматривалось использование ключевых слов this и super. Выражение this предоставляет ссылку,
указывающую на объект, в контек­сте которого оно встречается. Эта конструкция
помогает избегать кон­фликтов имен, а также применяется в конструкторах.

</p>
<p>Слово super позволяет задействовать свойства родительского клас­са, что необходимо
для реализации переопределенных методов, а также в конструкторах.

</p>
<p>Затем было введено понятие абстрактного метода и класса. Абст­рактный
метод не имеет тела, он лишь указывает, что метод с такой сигнатурой должен
быть реализован в классе-наследнике. Поскольку °Я не имеет собственной реализации, классы с абстрактными метода-Ми также должны быть объявлены с модификатором abstract, который
Указывает, что от них нельзя порождать объекты. Основная цель абст­рактных
методов — описать в родительском классе как можно больше °бщих свойств
наследников, пусть даже и в виде заголовков методов без реализации.

</p>
<p>Следующее важное
понятие — особый тип в Java, интерфейс. Его еЩе называют полностью абстрактным классом,
так как все его методы °бязательно абстрактные, а поля final static. Соответственно,
на основе "^ерфейсов невозможно создавать объекты.

</p>
<p>Интерфейсы являются
альтернативой множественному наследова-Классы не могут иметь более одного
родителя, но они могут реали-&#9632;^Вывать сколько угодно интерфейсов. Таким
образом, интерфейсы опи­








</p>
<p>сывают общие свойства
классов, не находящихся на одной ветви дерев-
наследования.                                                                                                                         '

</p>
<p>Наконец, важным свойством объектной модели является полимор. физм. Было
подробно изучено поведение полей и методов, как статичес ких, так и
динамических, при переопределении. Что позволило перейти к вопросу
соответствия типов переменной и ее значения.

</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>^   
Предположим, вы моделируете автомобиль, описывая его свойства в формате Java-класса. Какие из следующих
полей нужно объявить динамическими?

</p>
<p>Г*1   количество колес автомобиля

</p>
<p>Г*1   необходимое количество колес,
полагающееся по проектной документации

</p>
<p>Q   максимально
допустимая масса для этого класса автомобилей

</p>
<p>f*l   максимально большое количество
пассажиров, когда-либо одновременно перевозимых автомобилем

</p>
<p>&#9633;       дата
начала выпуска автомобилей

</p>
<p>&#9633;       дата
выпуска автомобиля

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Можно
ли при переопределении некоторого абстрактного
метода perforino использовать
выражение

</p>
<p>super, perforino?

</p>
<p>&#9633;      да
П    нет

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Для
каких элементов класса работает полиморфизм?

</p>
<p>Г~1  динамические
поля

</p>
<p>П    статические
поля

</p>
<p>П    динамические
методы

</p>
<p>П    статические
методы

</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.       Предположим,
вы моделируете автомобиль, описывая его
свойства в формате Java-класса. Какие из следующих
полей нужно объявить статическими?

</p>
<p>П   количество
колес автомобиля

</p>
<p>П   необходимое
количество колес, полагающееся по проектной документации

</p>
<p>П   максимально
допустимая масса для этого класса автомобилей

</p>
<p>П   максимально
большое количество пассажиров, когда-либо одновременно перевозимых автомобилем

</p>
<p>П   дата
начала выпуска автомобилей

</p>
<p>П   дата
выпуска автомобиля

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Можно
ли при наследовании не реализовывать
абстрактный метод родительского класса?

</p>
<p>П   можно

</p>
<p>П   можно, если наследник также abstract П   нельзя

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Может
ли переменная иметь тип абстрактный класс?
Интерфейс?

</p>
<p>&#9633;       
да, да

</p>
<p>&#9633;       
да, нет

</p>
<p>&#9633;       
нет, да

</p>
<p>&#9633;       
нет, нет

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1    Корректно ли следующее
обращение к переменной X? public class Test {

</p>
<p>static void performO
{

</p>
<p> 

</p>
<p>}

</p>
<p>private Test x;

</p>
<p>public static void ma in (String s[]) {

</p>
<p>x.perform();
// корректно ли это выражение?

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;       да

</p>
<p>&#9633;       нет

</p>
<p> 

</p>
<p>2.   Если имеется переменная типа абстрактный
класс, можно ли с ее помощью обращаться к
абстрактным методам этого класса?

</p>
<p>П   можно

</p>
<p>Г"|  
можно, но если ее значение будет равно null, то возникнет

</p>
<p>ошибка времени исполнения О   нельзя








</p>
<p>Какое значение появится на
консоли после выполнения следующей программы? public class Parent { int x =
2;

</p>
<p>public void print() {

</p>
<p>System. out.
println(x) ;

</p>
<p>}

</p>
<p>public class Child
extends Parent { intx = 3;

</p>
<p>public static void main(String s[]) {
^              new Child().print();

</p>
<p>}

</p>
<p>&#9633;       
0

</p>
<p>&#9633;       
2

</p>
<p>&#9633;          
3

</p>
<p>
</p>
<center> 
</center>
    </div>