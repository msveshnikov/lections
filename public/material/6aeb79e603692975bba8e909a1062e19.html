# encoding: windows-1251







<p>В этой лекции пойдет речь о синтаксисе языка Python для основных алгоритмических конструкций, литералов, выражений. Будет приведено описание встроенных типов данных, а также сделана попытка рассмотреть некоторые вопросы общепринятого в Python стиля программирования.</p>
<p>Что такое Python?</p>
<p>О Python (лучше произносить «питон», хотя некоторые говорят «пайтон») - предмете данного изучения, лучше всего говорит создатель этого языка программирования, голландец Гвидо ван Россум:</p>
<p>«Python — интерпретируемый, объектно–ориентированный высокоуровневый язык программирования с динамической семантикой. Встроенные высокоуровневые структуры данных в сочетании с динамическими типизацией и связыванием делают язык привлекательным для быстрой разработки приложений (RAD, Rapid Application Development). Кроме того, его можно использовать в качестве сценарного языка для связи программных компонентов. Синтаксис Python прост в изучении, в нем придается особое значение читаемости кода, а это сокращает затраты на сопровождение программных продуктов. Python поддерживает модули и пакеты, поощряя модульность и повторное использование кода. Интерпретатор Python и большая стандартная библиотека доступны бесплатно в виде исходных и исполняемых кодов для всех основных платформ и могут свободно распространяться.»</p>
<p>В процессе изучения будет раскрыт смысл этого определения, а сейчас достаточно знать, что Python — это универсальный язык программирования. Он имеет свои преимущества и недостатки, а также сферы применения. В поставку Python входит обширная стандартная библиотека для решения широкого круга задач. В Интернете доступны качественные библиотеки для Python по различным предметным областям: средства обработки текстов и технологии Интернет, обработка изображений, инструменты для создания приложений, механизмы доступа к базам данных, пакеты для научных вычислений, библиотеки построения графического интерфейса и т.п. Кроме того, Python имеет достаточно простые средства для интеграции с языками C, C++ (и Java) как путем встраивания (embedding) интерпретатора в программы на этих языках, так и наоборот, посредством использования библиотек, написанных на этих языках, в Python–программах. Язык Python поддерживает несколько парадигм программирования: императивное (процедурный, структурный, модульный подходы), объектно–ориентированное и функциональное программирование.</p>
<p>Можно считать, что Python — это целая технология для создания программных продуктов (и их прототипов). Она доступна почти на всех современных платформах (как 32–битных, так и на 64–битных) с компилятором C и на платформе Java.</p>
<p>Может показаться, что, в программной индустрии нет места для чего–то другого кроме C/C++, Java, Visual Basic, C#. Однако это не так. Возможно, благодаря данному курсу лекций и практических занятий у Python появятся новые приверженцы, для которых он станет незаменимым инструментом.</p>
<p>Как описать язык?</p>
<p>В этой лекции не ставится цели систематически описать Python: для этого существует оригинальное справочное руководство. Здесь предлагается рассмотреть язык одновременно в нескольких аспектах, что достигается набором примеров, которые позволят быстрее приобщиться к реальному программированию, чем в случае строгого академического подхода.</p>
<p>Однако стоит обратить внимание на правильный подход к описанию языка. Создание программы — это всегда коммуникация, в которой программист передает компьютеру информацию, необходимую для выполнения последним действий. То, как эти действия понимает программист (то есть «смысл»), можно назвать семантикой. Средством передачи этого смысла является синтаксис языка программирования. Ну а то, что делает интерпретатор на основании переданного, обычно называют прагматикой. При написании программы очень важно, чтобы в этой цепочке не возникало сбоев.</p>
<p>Синтаксис — полностью формализованная часть: его можно описать на формальном языке синтаксических диаграмм (что и делается в справочных руководствах). Выражением прагматики является сам интерпретатор языка. Именно он читает записанное в соответствии с синтаксисом «послание» и превращает его в действия по заложенному в нем алгоритму. Неформальным компонентом остается только семантика. Именно в переводе смысла в формальное описание и кроется самая большая сложность программирования. Синтаксис языка Python обладает мощными средствами, которые помогают приблизить понимание проблемы программистом к ее «пониманию» интерпретатором. О внутреннем устройстве Python будет говориться в одной из завершающих лекций.</p>
<p>История языка Python</p>
<p>Создание Python было начато Гвидо ван Россумом (Guido van Rossum) в 1991 году, когда он работал над распределенной ОС Амеба. Ему требовался расширяемый язык, который бы обеспечил поддержку системных вызовов. За основу были взяты ABC и Модула–3. В качестве названия он выбрал Python в честь комедийных серий BBC «Летающий цирк Монти–Питона», а вовсе не по названию змеи. С тех пор Python развивался при поддержке тех организаций, в которых Гвидо работал. Особенно активно язык совершенствуется в настоящее время, когда над ним работает не только команда создателей, но и целое сообщество программистов со всего мира. И все–таки последнее слово о направлении развития языка остается за Гвидо ван Россумом.</p>
<p>Программа на Python</p>
<p>Программа на языке Python может состоять из одного или нескольких модулей. Каждый модуль представляет собой текстовый файл в кодировке, совместимой с 7–битной кодировкой ASCII. Для кодировок, использующих старший бит, необходимо явно указывать название кодировки. Например, модуль, комментарии или строковые литералы которого записаны в кодировке KOI8–R, должен иметь в первой или второй строке следующую спецификацию:</p>
<p>Листинг</p>
<p># -*- coding: koi8–r -*-</p>
<p>Благодаря этой спецификации интерпретатор Python будет знать, как корректно переводить символы литералов Unicode–строк в Unicode. Без этой строки новые версии Python будут выдавать предупреждение на каждый модуль, в котором встречаются коды с установленным восьмым битом.</p>
<p>О том, как делать программу модульной, станет известно в следующих лекциях. В примерах ниже используются как фрагменты модулей, записанных в файл, так и фрагменты диалога с интерпретатором Python. Последние отличаются характерным приглашением &gt;&gt;&gt;. Символ решетка (#) отмечает комментарий до конца строки.</p>
<p>Программа на Python, с точки зрения интерпретатора, состоит из логических строк. Одна логическая строка, как правило, располагается в одной физической, но длинные логические строки можно явно (с помощью обратной косой черты) или неявно (внутри скобок) разбить на несколько физических:</p>
<p>Листинг</p>
<p>print a, " — очень длинная строка, которая не помещается в», \</p>
<p>80, «знакоместах»</p>
<p>Примечание:</p>
<p>Во всех примерах в основном используется «официальный» стиль оформления кода на Python в соответствии с документом «Python Style Guide», который можно найти на сайте http://python.org</p>
<p>Основные алгоритмические конструкции</p>
<p>Предполагается, что слушатели уже умеют программировать хотя бы на уровне школьной программы, и потому вполне достаточно провести параллели между алгоритмическими конструкциями и синтаксисом Python. Кроме того, Python как правило не подводит интуицию программиста (по крайней мере, науке хорошо известны типичные ловушки начинающих программистов на Python), поэтому изучать синтаксис Python предпочтительнее на примерах, а не с помощью синтаксических диаграмм или форм Бэкуса–Наура.</p>
<p>Последовательность операторов</p>
<p>Последовательные действия описываются последовательными строками программы. Стоит, правда, добавить, что в программах важны отступы, поэтому все операторы, входящие в последовательность действий, должны иметь один и тот же отступ:</p>
<p>Листинг</p>
<p>a = 1</p>
<p>b = 2</p>
<p>a = a + b</p>
<p>b = a — b</p>
<p>a = a — b</p>
<p>print a, b</p>
<p>Что делает этот пример? Проверить свою догадку можно с помощью интерактивного режима интерпретатора Python.</p>
<p>При работе с Python в интерактивном режиме как бы вводится одна большая программа, состоящая из последовательных действий. В примере выше использованы операторы присваивания и оператор print.</p>
<p>Оператор условия и выбора</p>
<p>Разумеется, одними только последовательными действиями в программировании не обойтись, поэтому при написании алгоритмов используется еще и ветвление:</p>
<p>Листинг</p>
<p>if a &gt; b:</p>
<p>c = a</p>
<p>else:</p>
<p>c = b</p>
<p>Этот кусок кода на Python интуитивно понятен каждому, кто помнит, что if по–английски значит «если», а else — «иначе». Оператор ветвления имеет в данном случае две части, операторы каждой из которых записываются с отступом вправо относительно оператора ветвления. Более общий случай — оператор выбора — можно записать с помощью следующего синтаксиса (пример вычисления знака числа):</p>
<p>Листинг</p>
<p>if a &lt; 0:</p>
<p>s = -1</p>
<p>elif a == 0:</p>
<p>s = 0</p>
<p>else:</p>
<p>s = 1</p>
<p>Стоит заметить, что elif — это сокращенный else if. Без сокращения пришлось бы применять вложенный оператор ветвления:</p>
<p>Листинг</p>
<p>if a &lt; 0:</p>
<p>s = -1</p>
<p>else:</p>
<p>if a == 0:</p>
<p>s = 0</p>
<p>else:</p>
<p>s = 1</p>
<p>В отличие от оператора print, оператор if–else — составной оператор.</p>
<p>Циклы</p>
<p>Третьей необходимой алгоритмической конструкцией является цикл. С помощью цикла можно описать повторяющиеся действия. В Python имеются два вида циклов: цикл ПОКА (выполняется некоторое действие) и цикл ДЛЯ (всех значений последовательности). Следующий пример иллюстрирует цикл ПОКА на Python:</p>
<p>Листинг</p>
<p>s = «abcdefghijklmnop»</p>
<p>while s != "":</p>
<p>print s</p>
<p>s = s[1: — 1]</p>
<p>Оператор while говорит интерпретатору Python: «пока верно условие цикла, выполнять тело цикла». В языке Python тело цикла выделяется отступом. Каждое исполнение тела цикла будет называться итерацией. В приведенном примере убирается первый и последний символ строки до тех пор, пока не останется пустая строка.</p>
<p>Для большей гибкости при организации циклов применяются операторы break (прервать) и continue (продолжить). Первый позволяет прервать цикл, а второй — продолжить цикл, перейдя к следующей итерации (если, конечно, выполняется условие цикла).</p>
<p>Следующий пример читает строки из файла и выводит те, у которых длина больше 5:</p>
<p>Листинг</p>
<p>f = open(«file.txt», «r»)</p>
<p>while 1:</p>
<p>l = f.readline()</p>
<p>if not l:</p>
<p>break</p>
<p>if len(l) &gt; 5:</p>
<p>print l,</p>
<p>f.close()</p>
<p>В этом примере организован бесконечный цикл, который прерывается только при получении из файла пустой строки (l), что обозначает конец файла.</p>
<p>В языке Python логическое значение несет каждый объект: нули, пустые строки и последовательности, специальный объект None и логический литерал False имеют значение «ложь», а прочие объекты значение «истина». Для обозначения истины обычно используется 1 или True.</p>
<p>Примечание:</p>
<p>Литералы True и False для обозначения логических значений появились в Python 2.3.</p>
<p>Цикл ДЛЯ выполняет тело цикла для каждого элемента последовательности. В следующем примере выводится таблица умножения:</p>
<p>Листинг</p>
<p>for i in range(1, 10):</p>
<p>for j in range(1, 10):</p>
<p>print "%2i» % (i*j),</p>
<p>print</p>
<p>Здесь циклы for являются вложенными. Функция range() порождает список целых чисел из полуоткрытого диапазона [1, 10). Перед каждой итерацией счетчик цикла получает очередное значение из этого списка. Полуоткрытые диапазоны общеприняты в Python. Считается, что их использование более удобно и вызывает меньше программистских ошибок. Например, range(len(s)) порождает список индексов для списка s (в Python–последовательности первый элемент имеет индекс 0). Для красивого вывода таблицы умножения применена операция форматирования % (для целых чисел тот же символ используется для обозначения операции взятия остатка от деления). Строка форматирования (задается слева) строится почти как строка форматирования для printf из C.</p>
<p>Функции</p>
<p>Программист может определять собственные функции двумя способами: с помощью оператора def или прямо в выражении, посредством lambda. Второй способ (да и вообще работа с функциями) будет рассмотрен подробнее в лекции по функциональному программированию на Python, а здесь следует привести пример определения и вызова функции:</p>
<p>Листинг</p>
<p>def cena(rub, kop=0):</p>
<p>return "%i руб. %i коп.» % (rub, kop)</p>
<p>print cena(8, 50)</p>
<p>print cena(7)</p>
<p>print cena(rub=23, kop=70)</p>
<p>В этом примере определена функция двух аргументов (из которых второй имеет значение по умолчанию — 0). Вариантов вызова этой функции с конкретными параметрами также несколько. Стоит только заметить, что при вызове функции сначала должны идти позиционные параметры, а затем, именованные. Аргументы со значениями по умолчанию должны следовать после обычных аргументов. Оператор return возвращает значение функции. Из функции можно возвратить только один объект , но он может быть кортежем из нескольких объектов.</p>
<p>После оператора def имя cena оказывается связанным с функциональным объектом.</p>
<p>Исключения</p>
<p>В современных программах передача управления происходит не всегда так гладко, как в описанных выше конструкциях. Для обработки особых ситуаций (таких как деление на ноль или попытка чтения из несуществующего файла) применяется механизм исключений. Лучше всего пояснить синтаксис оператора try–except следующим примером:</p>
<p>Листинг</p>
<p>try:</p>
<p>res = int(open('a.txt').read()) / int(open('c.txt').read())</p>
<p>print res</p>
<p>except IOError:</p>
<p>print «Ошибка ввода–вывода»</p>
<p>except ZeroDivisionError:</p>
<p>print «Деление на 0»</p>
<p>except KeyboardInterrupt:</p>
<p>print «Прерывание с клавиатуры»</p>
<p>except:</p>
<p>print «Ошибка»</p>
<p>В этом примере берутся числа из двух файлов и делятся одно на другое. В результате этих нехитрых действий может возникнуть несколько исключительных ситуаций, некоторые из них отмечены в частях except (здесь использованы стандартные встроенные исключения Python). Последняя часть except в этом примере улавливает все другие исключения, которые не были пойманы выше. Например, если хотя бы в одном из файлов находится нечисловое значение, функция int() возбудит исключение ValueError. Его–то и сможет отловить последняя часть except. Разумеется, выполнение части try в случае возникновения ошибки уже не продолжается после выполнения одной из частей except.</p>
<p>В отличие от других языков программирования, в Python исключения нередко служат для упрощения алгоритмов. Записывая оператор try–except, программист может думать так: «попробую, а если сорвется — выполнится код в except». Особенно часто это используется для выражений, в которых значение получается по ключу из отображения:</p>
<p>Листинг</p>
<p>try:</p>
<p>value = dict[key]</p>
<p>except:</p>
<p>value = default_value</p>
<p>Вместо</p>
<p>Листинг</p>
<p>if dict.has_key(key):</p>
<p>value = dict[key]</p>
<p>else:</p>
<p>value = default_value</p>
<p>Примечание:</p>
<p>Пример уже несколько устаревшей идиомы языка Python иллюстрирует только дух этого подхода: в современном Python лучше записать так value = dict.get(key, default_value).</p>
<p>Исключения можно возбуждать и из программы. Для этого служит оператор raise. Заодно следующий пример показывает канонический способ определения собственного исключения:</p>
<p>Листинг</p>
<p>class MyError(Exception):</p>
<p>pass</p>
<p>try:</p>
<p>…</p>
<p>raise MyError, «my error 1»</p>
<p>…</p>
<p>except MyError, x:</p>
<p>print «Ошибка:", x</p>
<p>Кстати, все исключения выстроены в иерархию классов, поэтому ZeroDivisionError может быть поймана как ArithmeticError, если соответствующая часть except будет идти раньше.</p>
<p>Для утверждений применяется специальный оператор assert. Он возбуждает AssertionError, если заданное в нем условие неверно. Этот оператор используют для самопроверки программы. В оптимизированном коде он не выполняется, поэтому строить на нем логику алгоритма нельзя. Пример:</p>
<p>Листинг</p>
<p>c = a + b</p>
<p>assert c == a + b</p>
<p>Кроме описанной формы оператора, есть еще форма try–finally для гарантированного выполнения некоторых действий при передаче управления изнутри оператора try–finally вовне. Он может применяться для освобождения занятых ресурсов, что требует обязательного выполнения, независимо от произошедших внутри катаклизмов:</p>
<p>Листинг</p>
<p>try:</p>
<p>…</p>
<p>finally:</p>
<p>print «Обработка гарантированно завершена»</p>
<p>Смешивать вместе формы try–except и try–finally нельзя.</p>
<p>Встроенные типы данных</p>
<p>Как уже говорилось, все данные в Python представлены объектами. Имена являются лишь ссылками на эти объекты и не несут нагрузки по декларации типа. Значения встроенных типов имеют специальную поддержку в синтаксисе языка: можно записать литерал строки, числа, списка, кортежа, словаря (и их разновидностей). Синтаксическую же поддержку операций над встроенными типами можно легко сделать доступной и для объектов определяемых пользователей классов.</p>
<p>Следует также отметить, что объекты могут быть неизменчивыми и изменчивыми. Например, строки в Python являются неизменчивыми, поэтому операции над строками создают новые строки.</p>
<p>Карта встроенных типов (с именами функций для приведения к нужному типу и именами классов для наследования от этих типов):</p>
<p>специальные типы: None, NotImplemented и Ellipsis;</p>
<p>числа;</p>
<p>целые</p>
<p>обычное целое int</p>
<p>целое произвольной точности long</p>
<p>логический bool</p>
<p>число с плавающей точкой float</p>
<p>комплексное число complex</p>
<p>последовательности;</p>
<p>неизменчивые:</p>
<p>строка str;</p>
<p>Unicode–строка unicode;</p>
<p>кортеж tuple;</p>
<p>изменчивые:</p>
<p>список list;</p>
<p>отображения:</p>
<p>словарь dict</p>
<p>объекты, которые можно вызвать:</p>
<p>функции (пользовательские и встроенные);</p>
<p>функции–генераторы;</p>
<p>методы (пользовательские и встроенные);</p>
<p>классы (новые и «классические»);</p>
<p>экземпляры классов (если имеют метод __call__);</p>
<p>модули;</p>
<p>классы (см. выше);</p>
<p>экземпляры классов (см. выше);</p>
<p>файлы file;</p>
<p>вспомогательные типы buffer, slice.</p>
<p>Узнать тип любого объекта можно с помощью встроенной функции type().</p>
<p>Тип int и long</p>
<p>Два типа: int (целые числа) и long (целые произвольной точности) служат моделью для представления целых чисел. Первый соответствует типу long в компиляторе C для используемой архитектуры. Числовые литералы можно записать в системах счисления с основанием 8, 10 или 16:</p>
<p>Листинг</p>
<p># В этих литералах записано число 10</p>
<p>print 10, 012, 0xA, 10L</p>
<p>Набор операций над числами — достаточно стандартный как по семантике, так и по обозначениям:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print 1 + 1, 3 — 2, 2*2, 7/4, 5%3</p>
<p>2 1 4 1 2</p>
<p>&gt;&gt;&gt; print 2L ** 1000</p>
<p>107150860718626732094842504906000181056140481170553360744375038</p>
<p>837035105112493612249319837881569585812759467291755314682518714</p>
<p>528569231404359845775746985748039345677748242309854210746050623</p>
<p>711418779541821530464749835819412673987675591655439460770629145</p>
<p>71196477686542167660429831652624386837205668069376</p>
<p>&gt;&gt;&gt; print 3 &lt; 4 &lt; 6, 3 &gt;= 5, 4 == 4, 4 != 4 # сравнения</p>
<p>True False True False</p>
<p>&gt;&gt;&gt; print 1 &lt;&lt; 8, 4 &gt;&gt; 2, ~4 # побитовые сдвиги и инверсия</p>
<p>256 1–5</p>
<p>&gt;&gt;&gt; for i, j in (0, 0), (0, 1), (1, 0), (1, 1):</p>
<p>… print i, j, ":", i &amp; j, i | j, i ^ j # побитовые операции</p>
<p>…</p>
<p>0 0 : 0 0 0</p>
<p>0 1 : 0 1 1</p>
<p>1 0 : 0 1 1</p>
<p>1 1 : 1 1 0</p>
<p>Значения типа int должны покрывать диапазон от–2147483648 до 2147483647, а точность целых произвольной точности зависит от объема доступной памяти.</p>
<p>Стоит заметить, что если в результате операции получается значение, выходящее за рамки допустимого, тип int может быть неявно преобразован в long:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; type(-2147483648)</p>
<p>&lt;type 'int'&gt;</p>
<p>&gt;&gt;&gt; type(-2147483649)</p>
<p>&lt;type 'long'&gt;</p>
<p>Также нужно быть осторожным при записи констант. Нули в начале числа — признак восьмеричной системы счисления, в которой нет цифры 8:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; 008</p>
<p>File "&lt;stdin&gt;", line 1</p>
<p>008</p>
<p>^</p>
<p>SyntaxError: invalid token</p>
<p>Тип float</p>
<p>Соответствует C–типу double для используемой архитектуры. Записывается вполне традиционным способом либо через точку, либо в нотации с экспонентой:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; pi = 3.1415926535897931</p>
<p>&gt;&gt;&gt; pi ** 40</p>
<p>7.6912142205156999e+19</p>
<p>Кроме арифметических операций, можно использовать операции из модуля math.</p>
<p>Примечание:</p>
<p>Для финансовых расчетов лучше применять более подходящий тип.</p>
<p>Из полезных встроенных функций можно вспомнить round(), abs().</p>
<p>Тип complex</p>
<p>Литерал мнимой части задается добавлением j в качестве суффикса (перемножаются мнимые единицы):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; -1j * -1j</p>
<p>(-1–0j)</p>
<p>Тип реализован на базе вещественного. Кроме арифметических операций, можно использовать операции из модуля cmath.</p>
<p>Тип bool</p>
<p>Подтип целочисленного типа для «канонического» обозначения логических величин. Два значения: True (истина) и False (ложь) - вот и все, что принадлежит этому типу. Как уже говорилось, любой объект Python имеет истинностное значение, логические операции можно проиллюстрировать с помощью логического типа:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; for i in (False, True):</p>
<p>… for j in (False, True):</p>
<p>… print i, j, ":", i and j, i or j, not i</p>
<p>…</p>
<p>…</p>
<p>False False : False False True</p>
<p>False True : False True True</p>
<p>True False : False True False</p>
<p>True True : True True False</p>
<p>Следует отметить, что Python даже не вычисляет второй операнд операции and или or, если ее исход ясен по первому операнду. Таким образом, если первый операнд истиннен, он и возвращается как результат or, в противном случае возвращается второй операнд. Для операции and все аналогично.</p>
<p>Тип string и тип unicode</p>
<p>В Python строки бывают двух типов: обычные и Unicode–строки. Фактически строка — это последовательность символов (в случае обычных строк можно сказать «последовательность байтов»). Строки–константы можно задать в программе с помощью строковых литералов. Для литералов наравне используются как апострофы ('), так и обычные двойные кавычки ("). Для многострочных литералов можно использовать утроенные апострофы или утроенные кавычки. Управляющие последовательности внутри строковых литералов задаются обратной косой чертой (\). Примеры написания строковых литералов:</p>
<p>Листинг</p>
<p>s1 = «строка1»</p>
<p>s2 = 'строка2\nс переводом строки внутри'</p>
<p>s3 = ""«строка3</p>
<p>с переводом строки внутри»""</p>
<p>u1 = u'\u043f\u0440\u0438\u0432\u0435\u0442' # привет</p>
<p>u2 = u'Еще пример' # не забудьте про coding!</p>
<p>Для строк имеется еще одна разновидность: необработанные строковые литералы. В этих литералах обратная косая черта и следующие за ней символы не интерпретируются как спецсимволы, а вставляются в строку «как есть»:</p>
<p>Листинг</p>
<p>my_re = r»(\d)=\1»</p>
<p>Обычно такие строки требуются для записи регулярных выражений (о них пойдет речь в лекции, посвященной обработке текстовой информации).</p>
<p>Набор операций над строками включает конкатенацию «+», повтор "*", форматирование "%". Также строки имеют большое количество методов, некоторые из которых приведены ниже. Полный набор методов (и их необязательных аргументов) можно получить в документации по Python.</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; «A» + «B»</p>
<p>'AB'</p>
<p>&gt;&gt;&gt; «A»*10</p>
<p>'AAAAAAAAAA'</p>
<p>&gt;&gt;&gt; "%s %i» % («abc», 12)</p>
<p>'abc 12'</p>
<p>Некоторые методы строковых объектов будут рассмотрены в лекции, посвященной обработке текстов.</p>
<p>Тип tuple</p>
<p>Для представления константной последовательности (разнородных) объектов используется тип кортеж. Литерал кортежа обычно записывается в круглых скобках, но можно, если не возникают неоднозначности, писать и без них. Примеры записи кортежей:</p>
<p>Листинг</p>
<p>p = (1.2, 3.4, 0.9) # точка в трехмерном пространстве</p>
<p>for s in «one», «two», «three»: # цикл по значениям кортежа</p>
<p>print s</p>
<p>one_item = (1,)</p>
<p>empty = ()</p>
<p>p1 = 1, 3, 9 # без скобок</p>
<p>p2 = 3, 8, 5, # запятая в конце игнорируется</p>
<p>Использовать синтаксис кортежей можно и в левой части оператора присваивания. В этом случае на основе вычисленных справа значений формируется кортеж и связывается один в один с именами в левой части. Поэтому обмен значениями записывается очень изящно:</p>
<p>Листинг</p>
<p>a, b = b, a</p>
<p>Тип list</p>
<p>В «чистом» Python нет массивов с произвольным типом элемента. Вместо них используются списки. Их можно задать с помощью литералов, записываемых в квадратных скобках, или посредством списковых включений. Варианты задания списка приведены ниже:</p>
<p>Листинг</p>
<p>lst1 = [1, 2, 3,]</p>
<p>lst2 = [x**2 for x in range(10) if x % 2 == 1]</p>
<p>lst3 = list(«abcde»)</p>
<p>Для работы со списками существует несколько методов, дополнительных к тем, что имеют неизменчивые последовательности. Все они связаны с изменением списка.</p>
<p>Последовательности</p>
<p>Ниже обобщены основные методы последовательностей. Следует напомнить, что последовательности бывают неизменчивыми и изменчивыми. У последних методов чуть больше.</p>
<p>Синтаксис Семантика</p>
<p>len(s) Длина последовательности s</p>
<p>x in s Проверка принадлежности элемента последовательности. В новых версиях Python можно проверять принадлежность подстроки строке. Возвращает True или False</p>
<p>x not in s = not x in s</p>
<p>s + s1 Конкатенация последовательностей</p>
<p>s*n или n*s Последовательность из n раз повторенной s. Если n &lt; 0, возвращается пустая последовательность.</p>
<p>s[i] Возвращает i–й элемент s или len(s)+i–й, если i &lt; 0</p>
<p>s[i:j:d] Срез из последовательности s от i до j с шагом d будет рассматриваться ниже</p>
<p>min(s) Наименьший элемент s</p>
<p>max(s) Наибольший элемент s</p>
<p>Дополнительные конструкции для изменчивых последовательностей:</p>
<p>s[i] = x i–й элемент списка s заменяется на x</p>
<p>s[i:j:d] = t Срез от i до j (с шагом d) заменяется на (список) t</p>
<p>del s[i:j:d] Удаление элементов среза из последовательности</p>
<p>Некоторые методы для работы с последовательностями</p>
<p>В таблице приведен ряд методов изменчивых последовательностей (например, списков).</p>
<p>Метод Описание</p>
<p>append(x) Добавляет элемент в конец последовательности</p>
<p>count(x) Считает количество элементов, равных x</p>
<p>extend(s) Добавляет к концу последовательности последовательность s</p>
<p>index(x) Возвращает наименьшее i, такое, что s[i] == x. Возбуждает исключение ValueError, если x не найден в s</p>
<p>insert(i, x) Вставляет элемент x в i–й промежуток</p>
<p>pop(i) Возвращает i–й элемент, удаляя его из последовательности</p>
<p>reverse() Меняет порядок элементов s на обратный</p>
<p>sort([cmpfunc]) Сортирует элементы s. Может быть указана своя функция сравнения cmpfunc</p>
<p>Взятие элемента по индексу и срезы</p>
<p>Здесь же следует сказать несколько слов об индексировании последовательностей и выделении подстрок (и вообще — подпоследовательностей) по индексам. Для получения отдельного элемента последовательности используются квадратные скобки, в которых стоит выражение, дающее индекс. Индексы последовательностей в Python начинаются с нуля. Отрицательные индексы служат для отсчета элементов с конца последовательности (-1 — последний элемент). Пример проясняет дело:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = [0, 1, 2, 3, 4]</p>
<p>&gt;&gt;&gt; print s[0], s[-1], s[3]</p>
<p>0 4 3</p>
<p>&gt;&gt;&gt; s[2] = -2</p>
<p>&gt;&gt;&gt; print s</p>
<p>[0, 1, — 2, 3, 4]</p>
<p>&gt;&gt;&gt; del s[2]</p>
<p>&gt;&gt;&gt; print s</p>
<p>[0, 1, 3, 4]</p>
<p>Примечание:</p>
<p>Удалять элементы можно только из изменчивых последовательностей и желательно не делать этого внутри цикла по последовательности.</p>
<p>Несколько интереснее обстоят дела со срезами. Дело в том, что в Python при взятии среза последовательности принято нумеровать не элементы, а промежутки между ними. Поначалу это кажется необычным, тем не менее, очень удобно для указания произвольных срезов. Перед нулевым (по индексу) элементом последовательности промежуток имеет номер 0, после него — 1 и т.д.. Отрицательные значения отсчитывают промежутки с конца строки. Для записи срезов используется следующий синтаксис:</p>
<p>Листинг</p>
<p>последовательность[нач:кон:шаг]</p>
<p>где нач — промежуток начала среза, кон — конца среза, шаг — шаг. По умолчанию нач=0, кон=len(последовательность), шаг=1, если шаг не указан, второе двоеточие можно опустить.</p>
<p>А теперь пример работы со срезами:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; s = range(10)</p>
<p>&gt;&gt;&gt; s</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>&gt;&gt;&gt; s[0:3]</p>
<p>[0, 1, 2]</p>
<p>&gt;&gt;&gt; s[-1:]</p>
<p>[9]</p>
<p>&gt;&gt;&gt; s[::3]</p>
<p>[0, 3, 6, 9]</p>
<p>&gt;&gt;&gt; s[0:0] = [-1, — 1, — 1]</p>
<p>&gt;&gt;&gt; s</p>
<p>[-1, — 1, — 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>&gt;&gt;&gt; del s[:3]</p>
<p>&gt;&gt;&gt; s</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>Как видно из этого примера, с помощью срезов удобно задавать любую подстроку, даже если она нулевой длины, как для удаления элементов, так и для вставки в строго определенное место.</p>
<p>Тип dict</p>
<p>Словарь (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар ключ–значение, где значение однозначно определяется ключом. В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.). Порядок пар ключ–значение произволен. Ниже приведен литерал для словаря и пример работы со словарем:</p>
<p>Листинг</p>
<p>d = {1: 'one', 2: 'two', 3: 'three', 4: 'four'}</p>
<p>d0 = {0: 'zero'}</p>
<p>print d[1] # берется значение по ключу</p>
<p>d[0] = 0 # присваивается значение по ключу</p>
<p>del d[0] # удаляется пара ключ–значение с данным ключом</p>
<p>print d</p>
<p>for key, val in d.items(): # цикл по всему словарю</p>
<p>print key, val</p>
<p>for key in d.keys(): # цикл по ключам словаря</p>
<p>print key, d[key]</p>
<p>for val in d.values(): # цикл по значениям словаря</p>
<p>print val</p>
<p>d.update(d0) # пополняется словарь из другого</p>
<p>print len(d) # количество пар в словаре</p>
<p>Тип file</p>
<p>Объекты этого типа предназначены для работы с внешними данными. В простом случае — это файл на диске. Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.</p>
<p>Следующий пример показывает копирование файла:</p>
<p>Листинг</p>
<p>f1 = open(«file1.txt», «r»)</p>
<p>f2 = open(«file2.txt», «w»)</p>
<p>for line in f1.readlines():</p>
<p>f2.write(line)</p>
<p>f2.close()</p>
<p>f1.close()</p>
<p>Стоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку на</p>
<p>Листинг</p>
<p>import urllib</p>
<p>f1 = urllib.urlopen(«http://python.onego.ru»)</p>
<p>О модулях, классах, объектах и функциях будет говориться на других лекциях.</p>
<p>Выражения</p>
<p>В современных языках программирования принято производить большую часть обработки данных в выражениях. Синтаксис выражений у многих языков программирования примерно одинаков. Синтаксис выражений Python не удивит программиста чем–то новым. (Разве что цепочечные сравнения могут приятно порадовать.)</p>
<p>Приоритет операций показан в нижеследующей таблице (в порядке уменьшения). Для унарных операций x обозначает операнд. Ассоциативность операций в Python — слева–направо, за исключением операции возведения в степень (**), которая ассоциативна справа налево.</p>
<p>Операция Название</p>
<p>lambda лямбда–выражение</p>
<p>or логическое ИЛИ</p>
<p>and логическое И</p>
<p>not x логическое НЕ</p>
<p>in, not in проверка принадлежности</p>
<p>is, is not проверка идентичности</p>
<p>&lt;,&lt;=,&gt;,&gt;=,!=,== сравнения</p>
<p>| побитовое ИЛИ</p>
<p>^ побитовое исключающее ИЛИ</p>
<p>&amp; побитовое И</p>
<p>&lt;&lt;, &gt;&gt; побитовые сдвиги</p>
<p>+, — сложение и вычитание</p>
<p>*, /, % умножение, деление, остаток</p>
<p>+x, — x унарный плюс и смена знака</p>
<p>~x побитовое НЕ</p>
<p>** возведение в степень</p>
<p>x.атрибут ссылка на атрибут</p>
<p>x[индекс] взятие элемента по индексу</p>
<p>x[от:до] выделение среза (от и до)</p>
<p>f(аргумент,…) вызов функции</p>
<p>( … ) скобки или кортеж</p>
<p>[ … ] список или списковое включение</p>
<p>{кл:зн, …} словарь пар ключ–значение</p>
<p>`выражения` преобразование к строке (repr)</p>
<p>Таким образом, порядок вычислений операндов определяется такими правилами:</p>
<p>Операнд слева вычисляется раньше операнда справа во всех бинарных операциях, кроме возведения в степень.</p>
<p>Цепочка сравнений вида a &lt; b &lt; c … y &lt; z фактически равносильна: (а &lt; b) and (b &lt; c) and … and (y &lt; z).</p>
<p>Перед фактическим выполнением операции вычисляются нужные для нее операнды. В большинстве бинарных операций предварительно вычисляются оба операнда (сначала левый), но операции or и and , а также цепочки сравнений вычисляют такое количество операндов, которое достаточно для получения результата. В невычисленной части выражения в таком случае могут даже быть неопределенные имена. Это важно учитывать, если используются функции с побочными эффектами.</p>
<p>Аргументы функций, выражения для списков, кортежей, словарей и т.п. вычисляются слева–направо, в порядке следования в выражении.</p>
<p>В случае неясности приоритетов желательно применять скобки. Несмотря на то, что одни и те же символы могут использоваться для разных операций, приоритеты операций не меняются. Так, % имеет тот же приоритет, что и *, а потому в следующем примере скобки просто необходимы, чтобы операция умножения произошла перед операцией форматирования:</p>
<p>Листинг</p>
<p>print "%i» % (i*j)</p>
<p>Выражения могут фигурировать во многих операторах Python и даже как самостоятельный оператор. У выражения всегда есть результат, хотя в некоторых случаях (когда выражение вычисляется ради побочных эффектов) этот результат может быть «ничем» — None.</p>
<p>Очень часто выражения стоят в правой части оператора присваивания или расширенного присваивания. В Python (в отличие, скажем, от C) нет операции присваивания, поэтому синтаксически перед знаком = могут стоять только идентификатор, индекс, срез, доступ к атрибуту или кортеж (список) из перечисленного. (Подробности в документации).</p>
<p>Имена</p>
<p>Об именах (идентификаторах) говорилось уже не раз, тем не менее, необходимо сказать несколько слов об их применении в языке Python.</p>
<p>Имя может начинаться с латинской буквы (любого регистра) или подчеркивания, а дальше допустимо использование цифр. В качестве идентификаторов нельзя применять ключевые слова языка и нежелательно переопределять встроенные имена. Список ключевых слов можно узнать так:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; import keyword</p>
<p>&gt;&gt;&gt; keyword.kwlist</p>
<p>['and', 'assert', 'break', 'class', 'continue', 'def', 'del',</p>
<p>'elif', 'else', 'except', 'exec', 'finally', 'for', 'from',</p>
<p>'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or',</p>
<p>'pass', 'print', 'raise', 'return', 'try', 'while', 'yield']</p>
<p>Имена, начинающиеся с подчеркивания или двух подчеркиваний, имеют особый смысл. Одиночное подчеркивание говорит программисту о том, что имя имеет местное применение, и не должно использоваться за пределами модуля. Двойным подчеркиванием в начале и в конце обычно наделяются специальные имена атрибутов — об этом будет говориться в лекции по объектно–ориентированному программированию.</p>
<p>В каждой точке программы интерпретатор «видит» три пространства имен: локальное, глобальное и встроенное. Пространство имен — отображение из имен в объекты.</p>
<p>Для понимания того, как Python находит значение некоторой переменной, необходимо ввести понятие блока кода. В Python блоком кода является то, что исполняется как единое целое, например, тело определения функции, класса или модуля.</p>
<p>Локальные имена — имена, которым присвоено значение в данном блоке кода. Глобальные имена — имена, определяемые на уровне блока кода определения модуля или те, которые явно заданы в операторе global. Встроенные имена — имена из специального словаря __builtins__.</p>
<p>Области видимости имен могут быть вложенными друг в друга, например, внутри вызванной функции видны имена, определенные в вызывающем коде. Переменные, которые используются в блоке кода, но связаны со значением вне кода, называются свободными переменными.</p>
<p>Так как переменную можно связать с объектом в любом месте блока, важно, чтобы это произошло до ее использования, иначе будет возбуждено исключение NameError. Связывание имен со значениями происходит в операторах присваивания, for, import, в формальных аргументах функций, при определении функции или класса, во втором параметре части except оператора try–except.</p>
<p>С областями видимости и связыванием имен есть много нюансов, которые хорошо описаны в документации. Желательно, чтобы программы не зависели от таких нюансов, а для этого достаточно придерживаться следующих правил:</p>
<p>Всегда следует связывать переменную со значением (текстуально) до ее использования.</p>
<p>Необходимо избегать глобальных переменных и передавать все в качестве параметров. Глобальными на уровне модуля должны остаться только имена–константы, имена классов и функций.</p>
<p>Никогда не следует использовать from модуль import * - это может привести к затенению имен из других модулей, а внутри определения функции просто запрещено.</p>
<p>Предпочтительнее переделать код, нежели использовать глобальную переменную Конечно, для программ, состоящих из одного модуля, это не так важно: ведь все определенные на уровне модуля переменные глобальны.</p>
<p>Убрать связь имени с объектом можно с помощью оператора del. В этом случае, если объект не имеет других ссылок на него, он будет удален. Для управления памятью в Python используется подсчет ссылок (reference counting), для удаления наборов объектов с зацикленными ссылками — сборка мусора (garbage collection).</p>
<p>Стиль программирования</p>
<p>Стиль программирования — дополнительные ограничения, накладываемые на структуру и вид программного кода группой совместно работающих программистов с целью получения удобных для применения, легко читаемых и эффективных программ. Основные ограничения на вид программы дает синтаксис языка программирования, и его нарушения вызывают синтаксические ошибки. Нарушение стиля не приводит к синтаксическим ошибкам, однако как отдельные программисты, так и целые коллективы сознательно ограничивают себя в средствах выражения ради упрощения совместной разработки, отладки и сопровождения программного продукта.</p>
<p>Стиль программирования затрагивает практически все аспекты написания кода:</p>
<p>именование объектов в зависимости от типа, назначения, области видимости;</p>
<p>оформление функций, методов, классов, модулей и их документирование в коде программы;</p>
<p>декомпозиция программы на модули с определенными характеристиками;</p>
<p>способ включения отладочной информации;</p>
<p>применение тех или иных функций (методов) в зависимости от предполагаемого уровня совместимости разрабатываемой программы с различными компьютерными платформами;</p>
<p>ограничение используемых функций из соображений безопасности.</p>
<p>Для языка Python Гвидо ван Россум разработал официальный стиль. С оригинальным текстом «Python Style Guide» можно ознакомиться по адресу http://www.python.org/doc/essays/styleguide.html.</p>
<p>Наиболее существенные положения этого стиля перечислены ниже. В случае сомнений хорошим образцом стиля являются модули стандартной библиотеки.</p>
<p>Рекомендуется использовать отступы в 4 пробела.</p>
<p>Длина физической строки не должна превышать 79 символов.</p>
<p>Длинные логические строки лучше разбивать неявно (внутри скобок), но и явные методы вполне уместны. Отступы строк продолжения рекомендуется выравнивать по скобкам или по первому операнду в предыдущей строке. Текстовый редактор Emacs в режиме python–mode и некоторые интегрированные оболочки (IDE) автоматически делают необходимые отступы в Python–программах:</p>
<p>def draw(figure, color=«White», border_color=«Black»,</p>
<p>size=5):</p>
<p>if color == border_color or \</p>
<p>size == 0:</p>
<p>raise «Bad figure»</p>
<p>else:</p>
<p>_draw(size, size, (color,</p>
<p>border_color))</p>
<p>Не рекомендуется ставить пробелы сразу после открывающей скобки или перед закрывающей, перед запятой, точкой с запятой, перед открывающей скобкой при записи вызова функции или индексного выражения. Также не рекомендуется ставить более одного пробела вокруг знака равенства в присваиваниях. Пробелы вокруг знака равенства не ставятся в случае, когда он применяется для указания значения по умолчанию в определении параметров функции или при задании именованных аргументов.</p>
<p>Также рекомендуется применение одиночных пробелов вокруг низкоприоритетных операций сравнения и оператора присваивания. Пробелы вокруг более приоритетных операций ставятся в равном количестве слева и справа от знака операции.</p>
<p>Несколько рекомендаций касаются написания комментариев.</p>
<p>Комментарии должны точно отражать актуальное состояние кода. (Поддержание актуальных комментариев должно быть приоритетной задачей!) После коротких комментариев можно не ставить точку, тогда как длинные лучше писать по правилам написания текста. Автор Python обращается к неанглоязычным программистам с просьбой писать комментарии на английском, если есть хотя бы небольшая вероятность того, что код будут читать специалисты, говорящие на других языках.</p>
<p>Комментарии к фрагменту кода следует писать с тем же отступом, что и комментируемый код. После "#" должен идти одиночный пробел. Абзацы можно отделять строкой с "#" на том же уровне. Блочный комментарий можно отделить пустыми строками от окружающего кода.</p>
<p>Комментарии, относящиеся к конкретной строке, не следует использовать часто. Символ "#" должен отстоять от комментируемого оператора как минимум на два пробела.</p>
<p>Хороший комментарий не перефразирует программу, а содержит дополнительную информацию о действии программы в терминах предметной области.</p>
<p>Все модули, классы, функции и методы, предназначенные для использования за пределами модуля, должны иметь строки документации, описывающие способ их применения, входные и выходные параметры.</p>
<p>Строка документации для отдельной программы должна объяснять используемые ею ключи, назначение аргументов и переменных среды и другую подобную информацию.</p>
<p>Для строк документации рекомендуется везде использовать утроенные кавычки (""").</p>
<p>Однострочная документация пишется в императиве, как команда: «делай это», «возвращай то».</p>
<p>Многострочная документация содержит расширенное описание модуля, функции, класса. Она будет смотреться лучше, если текст будет написан с тем же отступом, что и начало строки документации.</p>
<p>Документация для модуля должна перечислять экспортируемые функции, классы, исключения и другие объекты, по одной строке на объект.</p>
<p>Строка документации для функции или метода должна кратко описывать действия функции, ее входные параметры и возвращаемое значение, побочные эффекты и возможные исключения (если таковые есть). Должны быть обозначены необязательные аргументы и аргументы, не являющиеся частью интерфейса.</p>
<p>Документация для класса должна перечислять общедоступные методы и атрибуты, содержать рекомендации по применению класса в качестве базового для других классов. Если класс является подклассом, необходимо указать, какие методы полностью заменяют, перегружают, а какие используют, но расширяют соответствующие методы надкласса. Необходимо указать и другие изменения по сравнению с надклассом.</p>
<p>Контроль версий повышает качество процесса создания программного обеспечения. Для этих целей часто используются RCS или CVS. «Python Style Guide» рекомендует записывать $Revision: 1.31 $ в переменную с именем __version__, а другие данные заключать в комментарии "#".</p>
<p>Сегодня сосуществуют несколько более или менее широко распространенных правил именования объектов. Программисты вольны выбрать тот, который принят в их организации или конкретном проекте. Автор Python рекомендует придерживаться нижеследующих правил для именования различных объектов, с тем чтобы это было понятно любому программисту, использующему Python.</p>
<p>Имена модулей лучше давать строчными буквами, например, shelve, string, либо делать первые буквы слов прописными, StringIO, UserDict. Имена написанных на C модулей расширения обычно начинаются с подчеркивания "_", а соответствующие им высокоуровневые обертки — с прописных букв: _tkinter и Tkinter.</p>
<p>Ключевые слова нельзя использовать в качестве имен, однако, если все–таки необходимо воспользоваться этим именем, стоит добавить одиночное подчеркивание в конце имени. Например: class_.</p>
<p>Классы обычно называют, выделяя первые буквы слов прописными, как в Tag или HTTPServer.</p>
<p>Имена исключений обычно содержат в своем составе слово «error» (или «warning»). Встроенные модули пишут это слово со строчной буквы (как os.error) (но могут писать и с прописной): distutils.DistutilsModuleError.</p>
<p>Функции, экспортируемые модулем, могут именоваться по–разному. Можно давать с прописных букв имена наиболее важных функций, а вспомогательные писать строчными.</p>
<p>Имена глобальных переменных (если таковые используются) лучше начинать с подчеркивания, чтобы они не импортировались из модуля оператором from–import со звездочкой.</p>
<p>Имена методов записываются по тем же правилам, что и имена функций.</p>
<p>Имена констант (имен, которые не должны переопределяться) лучше записывать прописными буквами, например: RED, GREEN, BLUE.</p>
<p>При работе с языком Python необходимо учитывать, что интерпретатор считает некоторые классы имен специальными (обычно такие имена начинаются с подчеркивания).</p>
<p>Заключение</p>
<p>В этой лекции синтаксис языка показан на примерах, что в случае с Python оправдано, так как эта часть языка достаточна проста. Были рассмотрены основные операторы языка, выражения и многие из встроенных типов данных, кратко объяснены принципы работы Python с именами, приведены правила официального стиля программирования на Python.</p>
<center><div align="center"></div></center>





