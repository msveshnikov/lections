# encoding: windows-1251







<p>Эта лекция может показаться необычной для того, кто использует императивные языки программирования (вроде Pascal, C++ или Java). Тем не менее, функциональный подход дает программисту мощные средства, позволяя создавать не только более компактный, но и более устойчивый к ошибкам программный код. Совсем не обязательно писать с помощью Python чисто функциональные программы, но необходимо научиться видеть, где элементы функционального программирования принесут максимальный эффект.</p>
<p>Функции являются абстракциями, в которых детали реализации некоторого действия скрываются за отдельным именем. Хорошо написанный набор функций позволяет использовать их много раз. Стандартная библиотека Python содержит множество готовых и отлаженных функций, многие из которых достаточно универсальны, чтобы работать с широким спектром входных данных. Даже если некоторый участок кода не используется несколько раз, но по входным и выходным данным он достаточно автономен, его смело можно выделить в отдельную функцию.</p>
<p>Эта лекция более ориентирована на практические соображения, а не на теорию функционального программирования. Однако там, где нужно, будут употребляться и поясняться соответствующие термины.</p>
<p>Далее будут подробно рассмотрены описание и использование функций в Python, рекурсия, передача и возврат функций в качестве параметров, обработка последовательностей и итераторы, а также такое понятие как генератор. Будет продемонстрировано, что в Python функции являются объектами (и, значит, могут быть переданы в качестве параметров и возвращены в результате выполнения функций). Кроме того, речь пойдет о том, как можно реализовать некоторые механизмы функционального программирования, не имеющие в Python прямой синтаксической поддержки, но широко распространенные в языках функционального программирования.</p>
<p>Что такое функциональное программирование?</p>
<p>Функциональное программирование — это стиль программирования, использующий только композиции функций. Другими словами, это программирование в выражениях, а не в императивных командах.</p>
<p>Как отмечает Дэвид Мертц (David Mertz) в своей статье о функциональном программировании на Python, «функциональное программирование — программирование на функциональных языках (LISP, ML, OCAML, Haskell, …)», основными атрибутами которых являются:</p>
<p>«Наличие функций первого класса (функции наравне с другими объектами можно передавать внутрь функций).</p>
<p>Рекурсия является основной управляющей структурой в программе.</p>
<p>Обработка списков (последовательностей).</p>
<p>Запрещение побочных эффектов у функций, что в первую очередь означает отсутствие присваивания (в «чистых» функциональных языках)</p>
<p>Запрещение операторов, основной упор делается на выражения. Вместо операторов вся программа в идеале — одно выражение с сопутствующими определениями.</p>
<p>Ключевой вопрос: что нужно вычислить, а не как.</p>
<p>Использование функций более высоких порядков (функции над функциями над функциями)».</p>
<p>Функциональная программа</p>
<p>В математике функция отображает объекты из одного множества (множества определения функции) в другое (множество значений функции). Математические функции (их называют чистыми) «механически», однозначно вычисляют результат по заданным аргументам. Чистые функции не должны хранить в себе какие–либо данные между двумя вызовами. Их можно представлять себе черными ящиками, о которых известно только то, что они делают, но совсем не важно, как.</p>
<p>Программы в функциональном стиле конструируются как композиция функций. При этом функции понимаются почти так же, как и в математике: они отображают одни объекты в другие. В программировании «чистые» функции — идеал, не всегда достижимый на практике. Практически полезные функции обычно имеют побочный эффект: сохраняют состояние между вызовами или меняют состояние других объектов. Например, без побочных эффектов невозможно представить себе функции ввода–вывода. Собственно, такие функции ради этих «эффектов» и используются. Кроме того, математические функции легко работают с объектами, требующими бесконечного объема информации (например, вещественные числа). В общем случае компьютерная программа может выполнить лишь приближенные вычисления.</p>
<p>Кстати, бинарные операции «+», «-», "*", "/", которые записываются в выражениях, являются «математическими» функциями над двумя аргументами — операндами. Их используют настолько часто, что синтаксис языка программирования имеет для них более короткую запись. Модуль operator позволяет представлять эти операции в функциональном стиле:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from operator import add, mul</p>
<p>&gt;&gt;&gt; print add(2, mul(3, 4))</p>
<p>14</p>
<p>Функция: определение и вызов</p>
<p>Как уже говорилось, определить функцию в Python можно двумя способами: с помощью оператора def и lambda–выражения. Первый способ позволяет использовать операторы. При втором — определение функции может быть только выражением.</p>
<p>Забегая вперед, можно заметить, что методы классов определяются так же, как и функции. Отличие состоит в специальном смысле первого аргумента self (в нем передается экземпляр объекта).</p>
<p>Лучше всего рассмотреть синтаксис определения функции на нескольких примерах. После определения соответствующей функции показан один или несколько вариантов ее вызова (некоторые примеры взяты из стандартной библиотеки).</p>
<p>Определение функции должно содержать список формальных параметров и тело определения функции. В случае с оператором def функции также задается некоторое имя. Формальные параметры являются локальными именами внутри тела определения функции, а при вызове функции они оказываются связанными с объектами, переданными как фактические параметры. Значения по умолчанию вычисляются в момент выполнения оператора def, и потому в них можно использовать видимые на момент определения имена.</p>
<p>Вызов функции синтаксически выглядит как объект–функция(фактические параметры). Обычно объект–функция — это просто имя функции, хотя это может быть и любое выражение, которое в результате вычисления дает исполняемый объект.</p>
<p>Функция одного аргумента:</p>
<p>Листинг</p>
<p>def swapcase(s):</p>
<p>return s.swapcase()</p>
<p>print swapcase(«ABC»)</p>
<p>Функция двух аргументов, один из которых необязателен и имеет значение по умолчанию:</p>
<p>Листинг</p>
<p>def inc(n, delta=1):</p>
<p>return n+delta</p>
<p>print inc(12)</p>
<p>print inc(12, 2)</p>
<p>Функция с одним обязательным аргументом, с одним, имеющим значение по умолчанию и неопределенным числом именованных аргументов:</p>
<p>Листинг</p>
<p>def wrap(text, width=70, **kwargs):</p>
<p>from textwrap import TextWrapper</p>
<p># kwargs — словарь с именами и значениями аргументов</p>
<p>w = TextWrapper(width=width, **kwargs)</p>
<p>return w.wrap(text)</p>
<p>print wrap(«my long text …», width=4)</p>
<p>Функция произвольного числа аргументов:</p>
<p>Листинг</p>
<p>def max_min(*args):</p>
<p># args — список аргументов в порядке их указания при вызове</p>
<p>return max(args), min(args)</p>
<p>print max_min(1, 2, — 1, 5, 3)</p>
<p>Функция с обычными (позиционными) и именованными аргументами:</p>
<p>Листинг</p>
<p>def swiss_knife(arg1, *args, **kwargs):</p>
<p>print arg1</p>
<p>print args</p>
<p>print kwargs</p>
<p>return None</p>
<p>print swiss_knife(1)</p>
<p>print swiss_knife(1, 2, 3, 4, 5)</p>
<p>print swiss_knife(1, 2, 3, a='abc', b='sdf')</p>
<p># print swiss_knife(1, a='abc', 3, 4) # !!! ошибка</p>
<p>lst = [2, 3, 4, 5]</p>
<p>dct = {'a': 'abc', 'b': 'sdf'}</p>
<p>print swiss_knife(1, *lst, **dct)</p>
<p>Пример определения функции с помощью lambda–выражения дан ниже:</p>
<p>Листинг</p>
<p>func = lambda x, y: x + y</p>
<p>В результате lambda–выражения получается безымянный объект–функция, которая затем используется, например, для того, чтобы связать с ней некоторое имя. Однако, как правило, определяемые lambda–выражением функции, применяются в качестве параметров функций.</p>
<p>В языке Python функция может возвратить только одно значение, которое может быть кортежем. В следующем примере видно, как стандартная функция divmod() возвращает частное и остаток от деления двух чисел:</p>
<p>Листинг</p>
<p>def bin(n):</p>
<p>«"«Цифры двоичного представления натурального числа """</p>
<p>digits = []</p>
<p>while n &gt; 0:</p>
<p>n, d = divmod(n, 2)</p>
<p>digits = [d] + digits</p>
<p>return digits</p>
<p>print bin(69)</p>
<p>Примечание:</p>
<p>Важно понять, что за именем функции стоит объект. Этот объект можно связать с другим именем:</p>
<p>def add(x, y):</p>
<p>return x + y</p>
<p>addition = add # теперь addition и add — разные имена одного и того же объекта</p>
<p>Пример, в котором в качестве значения по умолчанию аргумента функции используется изменчивый объект (список). Этот объект — один и тот же для всех вызовов функций, что может привести к казусам:</p>
<p>Листинг</p>
<p>def mylist(val, lst=[]):</p>
<p>lst.append(val)</p>
<p>return lst</p>
<p>print mylist(1),</p>
<p>print mylist(2)</p>
<p>Вместо ожидаемого [1] [2] получается [1] [1, 2], так как добавляются элементы к «значению по умолчанию».</p>
<p>Правильный вариант решения будет, например, таким:</p>
<p>Листинг</p>
<p>def mylist(val, lst=None):</p>
<p>lst = lst or []</p>
<p>lst.append(val)</p>
<p>return lst</p>
<p>Конечно, приведенная выше форма может использоваться для хранения в функции некоторого состояния между ее вызовами, однако, практически всегда вместо функции с таким побочным эффектом лучше написать класс и использовать его экземпляр.</p>
<p>Рекурсия</p>
<p>В некоторых случаях описание функции элегантнее всего выглядит с применением вызова этой же функции. Такой прием, когда функция вызывает саму себя, называется рекурсией. В функциональных языках рекурсия обычно используется много чаще, чем итерация (циклы).</p>
<p>В следующем примере переписывается функция bin() в рекурсивном варианте:</p>
<p>Листинг</p>
<p>def bin(n):</p>
<p>«"«Цифры двоичного представления натурального числа """</p>
<p>if n == 0:</p>
<p>return []</p>
<p>n, d = divmod(n, 2)</p>
<p>return bin(n) + [d]</p>
<p>print bin(69)</p>
<p>Здесь видно, что цикл while больше не используется, а вместо него появилось условие окончания рекурсии: условие, при выполнении которого функция не вызывает себя.</p>
<p>Конечно, в погоне за красивым рекурсивным решением не следует упускать из виду эффективность реализации. В частности, пример реализации функции для вычисления n–го числа Фибоначчи это демонстрирует:</p>
<p>Листинг</p>
<p>def Fib(n):</p>
<p>if n &lt; 2:</p>
<p>return n</p>
<p>else:</p>
<p>return Fib(n–1) + Fib(n–2)</p>
<p>В данном случае количество рекурсивных вызовов растет экспоненциально от числа n, что совсем не соответствует временной сложности решаемой задачи.</p>
<p>В качестве упражнения предлагается написать итеративный и рекурсивный варианты этой функции, которые бы требовали линейного времени для вычисления результата.</p>
<p>Предупреждение:</p>
<p>При работе с рекурсивными функциями можно легко превысить глубину допустимой в Python рекурсии. Для настройки глубины рекурсии следует использовать функцию setrecursionlimit(N) из модуля sys, установив требуемое значение N.</p>
<p>Функции как параметры и результат</p>
<p>Как уже не раз говорилось, функции являются такими же объектами Python как числа, строки или списки. Это означает, что их можно передавать в качестве параметров функций или возвращать из функций.</p>
<p>Функции, принимающие в качестве аргументов или возвращающие другие функции в результате, называют функциями высшего порядка. В Python функции высшего порядка применяются программистами достаточно часто. В большинстве случаев таким образом строится механизм обратных вызовов (callbacks), но встречаются и другие варианты. Например, алгоритм поиска может вызывать переданную ему функцию для каждого найденного объекта.</p>
<p>Функция apply()</p>
<p>Функция apply() применяет функцию, переданную в качестве первого аргумента, к параметрам, которые переданы вторым и третьим аргументом. Эта функция в Python устарела, так как вызвать функцию можно с помощью обычного синтаксиса вызова функции. Позиционные и именованные параметры можно передать с использованием звездочек:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; lst = [1, 2, 3]</p>
<p>&gt;&gt;&gt; dct = {'a': 4, 'b': 5}</p>
<p>&gt;&gt;&gt; apply(max, lst)</p>
<p>3</p>
<p>&gt;&gt;&gt; max(*lst)</p>
<p>3</p>
<p>&gt;&gt;&gt; apply(dict, [], dct)</p>
<p>{'a': 4, 'b': 5}</p>
<p>&gt;&gt;&gt; dict(**dct)</p>
<p>{'a': 4, 'b': 5}</p>
<p>Обработка последовательностей</p>
<p>Многие алгоритмы сводятся к обработке массивов данных и получению новых массивов данных в результате. Среди встроенных функций Python есть несколько для работы с последовательностями.</p>
<p>Под последовательностью в Python понимается любой тип данных, который поддерживает интерфейс последовательности (это несколько специальных методов, реализующих операции над последовательностями, которые в данном курсе обсуждаться не будут).</p>
<p>Следует заметить, что тип, основной задачей которого является хранение, манипулирование и обеспечение доступа к самостоятельным данным называется контейнерным типом или просто контейнером. Примеры контейнеров в Python — списки, кортежи, словари.</p>
<p>Функции range() и xrange()</p>
<p>Функция range() уже упоминалась при рассмотрении цикла for. Эта функция принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно). Если аргументов два, то список начинается с числа, указанного первым аргументом. Если аргументов три — третий аргумент задает шаг</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print range(10)</p>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>&gt;&gt;&gt; print range(1, 10)</p>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>&gt;&gt;&gt; print range(1, 10, 3)</p>
<p>[1, 4, 7]</p>
<p>Функция xrange() - аналог range(), более предпочтительный для использования при последовательном доступе, например, в цикле for или с итераторами. Она возвращает специальный xrange–объект, который ведет себя почти как список, порождаемый range(), но не хранит в памяти все выдаваемые элементы.</p>
<p>Функция map()</p>
<p>Для применения некоторой функции ко всем элементам последовательности применяется функция map(f, *args). Первый параметр этой функции — функция, которая будет применяться ко всем элементам последовательности. Каждый следующий n+1–й параметр должен быть последовательностью, так как каждый его элемент будет использован в качестве n–го параметра при вызове функции f(). Результатом будет список, составленный из результатов выполнения этой функции.</p>
<p>В следующем примере складываются значения из двух списков:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; l1 = [2, 7, 5, 3]</p>
<p>&gt;&gt;&gt; l2 = [-2, 1, 0, 4]</p>
<p>&gt;&gt;&gt; print map(lambda x, y: x+y, l1, l2)</p>
<p>[0, 8, 5, 7]</p>
<p>В этом примере применена безымянная функция для получения суммы двух операндов ко всем элементам l1 и l2. В случае если одна из последовательностей короче другой, вместо соответствующего операнда будет None, что, конечно, собьет операцию сложения. В зависимости от решаемой задачи, можно либо видоизменить функцию, либо считать разные по длине последовательности ошибкой, которую нужно обрабатывать как отдельную ветвь алгоритма.</p>
<p>Частный случай применения map() - использование None в качестве первого аргумента. В этом случае просто формируется список кортежей из элементов исходных последовательностей:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; l1 = [2, 7, 5, 3]</p>
<p>&gt;&gt;&gt; l2 = [-2, 1, 0, 4]</p>
<p>&gt;&gt;&gt; print map(None, l1, l2)</p>
<p>[(2, — 2), (7, 1), (5, 0), (3, 4)]</p>
<p>Функция filter()</p>
<p>Другой часто встречающейся операцией является фильтрование исходной последовательности в соответствии с некоторым предикатом (условием). Функция filter(f, seq) принимает два аргумента: функцию с условием и последовательность, из которой берутся значения. В результирующую последовательность попадут только те значения из исходной, для которой f() возвратит истину. Если в качестве f задано значение None, результирующая последовательность будет состоять из тех значений исходной, которые имеют истинностное значение True.</p>
<p>Например, в следующем фрагменте кода можно избавится от символов, которые не являются буквами:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; filter(lambda x: x.isalpha(), 'Hi, there! I am eating an apple.')</p>
<p>'HithereIameatinganapple'</p>
<p>Списковые включения</p>
<p>Для более естественной записи обработки списков в Python 2 была внесена новинка: списковые включения. Фактически это специальный сокращенный синтаксис для вложенных циклов for и условий if, на самом низком уровне которых определенное выражение добавляется к списку, например:</p>
<p>Листинг</p>
<p>all_pairs = []</p>
<p>for i in range(5):</p>
<p>for j in range(5):</p>
<p>if i &lt;= j:</p>
<p>all_pairs.append((i, j))</p>
<p>Все это можно записать в виде спискового включения так:</p>
<p>Листинг</p>
<p>all_pairs = [(i, j) for i in range(5) for j in range(5) if i &lt;= j]</p>
<p>Как легко заметить, списковые включения позволяют заменить map() и filter() на более удобные для прочтения конструкции.</p>
<p>В следующей таблице приведены эквивалентные выражения в разных формах:</p>
<p>В форме функции В форме спискового включения</p>
<p>filter(f, lst) [x for x in lst if f(x)]</p>
<p>filter(None, lst) [x for x in lst if x]</p>
<p>map(f, lst) [f(x) for x in lst]</p>
<p>Функция sum()</p>
<p>Получить сумму элементов можно с помощью функции sum():</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; sum(range(10))</p>
<p>45</p>
<p>Эта функция работает только для числовых типов, она не может конкатенировать строки. Для конкатенации списка строк следует использовать метод join().</p>
<p>Функция reduce()</p>
<p>Для организации цепочечных вычислений (вычислений с накоплением результата) можно применять функцию reduce(), которая принимает три аргумента: функцию двух аргументов, последовательность и начальное значение. С помощью этой функции можно, в частности, реализовать функцию sum():</p>
<p>Листинг</p>
<p>def sum(lst, start):</p>
<p>return reduce(lambda x, y: x + y, lst, start)</p>
<p>Совет:</p>
<p>Следует помнить, что в качестве передаваемого объекта может оказаться список, который позволит накапливать промежуточные результаты. Тем самым, reduce() может использоваться для генерации последовательностей.</p>
<p>В следующем примере накапливаются промежуточные результаты суммирования:</p>
<p>Листинг</p>
<p>lst = range(10)</p>
<p>f = lambda x, y: (x[0] + y, x[1]+[x[0] + y])</p>
<p>print reduce(f, lst, (0, []))</p>
<p>В итоге получается:</p>
<p>Листинг</p>
<p>(45, [0, 1, 3, 6, 10, 15, 21, 28, 36, 45])</p>
<p>Функция zip()</p>
<p>Эта функция возвращает список кортежей, в котором i–й кортеж содержит i–е элементы аргументов–последовательностей. Длина результирующей последовательности равна длине самой короткой из последовательностей–аргументов:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print zip(range(5), «abcde»)</p>
<p>[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e')]</p>
<p>Итераторы</p>
<p>Применять для обработки данных явные последовательности не всегда эффективно, так как на хранение временных данных может тратиться много оперативной памяти. Более эффективным решением представляется использование итераторов — специальных объектов, обеспечивающих последовательный доступ к данным контейнера. Если в выражении есть операции с итераторами вместо контейнеров, промежуточные данные не будут требовать много места для хранения — ведь они запрашиваются по мере необходимости для вычислений. При обработке данных с использованием итераторов память будет требоваться только для исходных данных и результата, да и то необязательно вся сразу — ведь данные могут читаться и записываться в файл на диске.</p>
<p>Итераторы можно применять вместо последовательности в операторе for. Более того, внутренне оператор for запрашивает от последовательности ее итератор. Объект файлового типа тоже (построчный) итератор, что позволяет обрабатывать большие файлы, не считывая их целиком в память.</p>
<p>Там, где требуется итератор, можно использовать последовательность.</p>
<p>Работа с итераторами рассматривается в разделе, посвященном функциональному программированию, так как итераторами удобно манипулировать именно в функциональном стиле.</p>
<p>Использовать итератор можно и «вручную». Любой объект, поддерживающий интерфейс итератора, имеет метод next(), который при каждом вызове выдает очередное значение итератора. Если больше значений нет, возбуждается исключение StopIteration. Для получения итератора по некоторому объекту необходимо прежде применить к этому объекту функцию iter() (цикл for делает это автоматически).</p>
<p>В Python имеется модуль itertools, который содержит набор функций, комбинируя которые, можно составлять достаточно сложные схемы обработки данных с помощью итераторов. Далее рассматриваются некоторые функции этого модуля.</p>
<p>Функция iter()</p>
<p>Эта функция имеет два варианта использования. В первом она принимает всего один аргумент, который должен «уметь» предоставлять свой итератор. Во втором один из аргументов — функция без аргументов, другой — стоповое значение. Итератор вызывает указанную функцию до тех пор, пока та не возвратит стоповое значение. Второй вариант встречается много реже первого и обычно внутри метода класса, так как сложно порождать значения «на пустом месте»:</p>
<p>Листинг</p>
<p>it1 = iter([1, 2, 3, 4, 5])</p>
<p>def forit(mystate=[]):</p>
<p>if len(mystate) &lt; 3:</p>
<p>mystate.append(" ")</p>
<p>return " "</p>
<p>it2 = iter(forit, None)</p>
<p>print [x for x in it1]</p>
<p>print [x for x in it2]</p>
<p>Примечание:</p>
<p>Если функция не возвращает значения явно, она возвращает None, что и использовано в примере выше.</p>
<p>Функция enumerate()</p>
<p>Эта функция создает итератор, нумерующий элементы другого итератора. Результирующий итератор выдает кортежи, в которых первый элемент — номер (начиная с нуля), а второй — элемент исходной последовательности:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; print [x for x in enumerate(«abcd»)]</p>
<p>[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]</p>
<p>Функция sorted()</p>
<p>Эта функция, появившаяся в Python 2.4, позволяет создавать итератор, выполняющий сортировку:</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; sorted('avdsdf')</p>
<p>['a', 'd', 'd', 'f', 's', 'v']</p>
<p>Далее рассматриваются функции модуля itertools.</p>
<p>Функция itertools.chain()</p>
<p>Функция chain() позволяет сделать итератор, состоящий из нескольких соединенных последовательно итераторов. Итераторы задаются в виде отдельных аргументов. Пример:</p>
<p>Листинг</p>
<p>from itertools import chain</p>
<p>it1 = iter([1,2,3])</p>
<p>it2 = iter([8,9,0])</p>
<p>for i in chain(it1, it2):</p>
<p>print i,</p>
<p>даст в результате</p>
<p>Листинг</p>
<p>1 2 3 8 9 0</p>
<p>Функция itertools.repeat()</p>
<p>Функция repeat() строит итератор, повторяющий некоторый объект заданное количество раз:</p>
<p>Листинг</p>
<p>for i in itertools.repeat(1, 4):</p>
<p>print i,</p>
<p>1 1 1 1</p>
<p>Функция itertools.count()</p>
<p>Бесконечный итератор, дающий целые числа, начиная с заданного:</p>
<p>Листинг</p>
<p>for i in itertools.count(1):</p>
<p>print i,</p>
<p>if i &gt; 100:</p>
<p>break</p>
<p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</p>
<p>27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49</p>
<p>50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72</p>
<p>73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95</p>
<p>96 97 98 99 100 101</p>
<p>Функция itertools.cycle()</p>
<p>Можно бесконечно повторять и некоторую последовательность (или значения другого итератора) с помощью функции cycle():</p>
<p>Листинг</p>
<p>tango = [1, 2, 3]</p>
<p>for i in itertools.cycle(tango):</p>
<p>print i,</p>
<p>1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2</p>
<p>3 1 2 3 1</p>
<p>2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3</p>
<p>1 2 3 1 2</p>
<p>3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 …</p>
<p>Функции itertools.imap(), itertools.starmap() и itertools.ifilter()</p>
<p>Аналогами map() и filter() в модуле itertools являются imap() и ifilter(). Отличие imap() от map() в том, что вместо значения от преждевременно завершившихся итераторов объект None не подставляется. Пример:</p>
<p>Листинг</p>
<p>for i in map(lambda x, y: (x,y), [1,2], [1,2,3]):</p>
<p>print i,</p>
<p>(1, 1) (2, 2) (None, 3)</p>
<p>from itertools import imap</p>
<p>for i in imap(lambda x, y: (x,y), [1,2], [1,2,3]):</p>
<p>print i,</p>
<p>(1, 1) (2, 2)</p>
<p>Здесь следует заметить, что обычная функция map() нормально воспринимает итераторы в любом сочетании с итерабельными (поддающимися итерациям) объектами:</p>
<p>Листинг</p>
<p>for i in map(lambda x, y: (x,y), iter([1,2]), [1,2,3]):</p>
<p>print i,</p>
<p>(1, 1) (2, 2) (None, 3)</p>
<p>Функция itertools.starmap() подобна itertools.imap(), но имеет всего два аргумента. Второй аргумент — последовательность кортежей, каждый кортеж которой задает набор параметров для функции (первого аргумента):</p>
<p>Листинг</p>
<p>&gt;&gt;&gt; from itertools import starmap</p>
<p>&gt;&gt;&gt; for i in starmap(lambda x, y: str(x) + y, [(1,'a'), (2,'b')]):</p>
<p>… print i,</p>
<p>…</p>
<p>1a 2b</p>
<p>Функция ifilter() работает как filter(). Кроме того, в модуле itertools есть функция ifilterfalse(), которая как бы добавляет отрицание к значению функции:</p>
<p>Листинг</p>
<p>for i in ifilterfalse(lambda x: x &gt; 0, [1, — 2, 3, — 3]):</p>
<p>print i,</p>
<p>— 2–3</p>
<p>Функции itertools.takewhile() и itertools.dropwhile()</p>
<p>Некоторую новизну вносит другой вид фильтра: takewhile() и его «отрицательный» аналог dropwhile(). Следующий пример поясняет их принцип действия:</p>
<p>Листинг</p>
<p>for i in takewhile(lambda x: x &gt; 0, [1, — 2, 3, — 3]):</p>
<p>print i,</p>
<p>print</p>
<p>for i in dropwhile(lambda x: x &gt; 0, [1, — 2, 3, — 3]):</p>
<p>print i,</p>
<p>1</p>
<p>— 2 3–3</p>
<p>Таким образом, takewhile() дает значения, пока условие истинно, а остальные значения даже не берет из итератора (именно не берет, а не высасывает все до конца!). И, наоборот, dropwhile() ничего не выдает, пока выполняется условие, зато потом выдает все без остатка.</p>
<p>Функция itertools.izip()</p>
<p>Функция izip() аналогична встроенной zip(), но не тратит много памяти на построение списка кортежей, так как итератор выдает их строго по требованию.</p>
<p>Функция itertools.groupby()</p>
<p>Эта функция дебютировала в Python 2.4. Функция принимает два аргумента: итератор (обязательный) и необязательный аргумент — функцию, дающую значение ключа: groupby(iterable[, func]). Результатом является итератор, который возвращает двухэлементный кортеж: ключ и итератор по идущим подряд элементам с этим ключом. Если второй аргумент опущен, элемент итератора сам является ключом. В следующем примере группируются идущие подряд положительные и отрицательные элементы:</p>
<p>Листинг</p>
<p>import itertools, math</p>
<p>lst = map(lambda x: math.sin(x*.4), range(30))</p>
<p>for k, i in itertools.groupby(lst, lambda x: x &gt; 0):</p>
<p>print k, list(i)</p>
<p>Функция itertools.tee()</p>
<p>Эта функция тоже появилась в Python 2.4. Она позволяет клонировать итераторы. Первый аргумент — итератор, подлежащий клонированию. Второй (N) — количество необходимых копий. Функция возвращает кортеж из N итераторов. По умолчанию N=2. Функция имеет смысл, только если итераторы задействованы более или менее параллельно. В противном случае выгоднее превратить исходный итератор в список.</p>
<p>Собственный итератор</p>
<p>Для полноты описания здесь представлен пример итератора, определенного пользователем. Если пример не очень понятен, можно вернуться к нему после изучения объектно–ориентированного программирования:</p>
<p>Листинг</p>
<p>class Fibonacci:</p>
<p>«"«Итератор последовательности Фибоначчи до N»""</p>
<p>def __init__(self, N):</p>
<p>self.n, self.a, self.b, self.max = 0, 0, 1, N</p>
<p>def __iter__(self):</p>
<p># сами себе итератор: в классе есть метод next()</p>
<p>return self</p>
<p>def next(self):</p>
<p>if self.n &lt; self.max:</p>
<p>a, self.n, self.a, self.b = self.a, self.n+1, self.b, self.a+self.b</p>
<p>return a</p>
<p>else:</p>
<p>raise StopIteration</p>
<p># Использование:</p>
<p>for i in Fibonacci(100):</p>
<p>print i,</p>
<p>Простые генераторы</p>
<p>Разработчики языка не остановились на итераторах. Как оказалось, в интерпретаторе Python достаточно просто реализовать простые генераторы. Под этим термином фактически понимается специальный объект, вычисления в котором продолжаются до выработки очередного значения, а затем приостанавливаются до возникновения необходимости в выдаче следующего значения. Простой генератор формируется функцией–генератором, которая синтаксически похожа на обычную функцию, но использует специальный оператор yield для выдачи следующего значения. При вызове такая функция ничего не вычисляет, а создает объект с интерфейсом итератора для получения значений. Другими словами, если функция должна возвращать последовательность, из нее довольно просто сделать генератор, который будет функционально эквивалентной «ленивой» реализацией. Ленивыми называются вычисления, которые откладываются до самого последнего момента, когда получаемое в результате значение сразу используется в другом вычислении.</p>
<p>Для примера с последовательностью Фибоначчи можно построить такой вот генератор:</p>
<p>Листинг</p>
<p>def Fib(N):</p>
<p>a, b = 0, 1</p>
<p>for i in xrange(N):</p>
<p>yield a</p>
<p>a, b = b, a + b</p>
<p>Использовать его не сложнее, чем любой другой итератор:</p>
<p>Листинг</p>
<p>for i in Fib(100):</p>
<p>print i,</p>
<p>Однако следует заметить, что программа в значительной степени упростилась.</p>
<p>Генераторное выражение</p>
<p>В Python 2.4 по аналогии со списковым включением появилось генераторное выражение. По синтаксису оно аналогично списковому, но вместо квадратных скобок используются круглые. Списковое включение порождает список, а, значит, можно ненароком занять очень много памяти. Генератор же, получающийся в результате применения генераторного выражения, списка не создает, он вычисляет каждое следующее значение строго по требованию (при вызове метода next()).</p>
<p>В следующем примере можно прочесть из файла строки, в которых производятся некоторые замены:</p>
<p>Листинг</p>
<p>for line in (l.replace(" — ", " — ") for l in open(«input.dat»)):</p>
<p>print line</p>
<p>Ничто не мешает использовать итераторы и для записи в файл:</p>
<p>Листинг</p>
<p>open(«output.dat», «w»).writelines(</p>
<p>l.replace(" — ", " — ") for l in open(«input.dat»))</p>
<p>Здесь для генераторного выражения не потребовалось дополнительных скобок, так как оно расположено внутри скобок вызова функции.</p>
<p>Карринг</p>
<p>Библиотека Xoltar toolkit (автор Bryn Keller) включает модуль functional, который позволяет упростить использование возможностей функционального программирования. Модуль functional применяет «чистый» Python. Библиотеку можно найти по адресу: http://sourceforge.net/projects/xoltar–toolkit.</p>
<p>При карринге (частичном применении) функции создается новая функция, задавая некоторые аргументы исходной. Следующий пример иллюстрирует частичное применение вычитания:</p>
<p>Листинг</p>
<p>from functional import curry</p>
<p>def subtract(x, y):</p>
<p>return x — y</p>
<p>print subtract(3, 2)</p>
<p>subtract_from_3 = curry(subtract, 3)</p>
<p>print subtract_from_3(2)</p>
<p>print curry(subtract, 3)(2)</p>
<p>Во всех трех случаях будет выведено 1. В следующем примере получается новая функция, подставляя второй аргумент. Вместо другого аргумента вставляется специальное значение Blank:</p>
<p>Листинг</p>
<p>from functional import curry, Blank</p>
<p>def subtract(x, y):</p>
<p>return x + y</p>
<p>print subtract(3, 2)</p>
<p>subtract_2 = curry(subtract, Blank, 2)</p>
<p>print subtract_2(3)</p>
<p>print curry(subtract, Blank, 2)(3)</p>
<p>Заключение</p>
<p>В этой лекции рассматривался принцип построения функциональных программ. Кроме того, было показано, что в Python и его стандартных модулях имеются достаточно мощные выразительные средства для создания функциональных программ. В случае, когда требуются дополнительные возможности, например, карринг, их можно легко реализовать или взять готовую реализацию.</p>
<p>Следует отметить, что итераторы — это практичное продолжение функционального начала в языке Python. Итераторы по сути позволяют организовать так называемые ленивые вычисления (lazy computations), при которых значения вычисляются только когда они непосредственно требуются.</p>
<p>Ссылки по теме</p>
<p>Статья Д. Мертца http://www–106.ibm.com/developerworks/library/l–prog.html</p>
<p>Часто задаваемые вопросы в comp.lang.functional http://www.cs.nott.ac.uk/~gmh/faq.html</p>
<center><div align="center"></div></center>





