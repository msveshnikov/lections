<div class="span9 content pull-left">
<div class="banner">

  
  



</div>
<h2 id="rekomendatsii-po-dokumentirovaniyu-api" class="inside_page_header"> Рекомендации по документированию API</h2>
<p>Это руководство документирует рекомендации к документации Ruby on Rails API.</p>
<p>После его прочтения, вы узнаете:</p>
<ul>
<li>Как писать эффективную прозу для целей документирования.
</li>
<li>Стилистические рекомендации для документирования различного кода на Ruby.
</li>
</ul>

<h3 id="rdoc" class="inside_page_header"> RDoc</h3>
<p> генерируется с помощью . Чтобы ее сгенерировать, убедитесь, что вы в корневой директории rails, запустите <code>bundle install</code> и выполните:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
  bundle exec rake rdoc

</pre>
</div>
<p>Итоговые файлы HTML будут в директории ./doc/rdoc.</p>
<p>Обратитесь к документации RDoc за помощью с , а также примите во внимание эти .</p>
<h3 id="wording" class="inside_page_header">  Формулировки</h3>
<p>Пишите простые, декларативные предложения. Краткость — сестра таланта.</p>
<p>Пишите в настоящем времени: "Returns a hash that...", а не "Returned a hash that...", или "Will return a hash that...".</p>
<p>Начинайте комментарии с большой буквы. Следуйте обычным правилам пунктуации:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Declares an attribute reader backed by an internally-named
# instance variable.
def attr_internal_reader(*attrs)
  ...
end

</pre>
</div>
<p>Доносите до читателя правильный способ делать вещи, явно или неявно. Используйте идиомы, рекомендованные в последней версии. По необходимости перегруппируйте разделы, чтобы подчеркнуть предпочтительные подходы, и так далее. Документация должна быть моделью для лучшей практики и канонического, современного использования Rails.</p>
<p>Документация должна быть краткой, но всеобъемлющей. Исследуйте и документируйте крайние случаи. Что произойдет, если модуль анонимный? А что, если коллекция пустая? А если аргумент nil?</p>
<p>Правильные имена компонентов Rails имеют пробел между словами, например "Active Support". <code>ActiveRecord</code> это модуль на Ruby, в то время как Active Record — это ORM. Вся документация Rails должна последовательно ссылаться на компоненты Rails правильными именами, и, если в следующей публикации в блоге или презентации вы вспомните это правило и примете его в внимание, это будет феноменально.</p>
<p>Пишите имена правильно: Arel, Test::Unit, RSpec, HTML, MySQL, JavaScript, ERB. Когда сомневаетесь, взгляните на какой-нибудь авторитетный источник, например, на их официальную документацию.</p>
<p>Используйте артикль "an" для "SQL", как в "an SQL statement". А также "an SQLite database".</p>
<p>Предпочитайте формулировки, избегающие использование "you" и "your". Например, вместо</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
If you need to use `return` statements in your callbacks, it is recommended that you explicitly define them as methods.

</pre>
</div>
<p>используйте такую стилистику:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
If `return` is needed it is recommended to explicitly define a method.

</pre>
</div>
<p>Тем не менее, при использовании местоимений для ссылки на гипотетическую личность, такую как "a user with a session cookie", должны быть использованы гендерно нейтральные местоимения (they/their/them). Вместо:</p>
<ul>
<li>he или she... используйте they.
</li>
<li>him или her... используйте them.
</li>
<li>his или her... используйте their.
</li>
<li>his или hers... используйте theirs.
</li>
<li>himself или herself... используйте themselves.
</li>
</ul>
<h3 id="english" class="inside_page_header">  Английский язык</h3>
<p>Пожалуйста, используйте американский английский (<em>color</em>, <em>center</em>, <em>modularize</em> и т.д.). Обратитесь к .</p>
<h3 id="example-code" class="inside_page_header">  Пример кода</h3>
<p>Выбирайте осмысленные примеры, отображающие и покрывающие как основы, так и интересные моменты или подводные камни.</p>
<p>Используйте два пробела для отступа кусков кода — это означает, для целей разметки, два пробела с учетом левого отступа. Сами примеры должны следовать .</p>
<p>Короткие документы не нуждаются в явной метке "Examples" для представления примеров кода; они идут следующим параграфом:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Converts a collection of elements into a formatted string by
# calling +to_s+ on all elements and joining them.
#
#   Blog.all.to_formatted_s # =&gt; "First PostSecond PostThird Post"

</pre>
</div>
<p>С другой стороны, большие куски структурированной документации могут иметь отдельный раздел "Examples":</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# ==== Examples
#
#   Person.exists?(5)
#   Person.exists?('5')
#   Person.exists?(name: "David")
#   Person.exists?(['name LIKE ?', "%#{query}%"])

</pre>
</div>
<p>Результаты выражений следуют за ними и представляются с помощью "# =&gt; ", выравненными по вертикали:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# For checking if a fixnum is even or odd.
#
#   1.even? # =&gt; false
#   1.odd?  # =&gt; true
#   2.even? # =&gt; true
#   2.odd?  # =&gt; false

</pre>
</div>
<p>Если строчка слишком длинная, комментарий может быть помещен в следующей строчке:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
#   label(:article, :title)
#   # =&gt; &lt;label for="article_title"&gt;Title&lt;/label&gt;
#
#   label(:article, :title, "A short title")
#   # =&gt; &lt;label for="article_title"&gt;A short title&lt;/label&gt;
#
#   label(:article, :title, "A short title", class: "title_label")
#   # =&gt; &lt;label for="article_title" class="title_label"&gt;A short title&lt;/label&gt;

</pre>
</div>
<p>Избегайте использования любых выводящих методов, таких как <code>puts</code> или <code>p</code>, для этой цели.</p>
<p>С другой стороны, обычные комментарии не используют стрелку:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
#   polymorphic_url(record)  # same as comment_url(record)

</pre>
</div>
<h3 id="bulevy-znacheniya" class="inside_page_header"> Булевы значения</h3>
<p>В предикатных методах и флажках предпочитайте документировать булеву семантику над остальными значениями.</p>
<p>Когда "true" или "false" используются так, как определены в Ruby, используйте обычный шрифт. Синглтонам <code>true</code> и <code>false</code> необходим моноширинный шрифт. Пожалуйста, избегайте терминов, таких как "truthy", Ruby определяет, что такое true и false в языке, и поэтому эти слова имеют техническое значение и не нуждаются в замене.</p>
<p>Как правило, не документируйте синглтоны, кроме случая, когда это абсолютно необходимо. Это предотвращает искусственные конструкции, наподобие <code>!!</code> или тернарного оператора, позволяет рефакторинг, и коду не нужно полагаться на точные значения, возвращаемыми в этой реализации.</p>
<p>Например, в:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
`config.action_mailer.perform_deliveries` specifies whether mail will actually be delivered and is true by default

</pre>
</div>
<p>пользователю не нужно знать, какое действительное значение по умолчанию у этого флажка, поэтому мы документируем только его булеву семантику.</p>
<p>Пример с предикатом:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Returns true if the collection is empty.
#
# If the collection has been loaded
# it is equivalent to &lt;tt&gt;collection.size.zero?&lt;/tt&gt;. If the
# collection has not been loaded, it is equivalent to
# &lt;tt&gt;collection.exists?&lt;/tt&gt;. If the collection has not already been
# loaded and you are going to fetch the records anyway it is better to
# check &lt;tt&gt;collection.length.zero?&lt;/tt&gt;.
def empty?
  if loaded?
    size.zero?
  else
    @target.blank? &amp;&amp; !scope.exists?
  end
end

</pre>
</div>
<p>API осторожен, чтобы не обещать какое-либо конкретное значение, у метода есть предикатная семантика, этого достаточно.</p>
<h3 id="file-names" class="inside_page_header">  Имена файлов</h3>
<p>Как правило, используйте имена файлов относительно корня приложения:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
config/routes.rb            # ДА
routes.rb                   # НЕТ
RAILS_ROOT/config/routes.rb # НЕТ

</pre>
</div>
<h3 id="fonts" class="inside_page_header">  Шрифты</h3>
<h4 id="monoshirinnyy-shrift" class="inside_page_header"> Моноширинный шрифт</h4>
<p>Используйте моноширинные шрифты для:</p>
<ul>
<li>Констант, в частности имен классов и модулей.
</li>
<li>Имен методов.
</li>
<li>Литералов, таких как <code>nil</code>, <code>false</code>, <code>true</code>, <code>self</code>.
</li>
<li>Символов.
</li>
<li>Параметров методов.
</li>
<li>Имен файлов.
</li>
</ul>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Array
  # Calls +to_param+ on all its elements and joins the result with
  # slashes. This is used by +url_for+ in Action Pack.
  def to_param
    collect { |e| e.to_param }.join '/'
  end
end

</pre>
</div>
<div class="warning"><p>Использование <code>+...+</code> для моноширинного шрифта работает только с простым содержимым, таким как обычные имена методов, символы, пути (с обратными слэшами) и так далее. Для всего остального используйте <code>&lt;tt&gt;...&lt;/tt&gt;</code>, особенно для имен классов или модулей в пространстве имен, как в <code>&lt;tt&gt;ActiveRecord::Base&lt;/tt&gt;</code>.</p></div>
<p>Можно быстро протестировать результат RDoc с помощью следующей команды:</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ echo "+:to_param+" | rdoc --pipe
#=&gt; &lt;p&gt;&lt;code&gt;:to_param&lt;/code&gt;&lt;/p&gt;

</pre>
</div>
<h4 id="obychnyy-shrift" class="inside_page_header"> Обычный шрифт</h4>
<p>Когда "true" и "false" это английские слова, в отличие от ключевых слов Ruby, используйте обычный шрифт:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Runs all the validations within the specified context.
# Returns true if no errors are found, false otherwise.
#
# If the argument is false (default is +nil+), the context is
# set to &lt;tt&gt;:create&lt;/tt&gt; if &lt;tt&gt;new_record?&lt;/tt&gt; is true,
# and to &lt;tt&gt;:update&lt;/tt&gt; if it is not.
#
# Validations with no &lt;tt&gt;:on&lt;/tt&gt; option will run no
# matter the context. Validations with # some &lt;tt&gt;:on&lt;/tt&gt;
# option will only run in the specified context.
def valid?(context = nil)
  ...
end

</pre>
</div>
<h3 id="opisatelnye-spiski" class="inside_page_header"> Описательные списки</h3>
<p>В списках опций, параметров и т.д. используйте дефис между элементом и его описанием (читается лучше, чем двоеточие, так как опции обычно символы):</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# * &lt;tt&gt;:allow_nil&lt;/tt&gt; - Skip validation if attribute is +nil+.

</pre>
</div>
<p>Описание начинается с заглавной буквы и заканчивается точкой — это стандартный английский.</p>
<h3 id="dinamicheski-sozdavaemye-metody" class="inside_page_header"> Динамически создаваемые методы</h3>
<p>Методы, созданные с помощью <code>(module|class)_eval(STRING)</code>, имеют справа комментарий с экземпляром сгенерированного кода. Этот комментарий отделен двумя пробелами от шаблона:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
for severity in Severity.constants
  class_eval &lt;&lt;-EOT, __FILE__, __LINE__
    def #{severity.downcase}(message = nil, progname = nil, &amp;block)  # def debug(message = nil, progname = nil, &amp;block)
      add(#{severity}, message, progname, &amp;block)                    #   add(DEBUG, message, progname, &amp;block)
    end                                                              # end
                                                                     #
    def #{severity.downcase}?                                        # def debug?
      #{severity} &gt;= @level                                          #   DEBUG &gt;= @level
    end                                                              # end
  EOT
end

</pre>
</div>
<p>Если результирующие строчки получаются слишком длинными, скажем 200 символов и больше, поместите комментарий над вызовом:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# def self.find_by_login_and_activated(*args)
#   options = args.extract_options!
#   ...
# end
self.class_eval %{
  def self.#{method_id}(*args)
    options = args.extract_options!
    ...
  end
}

</pre>
</div>
<h3 id="vidimost-metodov" class="inside_page_header"> Видимость методов</h3>
<p>При написании документации для Rails, важно понимать различие между публичным пользовательским API и внутренним API.</p>
<p>Rails, как и многие библиотеки, использует ключевое слово private из Ruby для определения внутреннего API. Однако, публичный API следует немного отличающимся соглашениям. Вместо предположения, что все публичные методы разработаны для пользователя, Rails использует директиву <code>:nodoc:</code> для аннотирования таких методов как внутреннего API.</p>
<p>Это означает, что в Rails имеются методы с видимостью <code>public</code>, не предназначенные для пользователя.</p>
<p>Примером этого является <code>ActiveRecord::Core::ClassMethods#arel_table</code>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveRecord::Core::ClassMethods
  def arel_table #:nodoc:
    # do some magic..
  end
end

</pre>
</div>
<p>Если вы подумаете: "этот метод выглядит публичным методом класса для <code>ActiveRecord::Core</code>", то будете правы. Но фактически, основная команда Rails не хочет, чтобы пользователи полагались на этот метод. Поэтому они пометили его как <code>:nodoc:</code>, и он убран из публичной документации. Обоснованием этого является необходимость позволить команде изменить эти методы в соответствии с их внутренними потребностями между релизами, по их усмотрению. Может измениться имя этого метода, или возвращаемое значение, или может исчезнуть весь этот класс; нет гарантии, и поэтому вы не должны зависеть от этого API в ваших плагинах или приложениях. В противном случае, вы рискуете, что ваше приложение или гем сломаются при обновлении на новый релиз Rails.</p>
<p>В качестве контрибьютора важно думать, предназначен ли этот API для конечного пользователя. Команда Rails стремится не вносить какие-либо критические изменения в публичный API между релизами без прохождения полного цикла устаревания. Рекомендуется, чтобы вы помечали <code>:nodoc:</code> любые ваши внутренние методы/классы, за исключением тех, которые уже приватные (имеется в виду видимость), в этом случае они внутренние по умолчанию. Как только API стабилизируется, видимость может измениться, но изменение публичного API намного сложнее из-за обратной совместимости.</p>
<p>Классы или модули, помеченные <code>:nodoc:</code>, показывают, что все методы являются внутренним API, и никогда не должны использоваться непосредственно.</p>
<p>Если вы столкнулись с существующим <code>:nodoc:</code>, следует действовать осторожно. Попробуйте спросить кого-либо из основной команды или автора кода, до того, как уберете его. Это должно всегда происходить через пул-реквест, а не в проекте docrails.</p>
<p>Никогда не добавляйте <code>:nodoc:</code> только потому, что у метода или класса отсутствует документация. Могут быть экземпляры, где внутреннему публичному методу не дан <code>:nodoc:</code> по ошибке, например при переключении видимости метода с private на public. Когда это происходит, следует обсуждать каждый случай в пул-реквесте, и никогда не отправлять изменения непосредственно в docrails.</p>
<p>Итак, команда Rails использует <code>:nodoc:</code>, чтобы пометить публично видимые методы и классы для внутреннего использования; изменения видимости в API должны сначала тщательно рассматриваться и обсуждаться в пул-реквесте.</p>
<h3 id="otnositelno-steka-rails" class="inside_page_header"> Относительно стека Rails</h3>
<p>При документировании частей Rails API важно помнить все кусочки, составляющие стек Rails.</p>
<p>Это означает, что поведение может измениться в зависимости от области видимости или контекста метода или класса, который вы пытаетесь документировать.</p>
<p>В различных местах имеется различное поведение, если принимать во внимание полный стек, одним из примеров является <code>ActionView::Helpers::AssetTagHelper#image_tag</code>:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# image_tag("icon.png")
#   # =&gt; &lt;img alt="Icon" src="/assets/icon.png" /&gt;

</pre>
</div>
<p>Хотя поведением по умолчанию для <code>#image_tag</code> является всегда возвращать <code>/images/icon.png</code>, учитывая полный стек Rails (включая Asset Pipeline), мы можем увидеть вышеуказанный результат.</p>
<p>Мы беспокоимся только о поведении при использовании полного стека Rails по умолчанию.</p>
<p>В этом случае мы хотим документировать поведение этого <em>фреймворка</em>, а не просто этого отдельного метода.</p>
<p>Если у вас есть вопрос, как команда Rails управляет определенными API, не стесняйтесь открыть тикет или послать патч в .</p>
<div class="banner">

   
   



</div>
</div>