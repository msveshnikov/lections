# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 6. Объявление классов</h2></center>

<p> 

</p>
<p> 

</p>
<p>Центральная тема лекции — объявление классов, поскольку
любое Java-приложение является набором классов.

</p>
<p>Первый рассматриваемый вопрос — система разграничения
доступа в Java. Описывается, зачем вообще нужно управление доступом в
ОО-языке программирования и как оно осуществляется в Java. Затем подробно
рассма­тривается структура объявления заголовка класса и его тела, которое
состо­ит из элементов (полей и методов), конструкторов и инициализаторов. До­полнительно
описывается сигнатура метода main, с которого
начинается ра­бота Java-приложения, правила передачи параметров различных
типов в ме­тоды, перегруженные методы.

</p>
<p> 

</p>
<p>Ключевые слова: метод, тело метода, заголовок метода, сигнатура, инизиализатор,
перегруженные методы.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Объявление классов является центральной темой курса, поскольку любая
программа на Java — это набор
классов. Поскольку типы являются ключевой конструкцией языка, их структура
довольно сложна, имеет много тонкостей. Поэтому данная тема разделена на две
лекции.

</p>
<p>Эта лекция начинается с продолжения темы прошлой лекции — име­на и
доступ к именованным элементам языка. Необходимо рассмотреть механизм
разграничения доступа в Java, как он устроен, для чего применя­ется. Затем будут описаны ключевые
правила объявления классов.

</p>
<p>Следующая лекция подробно рассматривает особенности объектной модели Java. Вводится понятие
интерфейса. Уточняются правила объяв­ления классов и описывается объявление
интерфейса.

</p>
<p> 

</p>
<p>Модификаторы доступа

</p>
<p>Во многих языках существуют права доступа, которые ограничивают возможность
использования, например, переменной в классе. Например, легко представить два
крайних вида прав доступа: это public, когда поле доступно из любой точки программы, и private, когда поле может
исполь­зоваться только внутри того класса, в котором оно объявлено.

</p>
<p>Однако прежде, чем переходить к подробному рассмотрению этих и Других
модификаторов доступа, необходимо внимательно разобраться, зачем они вообще
нужны.








</p>
<p>Предназначение
модификаторов доступа

</p>
<p>Очень часто права доступа расцениваются как некий элемент безо­пасности
кода: мол, необходимо защищать классы от "неправильного"
использования. Например, если в классе Human (человек) есть поле age (возраст человека), то
какой-нибудь программист намеренно
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<center><h2>Лекция 6. Объявление классов</h2></center>

<p> 

</p>
<p> 

</p>
<p>Центральная тема лекции — объявление классов, поскольку
любое Java-приложение является набором классов.

</p>
<p>Первый рассматриваемый вопрос — система разграничения
доступа в Java. Описывается, зачем вообще нужно управление доступом в
ОО-языке программирования и как оно осуществляется в Java. Затем подробно
рассма­тривается структура объявления заголовка класса и его тела, которое
состо­ит из элементов (полей и методов), конструкторов и инициализаторов. До­полнительно
описывается сигнатура метода main, с которого
начинается ра­бота Java-приложения, правила передачи параметров различных
типов в ме­тоды, перегруженные методы.

</p>
<p> 

</p>
<p>Ключевые слова: метод, тело метода, заголовок метода, сигнатура, инизиализатор,
перегруженные методы.

</p>
<p> 

</p>
<p>Введение

</p>
<p>Объявление классов является центральной темой курса, поскольку любая
программа на Java — это набор
классов. Поскольку типы являются ключевой конструкцией языка, их структура
довольно сложна, имеет много тонкостей. Поэтому данная тема разделена на две
лекции.

</p>
<p>Эта лекция начинается с продолжения темы прошлой лекции — име­на и
доступ к именованным элементам языка. Необходимо рассмотреть механизм
разграничения доступа в Java, как он устроен, для чего применя­ется. Затем будут описаны ключевые
правила объявления классов.

</p>
<p>Следующая лекция подробно рассматривает особенности объектной модели Java. Вводится понятие
интерфейса. Уточняются правила объяв­ления классов и описывается объявление
интерфейса.

</p>
<p> 

</p>
<p>Модификаторы доступа

</p>
<p>Во многих языках существуют права доступа, которые ограничивают возможность
использования, например, переменной в классе. Например, легко представить два
крайних вида прав доступа: это public, когда поле доступно из любой точки программы, и private, когда поле может
исполь­зоваться только внутри того класса, в котором оно объявлено.

</p>
<p>Однако прежде, чем переходить к подробному рассмотрению этих и Других
модификаторов доступа, необходимо внимательно разобраться, зачем они вообще
нужны.








</p>
<p>Предназначение
модификаторов доступа

</p>
<p>Очень часто права доступа расцениваются как некий элемент безо­пасности
кода: мол, необходимо защищать классы от "неправильного"
использования. Например, если в классе Human (человек) есть поле age (возраст человека), то
какой-нибудь программист намеренно
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>или по не­знанию может присвоить этому полю
отрицательное значение, после чего объект станет работать неправильно, могут
появиться ошибки. Для защи­ты такого поля age необходимо объявить его private.

</p>
<p>Это довольно распространенная точка зрения, однако нужно при­знать, что
она далека от истины. Основным смыслом разграничения прав доступа является
обеспечение неотъемлемого свойства объектной модели - инкапсуляции, то есть
сокрытия реализации. Исправим пример таким образом, чтобы он корректно отражал
предназначение модификаторов доступа. Итак, пусть в классе Human есть поле age целочисленного типа, и
чтобы все желающие могли пользоваться этим полем, оно объявляется public.

</p>
<p> 

</p>
<p>public class Human { public int age;

</p>
<p>}

</p>
<p>Проходит время, и если в группу программистов, работающих над системой,
входят десятки разработчиков, логично предположить, что все, или многие, из них
начнут использовать это поле.

</p>
<p>Может получиться так, что целочисленного типа данных будет уже
недостаточно и захочется сменить тип поля на дробный. Однако если про­сто
изменить int на double, вскоре все разработчики, которые пользовались классом Human и его полем age, обнаружат, что в их коде появились ошиб­ки, потому что поле вдруг стало
дробным, и в строках, подобных этим:

</p>
<p>Human h = getHuman();
int i=h.age; // ошибка!!

</p>
<p>будет возникать ошибка из-за попытки провести неявным образом суже­ние
примитивного типа.

</p>
<p>Получается, что подобное изменение (в общем, небольшое и локаль­ное)
потребует модификации многих и многих классов. Поэтому внесение его окажется
недопустимым, неоправданным с точки зрения количества усилий, которые необходимо
затратить. То есть, объявив один раз поле или метод как public, можно оказаться в
ситуации, когда малейшие изменения

</p>
<p>(имени, типа,
характеристик, правил использования) в дальнейшем станут невозможны.

</p>
<p>Напротив, если бы поле было объявлено как private, а для чтения и изменения
его значения были бы введены дополнительные методы, ситу­ация поменялась бы в
корне:

</p>
<p>public class Human { private
int age;

</p>
<p>// метод, возвращающий значение age public int getAge() { return age;

</p>
<p>}

</p>
<p>// метод, устанавливающий значение age public void setAge(int a) { age=a;

</p>
<p>}

</p>
<p>}

</p>
<p>В этом случае с данным классом могло бы работать множество про­граммистов
и могло быть создано большое количество классов, использу­ющих тип Human, но модификатор private
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>дает гарантию, что никто
на­прямую этим полем не пользуется и изменение его типа было бы совсем
несложной операцией, связанной с изменением только в одном классе.

</p>
<p>Получение величины
возраста выглядело бы следующим образом:

</p>
<p> 

</p>
<p>Human h - getHuman();

</p>
<p>int i=h.getAge(); // обращение через метод

</p>
<p> 

</p>
<p>Рассмотрим, как выглядит
процесс смены типа поля age:

</p>
<p> 

</p>
<p>public class Human {

</p>
<p> 

</p>
<p>// поле получает новый тип double private /*int*/ double age;

</p>
<p> 

</p>
<p>//
старые методы работают с округлением значения public int getAge() {

</p>
<p>return (int)Math.round(age);

</p>
<p>}

</p>
<p>public void setAge(int a) { age=a;

</p>
<p>// добавляются новые методы для работы с типом double
public double getExactAge() { return age;

</p>
<p>}

</p>
<p>public
void setExactAge(double a) { age=a;

</p>
<p>}

</p>
<p>}

</p>
<p>Видно, что старые методы, которые, возможно, уже применяются во многих
местах, остались без изменения. Точнее, остался без изменений их внешний
формат, а внутренняя реализация усложнилась. Но такая пере­мена не потребует
никаких модификаций остальных классов системы. Пример использования

</p>
<p> 

</p>
<p>Human h = getHuman();

</p>
<p>int i=h.getAge(); // корректно

</p>
<p>остается верным, переменная i получает корректное
целое значение. Од­нако изменения вводились для того, чтобы можно было работать
с дроб­ными величинами. Для этого были добавлены новые методы и во всех ме­стах,
где требуется точное значение возраста, необходимо обращаться к ним:

</p>
<p> 

</p>
<p>Human h = getHuman();

</p>
<p>double d=h.getExactAge(); // точное значение возраста

</p>
<p>Итак, в класс была добавлена новая возможность, не потребовавшая никаких
изменений кода.

</p>
<p>За счет чего была достигнута такая гибкость? Необходимо выделить
свойства объекта, которые потребуются будущим пользователям этого класса, и
сделать их доступными (в данном случае, public). Те же элемен­ты
класса, что содержат детали внутренней реализации логики класса, же­лательно
скрывать, чтобы не образовались нежелательные зависимости, которые могут
сдерживать развитие системы.

</p>
<p>Этот пример одновременно иллюстрирует и другое теоретическое правило
написания объектов, а именно: в большинстве случаев доступ к полям лучше
реализовывать через специальные методы (accessors) для чтения (getters) и записи (setters). То есть само поле рассматривается как деталь внутренней реализации.
Действительно, если рассматривать внешний интерфейс объекта как целиком
состоящий из допустимых дей­ствий, то доступными элементами должны быть только
методы, реализу­ющие эти действия
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Один из случаев, в котором такой подход
приносит необходимую гибкость, уже рассмотрен.

</p>
<p>Есть и другие соображения. Например, вернемся к вопросу о кор­ректном
использовании объекта и установки верных значений полей. Как следствие,
правильное разграничение доступа позволяет ввести механиз­мы проверки входных
значений:

</p>
<p>public void setAge(int а) { (if а&gt;=0) { age=a;

</p>
<p>}

</p>
<p>}

</p>
<p>В этом примере поле age никогда не примет некорректное отрица­тельное значение. (Недостатком
приведенного примера является то, что в случае неправильных входных данных они
просто игнорируются, нет ни­каких сообщений, позволяющих узнать, что изменения
поля возраста на самом деле не произошло; для полноценной реализации метода
необхо­димо освоить работу с ошибками в Java.)

</p>
<p>Бывают и более существенные изменения логики класса. Например, данные
можно начать хранить не в полях класса, а в более надежном хра­нилище,
например, файловой системе или базе данных. В этом случае ме-тоды-аксессоры
опять изменят свою реализацию и начнут обращаться к persistent storage (постоянное
хранилище, например, БД) для чтения/запи­си значений. Если доступа к полям
класса не было, а открытыми были только методы для работы с их значениями, то
можно изменить код этих методов, а наружные типы, которые использовали данный
класс, совер­шенно не изменятся, логика их работы останется той же.

</p>
<p>Подведем итоги. Функциональность класса необходимо разделять на открытый
интерфейс, описывающий действия, которые будут использо­вать внешние типы, и на
внутреннюю реализацию, которая применяется только внутри самого класса. Внешний
интерфейс в дальнейшем моди­фицировать невозможно, или очень сложно, для
больших систем, поэто­му его требуется продумывать особенно тщательно. Детали
внутренней ре­ализации могут быть изменены на любом этапе, если они не меняют
логи­ку работы всего класса. Благодаря такому подходу реализуется одна из ба­зовых
характеристик объектной модели — инкапсуляция, и обеспечива­ется важное
преимущество технологии ООП — модульность.

</p>
<p>Таким образом, модификаторы доступа вводятся не для защиты типа °т
внешнего пользователя, а, напротив, для защиты, или избавления, Пользователя от
излишних зависимостей от деталей внутренней реализа­ции. Что же касается
неправильного применения класса,
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>то его создателям нужно стремиться к тому,
чтобы класс был прост в применении, тогда та­ких проблем не возникнет, ведь
программист не станет намеренно писать код, который порождает ошибки з его
программе.

</p>
<p>Конечно, такое разбиение на внешний интерфейс и внутреннюю реа­лизацию
не всегда очевидно, часто условно. Для облегчения задачи техни­ческих
дизайнеров классов в Java введено не два (public и private), а четыре уровня доступа. Рассмотрим их и весь механизм разграничения
доступа в Java более подробно.

</p>
<p> 

</p>
<p>Разграничение
доступа в Java

</p>
<p>Уровень доступа элемента языка является статическим свойством, задается
на уровне кода и всегда проверяется во время компиляции. По­пытка обратиться к
закрытому элементу вызовет ошибку.

</p>
<p>В Java модификаторы доступа указываются для:

</p>
<p>•   
типов (классов и интерфейсов)
объявления верхнего уровня;

</p>
<p>•   
элементов ссылочных типов
(полей, методов, внутренних типов);

</p>
<p>•   
конструкторов классов.

</p>
<p>Как следствие, массив также может быть недоступен в том
случае, если недоступен тип, на основе которого он объявлен. Все четыре уровня доступа
имеют только элементы типов и конст­рукторы. Это:

</p>
<p>•   
public;

</p>
<p>•   
private;

</p>
<p>•   
protected;

</p>
<p>•   
если не указан ни один из
этих трех типов, то уровень доступа оп­ределяется по умолчанию (default).

</p>
<p>Первые два из них уже были рассмотрены. Последний уровень (доступ по умолчанию)
упоминался в прошлой лекции — он допускает обращения из того же пакета, где
объявлен и сам этот класс. По этой причине пакеты в Java являются не просто набором типов, а более структурированной едини­цей,
так как типы внутри одного пакета могут больше взаимодействовать друг с другом,
чем с типами из других пакетов.

</p>
<p>Наконец, protected дает доступ
наследникам класса. Понятно, что наследникам может потребоваться доступ к
некоторым элементам роди­теля, с которыми не приходится иметь дело внешним
классам.

</p>
<p>Однако описанная структура не позволяет упорядочить модифи­каторы
доступа так, чтобы каждый следующий строго расширял преды­дущий. Модификатор protected может быть указан
для наследника из другого пакета, а доступ по умолчанию допускает обращения из
клас­сов-ненаследников, если они находятся в том же пакете. По этой при­чине
возможности protected были расширены
таким образом, что он включает в себя доступ внутри пакета. Итак, модификаторы
доступа упорядочиваются следующим образом (от менее открытых - к более
открытым):

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>private

</p>
<p>(none) default

</p>
<p>protected

</p>
<p>public

</p>
<p>Эта последовательность будет использована далее при изучении де­талей
наследования классов.

</p>
<p>Теперь рассмотрим, какие модификаторы доступа возможны для различных
элементов языка.

</p>
<p>•    Пакеты доступны всегда, поэтому у них нет модификаторов досту­па (можно
сказать, что все они public, то есть любой существующий в системе пакет может использоваться из
любой точки программы).

</p>
<p>•   
Типы (классы и интерфейсы)
верхнего уровня объявления. При их объявлении существует всего две возможности:
указать мо­дификатор public или не указывать
его. Если доступ к типу яв­ляется public, то это означает,
что он доступен из любой точки кода. Если же он не public, то уровень
доступа назначается по умолчанию: тип доступен только внутри того пакета, где
он объявлен.

</p>
<p>•    Массив имеет тот же уровень доступа, что и тип, на основе кото­рого он
объявлен (естественно, все примитивные типы являются полностью доступными).

</p>
<p>•    Элементы и конструкторы объектных типов. Обладают всеми че­тырьмя
возможными значениями уровня доступа. Все элементы интерфейсов являются public.

</p>
<p>Для типов объявления верхнего уровня нет необходимости во всех четырех
уровнях доступа. Private-типы образовывали бы закрытую мини-программу, никто не мог бы их
использовать. Типы, доступные только для наследников, также не были признаны
полезными.

</p>
<p>Разграничения доступа сказываются не только на обращении к эле­ментам
объектных типов или пакетов (через составное имя или прямое обращение), но
также при вызове конструкторов, наследовании, приве­дении типов. Импортировать
недоступные типы запрещается.

</p>
<p>Проверка уровня доступа проводится компилятором. Обратите вни­мание на
следующие примеры:

</p>
<p> 

</p>
<p>public class Wheel { private double radius;

</p>
<p>public double getRadius() { return radius;

</p>
<p>}

</p>
<p>}

</p>
<p>Значение поля radius недоступно снаружи
класса, однако открытый метод getRadius() корректно возвращает его.

</p>
<p>Рассмотрим следующие два модуля компиляции:

</p>
<p> 

</p>
<p>package first;

</p>
<p> 

</p>
<p>// Некоторый класс Parent

</p>
<p>public class Parent {

</p>
<p>}

</p>
<p> 

</p>
<p>package first;

</p>
<p> 

</p>
<p>// Класс Child наследуется от класса Parent, //
но имеет ограничение доступа по умолчанию class Child extends Parent { }

</p>
<p>public class Provider { public Parent getValue() { return
new Child();

</p>
<p>}

</p>
<p>}

</p>
<p>К методу getValue() класса Provider можно обратиться и
из дру­гого пакета, не только из пакета first, поскольку метод
объявлен как public
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Данный метод возвращает экземпляр класса Child, который не­доступен
из других пакетов. Однако следующий вызов является кор­ректным:

</p>
<p> 

</p>
<p>package second;

</p>
<p> 

</p>
<p>import first.*;

</p>
<p> 

</p>
<p>public class Test {

</p>
<p>public static void main(String s[]) { Provider pr = new
Provider(); Parent p = pr.getValue();

</p>
<p>System.out.println(p.getClass().getName()); // (Child)p
- приведет к ошибке компиляции!

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет: first.Child

</p>
<p>То есть на самом деле в классе Test работа идет с экземпляром недо­ступного класса Child, что возможно,
поскольку обращение к нему делается через открытый класс Parent. Попытка же
выполнить явное приведение вы­зовет ошибку. Да, тип объекта "угадан"
верно, но доступ к закрытому типу всегда запрещен.

</p>
<p>Следующий пример:

</p>
<p> 

</p>
<p>public class Point { private intx, у;

</p>
<p>public boolean equals(Object o) { if (o instanceof
Point) { Point p = (Point)o; return p.x==x &amp;&amp; p.y==y;

</p>
<p>}

</p>
<p>return false;

</p>
<p>}

</p>
<p>}

</p>
<p>В этом примере объявляется класс Point с двумя полями, описы­вающими координаты точки. Обратите внимание, что
поля полностью закрыты - private. Далее попытаемся переопределить стандартный метод equals() таким образом,
чтобы для аргументов, являющихся эк­земплярами класса Point, или его
наследников (логика работы опера­тора intsanceof), в случае равенства координат возвращалось истин­ное значение.
Обратите внимание на строку, где делается сравнение координат,- для этого
приходится обращаться к private-полям друго­го объекта!

</p>
<p>Тем не менее, такое действие корректно, поскольку private допускает обращения из любой точки класса, независимо от того, к какому
именно объекту оно производится.

</p>
<p>Другие примеры разграничения доступа в Java будут рассматривать­ся По ходу курса.








</p>
<p>Объявление классов

</p>
<p>Рассмотрим базовые возможности объявления классов. Объявление класса
состоит из заголовка и тела класса.

</p>
<p> 

</p>
<p>Заголовок класса

</p>
<p>Вначале указываются модификаторы класса. Модификаторы досту­па для
класса уже обсуждались. Допустимым является public, либо его от­сутствие
— доступ по умолчанию.

</p>
<p>Класс может быть объявлен как final. В этом случае не
допускается создание наследников такого класса. На своей ветке наследования он
яв­ляется последним. Класс String и классы-обертки,
например, представля­ют собой final-классы.

</p>
<p>После списка модификаторов указывается ключевое слово class, а затем имя
класса — корректный Java-идентификатор. Таким образом, кратчайшим объявлением класса может быть
такой модуль компиляции:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>class А {}

</p>
<p> 

</p>
<p>Фигурные скобки
обозначают тело класса, но о нем позже.

</p>
<p>Указанный идентификатор становится простым именем класса. Полное
составное имя класса строится из полного составного имени па­кета, в котором он
объявлен (если это не безымянный пакет), и простого имени класса, разделенных
точкой. Область видимости класса, где он мо­жет быть доступен по своему
простому имени, — его пакет.

</p>
<p>Далее заголовок может содержать ключевое слово extends, после ко­торого
должно быть указано имя (простое или составное) доступного не-final класса. В этом случае объявляемый класс наследуется от указанного
класса. Если выражение extends не применяется, то
класс наследуется на­прямую от Object. Выражение extends
Object допускается и игнорируется.

</p>
<p>class Parent {} // = class Parent extends Object {}

</p>
<p>final class LastChild extends Parent {}

</p>
<p>// class WrongChild extends LastChild {} // ошибка!!

</p>
<p>Попытка расширить final-класс приведет к
ошибке компиляции. Если в объявлении класса А указано выражение extends В, то класс А называют прямым наследником класса В.

</p>
<p>Класс А считается
наследником класса В, если: • А является прямым наследником В;

</p>
<p>188

</p>
<p>•  существует класс С,
который является наследником В, а А явля­ется наследником С (это правило
применяется рекурсивно).

</p>
<p>Таким образом можно проследить цепочки наследования на несколь­ко
уровней вверх.

</p>
<p>Если компилятор обнаруживает, что класс является своим наследни­ком, возникает
ошибка компиляции:

</p>
<p>// пример вызовет
ошибку компиляции class A extends В {} class В extends С {}

</p>
<p>class С extends А {} // ошибка!
Класс А стал своим наследником

</p>
<p> 

</p>
<p>Далее в заголовке может быть указано ключевое слово implements, за которым должно следовать перечисление через запятую имен (простых или
составных, повторения запрещены) доступных интерфейсов:

</p>
<p> 

</p>
<p>public final class String implements Serializable,
Comparable {}

</p>
<p> 

</p>
<p>В этом случае говорят, что класс реализует перечисленные интерфей­сы.
Как видно из примера, класс может реализовывать любое количество ин­терфейсов.
Если выражение implements отсутствует, то класс действительно не реализует никаких интерфейсов,
здесь значений по умолчанию нет.

</p>
<p>Далее следует пара фигурных скобок, которые могут быть пустыми или
содержать описание тела класса.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Тело класса

</p>
<p>Тело класса может
содержать объявление элементов (members) класса:

</p>
<p>•   
полей;

</p>
<p>•   
методов;

</p>
<p>•   внутренних типов (классов и интерфейсов); и остальных допустимых
конструкций:

</p>
<p>•   
конструкторов;

</p>
<p>•   
инициализаторов;

</p>
<p>•   
статических
инициализаторов.

</p>
<p>Элементы класса имеют имена и передаются по наследству, не-эле-менты -
нет. Для элементов простые имена указываются при объявлении, составные
формируются из имени класса, или имени переменной объект­ного типа, и простого
имени элемента. Областью видимости элементов является все объявление тела
класса. Допускается применение любого из всех четырех модификаторов
доступа. Напоминаем, что соглашения по именованию классов и их элементов
обсуждались в прошлой лекции.








</p>
<p>He-элементы не
обладают именами, а потому не могут быть вызва­ны явно. Их вызывает сама
виртуальная машина. Например, конструктор вызывается при создании объекта. По
той же причине не-элементы не об­ладают модификаторами доступа.

</p>
<p>Элементами класса являются элементы, описанные в объявлении тела класса
и переданные по наследству от класса-родителя (кроме Object — единственного класса, не имеющего родителя) и всех реализуемых ин­терфейсов
при условии достаточного уровня доступа. Таким образом, ес­ли класс содержит
элементы с доступом по умолчанию, то его наследни­ки из разных пакетов будут
обладать разным набором элементов. Классы из того же пакета могут пользоваться
полным набором элементов, а из других пакетов — только protected и public, private-элементы по наслед­ству
не передаются.

</p>
<p>Поля и методы могут иметь одинаковые имена, поскольку обращение к полям
всегда записывается без скобок, а к методам — всегда со скобками.

</p>
<p>Рассмотрим все эти
конструкции более подробно.

</p>
<p> 

</p>
<p>Объявление полей

</p>
<p>Объявление полей начинается с перечисления модификаторов. Воз­можно
применение любого из трех модификаторов доступа, либо никакого вовсе, что
означает уровень доступа по умолчанию.

</p>
<p>Поле может быть объявлено как final, это означает, что
оно инициали­зируется один раз и больше не будет менять своего значения.
Простейший способ работы с final-переменными - инициализация при объявлении:

</p>
<p> 

</p>
<p>final double Pl=3.1415;

</p>
<p> 

</p>
<p>Также допускается инициализация final-полей в конце
каждого кон­структора класса.

</p>
<p>Не обязательно использовать для инициализации константы компи­ляции, возможно
обращение к различным функциям, например:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>final long
creationTime=System.currentTimeMillis();

</p>
<p> 

</p>
<p>Данное поле будет хранить время создания объекта. Существует еше два
специальных модификатора - transient и volatile. Они будут рассмот­рены
в соответствующих лекциях.

</p>
<p>После списка модификаторов указывается тип поля. Затем идет пе­речисление
одного или нескольких имен полей с возможными инициали­заторами:

</p>
<p>int а;

</p>
<p>int b=3, c=b+5, d;

</p>
<p>Point p, p1=null,
p2=new Point();

</p>
<p>Повторяющиеся имена полей запрещены. Указанный
идентифика­тор при объявлении становится простым именем поля. Составное имя
формируется из имени класса или имени переменной объектного типа, и простого
имени поля. Областью видимости поля является все объявление тела класса.

</p>
<p>Запрещается использовать поле в инициализации других полей до его
объявления.

</p>
<p>int у=х; intx=3;

</p>
<p> 

</p>
<p>Однако в остальном поля
можно объявлять и ниже их использования:

</p>
<p> 

</p>
<p>class Point {

</p>
<p>int getX() {return x;}

</p>
<p> 

</p>
<p>int y=getX();
intx=3;

</p>
<p>public static void main (String s[]) { Point p=new Point();
System.out.println(p.x+", "+p.y);

</p>
<p>}

</p>
<p>}

</p>
<p>Результатом будет: 3,0

</p>
<p>Данный пример корректен, но для понимания его результата необ­ходимо
вспомнить, что все поля класса имеют значение по умолчанию:

</p>
<p>•   
для числовых полей
примитивных типов - 0;

</p>
<p>•   
для булевского типа - false;

</p>
<p>•   
для ссылочных — null.

</p>
<p>Таким образом, при инициализации переменной у был использован Результат
метода getX(), который вернул значение по умолчанию пере­менной х, то есть 0. Затем переменная х получила значение 3.

</p>
<p>Объявление методов

</p>
<p>Объявление метода состоит из заголовка и тела метода. Заголовок состоит
из:

</p>
<p>•   
модификаторов (доступа в
том числе);

</p>
<p>•   
типа возвращаемого
значения или ключевого слова void;

</p>
<p>•   
имени метода;

</p>
<p>•   
списка аргументов в
круглых скобках (аргументов может не быть);

</p>
<p>•   
специального throws-выражения.

</p>
<p>Заголовок начинается с перечисления модификаторов. Для методов доступен
любой из трех возможных модификаторов доступа. Также допу­скается использование
доступа по умолчанию.

</p>
<p>Кроме того, существует модификатор final, который говорит о
том. что такой метод нельзя переопределять в наследниках. Можно считать, что
все методы final-класса, а также все private-методы любого класса, яв­ляются final.

</p>
<p>Также поддерживается модификатор native. Метод,
объявленный с таким модификатором, не имеет реализации на Java. Он должен быть на­писан
на другом языке (C/C++, Fortran и т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>д.) и добавлен
в систему в ви­де загружаемой динамической библиотеки (например, DLL для Windows). Существует специальная спецификация JNI (Java Native Interface), опи­сывающая правила создания и использования native-методов.

</p>
<p>Такая возможность для Java необходима,
поскольку многие компа­нии имеют обширные программные библиотеки, написанные на
более старых языках. Их было бы очень трудоемко и неэффективно переписы­вать на
Java, поэтому необходима возможность подключать их в таком ви­де, в каком
они есть. Безусловно, при этом Java-приложения теряют целый ряд своих преимуществ, таких, как
переносимость, безопасность и другие. Поэтому применять JNI следует только в случае крайней необходимости.

</p>
<p>Эта спецификация накладывает требования на имена процедур во внешних
библиотеках (она составляет их из имени пакета, класса и само­го native-метода), а
поскольку библиотеки менять, как правило, очень неудобно, часто пишут
специальные библиотеки-"обертки", к которым обращаются Java-классы через JNI, а они сами
обращаются к целевым модулям.

</p>
<p>Наконец, существует еще один специальный модификатор synchro­nized, который будет
рассмотрен в лекции, описывающей потоки выпол­нения.

</p>
<p>После перечисления модификаторов указывается имя (простое или составное)
типа возвращаемого значения; это может быть как примитив­ный, так и объектный
тип. Если метод не возвращает никакого значения, указывается ключевое слово void.

</p>
<p>Затем определяется имя метода. Указанный идентификатор при объ­явлении
становится простым именем метода. Составное имя формирует­ся из имени класса
или имени переменной объектного типа и простого имени метода. Областью
видимости метода является все объявление тела класса.

</p>
<p>Аргументы метода перечисляются через запятую. Для каждого ука­зывается
сначала тип, затем имя параметра. В отличие от объявления пе­ременной здесь
запрещается указывать два имени для одного типа:

</p>
<p>// void cale (double х, у); - ошибка! void cale (double х, double у);

</p>
<p>Если аргументы отсутствуют, указываются пустые круглые скобки.
Одноименные параметры запрещены. Создание локальных переменных в методе, с
именами, совпадающими с именами параметров, запрещено. Для каждого аргумента
можно ввести ключевое слово final перед указани­ем
его типа. В этом случае такой параметр не может менять своего значе­ния в теле
метода (то есть участвовать в операции присвоения в качестве левого операнда).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>public void process(int х, final double у) { x=x*x+Math.sqrt(x);

</p>
<p>// y=Math.sin(x); - так писать нельзя, т.к. у - final!

</p>
<p>}

</p>
<p>О том, как происходит изменение значений аргументов
метода, рас­сказано в конце этой лекции.

</p>
<p>Важным понятием является сигнатура (signature) метода. Сигнатура определяется именем метода и его аргументами
(количеством, типом, по­рядком следования). Если для полей запрещается
совпадение имен, то Для методов в классе запрещено создание двух методов с
одинаковыми сигнатурами.

</p>
<p>Например,

</p>
<p> 

</p>
<p>class Point { void get(){} void get(int x) {}
void get(int x, double y) {} void get(double x, int y) {}

</p>
<p>}








</p>
<p>Такой класс объявлен
корректно. Следующие пары методов в одном классе друг с другом несовместимы:

</p>
<p> 

</p>
<p>void get() {} int
get(){}

</p>
<p>void get(intx) {} void get(inty) {}

</p>
<p>public intget()
{} private int get() {}

</p>
<p>В первом случае методы отличаются типом возвращаемого значения, которое,
однако, не входит в определение сигнатуры. Стало быть, это два метода с
одинаковыми сигнатурами и они не могут одновременно^ по­явиться в объявлении
тела класса. Можно составить пример, который со­здал бы неразрешимую проблему
для компилятора, если бы был допустим:

</p>
<p>// пример вызовет ошибку
компиляции class Test { int get(){ return 5;

</p>
<p>}

</p>
<p>Point get() {

</p>
<p>return new Point(3,5);

</p>
<p>}

</p>
<p>void print(intx) {

</p>
<p>System.out.println("it's int! "+x);

</p>
<p>}

</p>
<p>void print(Point p) {

</p>
<p>System.out.printlnfit's Point! "+p.x+",
"+p.y);

</p>
<p>}

</p>
<p>public static void main (String s[]) { Testt
= newTest(); t.print(t.get()); // Двусмысленность!

</p>
<p>}

</p>
<p>}

</p>
<p>В классе определена
запрещенная пара методов get() с одинаковыми сигнатурами и различными возвращаемыми значениями.
Обратимся к выделенной строке в методе main, где возникает
конфликтная ситуация, с которой компилятор не может справиться. Определены два
метода print() (у них разные аргументы, а значит, и сигнатуры, то есть это допус­тимые
методы), и чтобы разобраться, какой из них будет вызван, нужно знать точный тип
возвращаемого значения метода get(), что невозможно.

</p>
<p>На основе этого примера можно понять, как составлено понятие сигнатуры.
Действительно, при вызове указывается имя метода и пере­числяются его
аргументы, причем компилятор всегда может определить их тип. Как раз эти
понятия и составляют сигнатуру, и требование ее уни­кальности позволяет
компилятору всегда однозначно определить, какой метод будет вызван.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Точно так же в предыдущем примере вторая пара методов различает­ся
именем аргументов, которые также не входят в определение сигнатуры и не
позволяют определить, какой из двух методов должен быть вызван.

</p>
<p>Аналогично, третья пара различается лишь модификаторами доступа, что
также недопустимо.

</p>
<p>Наконец, завершает заголовок метода throws-выражение. Оно при­меняется
для корректной работы с ошибками в Java и будет подробно рас­смотрено в соответствующей лекции.

</p>
<p>Пример объявления метода:

</p>
<p> 

</p>
<p>public final java.awt.Point createPositivePoint(int x, int y) throws
NlegalArgumentException

</p>
<p>{

</p>
<p>return (x&gt;0 &amp;&amp; y&gt;0) ? new Point(x, y) : null;

</p>
<p>}

</p>
<p>Далее, после заголовка метода следует тело метода. Оно может быть пустым
и тогда записывается одним символом "точка с запятой". Native-методы всегда
имеют только пустое тело, поскольку настоящая реализа­ция написана на другом
языке.

</p>
<p>Обычные же методы имеют непустое тело, которое описывается в фигурных
скобках, что показано в многочисленных примерах в этой и Других лекциях. Если
текущая реализация метода не выполняет никаких Действий, тело все равно должно
описываться парой пустых фигурных скобок:

</p>
<p> 

</p>
<p>Public void empty() {}

</p>
<p> 

</p>
<p>Если в заголовке метода указан тип возвращаемого значения, а не ^°'d, то в теле метода
обязательно должно встречаться return-выражение.

</p>
<p>Ри этом компилятор проводит анализ структуры метода, чтобы гаранти-13»








</p>
<p>Однако логика работы конструкторов имеет и некоторые важные особенности.
Поскольку при их вызове осуществляется создание и ини­циализация объекта,
становится понятно, что такой процесс не может происходить без обращения к
конструкторам всех родительских классов. Поэтому вводится обязательное правило
- первой строкой в конструкто­ре должно быть обращение к родительскому классу,
которое записывает­ся с помощью ключевого слова super.

</p>
<p> 

</p>
<p>public class Parent { private int x, у;

</p>
<p> 

</p>
<p>public Parent() { x=y=0;

</p>
<p>}

</p>
<p>public Parent(int newx, int newy) { x=newx;
y=newy;

</p>
<p>}

</p>
<p>}

</p>
<p>public class Child extends Parent { public
Child() { super();

</p>
<p>}

</p>
<p>public Child(int newx, int newy) { super(newx,
newy);

</p>
<p>}

</p>
<p>}

</p>
<p>Как видно, обращение к родительскому конструктору записывает­ся с
помощью super, за которым идет перечисление аргументов
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Этот набор определяет, какой
из родительских конструкторов будет исполь­зован. В приведенном примере в
каждом классе имеется по два конст­руктора и каждый конструктор в наследнике
обращается к аналогично­му в родителе (это довольно распространенный, но,
конечно, не обяза­тельный способ).

</p>
<p>Проследим мысленно весь алгоритм создания объекта. Он начина­ется при
исполнении выражения с ключевым словом new, за которым
следует имя класса, от которого будет порождаться объект, и набор аргу­ментов
для его конструктора. По этому набору определяется, какой именно конструктор
будет использован, и происходит его вызов. Первая строка его тела содержит
вызов родительского конструктора. В свою оче­редь, первая строка тела
конструктора родителя будет содержать вызов к его родителю, и так далее.
Восхождение по дереву наследования закан­чивается, очевидно, на классе Object, у которого есть
единственный конструктор без параметров. Его тело пустое (записывается парой
пус­тых фигурных скобок), однако можно считать, что именно в этот момент JVM порождает объект и далее начинается процесс его инициализации.
Выполнение начинает обратный путь вниз по дереву наследования. У са­мого
верхнего родителя, прямого наследника от Object, происходит про­должение
исполнения конструктора со второй строки. Когда он будет полностью выполнен,
необходимо перейти к следующему родителю, на один уровень наследования вниз, и
завершить выполнение его конструк­тора, и так далее. Наконец, можно будет
вернуться к конструктору ис­ходного класса, который был вызван с помощью new, и также продол­жить
его выполнение со второй строки. По его завершении объект счи­тается полностью
созданным, исполнение выражения new будет закон­чено, а
в качестве результата будет возвращена ссылка на порожденный объект.

</p>
<p>Проиллюстрируем этот алгоритм следующим примером:

</p>
<p> 

</p>
<p>public class GraphicElement {

</p>
<p>private int x, у; // положение на экране

</p>
<p> 

</p>
<p>public GraphicElement(int пх, int пу) {

</p>
<p>super(); // обращение к конструктору родителя Object

</p>
<p>System, out. printlnC'GraphicElement");

</p>
<p>x=nx;

</p>
<p>y=nx;

</p>
<p>}

</p>
<p>}

</p>
<p>public class Square extends GraphicElement { private
int side;

</p>
<p>public Square(int x, int y, int nside) { super(x, y);

</p>
<p>System.out.println("Square"); side=nside;

</p>
<p>}

</p>
<p>}

</p>
<p>public class SmallColorSquare extends Square { private
Color color;

</p>
<p>public SmallColorSquare(int x, int y, Color c) { super(x,
y, 5);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>System.out.println("SmallColorSquare");
color=c;

</p>
<p>}

</p>
<p>}

</p>
<p>После выполнения выражения создания объекта на экране
появится следующее:

</p>
<p>GraphicElement Square

</p>
<p>SmallColorSquare

</p>
<p> 

</p>
<p>Выражение super может стоять только
на первой строке конструкто­ра. Часто можно увидеть конструкторы вообще без
такого выражения. В этом случае компилятор первой строкой по умолчанию
добавляет вызов родительского конструктора без параметров (super()). Если у
родитель­ского класса такого конструктора нет, выражение super обязательно должно быть записано явно (и именно на первой строке),
поскольку не­обходима передача входных параметров.

</p>
<p>Напомним, что, во-первых, конструкторы не имеют имени и их нельзя
вызвать явно, только через выражение создания объекта. Кроме того, конструкторы
не передаются по наследству. То есть, если в роди­тельском классе объявлено
пять разных полезных конструкторов и требу­ется, чтобы класс-наследник имел
аналогичный набор, необходимо все их описать заново.

</p>
<p>Класс обязательно должен иметь конструктор, иначе невозможно порождать
объекты ни от него, ни от его наследников. Поэтому если в классе не объявлен ни
один конструктор, компилятор добавляет один по умолчанию. Это public-конструктор без
параметров и с телом, опи­санным парой пустых фигурных скобок. Из этого
следует, что такое возможно только для классов, у родителей которых объявлен
конструк­тор без параметров, иначе возникнет ошибка компиляции. Обратите
внимание, что если затем в такой класс добавляется конструктор (не важно, с
параметрами или без), то конструктор по умолчанию больше не вставляется:

</p>
<p>/*

</p>
<p>* Этот класс имеет один конструктор.

</p>
<p>7

</p>
<p>public class One {

</p>
<p>// Будет создан
конструктор по умолчанию // Родительский класс Object имеет // конструктор без параметров.

</p>
<p> 

</p>
<p> 

</p>
<p>/*

</p>
<p>* Этот класс имеет один конструктор.

</p>
<p>7

</p>
<p>public class Two {

</p>
<p>// Единственный конструктор класса Second. // Выражение new Second() ошибочно! public Second(int х) { }

</p>
<p> 

</p>
<p>/*

</p>
<p>* Этот класс имеет два конструктора.

</p>
<p>7

</p>
<p>public class Three extends Two { public Three() {

</p>
<p>super(1 ); // выражение super требуется

</p>
<p>}

</p>
<p>public Three(int x) {

</p>
<p>super(x); // выражение super требуется

</p>
<p>}

</p>
<p>}

</p>
<p>Если класс имеет более одного конструктора, допускается в первой строке
некоторых из них указывать не super, a this - выражение, вызыва­ющее
другой конструктор этого же класса.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Рассмотрим следующий пример:

</p>
<p>public class Vector { private int vx, vy; protected
double length;

</p>
<p> 

</p>
<p>public Vector(int x, int y) {

</p>
<p>super(); vx=x;

</p>
<p>vy=y;

</p>
<p>length=Math.sqrt(vx*vx+vy*vy);

</p>
<p>}

</p>
<p>public Vector(int x1, int y1, int x2, int
y2) { super(); vx=x2-x1; vy=y2-y1;

</p>
<p>len gth=Math. sq
rt ( vx* vx+vy* vy ) ;

</p>
<p>}

</p>
<p>}

</p>
<p>Видно, что оба конструктора совершают практически идентичные действия,
поэтому можно применить более компактный вид записи:

</p>
<p>public class Vector { private int vx, vy; protected
double length;

</p>
<p>public Vector(int x, int y) { super(); vx=x;
vy=y;

</p>
<p>length=Math.sqrt(vx*vx+vy*vy);

</p>
<p>}

</p>
<p>public Vector(int x1, int y1, int x2, int
y2) { this(x2-x1, y2-y1 );

</p>
<p>}

</p>
<p>}

</p>
<p>Большим достоинством такого метода записи является то, что уда­лось
избежать дублирования идентичного кода. Например, если процесс инициализации
объектов этого класса удлинится на один шаг (скажем, до­бавится проверка длины
на ноль), то такое изменение надо будет внести только в первый конструктор.
Такой подход помогает избежать случай­ных ошибок, так как исчезает
необходимость тиражировать изменения в нескольких местах.

</p>
<p>Разумеется, такое обращение к конструкторам своего класса не должно
приводить к зацикливаниям, иначе будет выдана ошибка компи­дяции. Цепочка this должна в итоге приводить к super, который должен
присутствовать (явно или неявно) хотя бы в одном из конструкторов. По­сле того,
как отработают конструкторы всех родительских классов, будет продолжено
выполнение каждого конструктора, вовлеченного в процесс создания объекта.

</p>
<p>public class Test { public Test() {

</p>
<p>System.out.println("Test()");

</p>
<p>}

</p>
<p>public Test(int x) { thisO;

</p>
<p>System. out. pri ntln("Test( int x)" ) ;

</p>
<p>}

</p>
<p>}

</p>
<p>После выполнения выражения
new Test(0) на консоли появится:

</p>
<p>Test() Test(intx)

</p>
<p>В заключение рассмотрим применение модификаторов доступа для
конструкторов. Может вызвать удивление возможность объявлять конст­рукторы как private. Ведь они нужны для генерации объектов, а к таким конструкторам ни у кого
не будет доступа. Однако в ряде случаев моди­фикатор private может быть полезен.
Например:

</p>
<p>•    private-конструктор может
содержать инициализирующие дейст­вия, а остальные конструкторы будут использовать
его с помощью this, причем прямое обращение к этому конструктору по каким-то причинам
нежелательно;

</p>
<p>•   
запрет на создание
объектов этого класса, например, невозможно создать экземпляр класса Math;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•    реализация специального шаблона проектирования из ООП Singleton, для работы которого требуется контролировать создание объектов, что
невозможно в случае наличия не-private конструк­торов.

</p>
<p> 

</p>
<p>Инициализаторы

</p>
<p>Наконец, последней допустимой конструкцией в теле класса являет-Ся
объявление инициализаторов. Записываются объектные инициализа-ТоРЫ очень просто —
внутри фигурных скобок.

</p>
<p>public class Test { private int x, у, z;

</p>
<p>// инициализатор объекта {

</p>
<p>х=3; if (х&gt;0) У=4;

</p>
<p>z=Math.max(x, у);

</p>
<p>}

</p>
<p>}

</p>
<p>Инициализаторы не имеют имен, исполняются при создании объек­тов, не
могут быть вызваны явно, не передаются по наследству (хотя, ко­нечно,
инициализаторы в родительском классе продолжают исполняться при создании
объекта класса-наследника).

</p>
<p>Было указано уже три вида инициализирующего кода в классах - кон­структоры,
инициализаторы переменных, а теперь добавились объектные инициализаторы.
Необходимо разобраться, в какой последовательности что выполняется, в том числе
при наследовании. При создании экземпля­ра класса вызванный конструктор
выполняется следующим образом:

</p>
<p>•    если первой строкой идет обращение к конструктору родительско­го класса
(явное или добавленное компилятором по умолчанию), то этот конструктор
исполняется;

</p>
<p>•   
в случае успешного
исполнения вызываются все инициализаторы полей и объекта в том порядке, в каком
они объявлены в теле класса;

</p>
<p>•   
если первой строкой идет
обращение к другому конструктору этого же класса, то он вызывается. Повторное
выполнение ини­циализаторов не производится.

</p>
<p>Второй пункт имеет ряд важных следствий. Во-первых, из него сле­дует,
что в инициализаторах нельзя использовать переменные класса, если их объявление
записано позже.

</p>
<p>Во-вторых, теперь можно сформулировать наиболее гибкий подход к
инициализации final-полей. Главное требование — чтобы такие поля были проинициализированы
ровно один раз. Это можно обеспечить в следую­щих случаях:

</p>
<p>•   
если инициализировать поле
при объявлении;

</p>
<p>•    если инициализировать поле только один раз в инициализаторе объекта (он
должен быть записан после объявления поля);

</p>
<p>•    если инициализировать поле только один раз в каждом конструк­торе, в
первой строке которого стоит явное или неявное обраще­ние к конструктору
родителя. Конструктор, в первой строке ко­торого стоит this, не может
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>и не
должен инициализировать final-поле, так как цепочка this-вызовов приведет к конструктору с super, в котором эта инициализация
обязательно присутствует. Для иллюстрации порядка исполнения инициализирующих
конст­рукций рассмотрим следующий пример:

</p>
<p>public class Test { {

</p>
<p>System.out.println("initializer");

</p>
<p>}

</p>
<p>intx, y=getY(); final int z; {

</p>
<p>System.out.println("initializer2");

</p>
<p>}

</p>
<p>private int getY() {

</p>
<p>System.out.println("getY() "+z); return z;

</p>
<p>}

</p>
<p>public Test() {

</p>
<p>System.out.println("Test()"); z=3;

</p>
<p>}

</p>
<p>public Test(int x) { this();

</p>
<p>System.out.println("Test(int)");

</p>
<p>// z=4; - нельзя! final-поле уже было инициализировано

</p>
<p>}

</p>
<p>}

</p>
<p>После выполнения выражения newTest() на консоли
появится:

</p>
<p> 

</p>
<p>initializer getY() 0 initialized Test()

</p>
<p>Обратите внимание, что для инициализации поля у вызывается метод 9efY(), который возвращает
значение final-поля z, которое еще не было инициализировано. Поэтому в итоге поле у получит
значение по умолча-10110 0, а затем поле z получит постоянное
значение 3, которое никогда У*6 не изменится.








</p>
<p>После выполнения выражения new Test(3) на консоли появится:

</p>
<p>initializer
getY() О initialized Test() Test(int)

</p>
<p> 

</p>
<p>Дополнительные свойства
классов

</p>
<p>Рассмотрим в этом разделе некоторые особенности работы с класса­ми в Java. Обсуждение данного
вопроса будет продолжено в специальной лекции, посвященной объектной модели в Java.

</p>
<p> 

</p>
<p>Метод
main

</p>
<p>Итак, виртуальная машина реализуется приложением операционной системы и
запускается по обычным правилам. Программа, написанная на Java, является набором
классов. Понятно, что требуется некая входная точка, с которой должно
начинаться выполнение приложения.

</p>
<p>Такой входной точкой, по аналогии с языками C/C++, является ме­тод main(). Пример его
объявления:

</p>
<p> 

</p>
<p>public static void main(String[] args) {}

</p>
<p> 

</p>
<p>Модификатор static в этой лекции не
рассматривался и будет изучен позже. Он позволяет вызвать метод main(), не создавая
объектов. Метод не возвращает никакого значения, хотя в С есть возможность
указать код воз­врата из программы. В Java для этой цели существует метод System.exit(), который
закрывает виртуальную машину и имеет аргумент типа int.

</p>
<p>Аргументом метода main() является массив строк. Он заполняется до­полнительными параметрами,
которые были указаны при вызове метода.

</p>
<p> 

</p>
<p>package test.first;

</p>
<p> 

</p>
<p>public
class Test {

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>public static void main(String[] args) { for
(int i=0; i&lt;args.length; i++) { System.out.print(args[i]+" ");

</p>
<p>}

</p>
<p>System.out.println();

</p>
<p>}

</p>
<p>Для вызова программы виртуальной машине передается в качест­ве параметра
имя класса, у которого объявлен метод main(). Посколь­ку это
имя класса, а не имя файла, то не должно указываться никако­го расширения (.class или .java) и расположение класса записывает­ся через точку (разделитель имен
пакетов), а не с помощью файлово­го разделителя. Компилятору же, напротив,
передается имя и путь к файлу.

</p>
<p>Если приведенный выше модуль компиляции сохранен в файле Test.java, который лежит в каталоге test\first,
то вызов компилятора запи­сывается
следующим образом:

</p>
<p>javac test\first\Test.java

</p>
<p>А вызов виртуальной
машины:

</p>
<p>java test.first.Test

</p>
<p>Чтобы проиллюстрировать работу с параметрами, изменим строку запуска
приложения:

</p>
<p>java test.first.Test Hello, World!

</p>
<p>Результатом работы
программы будет:

</p>
<p>Hello, World!

</p>
<p> 

</p>
<p> 

</p>
<p>Параметры
методов

</p>
<p>Для лучшего понимания работы с параметрами методов в Java необ­ходимо рассмотреть несколько вопросов.

</p>
<p>Как передаются аргументы в методы — по значению или по ссылке? Сточки
зрения программы вопрос формулируется, например, следующим образом. Пусть есть
переменная и она в качестве аргумента передается в некоторый метод. Могут ли
произойти какие-либо изменения с этой пе­ременной после завершения работы
метода?

</p>
<p> 

</p>
<p>int х=3;

</p>
<p>process(x);

</p>
<p>print(x);

</p>
<p> 

</p>
<p>Предположим, используемый
метод объявлен следующим образом:

</p>
<p>public void process(int x) { x=5;

</p>
<p>}

</p>
<p>Какое значение появится на консоли после выполнения примера? Чтобы
ответить на этот вопрос, необходимо вспомнить, как переменные разных типов
хранят свои значения в Java.

</p>
<p>Напомним, что примитивные переменные являются истинными хранилищами
своих значений и изменение значения одной переменной никогда не скажется на
значении другой. Параметр метода process(), хоть и имеет
такое же имя х, на самом деле является полноценным храни­лищем целочисленной
величины. А потому присвоение ему значения 5 не скажется на внешних переменных.
То есть результатом примера будет 3 и аргументы примитивного типа передаются в методы по значению.
Единственный способ изменить такую переменную в результате работы метода —
возвращать нужные величины из метода и использовать их при присвоении:

</p>
<p> 

</p>
<p>public int
double(int х) { return х+х;

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>public void test() { int x=3; x=double(x);

</p>
<p>}

</p>
<p> 

</p>
<p>Перейдем к ссылочным типам.

</p>
<p> 

</p>
<p>public void process(Point p) { p.x=3;

</p>
<p>}

</p>
<p>public void test() {

</p>
<p>Point p = new Point(1,2);

</p>
<p>process(p);

</p>
<p>print(p.x);

</p>
<p>}

</p>
<p>Ссылочная переменная хранит ссылку на объект, находящийся в па­мяти
виртуальной машины. Поэтому аргумент метода processo будет иметь в качестве значения ту же самую ссылку и, стало
быть, ссылаться на тот же самый объект. Изменения состояния объекта,
осуществленные с по-мошью одной ссылки, всегда видны при обращении к этому
объекту с по­мощью другой. Поэтому результатом примера будет значение 3.
Объектные значения
передаются в Java по ссылке.

</p>
<p>Однако если изменять не состояние объекта, а саму ссылку, то ре­зультат
будет другим:

</p>
<p>public void process(Point p) { p = new Point(4,5);

</p>
<p>}

</p>
<p>public void test() {

</p>
<p>Point p = new Point(1,2);

</p>
<p>process(p);

</p>
<p>print(p.x);

</p>
<p>}

</p>
<p>В этом примере аргумент метода processo после присвоения начи­нает ссылаться на другой объект, нежели исходная
переменная p, а зна­чит, результатом примера станет значение 1. Можно сказать, что
ссылоч­ные величины передаются по значению, но значением является именно ссылка
на объект.

</p>
<p>Теперь можно уточнить, что означает возможность объявлять пара­метры
методов и конструкторов как final. Поскольку изменения значений параметров (но не объектов, на которые они
ссылаются) никак не сказы­ваются на переменных вне метода, модификатор final говорит лишь о том,
что значение этого параметра не будет меняться на протяжении работы метода.
Разумеется, для аргумента final Point
р выражение р.х=5 является допустимым (запрещается p=new Point(5, 5)).

</p>
<p> 

</p>
<p> 

</p>
<p>Перегруженные методы

</p>
<p>Перегруженными (overloading) методами называются методы одного класса с одинаковыми именами.
Сигнатуры у них должны быть различ­ными и различие может быть только в наборе
аргументов.

</p>
<p>Если в классе параметры перегруженных методов заметно различа­йся:
например, у одного метода один параметр, у другого - два, то для ava это совершенно независимые методы и совпадение их имен может служить
только для повышения наглядности работы класса. Каждый вы-3ов&gt; в
зависимости от количества параметров, однозначно адресуется то-МУ
Или иному методу.








</p>
<p>Однако если количество параметров одинаковое, а типы их различа­ются
незначительно, при вызове может сложиться двойственная ситуа­ция, когда
несколько перегруженных методов одинаково хорошо подхо­дят для использования.
Например, если объявлены типы Parent и Child, где Child расширяет Parent, то для следующих двух методов:

</p>
<p>void process(Parent р, Child с) {} void
process(Child с, Parent p) {}

</p>
<p>можно сказать, что они допустимы, их сигнатуры различаются. Однако при
вызове

</p>
<p> 

</p>
<p>process(new
Child(), new Child());

</p>
<p> 

</p>
<p>обнаруживается, что оба метода одинаково годятся для использования.
Другой пример, методы:

</p>
<p> 

</p>
<p>process(Object о) {} process(String s) {}

</p>
<p> 

</p>
<p>и примеры вызовов:

</p>
<p> 

</p>
<p>process(new
Objecto); process(new Point(4,5)); process("abc");

</p>
<p>Очевидно, что для первых двух вызовов подходит только первый метод, и
именно он будет вызван. Для последнего же вызова подходят оба перегру­женных
метода, однако класс String является более
"специфичным", или узким, чем класс Object. Действительно,
значения типа String можно пе­редавать в
качестве аргументов типа Object, обратное же неверно. Компи­лятор попытается отыскать наиболее
специфичный метод, подходящий для указанных параметров, и вызовет именно его.
Поэтому при третьем вы­зове будет использован второй метод.

</p>
<p>Однако для предыдущего примера такой подход не дает однозначного ответа.
Оба метода одинаково специфичны для указанного вызова, поэто­му возникнет
ошибка компиляции. Необходимо, используя явное приведе­ние, указать
компилятору, какой метод следует применить:

</p>
<p>process((Parent)(new Child()), new Child()); // или

</p>
<p>process(new
Child(),(Parent)(new Child()));

</p>
<p>Это верно и в случае использования значения null:

</p>
<p> 

</p>
<p>process((Parent)null,
null); // или

</p>
<p>process(null,(Parent)null);

</p>
<p> 

</p>
<p> 

</p>
<p>Заключение

</p>
<p>В этой лекции началось рассмотрение ключевой конструкции языка Java — объявление класса.

</p>
<p>Первая тема посвящена средствам разграничения доступа. Главный вопрос —
для чего этот механизм вводится в практически каждом совре­менном языке
высокого уровня. Необходимо понимать, что он предназ­начен не для обеспечения
"безопасности" или "защиты" объекта от неких неправильных
действий. Самая важная задача — разделить внешний ин­терфейс класса и детали
его реализации с тем, чтобы в дальнейшем вос­пользоваться такими преимуществами
ООП, как инкапсуляция и модуль­ность.

</p>
<p>Затем были рассмотрены все четыре модификатора доступа, а также
возможность их применения для различных элементов языка. Проверка уровня
доступа выполняется уже во время компиляции и запрещает лишь явное
использование типов. Например, с ними все же можно работать че­рез их более
открытых наследников.

</p>
<p>Объявление класса состоит из заголовка и тела класса. Формат заго­ловка
был подробно описан. Для изучения тела класса необходимо вспомнить понятие
элементов (members) класса. Ими могут быть поля, методы и внутренние типы. Для методов
важным понятием является сиг­натура.

</p>
<p>Кроме того, в теле класса объявляются конструкторы и инициализа­торы.
Поскольку они не являются элементами, к ним нельзя обратиться явно, они
вызываются самой виртуальной машиной. Также конструкторы и
инициализаторы не передаются по наследству.

</p>
<p>Дополнительно был рассмотрен метод main, который
вызывается пРи старте виртуальной машины. Далее описываются
тонкости, возника­ющие при передаче параметров, и связанный с этим вопрос о
перегру-Женных методах.

</p>
<p>Классы Java мы продолжим рассматривать в следующих лекциях.








</p>
<p>Вариант
1

</p>
<p> 

</p>
<p> 

</p>
<p>1.  
Какие модификаторы позволяют обращаться к элементу из классов того же пакета?

</p>
<p>О     public

</p>
<p>О      protected

</p>
<p>|~1   по умолчанию

</p>
<p>fjj    private

</p>
<p> 

</p>
<p> 

</p>
<p>2.   Корректен ли следующий код? public class Test { private int id; public Test(int i) {

</p>
<p>id=i;

</p>
<p>}

</p>
<p>public static boolean test(Test t, int id) { return
t.id==id;

</p>
<p>}

</p>
<p>}

</p>
<p>&#9633;   да, так
как метод test является элементом
класса Test

</p>
<p>П   нет, так как поле id объявлено как private, а значит
недоступно извне объекта

</p>
<p> 

</p>
<p> 

</p>
<p>3.   Как записывается заголовок метода
main?

</p>
<p>G   public
int main()

</p>
<p>П   public int main(String[] args)

</p>
<p>G   public static void main(String[] args)

</p>
<p>П   public void main()








</p>
<p> 








</p>
<p>Вариант 2

</p>
<p> 

</p>
<p> 

</p>
<p>1.      Если
в классе заводится новый элемент и пока нет
никаких факторов, позволяющих выбрать тот или иной
модификатор доступа, какой модификатор следует
использовать?

</p>
<p>О   public

</p>
<p>П   protected

</p>
<p>Г~!   по умолчанию

</p>
<p>&#9633;       private

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Если
метод использует переменную класса, должна ли
она быть объявлена выше объявления метода?

</p>
<p>&#9633;       
да

</p>
<p>&#9633;       
нет

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Может
ли измениться содержимое переменной типа
String, если
передать ее в качестве аргумента при вызове
метода?

</p>
<p>&#9633;       
да

</p>
<p>&#9633;       
нет

</p>
<p>Вариант 3

</p>
<p> 

</p>
<p> 

</p>
<p>1.      Пусть
класс User описывает пользователя системы.
В качестве имени используется его e-mail адрес,
который всем известен, а пароль, конечно, не должен
быть доступен никому, кроме самого пользователя.
Корректна ли следующая реализация?

</p>
<p> 

</p>
<p>public class User {

</p>
<p>public String login; // e-mail private String password;
// пароль

</p>
<p>}

</p>
<p>П   код
некорректен

</p>
<p>f~|   код корректен с точки зрения
компилятора, но, скорее всего, неверен с позиций ООП; лучше ограничить доступ к
переменной login с помощью метода getLogin(),
чтобы значение переменной не могло измениться непредсказуемо

</p>
<p>П   код
полностью верен

</p>
<p> 

</p>
<p> 

</p>
<p>2.      Может
ли класс не иметь ни одного конструктора?

</p>
<p>&#9633;  
да О   нет

</p>
<p> 

</p>
<p> 

</p>
<p>3.      Какие заголовки методов
являются корректными с точки
зрения компилятора?

</p>
<p>П     public void getX()

</p>
<p>П     static private int setY()

</p>
<p>П     public void static main (String s[])

</p>
<p>П     String toString(final int x)








</p>
<p>
</p>
<center> 
</center>
    </div>