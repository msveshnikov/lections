<div id="content" class="list-post">
			
																														
						
	
<div id="post-1393" class="post-1393 post type-post status-publish format-standard hentry category-lektsii-po-s category-prepodavatel post clearfix">
	
						
													   
			
	<div class="post-content">
				
		
												<h1 class="post-title"></h1>
				 
			
		    
		
					<p>Первыми формами модульности, появившимися в языках программирования, были <strong>процедуры</strong> и <strong>функции</strong>. Поскольку функции в математике использовались издавна, то появление их в языках программирования было совершенно естественным. Уже с первых шагов программирования  процедуры и функции позволяли решать одну из важнейших задач, стоящих перед программистами, – задачу повторного использования программного кода. Один раз написанную функцию можно многократно вызывать в программе с разными значениями параметров, передаваемых функции в момент вызова. Встроенные в язык функции позволяли существенно расширить возможности языка программирования. Важным шагом в автоматизации программирования было появление библиотек процедур и функций, доступных из языка программирования.<span id="more-1393"></span></p>
<p><strong>Процедуры и функции – методы класса</strong></p>
<p>Долгое время процедуры и функции играли не только функциональную, но и архитектурную роль. Весьма популярным при построении программных систем был метод функциональной декомпозиции «сверху вниз», и сегодня еще играющий важную роль. Вся программа рассматривалась, как некоторая главная функция. В процессе проектирования программы происходила декомпозиция главной функции на подфункции, решающие частные задачи. Этот процесс декомпозиции продолжался до тех пор, пока не приходили к достаточно простым функциям, реализация которых не требовала декомпозиции и могла быть описана базовыми конструкциями языка программирования.</p>
<p>с появлением ООП архитектурная роль функциональных модулей отошла на второй план. Для ОО-языков, к которым относится и язык C#, роль архитектурного модуля играет <strong>класс</strong>. Программная система строится из модулей, роль которых играют классы, но каждый из этих модулей имеют содержательную начинку, задавая некоторую абстракцию данных.</p>
<p>Процедуры и функции связываются теперь с классом, они обеспечивают требуемую функциональность класса и называются методами класса. Поскольку класс в объектно-ориентированном программировании рассматривается как некоторый тип данных, то главную роль в классе начинают играть его данные – поля класса, задающие свойства объектов класса. Методы класса  «служат» данным, занимаясь их обработкой. Помните, в C# процедуры и функции существуют только как методы некоторого класса, они не существуют вне класса.</p>
<p>В данном контексте понятие класс распространяется и на все его частные случаи – структуры, интерфейсы, делегаты.</p>
<p>В языке C# нет специальных ключевых слов – method, procedure, function, но сами понятия конечно же присутствуют. Синтаксис объявления метода позволяет однозначно определить, чем является метод – процедурой или функцией.</p>
<p>Прежнюю роль библиотек процедур и функций теперь играют <strong>библиотеки классов</strong>. Библиотека классов FCL, доступная в языке C#, существенно расширяет возможности языка. Знание классов этой библиотеки, методов этих классов совершенно необходимо для практического программирования на C#, использование всей его мощи.</p>
<p><strong>Процедуры и функции. Отличия</strong></p>
<p>Функция отличается от процедуры двумя особенностями:</p>
<ul>
<li>всегда вычисляет некоторое значение, возвращаемое в качестве результата функции;</li>
<li>вызывается в выражениях.</li>
</ul>
<p>Процедура C# имеет свои особенности:</p>
<ul>
<li>возвращает формальный результат void, указывающий на <strong>отсутствие результата, </strong>возвращаемого при вызове процедуры;</li>
<li>вызов процедуры является оператором языка;</li>
<li>имеет <strong>входные и выходные аргументы</strong>, причем выходных аргументов – ее результатов – может быть достаточно много.</li>
</ul>
<p>Хорошо известно, что одновременное существование в языке процедур и функций в каком-то смысле избыточно. Добавив еще один выходной аргумент любую функцию можно записать в виде процедуры. Справедливо и обратное. Если допускать функции с побочным эффектом, то любую процедуру можно записать в виде функции. В языке С – дедушке C# – так и сделали, оставив только функции. Однако значительно удобнее иметь обе формы реализации метода –  процедуры и функции. Обычно метод предпочитают реализовать в виде функции тогда, когда он имеет один выходной аргумент, рассматриваемый как результат вычисления значения функции. Возможность вызова функций в выражениях также влияет на выбор в пользу реализации метода в виде функции. В других случаях метод реализуют в виде процедуры.</p>
<p><strong>Описание методов (процедур и функций). Синтаксис</strong></p>
<p>Синтаксически в описании метода различают две части – <strong>описание</strong> <strong>заголовка</strong> и <strong>описание тела</strong> метода:</p>
<p>заголовок_метода</p>
<p>тело_метода</p>
<p>Рассмотрим синтаксис заголовка метода:</p>
[атрибуты][модификаторы]{void| тип_результата_функции} имя_метода([список_формальных_аргументов])
<p>Имя метода и список формальных аргументов составляют <strong>сигнатуру метода</strong>. Заметьте, в сигнатуру не входят имена формальных аргументов, здесь важны типы аргументов. В сигнатуру не входит и тип возвращаемого результата.</p>
<p>Квадратные скобки (метасимволы синтаксической формулы) показывают, что атрибуты и модификаторы могут быть опущены при описании метода. Подробное их рассмотрение будет дано в лекциях, посвященных описанию классов. Сейчас же упомяну только об одном из модификаторов – модификаторе доступа. У него четыре возможных значения, из которых пока рассмотрим только два – public и private. Модификатор public показывает, что <strong>метод</strong> <strong>открыт</strong> и доступен для вызова клиентами и потомками класса. Модификатор private говорит, что метод предназначен для внутреннего использования в классе и доступен для вызова только в теле методов самого класса. Заметьте, если  модификатор доступа опущен, то по умолчанию предполагается, что он имеет значение private и метод является <strong>закрытым </strong>для клиентов и потомков класса.</p>
<p>Обязательным при описании заголовка является указание типа результата, имени метода и круглых скобок, наличие которых необходимо и в том случае, если сам список формальных аргументов отсутствует. Формально тип результата метода указывается всегда, но значение void однозначно определяет, что метод реализуется процедурой. Тип результата, отличный от void, указывает на функцию. Вот несколько простейших примеров описания методов:</p>
<p>void A() {…};</p>
<p>int B(){…);</p>
<p>public void C(){…};</p>
<p>Методы A и B являются закрытыми, а метод С – открыт. Методы A и С реализованы процедурами, а метод B – функцией, возвращающей целое значение.</p>
<p><strong>Список формальных аргументов</strong></p>
<p>Как уже отмечалось, список формальных аргументов метода может быть пустым и это довольно типичная ситуация для методов класса. Список может содержать фиксированное число аргументов, разделяемых символом запятой.</p>
<p>Рассмотрим теперь синтаксис объявления одного формального аргумента:</p>
[ref|out|params]тип_аргумента имя_аргумента
<p>Обязательным является указание типа и имени аргумента. Заметьте, никаких ограничений на тип аргумента не накладывается. Он может быть любым скалярным типом, массивом, классом, структурой, интерфейсом, перечислением, функциональным типом.</p>
<p>Несмотря на фиксированное число формальных аргументов, есть возможность при вызове метода передавать ему <strong>произвольное число фактических аргументов</strong>. Для реализации этой возможности в списке формальных аргументов необходимо задать ключевое слово params. Оно может появляться в объявлении лишь для последнего аргумента списка, объявляемого как массив произвольного типа. При вызове метода этому формальному аргументу соответствует произвольное число фактических аргументов.</p>
<p>Содержательно, все аргументы метода разделяются на три группы: <strong>входные, выходные и обновляемые</strong>. Аргументы первой группы передают информацию методу, их значения в теле метода только читаются. Аргументы второй группы представляют собой результаты метода, они получают значения в ходе работы метода. Аргументы третьей группы выполняют обе функции. Их значения используются в ходе вычислений и обновляются в результате работы метода. Выходные аргументы всегда должны сопровождаться ключевым словом out, обновляемые – ref. Что же касается входных аргументов, то, как правило, они задаются без ключевого слова, хотя иногда их полезно объявлять с параметром ref, о чем подробнее скажу чуть позже. Заметьте, если аргумент объявлен как выходной с ключевым словом out, то в теле метода обязательно должен присутствовать оператор присваивания, задающий значение этому аргументу. В противном случае возникает ошибка еще на этапе компиляции.</p>
<p>Для иллюстрации давайте рассмотрим группу методов класса Testing из проекта ProcAndFun, сопровождающего эту лекцию:</p>
<p>/// &lt;summary&gt;</p>
<p>/// Группа перегруженных методов Cube()</p>
<p>/// первый аргумент — результат</p>
<p>/// представляет сумму кубов</p>
<p>/// произвольного числа оставшихся аргументов</p>
<p>/// Аргументы могут быть разного типа.</p>
<p>/// &lt;/summary&gt;</p>
<p>void Cube(out long p2, int p1)</p>
<p>{</p>
<p>p2 = (long)Math.Pow(p1, 3);</p>
<p>Console.WriteLine(«Метод A-1″);</p>
<p>}</p>
<p>void Cube(out long p2, params int[] p)</p>
<p>{</p>
<p>p2 = 0; for (int i = 0; i &lt; p.Length; i++)</p>
<p>p2 += (long)Math.Pow(p[i], 3);</p>
<p>Console.WriteLine(«Метод A-2″);</p>
<p>}</p>
<p>void Cube(out double p2, double p1)</p>
<p>{</p>
<p>p2 = Math.Pow(p1, 3);</p>
<p>Console.WriteLine(«Метод A-3″);</p>
<p>}</p>
<p>void Cube(out double p2, params double[] p)</p>
<p>{</p>
<p>p2 = 0; for (int i = 0; i &lt; p.Length; i++)</p>
<p>p2 += Math.Pow(p[i], 3);</p>
<p>Console.WriteLine(«Метод A-4″);</p>
<p>}</p>
<p>/// &lt;summary&gt;</p>
<p>/// Функция с побочным эффектом</p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;param name=»a»&gt;Увеличивается на 1&lt;/param&gt;</p>
<p>/// &lt;returns&gt;значение a на входе&lt;/returns&gt;</p>
<p>int F(ref int a)</p>
<p>{</p>
<p>return (a++);</p>
<p>}</p>
<p>Четыре перегруженных метода с именем Cube и метод F будут использоваться при объяснении перегрузки и побочного эффекта. Сейчас проанализируем только их заголовки. Все методы закрыты, поскольку объявлены без модификатора доступа. Перегруженные методы с именем Cube являются процедурами, метод F – функцией. Все четыре перегруженных метода имеют разную сигнатуру. Хотя имена и число аргументов у всех методов одинаковы, но типы и ключевые слова, предшествующие аргументам, различны. Первый аргумент у всех четырех перегруженных методов является выходным и сопровождается ключевым словом out, в теле метода этому аргументу присваивается значение. Аргумент функции F является обновляемым, он снабжен ключевым словом ref,  в теле функции используется его значение для получения результата функции, но и само значение аргумента изменяется в теле функции. Два метода из группы перегруженных методов используют ключевое слово params для своего последнего аргумента. Позже мы увидим, что при вызове этих методов этому аргументу будет соответствовать несколько фактических аргументов, число которых может быть произвольным.</p>
<p><strong>Тело метода</strong></p>
<p>Синтаксически тело метода является <strong>блоком</strong>, представляющим последовательность операторов и описаний переменных, заключенную в фигурные скобки. Если речь идет о теле функции, то в блоке должен быть хотя бы один оператор, возвращающий значение функции в форме return &lt;выражение&gt;.</p>
<p>Переменные, описанные в блоке, считаются локализованными в этом блоке. В записи операторов блока участвуют имена локальных переменных блока, имена полей класса и имена аргументов метода.</p>
<p>Знание семантики описаний и операторов достаточно для понимания семантики блока. Необходимые уточнения будут даны чуть позже.</p>
<p><strong>Вызов метода. Синтаксис</strong></p>
<p>Как уже отмечалось, метод может вызываться в выражениях или быть вызван как оператор тела блока. В качестве оператора может использоваться любой метод – как процедура, так и функция. Конечно, функцию разумно вызывать как оператор только, если она обладает побочным эффектом. В последнем случае она вызывается ради своего побочного эффекта, а возвращаемое значение никак не используется. Любое выражение с побочным эффектом может выступать в роли оператора, классическим примером является оператор x++;.</p>
<p>Если же попытаться вызвать процедуру в выражении, то это приведет к ошибке еще на этапе компиляции. Возвращаемое процедурой значение void не совместимо с выражениями. Так что  в выражениях могут быть вызваны только функции.</p>
<p>Сам <strong>вызов метода</strong>, независимо от того, процедура это или функция, имеет один и тот же синтаксис:</p>
<p>имя_метода([список_фактических_аргументов])</p>
<p>Если это оператор, то вызов завершается точкой с запятой.</p>
<p>Формальный аргумент, задаваемый при описании метода, синтаксически является  идентификатором – именем аргумента. Фактический аргумент – представляет собой «выражение», значительно более сложную синтаксическую конструкцию. Вот точный синтаксис фактического аргумента:</p>
[ref|out]выражение
<p><strong>О соответствии списков формальных и фактических аргументов</strong></p>
<p>Между списком формальных и списком фактических аргументов должно выполняться определенное соответствие по числу, порядку следования, типу и статусу аргументов. Если в первом списке n формальных аргументов, то фактических аргументов должно быть не меньше n (соответствие по числу). Каждому i-му формальному аргументу (для всех i от 1 до n-1) ставится в соответствие i-й фактический аргумент. Последнему формальному аргументу при условии, что он объявлен с ключевым словом params, ставятся в соответствие все оставшиеся фактические аргументы (соответствие по порядку). Если формальный аргумент объявлен с ключевым словом ref или out, то фактический аргумент должен сопровождаться таким же ключевым словом в точке вызова (соответствие по статусу).</p>
<p>Появление ключевых слов при вызове методов – это особенность языка C#, отличающая его от большинства других языков. Такой синтаксис следует приветствовать, поскольку он направлен на повышение надежности программной системы, напоминания программисту о том, что данный фактический аргумент является выходным и значение его наверняка изменится после вызова метода. Однако из-за непривычности синтаксиса при вызове методов эти слова часто забывают писать, что приводит к появлению синтаксических ошибок.</p>
<p>Если T – тип формального аргумента, то выражение, задающее фактический аргумент, должно быть согласовано по типу с типом T. Это означает, что вычисленный  тип выражения совпадает c типом T или допускает неявное преобразование к типу T, или является потомком типа T (соответствие по типу).</p>
<p>Если формальный аргумент является выходным – объявлен с ключевым словом ref или out, то соответствующий фактический аргумент не может быть сложным выражением, поскольку используется в левой части оператора присваивания, так что он должен быть именем, которому можно присвоить значение.</p>
<p><strong>Вызов метода. Семантика</strong></p>
<p>Что происходит в момент вызова метода? Выполнение начинается с вычисления фактических аргументов, которые, как мы знаем, являются выражениями. Вычисление этих выражений может приводить в свою очередь к вызову других методов. Так что первый этап может быть довольно сложным и требовать больших временных затрат. В чисто функциональном программировании все вычисление по программе сводится к вызову одной функции, фактические аргументы которой содержат вызовы функций, фактические аргументы которых содержат вызовы функций, и так далее и так далее. И на языке C# можно организовать вычисления подобным образом.</p>
<p>Для простоты понимания семантики вызова можно полагать, что в точке вызова создается блок, соответствующий телу метода (реально все происходит значительно эффективнее). В этом блоке происходит замена имен формальных аргументов фактическими аргументами. Для выходных (ref и out) аргументов, для которых фактические аргументы также являются именами, эта замена или передача аргументов происходит <strong>по ссылке</strong>, означая замену формального аргумента ссылкой на реально существующий объект, заданный фактическим аргументом. Чуть более сложную семантику имеет <strong>вызов по значению</strong>, применяемый к формальным аргументам, объявленным без ключевых слов ref и out. При вычислении выражений, заданных такими фактическими аргументами, их значения присваиваются специально создаваемым временным переменным, локализованным в теле исполняемого блока. Имена этих локализованных переменных и подставляются вместо имен формальных аргументов. Понятно, что тип локализованных переменных определяется типом соответствующего формального аргумента.</p>
<p>Заметьте, семантика замены формальных аргументов фактическими эквивалентна семантике присваивания, подробно рассмотренной в предыдущих главах.</p>
<p>Каково следствие семантики вызова по значению? Если вы забыли указать ключевое слово ref или out для аргумента, фактически являющегося выходным, то к нему будет применяться вызов по значению. Даже если в теле метода происходит изменение значения этого аргумента, то оно действует только на время выполнения тела метода. Как только метод заканчивает свою работу (завершается блок) все локальные переменные (в том числе созданные для замены формальных аргументов) оканчивают свое существование, так что изменения не затронут фактических аргументов, и они сохранят свое значение, бывшее у них до вызова. Отсюда вывод: все выходные аргументы значимых типов, значения которых предполагается изменить в процессе работы, должны иметь ключевое слово ref или out.</p>
<p>Говоря о семантике вызова по ссылке и по значению, следует сделать важное уточнение. В объектном программировании, каковым является и программирование на C#, основную роль играют ссылочные типы – мы работаем с классами и объектами. Когда методу передается объект ссылочного типа, то все поля этого объекта могут в методе меняться самым беззастенчивым образом. И это несмотря на то, что объект формально не является выходным, не имеет ключевых слов ref или out, использует семантику вызова по значению. Сама ссылка на объект при этом, как и положено, остается неизменной, но состояние объекта, его поля могут полностью обновиться. Такая ситуация типична и представляет один из основных способов изменения состояния объектов. Именно поэтому ref или out не столь часто появляются при описании аргументов метода.</p>
<p><strong>Что нужно знать о методах?</strong></p>
<p>Знания формального синтаксиса и семантики недостаточно, чтобы эффективно работать с методами. Рассмотрим сейчас несколько важных вопросов, касающихся различных сторон работы с методами класса.</p>
<p><strong>Почему у методов мало аргументов?</strong></p>
<p>Методы класса имеют значительно меньше аргументов, чем процедуры и функции в классическом процедурном стиле программирования, когда не используется концепция классов. За счет чего происходит уменьшение числа аргументов у методов? Ведь аргументы играют важную роль – они передают информацию методу, нужную ему для работы, и возвращают информацию – результаты работы метода – программе, вызвавшей метод.</p>
<p>Все дело в том, что методы класса – это не просто набор процедур и функций, это методы, обслуживающие данные класса. Все поля класса доступны любому методу по определению. Нужно четко понимать, что в момент выполнения программной системы работа идет с объектами – экземплярами класса. Из полей соответствующего объекта – цели вызова – извлекается информация, нужная методу в процессе работы, а работа метода чаще всего сводится к обновлению значений полей этого объекта. Поэтому понятно, что методу не нужно через входные аргументы передавать информацию, содержащуюся в полях. Если в результате работы метода обновляется значение некоторого поля, то, опять-таки не нужен никакой выходной аргумент.</p>
<p><strong>Поля класса или функции без аргументов?</strong></p>
<p>Поля хранят информацию о состоянии объектов класса. Состояние объекта динамически изменяется в ходе вычислений – обновляются значения полей. Часто возникающая дилемма при проектировании класса: что лучше – создать ли поле, хранящее информацию, или создать функцию без аргументов, вычисляющую значение этого поля всякий раз, когда это значение понадобится. Решение дилеммы – это вечный для программистов выбор между памятью и временем, Если предпочесть поле, то это приводит к дополнительным расходам памяти. Они могут быть значительными, когда создается большое число объектов, ведь поле должен иметь каждый объект. Если предпочесть функцию, то это потребует временных затрат на вычисление значения, они могут быть значительными, если функция вызывается многократно, а ее вычисление требует значительно больших затрат в сравнении с выбором текущего значения поля.</p>
<p>Если бы синтаксис описания метода допускал отсутствие скобок у функции (метода), в случае, когда список аргументов отсутствует, то клиент класса мог бы и не знать, обращается он к полю или к методу. Такой синтаксис принят, например, в языке Eiffel. Преимущество такого подхода в том, что изменение реализации никак не сказывается на клиентах класса. В языке C# это не так. Когда мы хотим получить длину строки, то пишем s.Length, точно зная, что Length – это поле, а не метод класса string. Если бы по каким-либо причинам разработчики класса string решили изменить реализацию и заменить поле Length соответствующей функцией, то ее вызов имел бы вид s.Length().</p>
<p><strong>Пример: Две версии класса Account</strong></p>
<p>Продемонстрируем рассмотренные выше вопросы на примере проектирования классов Account и Account1, описывающих такую абстракцию данных, как банковский счет. Определим на этих данных две основные операции – занесение денег на счет и снятие денег. В первом варианте – классе Account – будем активно использовать поля класса. Помимо двух основных полей credit и debit, хранящих приход и расход счета, введем поле balance, задающее текущее состояние счета и два поля, связанных с последней выполняемой операцией. Поле sum будет хранить сумму денег текущей операции, а поле result – результат выполнения операции. Увеличение числа полей класса приведет, как следствие, к уменьшению числа аргументов у методов класса. Вот описание нашего класса:</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Класс Account определяет банковский счет.</em></p>
<p>/// <em>простейший вариант с возможностью трех операций:</em></p>
<p>/// <em>положить деньги на счет, снять со счета, узнать баланс.</em></p>
<p>/// <em>Вариант</em><em> с</em><em> полями</em></p>
<p>/// &lt;/summary&gt;</p>
<p>public class Account</p>
<p>{</p>
<p><em>//</em><em>закрытые</em><em> поля</em><em> класса</em></p>
<p>int debit=0, credit=0, balance =0;</p>
<p>int sum =0, result=0;</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Зачисление на счет с проверкой</em></p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;param name=»sum»&gt;<em>зачисляемая</em><em> сумма</em>&lt;/param&gt;</p>
<p>public void putMoney(int sum)</p>
<p>{</p>
<p>this.sum = sum;</p>
<p>if (sum &gt;0)</p>
<p>{</p>
<p>credit += sum; balance = credit — debit; result =1;</p>
<p>}</p>
<p>else result = -1;</p>
<p>Mes();</p>
<p>}//<em>putMoney</em></p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Снятие со счета с проверкой</em></p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;param name=»sum»&gt; <em>снимаемая</em><em> сумма</em>&lt;/param&gt;</p>
<p>public void getMoney(int sum)</p>
<p>{</p>
<p>this.sum = sum;</p>
<p>if(sum &lt;= balance)</p>
<p>{</p>
<p>debit += sum; balance = credit — debit; result =2;</p>
<p>}</p>
<p>else result = -2;</p>
<p>Mes();</p>
<p>}//<em>getMoney</em></p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Уведомление о выполнении операции</em></p>
<p>/// &lt;/summary&gt;</p>
<p>void Mes()</p>
<p>{</p>
<p>switch (result)</p>
<p>{</p>
<p>case 1:</p>
<p>Console.WriteLine(«Операция зачисления денег прошла успешно!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance);</p>
<p>break;</p>
<p>case 2:</p>
<p>Console.WriteLine(«Операция снятия денег прошла успешно!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance);</p>
<p>break;</p>
<p>case -1:</p>
<p>Console.WriteLine(«Операция зачисления денег не выполнена!»);</p>
<p>Console.WriteLine(«Сумма должна быть больше нуля!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance);</p>
<p>break;</p>
<p>case -2:</p>
<p>Console.WriteLine(«Операция снятия денег не выполнена!»);</p>
<p>Console.WriteLine(«Сумма должна быть не больше баланса!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance);</p>
<p>break;</p>
<p>default:</p>
<p>Console.WriteLine(«Неизвестная операция!»);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}//<em>Account</em></p>
<p>Как можно видеть, только у методов getMoney и putMoney имеется один входной аргумент. Это тот аргумент, который нужен по сути дела, поскольку только клиент может решить какую сумму он хочет снять или положить на счет. Других аргументов у методов класса нет, вся информация передается через поля класса. Уменьшение числа аргументов приводит к повышению эффективности работы с методами, так как исчезают затраты на передачу фактических аргументов. Но за все надо платить. В данном случае усложняются сами операции работы со вкладом, поскольку нужно в момент выполнения операции обновлять значения многих полей класса. Закрытый метод Mes вызывается после выполнения каждой операции, сообщая о том, как прошла операция и информируя клиента о текущем состоянии его баланса.</p>
<p>А теперь спроектируем аналогичный класс Account1, отличающийся только тем, что у него будет меньше полей. Вместо поля balance  в классе появится соответствующая функция с этим же именем, вместо полей sum и result появятся аргументы у методов, обеспечивающие необходимую передачу информации. Вот как выглядит этот класс:</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Класс Account1 определяет банковский счет. </em></p>
<p>/// <em>Вариант с аргументами и функциями</em></p>
<p>/// &lt;/summary&gt;</p>
<p>public class Account1</p>
<p>{</p>
<p><em>//</em><em>закрытые</em><em> поля</em><em> класса</em></p>
<p>int debit=0, credit=0;</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Зачисление на счет с проверкой</em></p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;param name=»sum»&gt;<em>зачисляемая</em><em> сумма</em>&lt;/param&gt;</p>
<p>public void putMoney(int sum)</p>
<p>{</p>
<p>int res =1;</p>
<p>if (sum &gt;0)credit += sum;</p>
<p>else res = -1;</p>
<p>Mes(res,sum);</p>
<p>}//<em>putMoney</em></p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Снятие со счета с проверкой</em></p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;param name=»sum»&gt; <em>снимаемая</em><em> сумма</em>&lt;/param&gt;</p>
<p>public void getMoney(int sum)</p>
<p>{</p>
<p>int res=2;</p>
<p>if(sum &lt;= balance())debit += sum;</p>
<p>else res = -2;</p>
<p>balance();</p>
<p>Mes(res, sum);</p>
<p>}//<em>getMoney</em></p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>вычисление</em><em> баланса</em></p>
<p>/// &lt;/summary&gt;</p>
<p>/// &lt;returns&gt;<em>текущий</em><em> баланс</em>&lt;/returns&gt;</p>
<p>int balance()</p>
<p>{</p>
<p>return(credit — debit);</p>
<p>}</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>Уведомление о выполнении операции</em></p>
<p>/// &lt;/summary&gt;</p>
<p>void Mes(int result, int sum)</p>
<p>{</p>
<p>switch (result)</p>
<p>{</p>
<p>case 1:</p>
<p>Console.WriteLine(«Операция зачисления денег прошла успешно!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance());</p>
<p>break;</p>
<p>case 2:</p>
<p>Console.WriteLine(«Операция снятия денег прошла успешно!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance());</p>
<p>break;</p>
<p>case -1:</p>
<p>Console.WriteLine(«Операция зачисления денег не выполнена!»);</p>
<p>Console.WriteLine(«Сумма должна быть больше нуля!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance());</p>
<p>break;</p>
<p>case -2:</p>
<p>Console.WriteLine(«Операция снятия денег не выполнена!»);</p>
<p>Console.WriteLine(«Сумма должна быть не больше баланса!»);</p>
<p>Console.WriteLine(«Cумма={0}, Ваш текущий баланс={1}»,</p>
<p>sum,balance());</p>
<p>break;</p>
<p>default:</p>
<p>Console.WriteLine(«Неизвестная операция!»);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}//<em>Account1</em></p>
<p>Сравнивая этот класс с классом Account, можно видеть, что число полей сократилось с 5 до двух, упростились основные методы getMoney и putMoney. Но в качестве платы у класса появился дополнительный метод balance(),  у метода Mes теперь появились два аргумента. Какой класс лучше? Однозначно сказать нельзя, все зависит от контекста, приоритетов, заданных при создании конкретной системы.</p>
<p>Приведу процедуру класса Testing, тестирующую работу с классами Account и Account1:</p>
<p>public void TestAccounts()</p>
<p>{</p>
<p>Account myAccount = new Account();</p>
<p>myAccount.putMoney(6000);</p>
<p>myAccount.getMoney(2500);</p>
<p>myAccount.putMoney(1000);</p>
<p>myAccount.getMoney(4000);</p>
<p>myAccount.getMoney(1000);</p>
<p><em>//Аналогичная работа с классом </em><em>Account1</em></p>
<p>Console.WriteLine(«Новый класс и новый счет!»);</p>
<p>Account1 myAccount1 = new Account1();</p>
<p>myAccount1.putMoney(6000);</p>
<p>myAccount1.getMoney(2500);</p>
<p>myAccount1.putMoney(1000);</p>
<p>myAccount1.getMoney(4000);</p>
<p>myAccount1.getMoney(1000);</p>
<p>}</p>
<p>На рис. 1_5.1 показаны результаты работы этой процедуры.</p>
<p><em><strong>Рис. 1_5.1. Тестирование классов Account и Account1</strong></em></p>
<p><strong>Функции с побочным эффектом</strong></p>
<p>Функция называется <strong>функцией с побочным эффектом</strong>, если помимо результата, вычисляемого функцией и возвращаемого ей в операторе return, она имеет выходные аргументы с ключевыми словами ref и out. В языках C/C++ функции с побочным эффектом применяются сплошь и рядом. Хороший стиль ОО-программирования не рекомендует использование таких функций. Выражения, использующие функции с побочным эффектом, могут потерять свои прекрасные свойства, присущие им в математике. Если F(a) – функция с побочным эффектом, то a + F(a) может быть не равно F(a) + a, так что теряется коммутативность операции сложения.</p>
<p>Примером такой функции является функция F, приведенная выше. Вот тест, демонстрирующий потерю коммутативности сложения при работе с этой функцией:</p>
<p>/// &lt;summary&gt;</p>
<p>/// <em>тестирование побочного эффекта</em></p>
<p>/// &lt;/summary&gt;</p>
<p>public void TestSideEffect()</p>
<p>{</p>
<p>int a = 0, b=0, c=0;</p>
<p>a = 1; b = a + F(ref a);</p>
<p>a = 1; c = F(ref a) + a;</p>
<p>Console.WriteLine(«a={0}, b={1}, c={2}»,a, b, c);</p>
<p>}</p>
<p> </p>
<p>На рис. 1_5.2 показаны результаты работы этого метода.</p>
<p><strong><em>Рис. 1_5.2. Демонстрация вызова функции с побочным эффектом</em></strong></p>
<p>Обратите внимание на полезность указания ключевого слова ref в момент вызова. Его появление хоть как-то оправдывает некоммутативность сложения.</p>
<p>Напомню, что и выражения с побочным эффектом также приводят к потере коммутативности сложения и умножения. Выражение x + ++x не эквивалентно выражению ++x + x.</p>
<p><strong>Методы. Перегрузка</strong></p>
<p>Должно ли быть уникальным имя метода в классе? Нет, это не требуется. Более того, проектирование методов с одним и тем же именем является частью стиля программирования на С++  и стиля C#. Существование в классе методов с одним и тем же именем называется <strong>перегрузкой</strong>, а сами одноименные методы называются <strong>перегруженными</strong>.</p>
<p>Перегрузка методов полезна, когда требуется решать подобные задачи с разным набором аргументов. Типичный пример – это нахождение площади треугольника. Площадь можно вычислить по трем сторонам, по двум углам и стороне, по двум сторонам и углу между ними и при многих других наборах аргументов. СчиПродемонстрируем рассмотренные выше вопросы на примере проектирования классов Account и Account1, описывающих такую абстракцию данных, как банковский счет. Определим на этих данных две основные операции – занесение денег на счет и снятие денег. В первом варианте – классе Account – будем активно использовать поля класса. Помимо двух основных полей credit и debit, хранящих приход и расход счета, введем поле balance, задающее текущее состояние счета и два поля, связанных с последней выполняемой операцией. Поле sum будет хранить сумму денег текущей операции, а поле result – результат выполнения операции. Увеличение числа полей класса приведет, как следствие, к уменьшению числа аргументов у методов класса. Вот описание нашего класса:тается удобным во всех случаях иметь для метода одно имя, например Square, и всегда, когда нужно вычислить площадь, не задумываясь вызывать метод Square, передавая ему известные в данный момент аргументы.</p>
<p>Пример этот может быть не совсем удачен, поскольку при перегрузке сигнатуры реализаций должны отличаться, а для вычисления площади передаются три аргумента, вообще говоря, одного типа. Так что в этом случае придется использовать искусственные приемы, например, объявляя стороны треугольника типа float, а углы типа – double.</p>
<p>Перегрузка характерна и для знаков операций. В зависимости от типов аргументов один и тот же знак может выполнять фактически разные операции. Классическим примером является знак операции сложения +, который играет роль операции сложения не только для арифметических данных разных типов, но и выполняет конкатенацию строк.</p>
<p>Перегрузка требует уточнения семантики вызова метода. Когда встречается вызов не перегруженного метода, то имя метода в вызове однозначно определяет, тело какого метода должно выполняться в точке вызова. Когда же метод перегружен, то знания имени недостаточно – оно не уникально. Уникальной характеристикой перегруженных методов является их сигнатура. Перегруженные методы, имея одинаковое имя, должны отличаться либо числом аргументов, либо их типами, либо ключевыми словами (заметьте, с точки зрения сигнатуры ключевые слова ref и out не отличаются). Уникальность сигнатуры позволяет вызвать требуемый перегруженный метод.</p>
<p>Выше уже были приведены четыре перегруженных метода с именем Cube, отличающиеся сигнатурой. Методы отличаются типами аргументов и ключевым словом params. Когда вызывается метод Cube с двумя аргументами, то в зависимости от типа будет вызываться реализация, не содержащая аргумент с модификатором params. Когда же число аргументов больше двух, то работает реализация, позволяющая справиться с заранее не фиксированным числом аргументов. Заметьте, эта реализация может прекрасно работать и для случая двух аргументов, но полезно иметь частные случаи для фиксированного набора аргументов. При поиске подходящего перегруженного метода частные случаи получают предпочтение в сравнение с общим случаем.</p>
<p>Насколько полезна перегрузка методов? Здесь нет экономии кода, поскольку каждую реализацию нужно задавать явно, нет выигрыша по времени, скорее требуются определенные затраты на поиск подходящей реализации, который может приводить к конфликтам, к счастью, обнаруживаемым на этапе компиляции. В нашем примере вполне разумно было бы отказаться от перегрузки и иметь четыре метода с разными именами, осознанно вызывая метод, применимый к конкретным данным.</p>
<p>Есть ситуации, где перегрузка полезна, недаром она широко используется при построении библиотеки FCL. Возьмем, например класс Convert, у которого 16 методов с разными именами, зависящими от целевого типа преобразования. Каждый из этих 16 методов перегружен и в свою очередь имеет примерно 16 реализаций в зависимости от типа источника. Согласитесь, что-то неразумное было бы иметь в классе Convert 256 методов вместо 16 перегруженных методов. Впрочем, также неразумно было бы иметь один перегруженный метод, имеющий  256 реализаций. Перегрузка – это инструмент, которым следует пользоваться с осторожностью и обоснованно.</p>
<p>В заключение этой темы, посмотрим, как проводилось тестирование работы с перегруженными методами:</p>
<p>/// &lt;summary&gt;</p>
<p>/// Тестирование перегруженных методов Cube()</p>
<p>/// &lt;/summary&gt;</p>
<p>public void TestLoadMethods()</p>
<p>{</p>
<p>long u = 0; double v = 0;</p>
<p>Cube(out u, 7); Cube(out v, 7.5);</p>
<p>Console.WriteLine(«u= {0}, v= {1}», u, v);</p>
<p>Cube(out v, 7);</p>
<p>Console.WriteLine(«v = {0}», v);</p>
<p>Cube(out u, 7, 11, 13);</p>
<p>Cube(out v, 7.5, Math.Sin(11.5) + Math.Cos(13.5), 15.5);</p>
<p>Console.WriteLine(«u= {0}, v= {1}», u, v);</p>
<p>}//TestLoadMethods</p>
<p>На рис. 1_5.3 показаны результаты этого тестирования.</p>
<p><em><strong>Рис. 1_5.3 Тестирование перегрузки методов</strong></em></p>
<p><strong>Архитектура проекта</strong></p>
<p>Как обычно для поддержки примеров этой главы создано Решение с именем Ch5, содержащее консольный проект ProcAndFun. Помимо автоматически созданного класса Program в проект добавлены три класса – Testing, Account, Account1. В Main процедуре класса Program создается объект testObject класса Testing, вызывающий методы этого класса. Каждый из методов представляет собой тест, позволяющий на примере пояснить излагаемый материал.</p>
<p><strong>Задачи и алгоритмы</strong></p>
<p>Слово, число, рисунок, нота,– величайшие изобретения человечества. Для программистов это информационные объекты, с которыми нужно уметь оперировать.</p>
<p><strong>Числа</strong></p>
<p>Алгоритмы и задачи, рассматриваемые в этой главе, можно использовать на начальном этапе обучения программированию при изучении простейшего вида модульности – процедур и функций.</p>
<p>Многие задачи этой главы являются хорошими примерами при изучении темы классов. У класса двойственная природа – с одной стороны это модуль, с другой – тип данных. Рациональные числа, комплексные числа, простые числа, являются естественными примерами классов, поскольку интуитивно понятно, какой тип данных они задают.</p>
<p><strong>Цифры. Системы счисления</strong></p>
<p>Для записи чисел привычным способом, знакомым еще с первых классов школы, является их запись в позиционной системе счисления. Напомним некоторые факты. В позиционной системе счисления всегда есть цифра 1. Считается, что единицу создал бог, а остальные цифры придуманы человеком. Если так, то наиболее замечательной из человеческих придумок в этой области является введение цифры 0. Цифры позиционной системы упорядочены и каждая получатся из предыдущей прибавлением единицы. Число различных цифр в позиционной системе счисления задает основание системы счисления – p. В привычной для нас десятичной системе счисления p = 10 и цифрами являются знакомые всем символы: 0, 1, 2, … 9. В двоичной системе счисления цифр всего две – 0 и 1 и p = 2. В шестнадцатеричной системе счисления p =16 и привычных символов для обозначения цифр не хватает, так что дополнительно используются большие буквы латинского алфавита: 0, 1, 2, … 9, A, B, C, D, E, F, где A задает 10, а F – цифру 15. Поскольку в любой позиционной системе счисления цифры задают числа от 0 до p-1, то для числа p уже нет специального символа. Как следствие, в любой позиционной системе счисления основание системы счисления представляется числом 10, так что справедливы следующие соотношения: 2<sub>(10) </sub>= 10<sub>(2)</sub>; 16<sub>(10)</sub> = 10<sub>(16)</sub>; p<sub>(10)</sub> = 10<sub>(</sub><sub>p)</sub>. Здесь и в дальнейшем при записи числа при необходимости будем указывать в круглых скобках и систему счисления. В обыденной жизни непреложным фактом является утверждение «2*2=4». Мы понимаем, что столь же верным является утверждение «2*2 = 11» (в троичной системе счисления), или, если хотите «2*2 = 10», – все зависит от системы счисления, в которой ведутся вычисления.</p>
<p>Еще Эйлер занимался записью чисел в различных системах счисления. В его записных книжках можно найти запись числа π в двоичной системе счисления и запись чисел в системе с основанием 24, цифры которой он обозначал буквами латиницы.</p>
<p>Целые числа в позиционных системах счисления записываются в виде последовательности подряд идущих цифр: N=c<sub>n</sub>c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.Эта запись стала настолько естественной, что иногда теряется ее исконный смысл: N = c<sub>n</sub>10<sup>n</sup> + c<sub>n</sub><sub>-1</sub>10<sup>n-1</sup> + … + c<sub>1</sub>10<sup>1</sup> + c<sub>0</sub>10<sup>0</sup>, при котором цифры в записи числа представляют собой коэффициенты разложения числа N по степеням основания, так что вклад каждой цифры в число определяется как самой цифрой, так и ее позицией k и равен c<sub>k</sub>10<sup>k</sup>. По причине того, что вклад каждой цифры в число зависит от ее позиции, система счисления и называется позиционной.</p>
<p>Запись чисел в позиционной системе легко обобщается и на числа с дробной частью:
N=c<sub>n</sub>c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>,d<sub>1</sub>…d<sub>m</sub>, где дробная часть отделяется от целой символом запятой или точки. И в этом случае остается справедливым разложение числа N по степеням основания, в котором цифры дробной части задают коэффициенты для отрицательных степеней основания:
N = c<sub>n</sub>10<sup>n</sup> + c<sub>n</sub><sub>-1</sub>10<sup>n-1</sup> + … + c<sub>1</sub>10<sup>1</sup> + c<sub>0</sub>10<sup>0</sup> + d<sub>1</sub>10<sup>-1</sup> + d<sub>2</sub>10<sup>-2</sup> + … + d<sub>m</sub>10<sup>-</sup><sup>m</sup>           (1)</p>
<p>Понимание соотношения (1) достаточно для решения большинства задач, рассматриваемых в этом разделе, являющихся частными случаями следующей задачи: дано представление числа в системе с основанием p, требуется найти его представление в системе с основанием q. (Пример: найти запись числа N=2BA37,5F<sub>(16)</sub> в троичной системе счисления).</p>
<p>Рассмотрим возможную схему решения подобных задач. Зная основание системы счисления p и цифры в записи числа в этой системе счисления, нетрудно вычислить значение числа N в десятичной системе счисления. Для этого достаточно воспользоваться соотношением (1), в котором значения цифр и основание системы счисления – p задаются в десятичной системе и в ней же ведутся вычисления. Например:</p>
<p>N=2BA37,5F<sub>(16)</sub> = 2*16<sup>4</sup> + 11*16<sup>3</sup> +10*16<sup>2</sup> + 3*16<sup>1</sup> +7 + 5*16<sup>-1</sup> + 15*16<sup>-2</sup></p>
<p>Сложнее, но достаточно просто решается и обратная задача. Зная значение числа N в десятичной системе, нетрудно получить цифры, задающие его запись в системе с основанием q. Представим число N в виде суммы целой и дробной частей N= C+D. Рассмотрим схему получения цифр отдельно для целой части C и дробной – D. Пусть в системе с основанием q число C представимо в виде C = c<sub>n</sub>c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>. Тогда нетрудно получить его последнюю цифру c<sub>0</sub> и число M = c<sub>n</sub>c<sub>n</sub><sub>-1</sub>…c<sub>1</sub>, полученное отбрасыванием последней цифры в записи числа C. Для этого достаточно воспользоваться операциями деления нацело и получения остатка при делении нацело: c<sub>0</sub> = C%p; M = C/p;</p>
<p>Применяя этот прием n раз, получим все цифры в записи числа C. Заметьте, имеет место соотношение: N= (N/p)*p + N%p, где в соответствии с языком C# операция / означает деление нацело, а % – остаток от деления нацело. Чтобы получить все цифры и сохранить их в массиве, достаточно эту схему вставить в соответствующий цикл, что схематично можно представить следующим почти программным текстом:</p>
<p>M=C; i=0;</p>
<p>while(M!=0)</p>
<p>{</p>
<p>c=M%p; M=M/p; Ar[i] =c; i++;</p>
<p>}</p>
<p>Для получения цифр дробной части применяется та же схема, но с некоторой модификацией. Если цифры целой части вычисляются, начиная с последней, младшей цифры числа, то цифры дробной части вычисляются, начиная с первой цифры после запятой. Для ее получения достаточно имеющуюся дробь умножить на основание системы счисления и в полученном результате взять целую часть. Для получения последующих цифр этот процесс следует применять к числу M, представляющему дробь, из которой удалена первая цифра:
d<sub>1</sub> =[D*p]; m={d*p}. Здесь [x] и {x} означают соответственно взятие целой и дробной части числа x. Хотя напрямую этих операций нет в языке C#, но их достаточно просто выразить имеющимися средствами этого языка.</p>
<p>Чтобы перейти от системы счисления p к системе счисления q, всегда ли следует использовать десятичную систему в качестве промежуточной: p→ 10 → q? Нет, не всегда. В ряде случаев удобнее использовать прием, основанный на следующем утверждении:</p>
<p>Если основания систем счисления связаны соотношением p = q<sup>k</sup>, то для перехода от записи числа в системе с основанием p к записи числа в системе с основанием q достаточно каждую цифру системы p представить группой из k цифр системы q.</p>
<p>Для обратного перехода из q в p достаточно сгруппировать цифры системы q и каждую группу из k цифр заменить одной цифрой системы p. Доказательство этих утверждений оставляю читателю.</p>
<p>Для программистов особую важность представляют три системы счисления – двоичная, восьмеричная и шестнадцатеричная. Основания этих систем счисления связаны упомянутым соотношением: 16 = 2<sup>4</sup>; 8 = 2<sup>3</sup>. Рассмотрим число N, записанное в шестнадцатеричной системе N = 2A,3E<sub>(16)</sub>. Чтобы получить его запись в двоичной системе, каждую цифру запишем в двоичной системе, представив ее группой из четырех двоичных цифр. Нетрудно видеть, что N = 00101010,00111110<sub>(2)</sub>. Незначащие нули слева и справа могут быть отброшены, так что окончательно имеем: N = 101010,0011111<sub>(2)</sub>. Переведем это число в восьмеричную систему. Для этого достаточно провести группирование по три цифры влево и вправо от запятой соответственно для целой и дробной части, так что получим: N = 52,174<sub>(8)</sub>.</p>
<p><strong>Римская система счисления</strong></p>
<p>Еще сегодня для записи целых чисел, в особенности дат, используется римская система счисления. Эта система записи чисел не является позиционной. В ее основе лежит понятие человеческих рук с их пятью и десятью пальцами. Поэтому в этой системе есть цифры 1, 5 и 10, записываемые с помощью символов I, V, X. Помимо этого есть еще четыре цифры – 50, 100, 500, 1000, задаваемые символами L, C, D, M. В этой системе нет цифры 0 и она не является позиционной.  С помощью цифр римской системы обычно записывают целые числа, не превышающие 4000. Запись числа представляет собой последовательность подряд идущих цифр, а значением числа является сумма цифр в его записи. Например число III означает I + I + I = 3. В записи числа старшие цифры предшествуют младшим, например CVI = C+V+I = 100+5+1=106. Из этого правила есть одно исключение. Младшая цифра может предшествовать старшей цифре и тогда вместо сложения применяется вычитание, например CIX = C+X-I = 100+10-1=109.</p>
<p><strong>Задачи</strong></p>
<ol>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры. Получить n – число цифр в записи числа и целочисленный массив DigitsN такой, что DigitsN[i] = c<sub>i</sub>.</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры. Получить строку strN, задающую запись числа N.
<em>Указание</em>: конечно, можно воспользоваться стандартным методом ToString, но в задаче требуется дать собственную реализацию этого метода.</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры. Получить m – число цифр в записи числа и целочисленный массив FractN такой, что FractN[i] = d<sub>i</sub>.</li>
<li>Дано дробное число N = 0. d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры. Получить строку strN, задающую запись числа N.
<em>Указание</em>: конечно, можно воспользоваться стандартным методом ToString, но в задаче требуется дать собственную реализацию этого метода.</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры. Получить n и m – число цифр в записи целой и дробной части числа и целочисленный массив DigitsN из n+m элементов такой, что первые его n элементов содержат цифры целой части, а последние m элементов – дробной.</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры. Получить строку strN, задающую запись числа N.</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в двоичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, получить k – число цифр и целочисленный массив DigitsN такой, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в двоичной системе счисления.
<em>Пример</em>: N = 17<sub>(10)</sub> = 10001<sub>(2)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в троичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, получить k – число цифр и целочисленный массив DigitsN такой, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в троичной системе счисления.
<em>Пример</em>: N = 17<sub>(10)</sub> = 122<sub>(3)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в четверичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, получить k – число цифр и целочисленный массив DigitsN такой, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в четверичной системе счисления.
<em>Пример</em>: N = 17<sub>(10)</sub> = 101<sub>(4)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в восьмеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, получить k – число цифр и целочисленный массив DigitsN такой, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в восьмеричной системе счисления.
<em>Пример</em>: N = 17<sub>(10)</sub> = 21<sub>(8)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в шестнадцатеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, получить k – число цифр и целочисленный массив DigitsN такой, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в шестнадцатеричной системе счисления.
<em>Пример</em>: N = 17<sub>(10)</sub> = 11<sub>(16)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в двоичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>. Получить строку strN, задающую запись числа N.
<em>Пример</em>: N = 17<sub>(10)</sub> = 10001<sub>(2)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в троичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>. Получить строку strN, задающую запись числа N.
<em>Пример</em>: N = 17<sub>(10)</sub> = 122<sub>(3)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в четверичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>. Получить строку strN, задающую запись числа N.
<em>Пример</em>: N = 17<sub>(10)</sub> = 101<sub>(4)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в восьмеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>. Получить строку strN, задающую запись числа N.
<em>Пример</em>: N = 17<sub>(10)</sub> = 21<sub>(8)</sub>
</li>
<li>Дано целое число N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в шестнадцатеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>. Получить строку strN, задающую запись числа N.
<em>Пример</em>: N = 17<sub>(10)</sub> = 11<sub>(16)</sub>
</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в двоичную систему счисления N = 0.b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, вычислив k цифр в его записи, сохраняя их в целочисленном массиве DigitsN таком, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в двоичной системе счисления.
<em>Пример</em>: N = 0.17<sub>(10)</sub> = 0.001010111<sub>(2)</sub> при k=9.</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в троичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, вычислив k цифр в его записи, сохраняя их в целочисленном массиве DigitsN таком, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в троичной системе счисления.
<em>Пример</em>: N = 0.17<sub>(10)</sub> = 0.01112<sub>(3)</sub> при k=5.</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в четверичную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, вычислив k цифр в его записи, сохраняя их в целочисленном массиве DigitsN таком, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в четверичной системе счисления.
<em>Пример</em>: N = 0.17<sub>(10)</sub> = 0.02232<sub>(4)</sub> при k=5.</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в восьмеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, вычислив k цифр в его записи, сохраняя их в целочисленном массиве DigitsN таком, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в восьмеричной системе счисления.
<em>Пример</em>: N = 0.17<sub>(10)</sub> = 0.127<sub>(8)</sub> при k=3.</li>
<li>Дано дробное число N = 0.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где d<sub>i</sub> – это цифры десятичной системы счисления. Перевести число N в шестнадцатеричную систему счисления N = b<sub>k</sub><sub>-1</sub>…b<sub>0</sub>, вычислив k цифр в его записи, сохраняя их в целочисленном массиве DigitsN таком, что DigitsN[i] = b<sub>i</sub>, где b<sub>i</sub> – это цифры в записи числа N в шестнадцатеричной системе счисления.
<em>Пример</em>: N = 0.17<sub>(10)</sub> = 0.1B<sub>(16)</sub> при k=5.</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Перевести число N в двоичную систему счисления с заданной точностью, вычислив k цифр дробной части числа. Получить строку strN, задающую запись числа N в этой системе счисления.
<em>Пример</em>: N = 17.17<sub>(10)</sub> = 10001. 001010111<sub> (2)</sub>
</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Перевести число N в троичную систему счисления с заданной точностью, вычислив k цифр дробной части числа. Получить строку strN, задающую запись числа N в этой системе счисления.
<em>Пример</em>: N = 17.17<sub>(10)</sub> = 122. 01112<sub> (</sub><sub>3)</sub>
</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Перевести число N в четверичную систему счисления с заданной точностью, вычислив k цифр дробной части числа. Получить строку strN, задающую запись числа N в этой системе счисления.
<em>Пример</em>: N = 17.17<sub>(10)</sub> = 101. 02232<sub> (4)</sub>
</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Перевести число N в восьмеричную систему счисления с заданной точностью, вычислив k цифр дробной части числа. Получить строку strN, задающую запись числа N в этой системе счисления.
<em>Пример</em>: N = 17.17<sub>(10)</sub> = 21. 127<sub> (8)</sub>
</li>
<li>Дано вещественное число с целой и дробной частью N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Перевести число N в шестнадцатеричную систему счисления с заданной точностью, вычислив k цифр дробной части числа. Получить строку strN, задающую запись числа N в этой системе счисления.
<em>Пример</em>: N = 17.17<sub>(10)</sub> = 11. 1B<sub> (</sub><sub>16)</sub>
</li>
<li>Дана строка, задающая представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры десятичной системы счисления. Получить число N.
<em>Эту задачу можно сформулировать и так: задайте собственную реализацию метода </em><em>ToInt32 класса </em><em>Convert</em>.</li>
<li>Дана строка, задающая представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры десятичной системы счисления. Получить число N.
<em>Эту задачу можно сформулировать и так: задайте собственную реализацию метода </em><em>ToDouble класса </em><em>Convert</em>.</li>
<li>Дана строка, задающая в двоичной системе счисления представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры двоичной системы счисления. Получить число N.
<em>Эту задачу можно рассматривать, как расширение класса </em><em>Convert: добавление метода </em><em>FromBinaryToInt32</em>.</li>
<li>Дана строка, задающая в двоичной системе счисления представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры двоичной системы счисления. Получить число N.
<em>Эту задачу можно рассматривать, как расширение класса </em><em>Convert: добавление метода </em><em>FromBinaryToDouble</em>.</li>
<li>Дана строка, задающая в шестнадцатеричной системе счисления представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры шестнадцатеричной системы счисления. Получить число N.
<em>Эту задачу можно рассматривать, как расширение класса </em><em>Convert: добавление метода </em><em>FromHexToInt32</em>.</li>
<li>Дана строка, задающая в двоичной системе счисления представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры двоичной системы счисления. Получить число N.
<em>Эту задачу можно рассматривать, как расширение класса </em><em>Convert: добавление метода </em><em>FromHexToDouble</em>.</li>
<li>Дана строка, задающая в двоичной системе счисления представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры двоичной системы счисления. Получить строки str4N, str8N, str16N, задающие представление числа N в системах счисления: четверичной, восьмеричной, шестнадцатеричной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>Дана строка, задающая в двоичной системе счисления представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры двоичной системы счисления. Получить строки str4N, str8N, str16N, задающие представление числа N в системах счисления: четверичной, восьмеричной, шестнадцатеричной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>Дана строка, задающая в восьмеричной системе счисления представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры восьмеричной системы счисления. Получить строки str4N, str2N, str16N, задающие представление числа N в системах счисления: четверичной, двоичной, шестнадцатеричной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>Дана строка, задающая в восьмеричной системе счисления представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры восьмеричной системы счисления. Получить строки str4N, str2N, str16N, задающие представление числа N в системах счисления: четверичной, двоичной, шестнадцатеричной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>Дана строка, задающая в шестнадцатеричной системе счисления представление целого числа N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>, где c<sub>i</sub> – это цифры шестнадцатеричной системы счисления. Получить строки str4N, str8N, str2N, задающие представление числа N в системах счисления: четверичной, восьмеричной, двоичной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>Дана строка, задающая в шестнадцатеричной системе счисления представление вещественного числа с целой и дробной частью: N = c<sub>n</sub><sub>-1</sub>…c<sub>0</sub>.d<sub>m</sub><sub>-1</sub>…d<sub>0</sub>, где c<sub>i</sub>, d<sub>j</sub> – это цифры шестнадцатеричной системы счисления. Получить строки str4N, str8N, str2N, задающие представление числа N в системах счисления: четверичной, восьмеричной, двоичной.
<em>Указание</em>. <em>Используйте группирование цифр при переводе из одной системы счисления в другую.</em>
</li>
<li>(*) Заданы p и q – основания двух систем счисления, strN – строка, задающая представление вещественного числа N в системе с основанием p. Получить строку, задающую представление числа N в системе с основанием q, возможно с некоторой точностью, заданной параметром k – числом цифр дробной части числа N при его записи в системе с основанием q.</li>
<li>(*) Дано число N и основание системы счисления p. Получить c<sub>i</sub> – коэффициенты разложения числа N по степеням основания с заданной точностью Eps.
<em>Указание: В данной задаче предполагается, что </em><em>N, </em><em>p, </em><em>c<sub>i</sub> являются вещественными числами и для </em><em>c<sub>i</sub> выполняется условие (</em><em>c<sub>i</sub> &lt; </em><em>p). Пример</em><em>: N=30; p=2,5; c<sub>3</sub> = 1; c<sub>2</sub> = 1,5; c<sub>1</sub> = 2; c<sub>0</sub> = 0;
</em>
</li>
<li>Дано основание системы счисления p и c<sub>i</sub> – коэффициенты разложения числа N по степеням основания. Получить число N.
<em>Указание: В данной задаче предполагается, что </em><em>N, </em><em>p, </em><em>c<sub>i</sub> являются вещественными числами и для </em><em>c<sub>i</sub> выполняется условие (</em><em>c<sub>i</sub> &lt; </em><em>p). Пример: </em><em>p=2,5; </em><em>c<sub>3</sub> = 1; </em><em>c<sub>2</sub> = 1,5; </em><em>c<sub>1</sub> = 2; </em><em>c<sub>0</sub> = 0;
</em>
</li>
<li>(*) Дана строка strRome, задающая представление целого числа N, меньшего 4000, в непозиционной римской системе счисления. Получить число N.
<em>Пример: </em><em>N= </em><em>MMIV = 2004</em>
</li>
<li>(*) Дано целое число N, меньшее 4000. Получить строку strRome, задающую представление числа в непозиционной римской системе счисления.
<em>Пример: </em><em>N=2005 =</em><em>MMV </em>
</li>
</ol>
<p><strong>Именованные числа</strong></p>
<p>С давних пор числа применяются для измерения физических величин ­– длин, площадей, объемов. Как правило, при этом использовалась системы, вовсе не основанные на десятичной системе, а связанные с реально применяемыми мерами – бочонками, мешками и прочей применяемой тарой. Метрическая система мер, основанная на десятичной системе счисления, завоевала свои позиции лишь в последние два столетия, и мы стали применять километры и килограммы, килоджоули и килогерцы. Но рецидивы все еще дают себя знать, и примером тому является программисты, которые сравнительно недавно ввели систему мер для измерения объема информации. У нас байт равен 8 битам, а килобайт равен не 1000 байтов, как мог бы ожидать человек, далекий от программирования, а — 1024 байта. И связано это с любовью компьютеров к двоичной системе счисления, в которой 1 байт = 1000<sub>(2)</sub> битов, а 1 Кб = 10000000000<sub>(2)</sub> байтов.</p>
<p><strong>Задачи</strong></p>
<ol>
<li>Задано число T (температура) и единица измерения (C – градусы по Цельсию, F – по Фаренгейту, R – по Реомюру, K – по Кельвину). Определить значения температуры в других шкалах, используя следующие соотношения:<em>Пример: -40 (С) = -40 (</em><em>F) = -32 (</em><em>R) = 233,2 (</em><em>K)</em>
</li>
<li>Дано число N, задающее расстояние, измеренное с точностью до долей миллиметра. Получите строку, задающее расстояние с использованием старинной китайской системы, в которой справедливы следующие соотношения:</li>
<li>Дано число N, задающее расстояние, измеренное с точностью до долей миллиметра. Получите строку, задающее расстояние с использованием старинной древнерусской системы, в которой справедливы следующие соотношения:</li>
<li>Дано число N, задающее расстояние, измеренное с точностью до долей миллиметра. Получите строку, задающее расстояние с использованием английской системы мер длины, в которой справедливы следующие соотношения:</li>
<li>Дано вещественное число N, задающее объем хранимых данных в терабайтах. Выразите значение N в гигабайтах, мегабайтах, килобайтах, байтах, битах.</li>
</ol>
<p><strong>Классификация чисел</strong></p>
<p>Целые положительные числа – N = {1, 2, 3, … } – составляют множество натуральных чисел. Зачастую и 0 считают натуральным числом.</p>
<p>Множество целых чисел Z включает в себя все натуральные числа, число 0 и все натуральные числа, взятые со знаком минус: Z = {0, 1, -1, 2, -2, …}.</p>
<p>Каждое рациональное число x можно задать парой целых чисел (m, n), где m является числителем, n – знаменателем числа: x = m/n. Эквивалентным представлением рационального числа является его задание в виде числа, записанного в позиционной десятичной системе счисления, где дробная часть числа может быть конечной или бесконечной периодической дробью. Например, число x = 1/3 = 0,(3) представляется бесконечной периодической дробью.</p>
<p>Числа, задаваемые бесконечными непериодическими дробями, называются иррациональными числами. Таковыми являются, например все числа вида √p, где p – простое число. Иррациональными являются известные всем числа π и e.</p>
<p>Объединение множеств целых, рациональных и иррациональных чисел составляет множество вещественных чисел. Геометрическим образом множества вещественных чисел является прямая линия – вещественная ось, где каждой точке оси соответствует некоторое вещественное число, так что вещественные числа плотно и непрерывно заполняют всю вещественную ось.</p>
<p>Плоскость представляет геометрический образ множества комплексных чисел, где вводятся уже две оси – вещественная и мнимая. Каждое комплексное число, задаваемое парой вещественных чисел, представимо в виде: x = a+b*i, где a и b – вещественные числа, которые можно рассматривать, как декартовы координаты числа на плоскости.</p>
<p><strong>Делители и множители</strong></p>
<p>Рассмотрим сейчас классификацию, которая делит множество натуральных чисел на два подмножества – простых и составных чисел. В основе этой классификации лежит понятие делимости натуральных чисел. Если n делится нацело на d, то говорят, что d «делит» n,что записывают в виде: d | n. Заметьте, это определение, возможно, не соответствует интуитивному пониманию: d «делит» n, если n делится на d, а не наоборот. Число d называется делителем числа n. У каждого числа n есть два тривиальных делителя – 1 и n. Делители, отличные от тривиальных, называются множителями числа n. Число n называется простым, если у него нет делителей, отличных от тривиальных. Простые числа делятся только на 1 и сами на себя. Числа, у которых есть множители, называются составными. Число 1 является особым числом, поскольку не относится ни к простым, ни к составным числам. Отрицательные числа также не относятся ни к простым, ни к составным, но всегда можно рассматривать модуль числа и относить его к простым или составным числам.</p>
<p>Любое составное число N можно представить в виде произведения его множителей: N = q1 * q2 * … * qk. Это представление не единственно, например 96 = 8*12 = 2*3*16. Однако для каждого составного числа N существует единственное представление в виде произведения степеней простых чисел: N = p<sub>1</sub><sup>r1</sup> * p<sub>2</sub><sup>r2</sup> * … * p<sub>k</sub><sup>rk</sup>, где pi – простые числа и p<sub>k</sub> &lt; p<sub>k</sub><sub>+1. </sub>Это представление называется разложением числа N на простые множители. Например 96 = 2<sup>5 </sup>* 3<sup>1</sup>.</p>
<p>Если d | m и d | n, то d является общим делителем чисел m и n. Среди всех общих делителей можно выделить наибольший общий делитель, обозначаемый как НОД(m, n). Если НОД(m, n) = 1, то числа m и n называются взаимно простыми. Простые числа взаимно просты, так что НОД(q, p) =1, если q и p – простые числа.</p>
<p>Если m | A и n | A, то A является общим кратным чисел m и n. Среди всех общих кратных можно выделить наименьшее общее кратное, обозначаемое как НОК(m, n). Если НОК(m, n) = m*n, то числа m и n являются взаимно простыми. НОК(q, p) =q*p, если q и p – простые числа.</p>
<p>Если через P<sub>m</sub> и Q<sub>n</sub> обозначить множества всех простых множителей чисел m и n, то</p>
<p> </p>
<p>Если получено разложение чисел m и n на простые множители, то, используя приведенные соотношения, нетрудно вычислить НОД(m,n) и НОК(m,n). Существуют и более эффективные алгоритмы, не требующие разложения числа на множители.</p>
<p><strong>Алгоритм Эвклида</strong></p>
<p>Эффективный алгоритм вычисления НОД(m,n) предложен еще Эвклидом. Он основывается на следующих свойствах НОД(m,n), доказательство которых предоставляется читателю:</p>
<p> </p>
<p>Если m &gt; n, то по третьему свойству его можно уменьшить на величину n. Если же m &lt; n, то по второму свойству аргументы можно поменять местами и вновь придти к ранее рассмотренному случаю. Когда же в результате этих преобразований значения аргументов сравняются, то решение будет найдено. Поэтому можно предложить следующую схему:</p>
<p>while(m != n)</p>
<p>{</p>
<p>if(m &lt; n) swap(m,n);</p>
<p>m = m — n;</p>
<p>}</p>
<p>return(m);</p>
<p>Здесь процедура swap выполняет обмен значениями аргументов.</p>
<p>Если немного подумать, то становится ясно, что вовсе не обязательно обмениваться значениями, – достаточно на каждом шаге цикла изменять аргумент с максимальным значением. В результате приходим к схеме:</p>
<p>while(m != n)</p>
<p>{</p>
<p>if(m &gt; n) m = m — n;</p>
<p>else n = n – m;</p>
<p>}</p>
<p>return(m);</p>
<p>Если еще немного подумать, то можно улучшить и эту схему, перейдя к циклу с тождественно истинным условием:</p>
<p>while(true)</p>
<p>{</p>
<p>if(m &gt; n) m = m — n;</p>
<p>else if (n &gt; m) n = n – m;</p>
<p>else return(m);</p>
<p>}</p>
<p>Последняя схема хороша тем, что в ней отчетливо видна необходимость доказательства завершаемости этого цикла. Доказать завершаемость цикла нетрудно, используя понятие варианта цикла. Для данного цикла вариантом может служить целочисленная функция – max(m,n), которая уменьшается на каждом шаге, оставаясь всегда положительной.</p>
<p>Достоинством данной версии алгоритма Эвклида является и то, что на каждом шаге используется элементарная и быстрая операция над целыми числами – вычитание. Если допустить операцию вычисления остатка при делении нацело, то число шагов цикла можно существенно уменьшить. Справедливо следующее свойство:</p>
<p> </p>
<p>Это приводит к следующей схеме:</p>
<p>int temp;</p>
<p>if(n&gt;m) temp = m; m = n; n = temp; //swap(m,n)</p>
<p>while(m != n)</p>
<p>{</p>
<p>temp = m; m = n; n = temp%n;</p>
<p>}</p>
<p>Если немного подумать, то становится ясно, что вовсе не обязательно выполнять проверку перед началом цикла. Это приводит к более простой схеме вычисления НОД, применяемой обычно на практике:</p>
<p>int temp;</p>
<p>while(m != n)</p>
<p>{</p>
<p>temp = m; m = n; n = temp%n;</p>
<p>}</p>
<p>Для вычисления НОК(m, n) можно воспользоваться следующим соотношением:</p>
<p> </p>
<p>А можно ли вычислить НОК(m, n), не используя операций умножения и деления? Оказывается можно одновременно с вычислением НОД(m,n) вычислять и НОК(m,n). Вот соответствующая схема:</p>
<p>int x = v = m, y = u = n;</p>
<p>while(x != y)</p>
<p>{</p>
<p>if(x &gt; y){  x = x — y; v = v + u;}</p>
<p>else {y = y – x; u = u + v;}</p>
<p>}</p>
<p>НОД = (x + y)/2; НОК = (u+v)/2;</p>
<p>Доказательство того, что эта схема корректно вычисляет НОД, следует из ранее приведенных свойств НОД. Менее очевидна корректность вычисления НОК. Для доказательства заметьте, что инвариантом цикла является следующее выражение:</p>
<p> </p>
<p>Это соотношение выполняется после инициализации переменных до начала выполнения цикла. По завершении цикла, когда x и y становятся равными НОД, из истинности инварианта следует корректность схемы. Нетрудно проверить, что операторы тела цикла оставляют утверждение истинным. Детали доказательства оставляются читателям.</p>
<p>Понятие НОД и НОК можно расширить, определив их для всех целых чисел. Справедливы следующие соотношения:</p>
<p> </p>
<p><strong>Расширенный алгоритм Эвклида</strong></p>
<p>Иногда полезно представлять НОД(m,n) в виде линейной комбинации m и n:</p>
<p> </p>
<p>В частности вычисление коэффициентов a и b необходимо в алгоритме RSA – шифрования с открытым ключом. Приведу схему алгоритма, позволяющую вычислить тройку – d, a, b – наибольший общий делитель и коэффициенты разложения. Алгоритм удобно реализовать в виде рекурсивной процедуры</p>
<p>ExtendedEuclid(int m, int n, ref int d, ref int a, ref int b),</p>
<p>которая по заданным входным аргументам m и n вычисляет значения аргументов d, a, b. Нерекурсивная ветвь этой процедуры соответствует случаю n = 0, возвращая в качестве результата значения: d = m, a = 1, b = 0. Рекурсивная ветвь вызывает</p>
<p>ExtendedEuclid(n, m % n, ref d, ref a, ref b)</p>
<p>и затем изменяет полученные в результате вызова значения a и b следующим образом:</p>
<p> </p>
<p>Доказательство корректности этого алгоритма построить нетрудно. Для нерекурсивной ветви корректность очевидна, а для рекурсивной ветви нетрудно показать, что из истинности результата, возвращаемого при рекурсивном вызове, следует его истинность для входных аргументов после пересчета значений a и b.</p>
<p>Как работает эта процедура? Вначале происходит рекурсивный спуск, пока n не станет равно нулю.</p>
<p>В этот момент впервые будет вычислено значение d и значения параметров a и b. После этого начнется подъем и будут перевычисляться параметры a и b.</p>
<p>Задачи</p>
<ol>
<li>Даны m и n – натуральные числа. Вычислите НОД(m, n). При вычислениях не используйте операций умножения и деления.</li>
<li>Даны m и n – натуральные числа. Вычислите НОК(m, n).</li>
<li>Даны m и n – натуральные числа. Вычислите НОК(m, n). При вычислениях не используйте операций умножения и деления.</li>
<li>Даны m и n – целые числа. Вычислите НОД(m, n). При вычислениях не используйте операций умножения и деления.</li>
<li>Даны m и n – целые числа. Вычислите НОК(m, n). При вычислениях не используйте операций умножения и деления.</li>
<li>Даны m и n – целые числа. Вычислите НОД(m, n). При вычислениях используйте операцию взятия остатка от деления нацело.</li>
<li>Даны m и n – целые числа. Вычислите НОК(m, n). При вычислениях используйте операцию взятия остатка от деления нацело.</li>
<li>Даны m и n – целые числа. Вычислите тройку чисел – (d, a, b), используя расширенный алгоритм Эвклида.</li>
<li>Даны m и n – натуральные числа. Представьте НОД(m, n) в виде линейной комбинации m и n.</li>
<li>Даны m и n – целые числа. Представьте НОД(m, n) в виде линейной комбинации m и n.</li>
<li>Даны m и n – целые числа. Проверьте, являются ли числа m и n взаимно простыми.</li>
</ol>
<p><strong>Простые числа</strong></p>
<p>Среди четных чисел есть только одно простое число – это 2. Простых нечетных чисел сколь угодно много. Нетрудно доказать, что число N = (p1 * p2 * … * pk) +1, где pi – подряд идущие простые числа, является простым. Так что, если построено k простых чисел, то можно построить еще одно простое число p, большее p<sub>k</sub>. Отсюда следует, что множество простых чисел неограниченно. Пример: число N = 2*3*5*7 + 1 = 211 является простым числом.</p>
<p><strong>Решето Эратосфена</strong></p>
<p>Как определить, что число N является простым? Если допустима операция N % m, дающая остаток от деления числа N на число m, то простейший алгоритм состоит в проверке того, что остаток не равен нулю при делении числа N на все числа m, меньшие N. Очевидным улучшением этого алгоритма является сокращение диапазона проверки – достаточно рассматривать числа m в диапазоне [2, √N].</p>
<p>Еще в 3-м веке до н.э. греческий математик Эратосфен предложил алгоритм нахождения простых чисел в диапазоне [3, N], не требующий операций деления. Этот алгоритм получил название «Решето Эратосфена». В компьютерном варианте идею этого алгоритма можно описать следующим образом. Построим массив Numbers, элементы которого содержат подряд идущие нечетные числа, начиная с 3. Вначале все числа этого массива считаются невычеркнутыми. Занесем первое невычеркнутое число из этого массива в массив SimpleNumbers – и это будет первое нечетное простое число (3). Затем выполним просеивание, проходя по массиву Numbers с шагом, равным найденному простому числу, вычеркивая все попадающиеся при этом проходе числа. При первом проходе будет вычеркнуто число 3 и все числа, кратные 3. На следующем проходе в таблицу простых чисел будет занесено следующее простое число 5, а из массива Numbers будут вычеркнуты числа, кратные 5. Процесс повторяется, пока не будут вычеркнуты все числа в массиве Numbers. В результате массив SimpleNumbers будет содержать таблицу первых простых чисел, меньших N.</p>
<p>Этот алгоритм хорош для нахождения сравнительно небольших простых чисел. Но если потребуется найти простое число с двадцатью значащими цифрами, то памяти компьютера уже не хватит для хранения соответствующих массивов. Замечу, что в современных алгоритмах шифрования используются простые числа, содержащие несколько сотен цифр.</p>
<p><strong>Плотность простых чисел</strong></p>
<p>Мы показали, что число простых чисел неограниченно. Понятно, что их меньше, чем нечетных чисел, но насколько меньше? Какова плотность простых чисел? Пусть π(n) – это функция, возвращающая число простых чисел, меньших n. Точно задать эту функцию не удается, но для нее есть хорошая оценка. Справедлива следующая теорема:</p>
<p> </p>
<p>Функция π(n) асимптотически сверху приближается к своему пределу, так что оценка дает слегка заниженные значения. Эту оценку можно использовать в алгоритме решета Эратосфена для выбора размерности массива SimpleNumbers, когда задана размерность массива Numbers, и, наоборот, при заданной размерности таблицы простых чисел можно выбрать подходящую размерность для массива Numbers.</p>
<p><strong>Табличный алгоритм определения простоты чисел</strong></p>
<p>Если хранить таблицу простых чисел SimpleNumbers, в которой наибольшее простое число равно M, то достаточно просто определить является ли число N, меньшее M<sup>2</sup>, простым. Если N меньше M, то достаточно проверить, находится ли число N в таблице SimpleNumbers. Если N больше M, то достаточно проверить, делится ли число N на числа из таблицы SimpleNumbers, не превосходящие значения √N. Понятно, что если у числа N нет простых множителей, меньших √N, то число N является простым.</p>
<p>Использование таблицы простых чисел требует соответствующей памяти компьютера, а следовательно ограничивает возможности этого алгоритма, не позволяя использовать его для нахождения больших простых чисел.</p>
<p><strong>Тривиальный алгоритм</strong></p>
<p>Если N – нечетное число, то проверить, что оно является простым, можно на основе определения простоты числа. При этом не требуется никакой памяти для хранения таблиц чисел, но, как всегда, выигрывая в памяти, проигрываем во времени. Действительно, достаточно проверить, делится ли нацело число N на подряд идущие нечетные числа в диапазоне [3, √N]. Если у числа N есть хоть один множитель, то оно составное, иначе – простое.</p>
<p>Все рассмотренные алгоритмы перестают эффективно работать, когда числа выходят за пределы разрядной сетки компьютера, отведенной для представления чисел, так что если возникает необходимость работы с целыми числами, выходящими за пределы диапазона System.Int64, то задача определения простоты такого числа становится совсем не простой. Существуют некоторые рецепты, позволяющие определить, что число является составным. Вспомним хотя бы известные со школьных времен алгоритмы. Если последняя цифра числа делится на 2, то и число делится на 2. Если две последние цифры числа делятся на 4, то и число делится на 4. Если сумма цифр делится на 3 (на 9), то и число делится на 3 (на 9). Если последняя цифра рана 0 или 5, то число делится на 5. Математики затратили много усилий, доказывая, что то или иное число является (или не является) простым числом. Сейчас есть особые приемы, позволяющие доказать, что числа некоторого вида являются простыми. Наиболее подходящими кандидатами на простоту являются числа вида 2<sup>p</sup> -1, где p – это простое число. Например, доказано, что число 2<sup>19937</sup> — 1, имеющее более 6000 цифр, является простым, но нельзя сказать, какие простые числа являются ближайшими соседями этого числа.</p>
<p><strong>Задачи</strong></p>
<ol>
<li>Дано целое N. Используя алгоритм решета Эратосфена, найдите все простые числа, меньшие N.</li>
<li>Дано целое N. Используя алгоритм решета Эратосфена, найдите N первых простых чисел.</li>
<li>Дана таблица, содержащая N первых простых чисел. По заданному n &lt; N вычислите разность между функцией π(n) и ее оценкой – n/ln(n).</li>
<li>Дана таблица, содержащая N первых простых чисел. Используя табличный алгоритм, вычислите все простые числа в диапазоне [M+1, M*M], где M – наибольшее простое число, хранимое в таблице.</li>
<li>Дано целое N. Постройте таблицу, содержащую N первых нечетных простых чисел. Используйте табличный алгоритм с постепенным заполнением таблицы, начиная со случая, когда в ней хранится только одно простое число 3.</li>
<li>Дано число N. Определите, является ли оно простым, используя тривиальный алгоритм.</li>
</ol>
<p>Дано число N. Определите его первый простой множитель, если он существует.</p>
<p><strong>Проекты</strong></p>
<ol>
<li>Построить класс «Температура», позволяющий задавать температуру в разных единицах измерения. Построить Windows проект, поддерживающий интерфейс для работы с классом.</li>
<li>Построить класс «Расстояния», позволяющий использовать разные системы мер. Построить Windows проект, поддерживающий интерфейс для работы с классом.</li>
<li>Построить класс «Простые числа». Построить Windows проект, поддерживающий интерфейс для работы с классом.</li>
<li>Построить класс «Системы счисления». Построить Windows калькулятор, поддерживающий вычисления в заданной системе счисления.</li>
<li>Построить класс «Рациональные числа». Построить Windows калькулятор, поддерживающий вычисления с этими числами.</li>
<li>Построить класс «Комплексные числа». Построить Windows калькулятор, поддерживающий вычисления с этими числами.</li>
</ol>
