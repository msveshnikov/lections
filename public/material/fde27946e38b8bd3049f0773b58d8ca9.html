<div class="document">




<h4></h4>

<p>

Альтернативный метод сериализации транзакций, хорошо работающий в условиях редких конфликтов транзакций и не требующий построения графа ожидания транзакций. основан на использовании временных меток.

</p>
<p>

Основная идея метода (у которого существует множество разновидностей) состоит в следующем: если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой режим выполнения, как если бы T1 была целиком выполнена до начала T2.

</p>
<p>

Для этого каждой транзакции T предписывается временная метка t, соответствующая времени начала T. При выполнении операции над объектом r транзакция T помечает его своей временной меткой и типом операции (чтение или изменение).

</p>
<p>

Перед выполнением операции над объектом r транзакция T1 выполняет следующие действия:

</p>
<ul type="disc">

<li>Проверяет, не закончилась ли транзакция T, пометившая этот объект. Если T закончилась, T1 помечает объект r и выполняет свою операцию.

</li>
<li>Если транзакция T не завершилась, то T1 проверяет конфликтность операций. Если операции неконфликтны, при объекте r остается или проставляется временная метка с меньшим значением, и транзакция T1 выполняет свою операцию.

</li>
<li>Если операции T1 и T конфликтуют, то если t(T) &gt; t(T1) (т.е. транзакция T является более "молодой", чем T), производится откат T и T1 продолжает работу.

</li>
<li>Если же t(T) &lt; t(T1) (T "старше" T1), то T1 получает новую временную метку и начинается заново.

</li>
</ul>

<p>

К недостаткам метода временных меток относятся потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Кроме того, в распределенных системах не очень просто вырабатывать глобальные временные метки с отношением полного порядка (это отдельная большая наука).

</p>
<p>

Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а как мы уже отмечали, построение графа ожидания в распределенных системах стоит очень дорого.



</p>
<p></p>
<center> ||  || <p>

</p>
<p></p>
</center>
</div>