# encoding: windows-1251
<div class="left">
      <p></p>
<p></p>
<center><h2>Лекция
16. Введение в сетевые протоколы</h2></center>

<p> 

</p>
<p> 

</p>
<p>Завершает курс лекция, в которой рассматриваются
возможности постро­ения сетевых приложений. Сначала дается краткое введение в
сетевые протоко­лы, семиуровневую модель OSI, стек протоколов TCP/IP и описываются основ­ные утилиты,
предоставляемые операционной системой для мониторинга сети. Эти значения
необходимы, поскольку библиотека java.net, по сути, является ин­терфейсом для работы с этими
протоколами. Рассматриваются классы для со­единений через высокоуровневые
протоколы, протоколы TCP и UDP.

</p>
<p> 

</p>
<p>Ключевые слова: encapsulation, decapsulation, message, протокольный блок данных, protocol data unit, PDU, physical layer, коаксиальный кабель, витая пара, twisted pair, оптоволокно, сетевой адаптер, net­work adapter, data layer, logical link, LLC, media access control, MAC, Ethernet, Token ring, frame relay, коллизия, широковещание, broadcast, поле подсети.

</p>
<p> 

</p>
<p>Основы модели OSI

</p>
<p>В течение последних нескольких десятилетий размеры и
количество сетей значительно выросли. В 80-х годах существовало множество типов
сетей. И практически каждая из них была построена на своем типе обору­дования и
программного обеспечения, зачастую не совместимых между собой. Это приводило к
значительным трудностям при попытке соединить несколько сетей (например,
различный тип адресации делал эти попытки практически безнадежными).

</p>
<p>Эта проблема была рассмотрена Всемирной организацией по
стандар­тизации (International
Organization for Standardization, ISO) и было принято решение разработать модель сети,
которая могла бы помочь разработчикам и производителям сетевого оборудования и
программного обеспечения действовать сообща. В результате в 1984 г. была
создана модель OSI — мо­дель взаимодействия открытых систем (Open Systems Interconnected). Она состоит из семи уровней, на которые разделяется
задача организации сете­вого взаимодействия. Схематично они представлены в
таблице 16.1.

</p>
<p>Хотя сегодня существуют разнообразные модели сетей,
большинство разработчиков придерживается именно этой общепризнанной схемы.

</p>
<p>Рассмотрим процесс передачи информации между двумя
компью­терами. Программное обеспечение формирует сообщение на уровне 7
(приложений), состоящее из заголовка и полезных данных. В заголовке содержится
служебная информация, которая необходима уровню при-








</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="104" valign="top">
  <p>Номер уровня
  </p>
</td>
  <td width="176" valign="top">
  <p>Название уровня
  </p>
</td>
  <td width="148" valign="top">
  <p>Единица информации
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 7
  </p>
</td>
  <td width="176" valign="top">
  <p>Уровень приложений
  </p>
</td>
  <td width="148" valign="top">
  <p>———------ 
  </p>
<p>Данные (data)           
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 6
  </p>
</td>
  <td width="176" valign="top">
  <p>Представительский
  уровень
  </p>
</td>
  <td width="148" valign="top">
  <p>Данные (data)           
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 5
  </p>
</td>
  <td width="176" valign="top">
  <p>Сессионный уровень
  </p>
</td>
  <td width="148" valign="top">
  <p>Данные (data)
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 4
  </p>
</td>
  <td width="176" valign="top">
  <p>Транспортный уровень
  </p>
</td>
  <td width="148" valign="top">
  <p>Сегмент (segment)
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 3
  </p>
</td>
  <td width="176" valign="top">
  <p>Сетевой уровень
  </p>
</td>
  <td width="148" valign="top">
  <p>Пакет (packet)
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 2
  </p>
</td>
  <td width="176" valign="top">
  <p>Уровень передачи данных
  </p>
</td>
  <td width="148" valign="top">
  <p>Фрейм (frame)
  </p>
</td>
 </tr>
 <tr>
  <td width="104" valign="top">
  <p>Layer 1
  </p>
<p> 
  </p>
</td>
  <td width="176" valign="top">
  <p>Физический уровень
  </p>
</td>
  <td width="148" valign="top">
  <p>—--- —_______ 
  </p>
<p>Бит (bit)                  
  </p>
</td>
 </tr>
 <tr>
  <td width="427" colspan="3" valign="top">
  <p>_------------------------------------------------ 
  ^
  </p>
</td>
 </tr>
</table>

<p>ложений адресата для
обработки пересылаемой информации (напри­мер, это может быть информация о
файле, который необходимо пере­дать, или операции, которую нужно выполнить).
После того, как сооб­щение было сформировано, уровень приложений направляет его
"вниз" на представительский уровень (layer 6). Полученное сообщение, состоя­щее из служебной информации уровня 7 и
полезных данных, для уров­ня 6 представляется как одно целое (хотя уровень 6
может считывать служебную информацию уровня 7). Протокол представительского
уров­ня выполняет необходимые действия на основании данных, получен­ных из
заголовка уровня приложений, и добавляет заголовок своего уровня, в котором
содержится информация для соответствующего (6-го) уровня адресата. Полученное в
результате сообщение передается да­лее "вниз" сеансовому уровню, где
также добавляется служебная инфор­мация. Дополненное сообщение передается на
следующий транспортный уровень и т.д. на каждом последующем уровне (схематично
это представ­лено на рис. 16.1). При этом служебная информация может
добавляться не только в начало сообщения, но и в конец (например, на 3-м
уровне, рис. 16.2). В итоге получается сообщение, содержащее служебную инфор­мацию
всех семи уровней.

</p>
<p>Процесс "обертывания" передаваемых данных служебной информа­цией
называется инкапсуляцией (encapsulation).

</p>
<p>Далее это сообщение передается через сеть в виде битов. Бит — это
минимальная порция информации, которая может принимать значение О или 1. Таким
образом, все сообщение кодируется в виде набора нулей и единиц, например,
010110101. В простейшем случае на физическом уров­не для передачи формируется
электрический сигнал, состоящий из серии электрических импульсов (0 - нет
сигнала, 1 - есть сигнал). Именно эта единица принята для измерения скорости
передачи информации. Совре­менные сети обычно предоставляют каналы с
производительностью в де­сятки и сотни Кбит/с и Мбит/с.








</p>
<p>Получатель на физическом уровне получает сообщение в виде элект­рического
сигнала (рис. 16.3). Далее происходит процесс, обратный инкап­суляции,-
декапсуляция (decapsulation). На каждом уровне происходит pa s бор служебной информации. После декапсуляции сообщения на первом уровне
(считывания и обработки служебной информации 1-го уровня)
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>-но сообщение,
содержащее служебную информацию второго уровня и данные в виде полезных данных
и служебной информации вышестоящих уровней, передается на следующий уровень. На
канальном (2-м) уровне снова проис­ходит анализ системной информации и
сообщение передается на следующий уровень. И так до тех пор, пока сообщение не
дойдет до уровня приложений, где в виде конечных данных передается принимающему
приложению.

</p>
<p> 

</p>
<p>0    
10     110     10

</p>
<p></p>
<center><img border="0" width="179" height="30" src="http://kufas.ru/java.files/image050.jpg"></center>

<p> 

</p>
<p> 

</p>
<p>Рис. 16.3. Представление
данных в виде электрического импульса.

</p>
<p> 

</p>
<p>В качестве примера можно привести обращение браузера к web-сер­веру.
Приложение клиента - браузер - формирует запрос для получения web-страницы. Этот
запрос передается приложением на уровень 7 и далее
последовательно на каждый уровень модели OSI. Достигнув
физического уровня, наш первоначальный запрос "обрастает" служебной
информаци­ей каждого уровня. После этого он передается по физической сети (кабе­лям)
в виде электрических импульсов на сервер. На сервере происходит разбор
соответствующей системной информации каждого уровня, в ре­зультате чего
посланный запрос достигает приложения web-сервера. Там он
обрабатывается, после чего клиенту отправляется ответ. Процесс от­правки ответа
аналогичен отправке запроса — за исключением того, что сообщение посылает
сервер, а получает клиент.

</p>
<p>Так как каждый уровень модели OSI стандартизирован,
потребители могут использовать совместно оборудование и программное обеспечение
различных производителей. В результате web-сервер под
управлением операционной системы Sun Solaris может передать HTML-страницу пользователю MS Windows.

</p>
<p>Разумеется, совместимость можно обеспечить лишь до некоторого уровня.
Если одна машина передает данные в виде радиоволн, а другая в виде световых
импульсов, то их взаимодействие без использования допол­нительного оборудования
невозможно. Поэтому было введено понятие сете-независимых и сете-зависимых
уровней.

</p>
<p>Три нижних уровня — физический, канальный и сетевой - являются
сете-зависимыми. Например, смена Ethernet на ATM влечет за собой пол­ную
смену протокола физического и канального уровней.

</p>
<p>Три верхних уровня - приложений, представительский и сессион­ный —
ориентированы на прикладные задачи и практически не зависят от физической
технологии построения сети. Так, переход от Token Ring на Ethernet не требует
изменений в перечисленных уровнях.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Транспортный уровень является промежуточным между сете-зави­симыми и
сете-независимыми уровнями. Он скрывает все детали функ­ционирования нижних
уровней от верхних. Это позволяет разработчику приложений не задумываться о
технических средствах реализации транс­портировки сетевых сообщений.

</p>
<p>Вместе с названием сообщение (message) в стандартах ISO для обо­значения единицы данных используют термин протокольный блок дан­ных
(Protocol Data Unit, PDU). В разных протоколах применяются и дру­гие названия, закрепленные
стандартами, или просто традиционные. Например, в семействе протоколов TCP/IP
протокол TCP разделяет по­ток
данных на сегменты, протокол UDP работает с
датаграммами (или дейтаграммами, от datagram), сам протокол IP использует термин пакеты. Часто так же говорят о кадрах или фреймах.

</p>
<p>Для более глубокого понимания принципов работы сети рассмотрим каждый
уровень по отдельности.

</p>
<p> 

</p>
<p>Physical layer (layer 1 )

</p>
<p>Как видно из общей схемы расположения уровней в модели OSI, фи­зический уровень
(Physical layer) самый первый. Этот уровень описывает среду передачи данных.
Стандартизируются физические устройства, отве­чающие за передачу электрических
сигналов (разъемы, кабели и т.д.) и правила формирования этих сигналов.
Рассмотрим по порядку все состав­ляющие этого уровня.

</p>
<p>Большая часть сетей строится на кабельной структуре (хотя сущест­вуют
сети, основанные на передаче информации с помощью, например, радиоволн). Сейчас
существуют различные типы кабелей. Наиболее рас­пространенные из них:

</p>
<p>•   
телефонный провод;

</p>
<p>•   
коаксиальный кабель;

</p>
<p>•   
витая пара;

</p>
<p>•   
оптоволокно.

</p>
<p>Телефонный кабель начал использоваться для передачи данных со времен
появления первых компьютеров. Главным преимуществом теле­фонных линий было
наличие уже созданной и развитой инфраструктуры.








</p>
<p>С ее помощью можно
передавать данные между компьютерами, находя­щимися на разных материках, так же
легко, как и вести разговор людям, которые находятся за много тысяч километров
друг от друга. На сего­дняшний день использование телефонных линий также
остается попу­лярным. Пользователи, которых устраивает небольшая скорость
переда­чи данных, могут получить доступ к Internety со своих домашних
компью­теров. Основными недостатками использования телефонного кабеля яв­ляется
небольшая скорость передачи, т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>к. соединение происходит не на­прямую, а через
телефонные станции. При этом требование к качеству передаваемого сигнала при
передаче данных значительно выше, чем при передаче "голоса". А так
как большинство аналоговых АТС не справляется с этой задачей (уровень
"шума", или помех, и качество сигнала оставляет желать лучшего), то
скорость передачи данных очень низкая. Хотя при подключении к современным
цифровым АТС можно получить высокую и надежную скорость связи.

</p>
<p>Коаксиальный кабель использовался в сетях еще несколько лет назад, но
сегодня это большая редкость. Такой тип кабеля по строению практически
идентичен обычному телевизионному коаксиальному кабелю - центральная медная
жила отделена слоем изоляции от оплетки. Некоторые отличия есть в электрических
характеристиках (в телевизион­ном кабеле используется кабель с волновым
сопротивлением 75 Ом, в се­тевом — 50 Ом).

</p>
<p>Основными недостатками этого кабеля является низкая скорость передачи
данных (до 10 Мбит/с), подверженность воздействиям внешних помех. Кроме того,
подключение компьютеров в таких сетях происходит параллельно, а значит,
максимальная возможная скорость пропускания делится на всех пользователей. Но,
по сравнению с телефонным кабелем, коаксиал позволяет объединять близко
расположенные компьютеры с намного лучшим качеством связи и более высокой скоростью передачи
данных.

</p>
<p>Витая пара ("twisted pair") - наиболее распространенное средство для передачи данных между
компьютерами. В данном типе кабеля использу­ется медный попарно скрученный
провод, что позволяет уменьшить ко­личество помех и наводок, как при передаче
сигната по самому кабелю, так и при воздействии внешних помех.

</p>
<p>Существует несколько категорий этого кабеля. Перечислим основные из них.
Cat 3 - был
стандартизирован в 1991 г., электрические характеристики позволяли поддерживать
частоты передачи до 16 МГц. использовался для передачи данных и голоса. Более
высокая категория -Cat 5, была специально
разработана для поддержки высокоскоростных протоколов. Поэтому его
электрические характеристики лежат в пределах до ЮОМгц. На таком типе кабеля
работают протоколы передачи данных

</p>
<p>10, 100, 1000 Мбит/с. На сегодняшний день кабель Cat5 практически
вытеснил Cat 3. Основное
преимущество витой пары перед телефонными и коаксиальными кабелями - более
высокая скорость передачи данных
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Также использование Cat 5 в большинстве случаев позволяет, не меняя кабельную структуру,
повысить производительность сети (переходом от 10 к 100 и от 100 к 1000
Мбит/с).

</p>
<p>Оптоволокно используется для соединения больших сегментов сети, которые
располагаются далеко друг от друга, или в сетях, где требуется большая полоса
пропускания, помехоустойчивость. Оптический кабель состоит из центрального
проводника света (сердцевины) - стеклянного волокна, окруженного другим слоем
стекла - оболочкой, обладающей меньшим показателем преломления, чем сердцевина.
Распространяясь по сердцевине, лучи света не выходят за ее пределы, отражаясь
от покры­вающего слоя оболочки. Световой луч обычно формируется полупровод­никовым
или диодным лазером. В зависимости от распределения показа­теля преломления и
от величины диаметра сердечника различают:

</p>
<p>•   
одномодовое волокно;

</p>
<p>•   
многомодовое волокно.

</p>
<p>Понятие "мода" описывает режим распространения световых лучей
в сердечнике кабеля. В одномодовом кабеле используется проводник очень малого
диаметра, соизмеримого с длиной волны света. В многомодовом кабеле применяются
более широкие сердечники, которые легче изгото­вить. В этих кабелях в
сердечнике одновременно существует несколько световых лучей, отражающихся от
оболочки под разными углами. Угол отражения луча называется модой луча.
Оптоволокно обладает следую­щими преимуществами: устойчивость к
электромагнитным помехам, вы­сокие скоростные характеристики на больших
расстояниях. Основным недостатком является как дороговизна самого кабеля, так и
трудоемкость монтажных работ, так как все работы выполняются на дорогостоящем
вы­сокоточном оборудовании.

</p>
<p>Физический уровень также отвечает за преобразование сигналов между
различными средами передачи данных. Например, при необходимо­сти соединить
сегменты сети, построенные на оптоволокне и витой паре, применяют так
называемые конверторы (в данном случае они преобразуют световой импульс в
электрический).

</p>
<p>Для включения компьютера в сеть используется специальное уст­ройство -
сетевой адаптер (Network adapter), позволяющий обменивать­ся наборами битов, представленными
электрическими сигналами. Сете­вая карта (так чаще называют сетевой адаптер)
обычно
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>имеет шину ISA или PCI для подключения в
компьютер и соответствующий разъем для подключения к среде передачи данных
(например, для витой пары, коак-сиала и т.п.).








</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="0" height="0"></td>
  <td width="450"></td>
  <td width="45"></td>
  <td width="444"></td>
 </tr>
 <tr>
  <td height="1"></td>
  <td rowspan="3" align="left" valign="top"><center><img width="450" height="444" src="http://kufas.ru/java.files/image051.png"></center></td>
 </tr>
 <tr>
  <td height="303"></td>
  <td></td>
  <td align="left" valign="top"><center><img width="444" height="303" src="http://kufas.ru/java.files/image052.png"></center></td>
 </tr>
 <tr>
  <td height="140"></td>
 </tr>
</table>


Теперь, когда мы знаем, как происходит соединение
компьютеров в одну сеть, рассмотрим варианты физической схемы такой сети, или,
други­ми словами, физической топологии (структуры локальной сети).

<p>Топология "шина"
(bus) показана на рис. 16.4.

</p>
<p>Все компьютеры и сетевые устройства подсоединены к одному про­воду и
фактически напрямую соединены между собой.

</p>
<p>Топология
"кольцо" (ring) показана на рис. 16.5.

</p>
<p>Кольцо состоит из сетевых устройств и кабелей между ними, образу­ющих
одно замкнутое кольцо.

</p>
<p>Топология
"звезда" показана на рис. 16.6.

</p>
<p>Все компьютеры и сетевые устройства подключены к одному цент­ральному
устройству.

</p>
<p>Топология
"расширенная звезда" (extended star) показана на рис. 16.7.

</p>
<p>Такая схема практически аналогична топологии "звезда", за
одним исключением. Каждое устройство соединено с локальным центральным
устройством, а оно, в свою очередь, соединено с центром другой
"звезды".

</p>
<p> 

</p>
<p>Data layer (layer 2)

</p>
<p>Физический уровень пересылает просто набор сигналов - битов. При этом не
учитывается, что несколько компьютеров, подключенных к одной среде передачи
данных (например, к одному кабелю), могут начать одновременно передавать
информацию в виде электрических импульсов,

</p>
<p>35*                                                                547








</p>
<p>Курс




</p>
<p>Программирование на Java




</p>
<p>Лекция
16




</p>
<p>Введение
в сетевые протоколы








</p>
<p> 

</p>
<p>что, очевидно, приведет к смешению сигналов. Поэтому одной из задач Data layer (канальный уровень) является проверка доступности среды пе­редачи. Также
этот уровень отвечает за доставку фреймов между источни­ком и адресатом в
пределах сети с одной топологией. Для обеспечения та­кой функциональности Data layer разделяют на два подуровня:

</p>
<p>•   
логическая передача данных
(Logical Link Control, LLC);

</p>
<p>•   
управление доступом к
среде (Media Access Control, MAC).

</p>
<p>LLC отвечает за переход со второго уровня на более высший — третий сетевой
уровень.

</p>
<p>MAC отвечает за передачу данных на более низкий уровень -Physical layer.

</p>
<p>Рассмотрим эти подуровни
более подробно.

</p>
<p> 

</p>
<p>LLC sublayer

</p>
<p>Этот подуровень был создан для обеспечения независимости от су­ществующих
технологий
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Он обеспечивает обмен данными с сетевым (третьим) уровнем вне
зависимости от физической среды передачи дан­ных. LLC получает данные с сетевого уровня, добавляет в них служебную информацию
и передает пакет для последующей инкапсуляции и обра­ботки протоколом уровня MAC. Например, это может быть Ethernet, Token Ring, Frame Relay.

</p>
<p> 

</p>
<p>MAC sublayer

</p>
<p>Этот подуровень обеспечивает доступ к физическому уровню. Для передачи
пакетов по сети необходимо организовать идентификацию ком­пьютеров в сети. Для
этого у каждого компьютера на канальном уровне определен уникальный адрес,
который еще иногда называют физическим адресом, или МАС-адресом.

</p>
<p>Он записан в энергонезависимой памяти сетевой карты и задается
производителем. Длина МАС-адреса 48 бит, или 6 байт (каждый байт со­стоит из 8
бит), которые записываются в шестнадцатеричном формате. Первые 3 байта
называются OUI (Organizational Unique Identifier), орга­низационный уникальный идентификатор. Этот номер выдается каждо­му
производителю сетевого оборудования международной организаци­ей IEEE (Institute of Electrical and Electronic Engineers, Институт инжене­ров по электротехнике и радиоэлектронике, источник
многих стандар­тов и спецификаций). Последние 3 байта являются идентификацион­ным
номером самой сетевой карты. Производитель гарантирует, что все его адаптеры
имеют различные номера. Такая система адресов гаранти­рует, что в сети не будет
двух компьютеров с одинаковыми физическими адресами.

</p>
<p>Записываться физический адрес может в разных форматах, например:
00:00:В4:90:4С:8С, 00-00-В4-90-4С-8С, 0000.В490.4С8С - разные про­изводители
используют разные стандарты. Рассмотрим, например, адрес 0000.1 с 12.3456.
Здесь 0000.1с — идентификатор производителя, а 12.3456 — идентификатор сетевой
карты.

</p>
<p>Один из самых распространенных протоколов М AC-уровня - протокол Ethernet. В сетях, построенных на его основе, применяется специальный метод для
организации доступа к среде передачи данных - CSMA/CD (cani-er sense multiply access/collision
detect, коллективный доступ с
опознаванием несущей и обнаружением коллизий). Предполагается, что основой сети
явля­ется общая шина (например, коаксиальный кабель), к которой подключены все
компьютеры. В результате сообщение, отправленное одной машиной, до­ставляется
всем подключенным сетевым устройствам
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> CSMA/CD описывает целый
комплекс мер, необходимых для предотвращения и корректной обра­ботки коллизий (collision), то есть ситуаций, когда несколько компьютеров одновременно начали
передачу данных. Очевидно, что в таком случае никто не сможет получить
корректную информацию из сети.

</p>
<p>Рассмотрим более подробно процесс передачи данных на Data layer. Пусть один компьютер собирается послать данные другому. Во время
процесса инкапсуляции МАС-адрес этой машины и МАС-адрес получа­теля будут
записаны в служебные поля. Сгенерированное сообщение по правилам протокола Ethernet отсылается через общую шину всем маши­нам, подключенным к этому участку
сети.

</p>
<p>Каждый компьютер, получивший сообщение, проверяет, кому оно было
адресовано. Если МАС-адрес, указанный во фрейме, и МАС-адрес, записанный в
сетевом адаптере получателя, совпадают, то пакет прини­мается и передается на
вышестоящий уровень для дальнейшей обработки. Если же адрес в пакете не
совпадает с адресом сетевой карты, то такой па­кет отбрасывается.

</p>
<p>Иногда бывает необходимо послать сообщение, которое должно быть получено
всеми узлами локальной сети. В этом случае в пакете ука­зывается МАС-адрес
получателя в виде FF-FF-FF-FF-FF-FF.
Этот адрес используется
для широковещания (broadcast), которое примут все сетевые устройства и передадут на вышестоящий
уровень.

</p>
<p>Рассмотрим устройства, применяемые для построения сетей в разных
топологиях.

</p>
<p>Топология шина ("bus")
описывает общую среду
передачи данных, которая уже рассматривалась для иллюстрации протокола Ethernet. Спе­циальных устройств для построения такой сети не используется
(впрочем, конкретные технологии могут предъявлять специфические требования;
например, концы коаксиального кабеля должны подключаться к особому устройству —
терминатору, но это не влияет на структуру сети).








</p>
<p>На топологии кольцо ("ring") основывается
протокол Token Ring. Физически сеть представляет собой замкнутое кольцо, в котором каждый
компьютер двумя отрезками кабеля соединяется со своими соседями. В отличие от
сети, работающей на основе Ethernet, здесь используется более сложная схема. Передача ведется последовательно
по кольцу в одном направлении. В сети циркулирует кадр специального формата —
маркер (token). Если машина не имеет данных для передачи, она при получении маркера
передает его дальше по кольцу
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> В противном случае она изымает его из обращения,
что дает ей доступ к сети, и затем отправляет пакет с адресом получателя,
который начинает передаваться по кольцу. Когда он доходит до адресата, тот
делает пометку, что пакет получен. Машина-отправитель, по­лучив подтверждение,
отправляет соседу новый маркер для обеспечения возможности другим станциям сети
передавать данные. Хотя этот алгоритм более сложен, он обеспечивает свойства
отказоустойчивости.

</p>
<p>При построении сети на основе топологии "звезда" нужно
использовать, кроме сетевых карт в компьютере, дополнительное сетевое
оборудование в центре, куда подключаются все "лучи звезды". Например,
в качестве такого устройства может применяться концентратор (hub). В этом случае
каждый компьютер подключается к нему с помощью кабеля "витая пара".
Алгоритм работы концентратора очень прост — получив пакет на один из своих
портов, он пересылает его на все остальные. В результате снова получается общая
шина, точнее, - логическая общая шина, поскольку физическая структура сети
звездно-образная. Технология Ethernet позволяет снизить
количество коллизий с помощью CSMA/CD. Недостатком концентратора является то, что пользователи сети могут
"прослушивать" чужой трафик (в том числе перехватить пароль, если он
передается в открытом виде). Общая максимальная скорость делится между всеми подключенными
пользователями. То есть, если скорость передачи данных составляет 10 Мбит/с, то
в среднем на каждого пользователя может приходиться всего 2 Мбит/с.

</p>
<p>Более дорогим, но и более производительным решением является
использование коммутатора (switch). Коммутатор, в отличие от концент­ратора, имеет в памяти таблицу,
сопоставляющую номера его портов и МАС-адреса подключенных к нему компьютеров.
Он анализирует у каж­дого пересылаемого фрейма адрес отправителя, пытаясь
определить, ка­кие машины подключены к каждому из его портов. Таким образом ком­мутатор
заполняет свою таблицу. Далее при прохождении очередного фрейма он проверяет
адрес получателя, и если он знает, к какому порту подключена эта машина, он
посылает фрейм только на один этот порт. Если адрес получателя коммутатору
неизвестен, то он отправляет фрейм на все порты, кроме того, с которого этот
пакет пришел
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Таким образом, получается, что если два компьютера обмениваются
данными между со­бой, то они не перегружают своими пакетами другие порты и, соответст­венно,
их пакеты практически невозможно перехватить.

</p>
<p>Построенные таким образом сети могут охватывать несколько сотен машин и
иметь протяженность в несколько километров. Как правило, такая сеть охватывает
одно или несколько зданий одного предприятия, а потому называется локальной
сетью (Local area network, LAN).

</p>
<p> 

</p>
<p>Network layer (layer 3)

</p>
<p>В предыдущей лекции мы рассмотрели второй уровень в модели OSI. Одним из
ограничений этого уровня является использование "плоской"
одноуровневой модели адресации. При попытке построить большую сеть, применяя
для идентификации компьютеров МАС-адреса, мы получим ог­ромное количество broadcast-трафика. Протокол, который поддерживает­ся третьим уровнем, задействует
иерархическую структуру для уникальной идентификации компьютеров.

</p>
<p>Для примера представим себе телефонную сеть. Она также имеет
иерархическую адресацию. Например, в номере +7-095-101-12-34 первая цифра
обозначает код страны, далее идет код области/города(095), а затем указывается
сам телефон (101-12-34). Последний номер также является составным. 101 - это
код станции, куда подключен телефон, а 12-34 определяет местоположение
телефона. Благодаря такой иерархической структуре мы можем определить
расположение требуемого абонента с наименьшими затратами. Иерархическая
адресация для компьютерной сети также должна позволять устанавливать связь
между разрозненными и удаленными сетями.

</p>
<p>На сетевом уровне (Network layer) существует
несколько протоколов, которые позволяют передавать данные между сетями.
Наиболее распространенным из них на сегодняшний день является IP. Его предше­ственник,
протокол IPX, сейчас уже практически не используется в пуб­личных сетях, но его
можно найти в частных, закрытых сетях.

</p>
<p>Основное устройство, применяемое на 3-м уровне, называется роутером (router), или
маршрутизатором. Он соединяет удаленные локальные сети (LAN), образуя
глобальную сеть (Wide area network, WAN). Роутер имеет два или более сетевых интерфейса и таким образом
подключен сразу к нескольким локальным сетям. Получив пакет с локального
устройства или компьютера, принадлежащего к одной из LAN, роутер про­сматривает
заголовок третьего уровня
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> На основании полученной информа­ции роутер принимает
решение, что делать с пакетом. Если получатель па­кета находится в той же
локальной сети, что и отправитель, роутер игнори­рует его, поскольку сообщение,
как уже рассматривалось, доставляется средствами более низкоуровневых
протоколов (например, Ethernet).

</p>
<p>В противном случае пакет нужно передать в одну из других LAN, к которым
подключен роутер. Основная задача этого устройства — выбор пути, по которому
будет пересылаться сообщение. Поскольку может су­ществовать множество связей
между некоторыми двумя сетями отправи­теля и получателя, роутер должен выбрать
наиболее оптимальный путь. Пересылка пакета от одного узла сети к следующему
называется hop (до­словно —
прыжок, скачок). Выбор очередного узла, которому роутер пе­решлет сообщение,
может зависеть от многих факторов - загрузка сети, наименьший путь до
получателя, стоимость трафика по различным мар­шрутам и т.д.

</p>
<p>Новая система адресации, вводимая на сетевом уровне, должна об­легчать
роутеру определение пути для доставки пакета через глобальные сети. Рассмотрим
реализацию наиболее популярного на сегодняшний день протокола IP более подробно.

</p>
<p>При прохождении данных с верхних уровней на нижние на сетевом уровне к
пакету добавляется служебный заголовок этого уровня. В заголов­ке IP-пакета содержится
необходимая для дальнейшей передачи информа­ция, такая как адреса отправителя и
получателя. Понятие IP-адреса очень важно для понимания работы глобальных сетей, поэтому
остановимся на нем более подробно.

</p>
<p> 

</p>
<p>IP-адрес

</p>
<p></p>
<center><img width="430" height="143" src="http://kufas.ru/java.files/image053.png"></center>
IP-адрес
представляется 32-битным бинарным числом, которое часто записывают в виде 4
десятичных чисел, от 0 до 255 каждое. Например: 60.13.54.11, 130.154.201.1, 194.11.3.200. Логически он
состоит из двух частей — адреса машины (host) и адреса сети (network). Сетевая часть IP-адреса показывает,
к какой сети принадлежит адресат, а хост-часть (host) идентифицирует
сетевое устройство в этой сети. Компьютеры с одинаковой сетевой частью
находятся в одной локальной сети, а потому могут легко обмениваться данными.
Если же у них различ­ные network-ID, то, даже находясь в одном физическом сегменте, они обычно не могут
"увидеть" друг друга.

<p>Так как 1Р-адрес состоит из 4-х октетов (так называют эти числа, поскольку 2 56=28), один, два или три первых октета могут использоваться для определения
сетевого адреса, остальные задают 1ю51-части
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Для удобства
выделения адресов пользователям (ведь, как правило, организации требуется их
сразу несколько), было введено 5 классов адресов. Их обозначают латинскими
буквами от А до Е. В открытых сетях используются первые три из них.

</p>
<p>В таблице 16.2 дано примерное разбиение 1Р-адресов на сетевую (ГМ) и
машинную (Н) части в зависимости от класса сети.

</p>
<p> 

</p>
<p>Класс А

</p>
<p>В классе А для идентификации сети, к которой принадлежит адрес,
используется первый октет, причем, первый бит всегда равен 0. Осталь­ные октеты
задают адрес хоста. Таким образом, адрес сети класса А может быть в диапазоне 0-126. 127-й адрес зарезервирован
для специального использования — все адреса, начинающиеся со 127, считаются
локальными для сетевого адаптера, то есть всегда отправитель сам является и
получате­лем. Остальные свободные три октета применяются для задания адреса хо­ста
в данной сети. Это означает, что в одной сети может быть использовано до 224 адресов (из них два крайних, то есть 0 и 224-1, зарезервированы, они рассматриваются ниже). Стало быть, в каждой из 127 сетей класса А
можно адресовать 16,777,214 машин.

</p>
<p>Диапазон адресов 10.0.0.0-10.255.255.255 в публичных сетях
не используется. Эти адреса специально зарезервированы для применения в
локальных сетях и глобальными маршрутизаторами не обрабатываются.

</p>
<p> 

</p>
<p>Класс В

</p>
<p>В сети класса В первые два октета (причем, первый бит всегда равен 1, второй - 0) используются для определения сети, последние два октета — для
определения адреса хоста. Диапазон адресов сети класса В лежит в пределах от 128.0.х.хдо 191.255.х.х, что дает 16,384 таких сетей. В
каждой из них может быть не более 65,534=2'6-2 адресов (два
крайних адреса ис­ключаются).

</p>
<p>В этой подсети зарезервированными для локального использования являются
следующие адреса: 172.16.0.0-172.31.0.0.

</p>
<p> 

</p>
<p>Класс С

</p>
<p>Диапазон сети класса С определяется первыми тремя октетами (первые биты
всегда 110). И в десятичном виде
эта сеть может начинаться со 192 по 223. Для определения адреса хоста
используется последний октет. Таким образом, в каждой из 2,097,152 сетей класса
С может был, задействовано 28 (без двух крайних) или 254 адреса.

</p>
<p>Зарезервированными для локального использования являются следующие
адреса: 192.168.0.0-192.168.255.255.

</p>
<p> 

</p>
<p>Class D

</p>
<p>Этот класс используется для особых задач (multicast-группы). Диапазон адресов - 224.0.0.0-239.255.255.255.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p> 

</p>
<p>Class E

</p>
<p>Этот класс адресов зарезервирован для применения в будущем. Диапазон
адресов - 240.0.0.0-247.255.255.255.

</p>
<p>Два адреса в каждой подсети являются зарезервированными. ІР-адрес, в котором вся хост-часть состоит из бинарных нулей, используется для
обозначения адреса самой сети. Например, сеть класса А может иметь адрес
112.0.0.0, а компьютер, подкпюченный к ней, - адрес 112.2.3.4. Адрес сети
используется роутерами для задания маршрута.

</p>
<p>Второй зарезервированный адрес - броадкаст-адрес (broadcast). Этот адрес применяется, когда источник хочет послать данные всем уст­ройствам
в локальной сети. Для этого хост-часть заполняется бинарными единицами.
Например, для рассмотренной сети 112.0.0.0 это будет адрес 112.255.255.255, а
для сети юіасса В 171.10.0.0 броадкаст-адрес будет выглядеть как 171.10.255.255. Данные,
посланные по адресу 171.10.255.255, будут получены всеми устройствами в сети
171.10.0.0.

</p>
<p> 

</p>
<p>Подсети. Маска подсети

</p>
<p>Введение классов сетей во многом упростило задачу распределения адресов
по организациям. Но не всегда имеет смысл использовать, на­пример, целую сеть
класса С, если в ней реально будет размещено лишь 10 компьютеров. Для более
рационального использования сетей органи­зуют подсети.

</p>
<p>Адрес подсети включает в себя сетевую часть от сети ктасса А, В или С и
так называемое поле подсети (subnet field). Для этого значения выделяют дополнительные биты, принадлежащие
хост-части (то есть для адреса подсети может быть использовано до 3-х октетов
из сети класса А, до 2-х из сети класса В, и I для С, соответственно). Таких
битов может быть минимально один (таким образом одна сеть разделяется на две
подсети), а максимально столько, чтобы для хост-части оставалось еще два бита
(иначе подсеть будет состоять лишь из двух служебных адресов ­адреса подсети и
броадкаст-адреса). Для сетей ктасса А это дает от 1 до 22 битов, для В — от 1
до 14 битов, для С — от 1 до 6.

</p>
<p>Разбиение на подсети уменьшает также размеры броадкаст-доменов, что
необходимо, иначе для сети класса А броадкаст-запрос может рассы­латься на 16
миллионов компьютеров. И если каждый из них пошлет хотя бы по одному такому
запросу, нагрузка на сеть будет чрезмерно большой. Если же компьютер находится
в выделенной подсети, то в соседние сети и подсети роутер пересылать
броадкаст-запрос не будет, вследствие чего экономится полоса пропускания
физических каналов связи.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Для определения длины адреса подсети используется специальное понятитие
— маска подсети. Это число определяет, какая часть IP-адреса применяется
для задания сетевой и подсетевой части. Маску подсети можно определить
следующем образом. Запишем !Р-адрес в бинарном виде. Все разряды, относящиеся к
network- и subnet-части, заменим на 1, все значения, относящиеся к host-части,- на 0. В
результате получим мас­ку подсети.

</p>
<p>Например, маска подсети для целой сети класса А будет выглядеть как
255.0.0.0, для сети класса В: 255.255.0.0, для сети ктасса С -255.255.255.0.
Для разделения на подсети, как было сказано выше, нужно некоторые биты
хост-части выделить для поля подсети. Например, маска 255.255.255.192
определяет подсеть класса С, для которой количество хостов будет равно 62.

</p>
<p> 

</p>
<p>Протоколы ARP, RARP

</p>
<p>Когда формируется пакет для отправления, на сетевом уровне закла­дывается
IP-адрес получателя. Однако для передачи иа нижестоящий ка­нальный уровень
также нужно знать МАС-адрес. Для определения соответ­ствия IP-адресу МАС-адреса
существует ARР-протокол (Address
Resolution Protocol, протокол определения адресов). Он работает следующим образом.

</p>
<p>Формируется специальный широковещательный (broadcast) запрос. Он рассматривался выше, ею особенность в том, что ею получают
все ус­тройства, подключенные к этой локальной сети. В таком запросе МАС-адрес
получателя состоит из одних бинарных единиц, а в поле IP-адреса записы­вается
именно тот адрес, для которого требуется отпределить МАС-адрес. Когда некий
компьютер получает такой запрос, он сравнивает указанный IP-адрес со своим.
Если они различаются, сообщение игнорируется. Если они равны, то формируется
ответ, в котором по всем правилам указаны IP-и МАС-адреса
отправителя, то есть искомой машины.

</p>
<p>Для того, чтобы не нагружать широковещательными запросами сеть, ARP-протокол
поддерживает специальную ARP-таблицу, которая нахо­дится в оперативной памяти и хранит соответствие
между IP- и МАС-ад­ресами. После удачного определения МАС-адреса какого-нибудь
узла се­ти делается соответствующая запись в таблицу, чтобы при следующей от
-сылке пакета не пришлось снова рассылать broadcast-запросы. Спустя не которое время запись удаляется
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Это позволяет
автоматически подстраи­ваться под изменения в сети, ведь у какого-то узла могли
изменить MAC или IP-адрес. Если
отправитель не находит IP-адрес получателя в ARP таблице, то снова формируется и отправляется ARP-запрос.

</p>
<p>Протокол RARP (Reverse ARP - обратный ARP) действует
наоборсм — он известному МАС-адресу сопоставляет IP-адрес. Это
необходимо, например, для работы таких протоколов, как ВООТР (Bootstrap Protocol, протокол автоматической настройки) и DHCP (Dynamic Ном Configuration Protocol, протокол динамической конфигурации хостов). Их назначение — облегчить
задачи системному администратору. Они поз­воляют не вводить IP-адрес в каждый
компьютер локальной сети, а на­значают их сами в автоматическом режиме. При
загрузке очередной ма­шины посылается broadcast-запрос — противоположный ARP-запросч Если в ARP-запросе идет опрос
"IP получателя
известен, MAC получате ля -
???", то в RARP-запросе "MAC получателя
известен, 1Р - ???". Если в сети есть DHCP-сервер, он
отвечает на RARP-запрос, указывая IP-адрес для этого компьютера (особенно это эффективно при большом
количест­ве компьютеров).

</p>
<p>Оба эти протокола работают в рамках лишь локальной сети, по­скольку все
пакеты, направляемые в другие сети, обрабатываются и мар шрутизируются
роутсром, поэтому знать МАС-адрес не требуется (отпра­витель указывает
МАС-адрес самого роутера).

</p>
<p> 

</p>
<p>Transport layer (layer 4)

</p>
<p>Рассмотрим протокол 4-го транспортного уровня модели OSI. Се мейство TCP/IP
включает в себя два таких протокола - TCP и UDP. TCP (Transmission Control Protocol, протокол управления передачей) обеспечи­вает виртуальные соединения
между пользовательскими приложениями и гарантирует точную доставку данных. UDP (User Datagram Protocol, протокол передачи
датаграмм пользователя) служит для быстрого обмена специальными сообщениям
(датаграммами) без гарантии доставки.

</p>
<p>Основные характеристики TCP и UDP показаны втабл.
16.3.

</p>
<p> 

</p>
<p>TCP

</p>
<p>TCP/IP представляет собой комбинацию двух уровней, TCP и IP. IP — протокол третьего
уровня — обеспечивает наилучшую, но не гарантиро­ванную доставку данных через
сеть. TCP — протокол
четвертою уровня ­позволяет эту гарантию обеспечить. Поэтому совместно они
могут предо­ставить большее количество сервисов.

</p>
<p>Работа по TCP-протоколу начинается с установления соединения. Два компьютера (один из
них инициатор соединения, второй — принима­ющий) обмениваются специальными
пакетами в три этапа
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Условно их можно назвать "запрос",
"подтверждение" и "подтверждение на подтверж­дение". Такая
процедура необходима, чтобы при получении какого-ни­будь старого пакета
(например, делается вторая попытка установить со­единение) не возникало никаких
неоднозначностей.

</p>
<p>После успешного установления соединения участники могут начать
обмениваться данными. Рассмотрим пример HTTP-сервера, который
от­правляет HMTL-страницу клиенту. Текст может быть слишком длинным, чтобы уместиться в
один пакет, поэтому первая задача уровня TCP - раз­бить сообщение на несколько пакетов, а на стороне отправителя — со­брать
их опять в единое целое. Поскольку очередность пакетов несомнен­но важна,
каждый получает порядковый номер.

</p>
<p>Следующая задача протокола 2 — обеспечить гарантированную до­ставку.
Делается это с помощью следующей процедуры. Отправитель посы­лает пакет с
номером п и начинает ждать. Получатель в случае успешного прихода пакета п,
отправляет подтверждение о получении ("квитанцию"), в котором также
указывает номер п. Если отправитель в течение определенн-ного времени
(тайм-аута) не получает подтверждения, он считает пакет п потерянным и отсылает
его еще раз.

</p>
<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="22" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="432" height="241" src="http://kufas.ru/java.files/image054.png"></center></td>
 </tr>
</table>


Разумеется, отправителю неэффективно просто ждать, пока
полу­чатель получит и обработает каждый пакет по одному. Поэтому проце­дура
усложняется, вводится специальное понятие — "окно" (window).








<p>Окно имеет
некоторый размер, предположим, 10. Это означает, что пе­редача начинается с
отсылки 10 первых пакетов. Получатель можег принять их не в том порядке, в
каком они были отосланы. Тем не менее, на каждый успешно полученный пакет
отсылается подтверждение с ука­занием номера такого пакета. Если отправитель
отослал уже все 10 па­кетов, но квитанция о получении пакета 1 так и не пришла,
то передача приостанавливается, а по прошествии тайм-аута первый пакет считает­ся
потерянным и пересылается еще раз. Если же подтверждения прихо­дят регулярно,
то отправляются новые пакеты, но не более 10 единовре­менно.

</p>
<p>Этот алгоритм носит название "скользящего окна". Если
представить, что все пакеты выстроены в ряд, то окно "скользит" по
нему, определяя, какие пакеты готовы для отсылки
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Такой подход обеспечивает
гарантированную доставку при максимально возможной скорости передачи данных.
Разумеется, протокол TCP работает не столь
быстро, ведь часть пропускной способности сети тратится на пересылку квитанций
и повторов потерянных пакетов. Однако, большое количество информации требуется
доставлять именно таким образом. Понятно, что части, например, текста должны
составляться в строгом порядке и без пропусков. Были разработаны специальные
механизмы, автоматически регулирующие величины таких характеристик, как
тайм-аут и размер окна, для достижения оптимальной производительности.

</p>
<p> 

</p>
<p>UDP

</p>
<p>В отличие от TCP, UDP не гарантирует
доставку данных. UDP не ус­танавливает
виртуального соединения, источник просто шлет специаль­ные сообщения (в UDP они называются датаграммами) получателю. Ес­ли данные были доставлены
некорректно, или вообще часть пакетов по­терялась, UDP не позволяет их восстановить. Запрос на получение дан­ных должен будет
выполняться заново.

</p>
<p>Казалось бы, недостатков у такого протокола довольно много, что ставит
под сомнение его эффективность. Но есть сервисы, где UDP неза­меним. Например, при передаче потокового аудио-видео если бы мы ис­пользовали
TCP, то при потере одного пакета у нас была бы приостанов­лена трансляция
для его повторной передачи. При использовании UDP один потерянный пакет - всего лишь незначительное (наверняка, вооб­ще
незаметное пользователю) ухудшение изображения/звука, при этом передача данных
не прерывается. Также при использовании UDP не обя­зательно устанавливать виртуальное соединение, не нужно отсылать
кви­танции — все это ускоряет работу протокола.

</p>
<p>Порты

</p>
<p>Как было рассмотрено, для протокола IP достаточно знать IP-адрес, чтобы обработать сообщение. Оба протокола транспортного уровня, TCP и UDP, дополнительно используют порты (port) для
взаимодействия с выше­стоящими уровнями. Порт описывается числом от 0 до 65535
и позволяет операционной системе распределять пакеты, приходящие на
транспортный уровень, между различными прикладными программами. Предположим,
пользователь одновременно скачивает файл с FTP-сервера и работает
с уда­ленным сервером базы данных. От обоих этих серверов пользовательская
машина будет получать по сети пакеты и необходимо правильно передавать их
соответствующим приложениям (FTP-клиенту и БД-клиенту).

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Часть портов зарезервирована под стандартные приложения. Например, для FTP зарезервирован порт 21, для telnet - 23, для HTTP -80. Далее приведен
список распределения портов:

</p>
<p>•   
порты меньше 255
используются для публичных сервисов;

</p>
<p>•   
порты из диапазона
255-1023 назначаются компаниями-разрабо-чиками для приложений;

</p>
<p>•   
номера свыше 1023 - не
регулируемые.

</p>
<p>Таким образом, говоря об установленном TCP-соединении, имеют
ввиду 4 числа: IP-адрес и порт одной сторны и те же параметры второй стороны. Например,
если пользователь со своей машины 194.11.22.33 обратился через браузер к web-серверу
213.180.194.129, то это означает, что установлено соединение
194.11.22.33:10123-213.180.194.129:80 (но­мер 10123 выбран произвольно -
используется любой незанятый порт).

</p>
<p>Используется также термин "сокет" (socket), под которым
подразуме­вается пара "!Р-адрес:порт" — адресная "точка"
для сетевых обращений.

</p>
<p> 

</p>
<p>Session layer (layer 5)

</p>
<p>После транспортного уровня пакет поступает на уровень сессий. Когда
приложения, запущенные на различных машинах, начинают взаи­модействовать через
сеть, то между ними происходит множество мини-"переговоров", обменов,
диалогов, из которых и состоит сетевая сессия.

</p>
<p>Session layer координирует установление и завершение соединений и сессий между
приложениями.

</p>
<p>Presentation layer (layer 6)

</p>
<p>Этот уровень отвечает за представление данных, пересылаемых по сети. Он
обеспечивает следующую функциональность: data formatting (presentation, то есть преобразование данных в понятный получателю формат), data encryption (шифрование), data compression (сжатие данных).

</p>
<p>Presentation layer выполняет одну или
все эти функции во время передачи сообщений между 7-м и 5-м уровнями. Приведем
пример использования уровня представлений.

</p>
<p>Предположим, хост-получатель использует EBCDIC (кодировка, применяемая на крупных IBM-серверах для
передачи символов в виде чисел), а хост-отправитель - ASCII (традиционная кодировка для персо­нальных компьютеров). Presentation layer будет обеспечивать
преобразо­вание пересылаемых данных между этих машинами.

</p>
<p>Для обеспечения безопасности при передаче частной информации через
публичные сети необходимо шифрование данных. Один из распро­страненных
протоколов, используемых для этой цели, - SSL (Secured Sockets Layer) — может быть
отнесен к уровню представлений.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Если канал связи обладает низкой пропускной способностью, целесообразно
применять компрессию данных. Представительский уровень, используя
математические алгоритмы, позволяет уменьшить объем передаваемых данных. Что
касается высокоскоростных каналов, то для них использование компрессии может
потребовать значительных вычислительных мощностей при больших объемах трафика.

</p>
<p> 

</p>
<p>Application layer (layer 7)

</p>
<p>Последний уровень - уровень приложений, на котором определяют­ся
взаимодействующие стороны, учитывается авторизация пользователя, определяется
качество обслуживания (quality of servive) и, собственно, обеспечивается выполнение прикладных задач, таких, как
обмен файла­ми, электронными письмами и т.д. Уровень приложения - это не само
приложение, хотя зачастую программы выполняют некоторые функции Application layer.

</p>
<p>Уже упоминались многие протоколы этого уровня: FTP, HTTP, telnet. Этот список легко
продолжить, например, протоколы РОРЗ и SMTP для получения и отправки электронных писем, или протоколы DNS (Domain Name System, служба имен
доменов), обеспечивающие преобразование числовых IP-адресов в
текстовые доменные имена и обратно. Хотя Internet с технической точки зрения построен на основе IP-адресации,
текстовые имена понятнее и легче запоминаются, а потому гораздо более
распространены среди обычных пользователей.

</p>
<p>Рассмотрим принцип работы DNS более подробно. Все привыкли об­ращаться к, например, web-серверам по
доменному имени. С другой сторо­ны для установления соединения требуется IP-адрес. Так, при
обращении к cepBepywww.ru устанавливается TCP-соединение с
хостом 194.87.0.50.

</p>
<p>Поскольку в сети огромное количество серверов, DNS-имена являют­ся
иерархическими, иначе с ними было бы очень затруднительно работать.

</p>
<p>Иерархические части имени
записываются через точку. Первый уровень указывается последним. Первоначально
существовало 7 трехбуквенных до­менов первого уровня:

</p>
<p>•   
сот - commercial (коммерческие организации);

</p>
<p>•   
org — non-profit (некоммерческие организации);

</p>
<p>•   
net - network service (организация работы сети);

</p>
<p>•   
edu — educational (образование, зачастую — американские универ­ситеты);

</p>
<p>•   
int — internatjonal (международные организации);

</p>
<p>•   
gov — government (правительство, организации американского правительства);

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>•   mil - military (военные, американские военные организации). Кроме того, для каждой
страны был заведен двухбуквенный домен,

</p>
<p>например, ru - Россия, su - СССР, us - США, fr - Франция и т.д. В
по­следнее время вводятся новые доменные имена верхнего уровня, такие, как biz и info.

</p>
<p>В каждом домене первого уровня может быть множество доменов вто­рого
уровня. Так, существует множество сайтов в домене ru, или сот. У до­мена
второго уровня может быть множество доменов третьего уровня и т.д.

</p>
<p>Как же определить, какому IP-адресу
соответствует доменное имя сервера, к которому обращается пользователь? Для
этого существует аналогичная иерархическая система DNS-серверов, каждый
из которых отвечает за свой домен. В сетевых настройках компьютера указывается адрес
локального DNS-сервера. При запросе к нему сервер сначала проверяет список имен, за
которые отвечает он сам, и кеш. Если искомое имя ему неизвестно, он делает
запрос вышестоящему DNS-серверу. Например, при обращении к intuit.ru будет сделан запрос
к DNS-серверу, отвечающему за домен ru.

</p>
<p>В свою очередь, сервер intuit.ru знает про все имена
в своей зоне intuit.ru, либо, в случае обращения к домену следующего уровня (напри­мер, node1.host1.intuit.ru), знает адрес другого сервера (host1.intuit.ru), который за него отвечает, и на этот сервер перенаправляет запрос.

</p>
<p>Таким образом можно установить IP-адрес для любого
зарегистри­рованного доменного имени.

</p>
<p>Утилиты для работы с сетью

</p>
<p>Рассмотрим основные программы, позволяющие читать и изменять сетевые
параметры, диагностировать и выявлять ошибки при работе сети.

</p>
<p>В различных ОС существуют свои наборы утилит. Сравним их для двух
систем, например, Microsoft Windows
NT и Sun Solaris. Какими бы разными ни были эти ОС, в каждой из них реализована модель OSI.








</p>
<p>Естественно,
программная и аппаратная реализация стека этой модели у
них различается, но взаимодействие всех уровней осуществляется Ло
установленному стандарту.                                                                           чвляс!ся по
используется команда агр. Например, агр -а выводит все известные МАС-адреса.








</p>
<p> 

</p>
<p>IPCONFIG (IFCONFIG)

</p>
<p>Начнем с утилиты, которая позволяет просматривать,
проверять и изменять сетевые настройки. Обычно эти настройки включают в себя
информацию 3-го (сетевого) уровня — IP-адрес, маску
подсети и т
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>д. Для работы с ними в ОС Windows можно использовать команду ipconfig. Она выдает
информацию об IP-адресе, маске подсети (netmask), роутере по умолчанию (default gateway). Задав дополнительный параметр -all, можно получить
более подробную информацию - имя компьютера, имя домена, тип сетевой карты,
МАС-адрес и т.д.

</p>
<p></p>
<center><img border="0" width="349" height="185" src="http://kufas.ru/java.files/image055.jpg"></center>



<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="10">
 <tr>
  <td valign="top" align="left" height="10">
  <p>bash-2".fl3tt  ifcoсfiT"—™
  </p>
</td>
 </tr>
</table>







<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="88">
 <tr>
  <td valign="top" align="left" height="88">
  <p></p>
<center><img border="0" width="407" height="88" src="http://kufas.ru/java.files/image056.jpg"></center>
  </td>
 </tr>
</table>





<p>ВОС5о1аш для получения 1Р-адреса и прочих сетевых
настроек ис-
пользуется команда 1Ыё. Она также показывает название интерфейса
1Р-адреса, маску подсети, МАС-адрес.                                                               ерщеиса,

</p>
<p>АЯР

</p>
<p>Как уже было сказано
ранее, в оперативной памяти компьютера находится АКР-таблица. В ней содержатся
МАС-адрес удаленной
машины и соответствующий ему 1Р-адрес. Для просмотра
этой ™блИЦЬ1

</p>
<p></p>
<center><img border="0" width="384" height="66" src="http://kufas.ru/java.files/image057.jpg"></center>

<p>Существует два типа записей в АРчР-таблице -
статический и динамический. Статическая запись вносится вручную и существует до
тех пор, пока вручную же не будет удалена, или компьютер (маршрутизатор) не
будет перезагружен.

</p>
<p>Динамическая запись появляется при попытке отправить сообщение на
1Р-адрес, для которого неизвестен МАС-адрес. В этом случае формиру­ется
АЯР-запрос, который позволяет этот адрес определить, после чего со­ответствующая
динамическая запись добавляется в АЯР-таблицу. Хра­ниться там она будет не
постоянно. После определенного времени она бу­дет автоматически удалена, если к
данному 1Р-адресу не было обращений. Задержка на получение МАС-адреса
составляет порядка нескольких мил­лисекунд, так что для пользователя это будет
практически незаметно, зато появляется возможность отследить изменения в
конфигурации сети (в со­ответствии 1Р- и МАС-адресов).

</p>
<p> 

</p>
<p>Ping

</p>
<p>Для выявления различных неполадок в сети существует несколько утилит,
которые позволяют определить, на каком уровне модели OSI произошел сбой, или
указаны неверные настройки сетевых протоколов. Одна из таких утилит — ping.

</p>
<p>Эта утилита позволяет определить ошибки на сетевом уровне (layer 3), используя протокол ICMP (Internet Control Message Protocol) — прото­кол межсетевых управляющих сообщений. Формат использования
этой утилиты довольно прост: ping 194.87.0.50 (где 194.87.0.50 - IP-адрес

</p>
<p></p>
<center><img border="0" width="371" height="107" src="http://kufas.ru/java.files/image058.jpg"></center>

<p>удаленного компьютера). Если сеть работает корректно, в
результате выво­дится время ожидания прихода ответа от удаленного компьютера и
время жизни пакета (TTL, time to live, количество &amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>хопов", после которого пакет
был бы отброшен; этот параметр показывает, сколько оставалось допус­тимых
переходов у пакета-ответа).

</p>
<p>Протокол ICMP находится на стыке двух уровней — сетевого и
транспортного. Основной принцип действия этого протокола — форми­рование ICMP эхо-запроса (echo-request) и эхо-ответа (echo-reply). За­прос эха и ответ на него может использоваться для
проверки достижимо­сти хоста-получателя и его способности отвечать на запросы.
Также про­хождение эхо-запроса и эхо-ответа проверяет работоспособность основ­ной
части транспортной системы, маршрутизацию на машине источника,
работоспособность и корректную маршрутизацию на роутерах между ис­точником и
получателем, а также работоспособность и правильность мар­шрутизации
получателя.

</p>
<p>Таким образом, если на посланный echo-request возвращается кор­ректный
echo-reply от машины, которой
был послан запрос, можно ска­зать, что транспортная система работает корректно.
И если браузер не мо­жет отобразить web-страницу, то
проблема, по всей видимости, не в пер­вых трех уровнях модели OSI.

</p>
<p>Из примера видно, что по умолчанию размер посылаемого
пакета -32 байта, далее выводится время задержки ответа и TTL. В этом примере показано успешное выполнение команды ping. В случаях, когда запросы echo request посылаются, но echo reply не возвращаются,
выводится сообщение об истечении времени ожидания ответа.

</p>
<p>E:\WINNI \Sy jtem32\cmd.eiKe

</p>
<p></p>
<center><img border="0" width="410" height="107" src="http://kufas.ru/java.files/image059.jpg"></center>

<p> 

</p>
<p>Traceroute

</p>
<p>Утилита traceroute также использует протокол ЮМРдля определения маршрута
прохождения пакета. При отсылке traceroute устанавливает зна­чение TTL последовательно от
1 до 30. Каждый маршрутизатор, через ко­торый проходит пакет на пути к
назначенному хосту, увеличивает значение TTL на единицу. С
помощью TTL происходит предотвращение зациклива­ние пакета в
"петлях" маршрутизации, иначе "заблудившиеся" пакеты
окончательно перегрузили бы сеть. Однако, при выходе маршрутизатора или линии
связи из строя требуется несколько дополнительных переходов для понимания, что
данный маршрут потерян и его необходимо обойти. Чтобы предотвратить потерю
датаграммы, поле TTL устанавливается на
максимальную величину.

</p>
<p>Когда маршрутизатор получает lP-датаграмму с TTL. равным 0 или 1,
он уничтожает ее и посылает хосту, который ее отправил, ICMP-сооб-щение
&amp;quot
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p>время истекло" (time exceeded). Принцип работы traceroute за­ключается в том,
что IP-датаграмма, содержащая это ICMP-сообщение, имеет в
качестве адреса источника IP-адрес маршрутизатора.

</p>
<p>Теперь легко понять, как работает traceroute. На хост назначения отправляется IP- датаграмма с TTL, равным единице.
Первый маршру­тизатор, который должен обработать датаграмму, уничтожает ее (так
как TTL равно 1) и
отправляет ICMP-сообщение об истечении времени (time exceeded). Таким образом определяется первый маршрутизатор в
маршруте. Затем traceroute отправляет
датаграмму с TTL, равным 2, что позволяет получить IP-адрес второго
маршрутизатора. Так продолжает­ся до тех пор, пока датаграмма не достигнет хоста
назначения. Утилита traceroute может посылать в
качестве такой датаграммы UDP-сообще-ние с номером порта, который заведомо не будет
обработан приложени­ем (порт выше 30000), поэтому хост назначения ответит
"порт недосту­пен" (port unreachable). При получении такого ответа делается вывод, что
удаленный хост работает корректно. В противном случае макси­мального значения TTL (по умолчанию 30) не хватило для того, чтобы

</p>
<p>его достигнуть.

</p>
<p>Рассмотрим пример выполнения утилиты traceroute.

</p>
<p>traceroute to netserv1.chg.ru
(193.233.46.3), 30 hops max, 38 byte packets

</p>
<p>1   
n3-core.mipt.ru (194.85.80.1) 1.508 ms 0.617 ms 0.798 ms

</p>
<p>2      
mipt-gw-eth0.mipt.ru
(193.125.142.177) 2.362 ms 2.666 ms 1.449 ms

</p>
<p>3      
msu-mipt-atmO.mipt.ru
(212.16.1.1) 5.536 ms 5.993 ms 10.431 ms

</p>
<p>4       M9-LYNX.ATM6-0.11.M9-R2.msu.net (193.232.127.229) 12.994 ms 7.830 ms 6.816 ms

</p>
<p>5       Moscow-BNS045-ATM4-0-3.free.net (147.45.20.37) 12.228

</p>
<p>ms 7.041 ms 8.731 ms

</p>
<p>6    ChgNet-gw.free.net (147.45.20.222) 77.103 ms 75.234 ms

</p>
<p>92.334 ms

</p>
<p>7 netservl .chg.ru (193.233.46.3)
96.627 ms 94.714 ms 134.676 ms








</p>
<p>Route








</p>
<p>Первая строка содержит имя и IP-адрес хоста
назначения, мак­симальное значение TTL и размер посылаемого пакета (38 байт). По­следующие строки начинаются с TTL, после чего следует
имя хоста, или маршрутизатора и его IP-адрес. Для каждого
значения TTL от­правляются три
датаграммы. Для каждой возвращенной датаграммы определяется и выводится время
возврата. Если в течение 3-х секунд на каждую из 3-х датаграмм не был получен
ответ, то посылается сле­дующая датаграмма, а вместо значения времени выводится
звездочка
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Время возврата — это время прохождения датаграммы от источника
(хоста, выполняющего программу traceroute) до маршрутизатора. Ес­ли нас интересует время, потраченное на пересылку
между, например, 5 и 6 узлом, необходимо вычесть из значения времени TTL 6 время TTL 5.

</p>
<p>В каждой из операционных систем сетевая часть утилиты реализова­на
практически одинаково, но реализация на уровне приложений разли­чается.

</p>
<p>В ОС Solaris используется
утилита traceroute. В качестве параметра задается IP-адрес, или
доменное имя удаленного хоста, связь до которого требуется проверить. В
примере, приведенном выше, видно успешное вы­полнение traceroute и корректную работу
сете-зависимых уровней (фи­зический, канальный, сетевой).

</p>
<p>В ОС Windows утилита называется tracert. Используется она
так же, как и в ОС Solaris (tracert netserv1.chg.ru). Принципиального различия между утилитами tracert и traceroute нет. Особенностью traceroute явля­ется наличие
большего количества функций (например, можно указать, начиная с какого TTL выводить информацию).

</p>
<p>В случае какой-либо неполадки выводится соответствующее сообщение.
Например, при недоступности сети на маршрутизаторе выдается сообщение !N (net unreachable):

</p>
<p> 

</p>
<p>Moscow-BNS045-ATM4-0-3.free.net (147.45.20.37) 947.327 ms !N 996.548 ms !N 995.257 ms

</p>
<p> 

</p>
<p>Это означает, что 147.45.20.37 - маршрутизатор, начиная с которого,
последующий маршрут недоступен. Если недоступен сам хост, то сообще­ние будет
выглядеть так:

</p>
<p> 

</p>
<p>msu-mipt-atmO.mipt.ru (212.16.1.1) 5.536 ms !Н 5.993 ms !Н 10.431 ms !Н.

</p>
<p> 

</p>
<p>Ошибка !Р означает
недоступность протокола (protocol unreachable).

</p>
<p>« пелактирования таблицы маршрутов используется ухилГТоГе^иичГй "пример  таблицы   маршрутизации   на

</p>
<p>персональном компьютере: Для ОС Windows:

</p>
<p> 

</p>
<p>route print

</p>
<p></p>
<center><img border="0" width="428" height="158" src="http://kufas.ru/java.files/image060.jpg"></center>

<p>В таблице маршрутизации указывается сеть, маска сети, маршрутизатор,
через который доступна эта сеть, интерфейс и метрика маршрута. Из приведенной
таблицы видно, что маршрут по умолчанию доступен через маршрутизатор
192.168.1.1. Сеть 192.168.1.0 с маской 255.255.255.0 является локальной сетью.

</p>
<p>При добавлении маршрута
можно использовать следующую команду.

</p>
<p>route ADD 157.0.0.0 MASK 255.0.0.0 157.55.80.1

</p>
<p>157.0.0.0 - удаленная
сеть, 255.0.0.0 - маска удаленной сети,

</p>
<p>157.55.80.1 - маршрутизатор, через который доступна эта сеть.

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>Примерно такой же синтаксис используется при удалении маршрута:

</p>
<p>route DELETE 157.0.0.0

</p>
<p></p>
<center><img width="415" height="123" src="http://kufas.ru/java.files/image061.png" align="left"></center>В ОС Solaris для просмотра таблицы маршрутизации используется








<p>

</p>
<table cellpadding="0" cellspacing="0">
 <tr>
  <td width="503" height="0"></td>
 </tr>
 <tr>
  <td></td>
  <td><center><img width="407" height="285" src="http://kufas.ru/java.files/image062.png"></center></td>
 </tr>
</table>


Добавление и удаление маршрутов выполняется командой route-route add -net 157.6 157.6.1.20, где 157.6 - сокращенный адрес подсети, а 157.6.1.20 -
маршрут, по которому эта сеть доступна. Также удаление маршрутов в таблице
маршрутизации: route del -net 157.6

<p> 

</p>
<p>N618181

</p>
<p>Утилита пегэ*^ позволяет определить, какие порты
открыты и по каким портам происходит передача данных между узлами сети.
Например, если запустить \уеЬ-браузер и открыть для просмотра \veb-страницу, то, запустив пе1зт.а1, можно увидеть следующую строку:

</p>
<p>TCP
mycomp:3687 www.ru:http ESTABLISHED



</p>
<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="23">
 <tr>
  <td valign="top" align="left" height="23">
  <p>&#9633;
  </p>
</td>
 </tr>
</table>







<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="202">
 <tr>
  <td valign="top" align="left" height="202">
  <p></p>
<center><img border="0" width="366" height="202" src="http://kufas.ru/java.files/image063.jpg"></center>
  </td>
 </tr>
</table>





<p> 

</p>
<p>В проведенном примере первое значение — TCP — тип протокола (может быть TCP или UDP), далее следует имя локальной машины и локальный порт, www.ru:http — имя удаленного
хоста и порта, к кото­рому производится обращение (поскольку использовался порт
по умолчанию для протокола HTTP, то отображается не его числовое зна­чение 80, а имя протокола), ESTABLISHED - показывает, что
ТСР-со-единение установлено.

</p>
<p> 

</p>
<p>В ОС Windows с помощью команды netstat -an можно получить список всех открытых портов (параметр -п не определяет DNS-имя, а выводит
только IP-адрес). Из примера выше видно, что установленных соединений нет, а все
открытые порты находятся в состоянии "прослуши­вания", т.е. к этому
порту можно обратиться для установки соединения.

</p>
<p>ТСР-порт 139
отвечает за установку Netbios-сессий (например, для пере­дачи данных через "сетевое
окружение").

</p>
<p>В ОС Solaris для получения
информации об используемых портах также применяется утилита netstat. Формат вывода
практически одинаков.

</p>
<p> 

</p>
<p>riaKeTjava.net

</p>
<p>Перейдем к рассмотрению
средств Java для работы с сетью.

</p>
<p>Классы, работающие с сетевыми протоколами, располагаются в naKeTejava.net, и простейшим из них является класс URL. С его помощью можно
сконструировать uniform resource locator (URL), который имеет
следующий формат:

</p>
<p> 

</p>
<p>protocol://host:port/resource

</p>
<p>Здесь protocol - название
протокола, используемого для связи; host-IP-адрес, или DNS-имя сервера, к
которому производится обращение; port — номер порта сервера (если порт не указан, то используется значение по
умолчанию для указанного протокола); resource - имя запрашиваемого ресурса, причем, оно может быть составным,
например:

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>ftp://myserver.ru/pub/docs/Java/JavaCourse.txt

</p>
<p>Затем можно воспользоваться методом openStream(), который воз­вращает InputStream, что позволяет считать содержимое ресурса. Напри-

</p>
<p>569








</p>
<p>мер, следующая программа при помощи LineNumberReader считывает первую
страницу сайта http://www.ru и выводит ее на
консоль.

</p>
<p>import java.io.*; importjava.net.*;

</p>
<p> 

</p>
<p>public class Net {

</p>
<p>public static void main(String args[]) { try {

</p>
<p>URL uri = new URL("http://www.ru");
LineNumberReader r = new LineNumberReader(new

</p>
<p>lnputStreamReader(url.openStream())); String s = r.readLine();
while (s!=null) {

</p>
<p>System.out.println(s);

</p>
<p>s = r.readьneO;

</p>
<p>}

</p>
<p>System.out. println(r.getLineNumber());
r.close();

</p>
<p>} catch
(MalformedURLException e) {

</p>
<p>e. printStackTrace( ) ; } catch (lOException
e) {

</p>
<p>e.
printStackTrace() ;

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Из примера мы видим, что работа с сетью, как и работа с потоками,
требует дополнительной работы с исключительными ситуациями. Ошиб­ка MalformedURLException появляется в случае, если строка с URL со­держит ошибки.

</p>
<p>Более функциональным классом является URLConnection, который можно получить с помощью метода класса URL.openConnectionQ. У этого класса есть два метода - getlnputStream() (именно с его помощью работа­ет URL.openStreamO) и getOutputStream(),
который можно использовать
для передачи данных на сервер, если он поддерживает такую операцию (многие
публичные web-серверы закрыты для таких действий).

</p>
<p>Класс URLConnection является абстрактным. Виртуальная машина предоставляет реализации этого
класса для каждого протокола, например, в том же пакете java.net определен ктасс HttpURLConnection. Понятно, что классы URL и URLConnection предоставляют возможность работы че­рез сеть на прикладном уровне с
помощью высокоуровневых протоколов.

</p>
<p>naKeTJava.net также предоставляет
доступ к протоколам более низко­го уровня - TCP и UDP. Для этого сначала надо ознакомиться с классом InetAddress, который является Internet-адресом, или IP. Экземпляры этого класса создаются не с помощью конструкторов, а с
помощью статических методов:

</p>
<p>InetAddress getLocalHost() InetAddress getByName(String
name) lnetAddress[] getAIIByName(String name)

</p>
<p>Первый метод возвращает IP-адрес машины, на которой исполняется Java-программа
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Второй
метод возвращает адрес сервера, чье имя передает­ся в качестве параметра. Это
может быть как DNS-имя, так и числовой IP, записанный в виде текста, например, "67.11.12.101". Наконец,
третий ме­тод определяет все I Р-адреса указанного сервера.

</p>
<p>Для работы с TCP-протоколом используются классы Socket и ServerSocket. Первым создается ServerSocket - сокет на стороне
сервера. Его простейший конструктор имеет только один параметр — номер порта,
на котором будут приниматься входящие запросы. После создания вызыва­ется метод
accept(), который приостанавливает выполнение программы и ожидает, пока
какой-нибудь клиент не инициирует соединение. В этом случае работа сервера
возобновляется, а метод возвращает экземпляр класса Socket для взаимодействия с клиентом:

</p>
<p> 

</p>
<p>try {

</p>
<p>ServerSocket ss = new
ServerSocket(3456); Socket client=ss.accept(); // Метод не возвращает

</p>
<p>//управление, пока не подключится клиент } catch (lOException e) { e.printStackTrace();

</p>
<p>}

</p>
<p>Клиент для подключения к серверу также использует класс Socket. Его простейший конструктор
принимает два параметра - адрес сервера (в виде строки, или экземпляра InetAddress) и номер порта. Если сервер принял запрос, то сокет конструируется
успешно и далее можно воспользоваться методами getlnputStream() или getOutputStream().

</p>
<p> 

</p>
<p>try {

</p>
<p>Socket s = new Socket("localhost", 3456); InputStream
is = s.getlnputStream(); is.read();

</p>
<p>} catch (UnknownHostException e) {

</p>
<p>e.printStackTrace(); } catch
(lOException e) {

</p>
<p>e. printStackTrace( ) ;

</p>
<p>}

</p>
<p> 

</p>
<p>Обратите внимание на обработку исключительной ситуации UnknownHostException, которая будет генерироваться, если виртуальная машина с помощью
операционной системы не сможет распознать указанный адрес сервера в случае,
если он задан строкой. Если же он задан экземпляром InetAddress, то эту ошибку надо обрабатывать при вызове статических методов данного
класса.

</p>
<p>На стороне сервера класс Socket используется точно таким же образом - через методы getlnputStreamQ и getOutputStream(). Приведем более полный пример:

</p>
<p> 

</p>
<p>import java.io.*; importjava.net.*; public
class Server {

</p>
<p>public static void main(String args[]) { try{

</p>
<p>ServerSocket ss = new ServerSocket(3456);
System, out. println("Waiting..."); Socket
client=ss.accept(); System.out.println("Connected"); client.getOutputStream().write(
10); client. closeQ; ss.close(); } catch
(lOException e) { e.printStackTrace();

</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p></p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p> 

</p>
<p>Сервер по запросу клиента отправляет число 10 и завершает работу.
Обратите внимание, что при завершении вызываются методы close() для открытых
сокетов.

</p>
<p>Класс клиента:

</p>
<p>import
java.io.*; importjava.net.*; public
class Client {

</p>
<p>public static void main(String args[]) { try{

</p>
<p>Socket s = new Socketf'localhost",
3456);

</p>
<p>InputStream is = s.getlnputStream();

</p>
<p>System.out.println("Read: "+is.read());

</p>
<p>s.close(); } catch
(UnknownHostException e) {

</p>
<p>e.printStackTrace(); } catch
(lOException e) {

</p>
<p>e.printStackTrace();

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>После запуска сервера, a затем клиента,
можно увидеть результат -полученное число 10, после чего обе программы
закроются.

</p>
<p>Рассмотрим эти классы более подробно. Во-первых, класс ServerSocket имеет конструктор, в который передается, кроме номера порта, еще и адрес
машины. Это может показаться странным, ведь сервер открывается на той же
машине, где работает программа, зачем специально указывать ее адрес? Однако,
если компьютер имеет несколько сетевых ин­терфейсов (сетевых карточек), то он
имеет и несколько сетевых адресов. С помощью такого детализированного
конструктора можно указать, по какому именно адресу ожидать подключения. Это
должен быть именно локальный адрес машины, иначе возникнет ошибка.

</p>
<p>Аналогично, класс Socket имеет расширенный конструктор для ука­зания как локального адреса, с
которого будет устанавливаться соединение, так и локального порта (иначе
операционная система выделяет произволь­ный свободный порт).

</p>
<p>Во-вторых, можно воспользоваться методом setSoTimeout(int time­out) класса ServerSocket, чтобы указать время в миллисекундах, на про­тяжении которого нужно
ожидать подключение клиента. Это позволяет серверу не "зависать", если
никто не пытается начать с ним работать. Тайм-аут задается в миллисекундах,
нулевое значение означает бесконеч­ное время ожидания.

</p>
<p>Важно подчеркнуть, что после установления соединения с клиентом сервер
выходит из метода accept(), то есть перестает быть готовым при­нимать новые запросы. Однако, как
правило, желательно, чтобы сервер мог работать с несколькими клиентами
одновременно. Для этого необхо­димо при подключении очередного пользователя
создавать новый поток исполнения, который будет обслуживать его, а основной
поток снова войдет в метод ассерг()
</p>
<center> 
</center>
    </div><div class="left">
      <p></p>
<p> Приведем пример такого решения: import Java.io.*; importjava.net.*;

</p>
<p> 

</p>
<p>public class NetServer {

</p>
<p>public static final int PORT = 2500; private static
final int TIMERS EN DSLEEP = 100; private static final int COUNT_TO_SEND = 10;
private ServerSocket servSocket;

</p>
<p> 

</p>
<p>public static void main(String[] args) {
NetServer server = new NetServer(); server. go();

</p>
<p>}

</p>
<p> 

</p>
<p>public NetServer() { try{

</p>
<p>servSocket = new ServerSocket(PORT); }
catch(IOException e) {

</p>
<p>System.err.println("Unable to open Server Socket:" +
e.toString());

</p>
<p>}

</p>
<p> 

</p>
<p> 

</p>
<p>public void go() {

</p>
<p> 

</p>
<p>// Класс-поток для работы с подключившимся клиентом class Listener implements Runnable { Socket socket;

</p>
<p>public Listener(Socket aSocket) { socket = aSocket;

</p>
<p>}

</p>
<p>public void run() { try{

</p>
<p>System.out.println("Listener started"); int
count = 0;

</p>
<p>OutputStream out = socket.getOutputStream();
OutputStreamWriter writer = new

</p>
<p>OutputStreamWriter(out); PrintWriter pWriter = new
PrintWriter(writer); while (count&lt;COUNT_TO_SEND) {

</p>
<p>count++;

</p>
<p>pWriter.print(((count&gt;1)?",":"")+
"Say" + count);

</p>
<p>Sleeps(TIME_SEND_SLEEP);

</p>
<p>}

</p>
<p>pWriter.close(); } catch(IOException e) {

</p>
<p>System.err.println("Exception : " + e.toString());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>//Основной поток, циклически выполняющий метод accept() System, out. printlnfServer started");
while (true) { try{

</p>
<p>Socket
socket = servSocket.accept(); Listener listener = new Listener(socket); Thread
thread = new Thread(listener); thread.start(); } catch(IOException e) {

</p>
<p>System.err.println("IOException :" + e.toString());

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>public void sleeps(long time) { try{

</p>
<p>Thread.sleep(time); } catch(lnterruptedException
e) { }

</p>
<p>}

</p>
<p>}

</p>
<p>Теперь объявим клиента. Эта программа будет запускать несколько потоков,
каждый из которых независимо подключается к серверу, считы­вает его ответ и
выводит на консоль.

</p>
<p>import java.io.*; importjava.net.*;

</p>
<p>public class NetClient implements Runnable { public
static final int PORT = 2500; public static final String HOST =
"localhost"; public static final int CLIENTS_COUNT = 5;








</p>
<p>Программирование
на Java




</p>
<p>Лекция
16




</p>
<p>Введение В
Сетевые nnn-m^ni ,








</p>
<p>public static final int READ_BUFFER_S1ZE = 10; private
String name = null;

</p>
<p>public static void main(String[] args) {
String name = "name"; for (int i=1; i&lt;=CUENTS_COUNT; i++) {

</p>
<p>NetClient client = new NetClient(name+i);

</p>
<p>Thread thread - newThread(client);

</p>
<p>thread.start();

</p>
<p>}

</p>
<p>}

</p>
<p>public NetClient(String name) { this.name = name;

</p>
<p>}

</p>
<p>public void run() {

</p>
<p>char[] readed = newchar[READ_BUFFER_SIZE]; StringBuffer
strBuff = new StringBuffer(); try{

</p>
<p>Socket socket = new Socket(HOST, PORT); InputStream in
= socket.getlnputStream(); InputStreamReader reader = new
InputStreamReader(in);

</p>
<p>while (true) {

</p>
<p>int count = reader, read (readed, 0,

</p>
<p>READ_BUFFER_SlZE); if (count—-1) break;
strBuff.append(readed, 0, count); Thread .yield();

</p>
<p>}

</p>
<p>} catch (UnknownHostException e) {

</p>
<p>e. prints tackTrace(); } catch (lOException e) {

</p>
<p>e.printStackTrace();

</p>
<p>}

</p>
<p>System.out.printlnfclient" + name +
" read :" + strBuff.toStringO);

</p>
<p>}

</p>
<p>Теперь рассмотрим UDP. Для работы с этим протоколом и на сторо­не клиента, и на стороне
сервера используется класс DatagramSocket У него есть
следующие конструкторы:

</p>
<p> 

</p>
<p>DatagramSocketO DatagramSocket(int port)
DatagramSocket(int port, InetAddress laddr)

</p>
<p> 

</p>
<p>При вызове первого конструктора сокет открывается на произволь­ном
доступном порту, что уместно для клиента. Конструктор с одним пара­метром,
задающим порт, как правило, применяется на серверах, чтобы клиенты знали, на
каком порту им нужно пытаться устанавливать соедине­ние. Наконец, последний
конструктор необходим для машин, у которых присутствует несколько сетевых
интерфейсов.

</p>
<p>После открытия сокетов начинается обмен датаграммами. Они представляются
экземплярами класса DatagramPacket. При отсылке сообщения применяется следующий конструктор:

</p>
<p> 

</p>
<p>DatagramPacket(byte[] buf, int length, InetAddress address, int port)

</p>
<p>Массив содержит данные для отправки (созданный пакет будет иметь длину,
равную length), а адрес и порт указывают получателя пакета. После этого вызывается
метод send() класса DatagramSocket.

</p>
<p> 

</p>
<p>try {

</p>
<p>DatagramSocket s = new DatagramSocketO; byte data[]={1, 2, 3};

</p>
<p>InetAddress addr = lnetAddress.getByName("localhost");
DatagramPacket p = new DatagramPacket(data, 3, addr, 3456); s.send(p);

</p>
<p>System.out.println("Datagram sent");

</p>
<p>s.close();
} catch (SocketException e) {

</p>
<p>e.printStackTrace();
} catch (UnknownHostException e) {

</p>
<p>e.printStackTrace(); } catch (lOException e) {

</p>
<p>e.printStackTrace();

</p>
<p>}

</p>
<p>Для получения датаграммы также создается экземпляр
класса DatagramPacket, но в конструктор передается лишь массив, в который








</p>
<p>3440




</p>
<p>577








</p>
<p>будут записаны
полученные данные (также указывается ожидаемая длина пакета). Сокет необходимо
создать с указанием порта, иначе, скорее всего, сообщение просто не дойдет до
адресата. Используется метод receive() класса DatagramSocket (аналогично методу ServerSocket.accept(), этот метод также прерывает выполнение потока, пока не придет запрос
от клиента). Пример реализации получателя:

</p>
<p> 

</p>
<p>try {

</p>
<p>DatagramSocket
s = new DatagramSocket(3456); byte data[]=new byte[3];

</p>
<p>DatagramPacket p = new DatagramPacket(data, 3);

</p>
<p>System.out.println("Waiting...");

</p>
<p>s.receive(p);

</p>
<p>System.out.println("Datagram received:
"+data[0]+", "+data[1]+", "+data[2]);

</p>
<p>s.close(); } catch (SocketException e) {

</p>
<p>e.printStackTrace(); } catch (lOException e) {

</p>
<p>e. pri ntStackTrace();

</p>
<p>}

</p>
<p>Если запустить сначала получателя, а затем отправителя, то можно
увидеть, что первый напечатает содержимое полученной датаграммы, а потом
программы завершат свою работу.

</p>
<p>В заключение приведем пример сервера, который получает датаграммы и
отправляет их обратно, дописав к ним слово received.

</p>
<p>import java.
io.*; import java.net.*;

</p>
<p>public class DatagramDemoServer { public static final
int PORT = 2000; private static final int LENGTH_RECEIVE = 1; private static
final byte[] answer = ("received").getBytes(); private DatagramSocket
servSocket = null; private boolean keepRunning = true; public static void
main(String[] args) {

</p>
<p>DatagramDemoServer server = new DatagramDemoServer();

</p>
<p>server.service();

</p>
<p>public DatagramDemoServerO { try {

</p>
<p>servSocket = new DatagramSocket(PORT); }
catch(SocketException e) {

</p>
<p>System.err.println("Unable to open socket : "
+ e.toStringQ);

</p>
<p>}

</p>
<p>}

</p>
<p>protected void service() { DatagramPacket
datagram; InetAddress clientAddr; int clientPort; byte[] data; while (keepRunning)
{ try {

</p>
<p>data = new byte[LENGTH_RECEIVE];

</p>
<p>datagram = new DatagramPacket(data, data.length);

</p>
<p>servSocket. receive(datagram);

</p>
<p>clientAddr = datagram. getAddress();

</p>
<p>clientPort = datagram.getPort();

</p>
<p>data = getSendData(datagram.getData());

</p>
<p>datagram = new DatagramPacket(data, data.length,

</p>
<p>clientAddr, clientPort); servSocket.send(datagram); }
catch(IOException e) {

</p>
<p>System.err.println("l/0 Exception : " +
e.toStringO);

</p>
<p>}

</p>
<p>}

</p>
<p>}

</p>
<p>protected byte[] getSendData(byte b[]) {

</p>
<p>byte[] result = new bytefb.length+answer.length];
System.arraycopy(b, 0, result, 0, b.length); System.arraycopy(answer, 0,
result, b.length, answer.length); return result;

</p>
<p>}

</p>
<p>}

</p>
<p>Заключение

</p>
<p>В данном разделе были рассмотрены теоретические основы сети как одной
большой взаимодействующей системы. Были описаны все уровни модели OSI и их функциональные
назначения. Также были представлены основные утилиты, используемые для
настройки и обнаружения неис-








</p>
<p>правностей в сети. Затем были рассмотрены средства Java для работы с на­иболее распространенными сетевыми проколами. Приведен
подробный пример и для более сложного случая — сервер, обслуживающий несколько
клиентов одновременно.

</p>
<p>Вариант 1

</p>
<p> 

</p>
<p> 

</p>
<p>1.       Назовите
сете-зависимые уровни модели OSI.

</p>
<p>П   уровень
передачи данных Г*|  
представительский уровень Г*|   сессионный уровень П   физический уровень

</p>
<p>&#9633;       транспортный
уровень Г*|  
сетевой уровень

</p>
<p>П   уровень приложений

</p>
<p> 

</p>
<p> 

</p>
<p>2.       Какие
из следующих адресов относятся к подсети класса В?

</p>
<p>&#9633;       
194.80.20.1

</p>
<p>&#9633;       
172.16.0.1

</p>
<p>&#9633;       
172.16.256.2

</p>
<p>&#9633;       
140.150.160.1

</p>
<p>&#9633;       
224.0.0.10

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Каким
классом лучше воспользоваться для загрузки
web-страницы
с сервера?

</p>
<p>&#9633;          
URL

</p>
<p>&#9633;          
Socket

</p>
<p>&#9633;        DatagramSocket








</p>
<p>Вариант
2




</p>
<p>Вариант
3








</p>
<p> 








</p>
<p>1.    Назовите сете-независимые уровни модели OSI.

</p>
<p>П    уровень передачи данных

</p>
<p>П    представительский уровень

</p>
<p>П     сессионный
уровень

</p>
<p>П     физический уровень

</p>
<p>П     транспортный уровень

</p>
<p>Г~|  сетевой уровень

</p>
<p>П     уровень приложений

</p>
<p>1.   Какие из перечисленных ниже терминов относятся к
подуровням второго уровня?

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="24">
  <p>&#9633;
  </p>
</td>
  <td width="35" valign="top">
  <p>LLC
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="35" valign="top">
  <p>МАС
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="35" valign="top">
  <p>TCP
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="35" valign="top">
  <p>ARP
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="35" valign="top">
  <p>RIP
  </p>
</td>
 </tr>
</table>








<p> 








</p>
<p> 

</p>
<p>2.       Какие
из перечисленных ниже характеристик относятся
к протоколу TCP?

</p>
<p>образование постоянного соединения |~|   не
гарантирует доставку сообщения |~|   использование в важных сервисах П   протокол уровня приложений

</p>
<p> 

</p>
<p> 

</p>
<p>3.       Каким
классом лучше воспользоваться для рассылки
сигналов точного времени?

</p>
<p>&#9633;       
URL

</p>
<p>&#9633;       
Socket

</p>
<p>&#9633;       
DatagramSocket

</p>
<p>2.  
Какие из утилит используются для тестирования работоспособности сети в ОС Windows?

</p>
<p> 

</p>
<table class="MsoNormalTable" border="0" cellspacing="0" cellpadding="0">
 <tr>
  <td width="24">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>ping
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>telnet
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>routed
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>ifconfig
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>netstat
  </p>
</td>
 </tr>
 <tr>
  <td width="24" valign="top">
  <p>&#9633;
  </p>
</td>
  <td width="66" valign="top">
  <p>traceroute
  </p>
</td>
 </tr>
</table>

<p> 

</p>
<p> 

</p>
<p>3.   Можно ли с помощью класса URL пересылать данные на сервер?

</p>
<p>&#9633;       
нет

</p>
<p>&#9633;       
да

</p>
<p>&#9633;       
да,если сервер позволяет
закачивание (upload) данных.

</p>
<p>                                                                                                    Программирование на Java




</p>
<p>






</p>
<center> </center>
    </div>