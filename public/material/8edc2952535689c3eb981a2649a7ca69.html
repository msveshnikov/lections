# encoding: windows-1251
<section id="l4_1">
<h1> 1.	«Классический» ввод/вывод </h1>

<p>
В языке С определены три стандартных потока ввода/вывода:

</p>
<ol>
	<li>
<span class="sint">stdin</span>      – стандартное устройство ввода (клавиатура);
	</li>
<li>
<span class="sint">stdout</span>   – стандартное устройство вывода (экран);
	</li>
<li>
<span class="sint">stderr</span>    – стандартное устройство вывода сообщения об ошибках (также экран).
</li>
</ol>

<p>
Простейший ввод/вывод: 

</p>
<ul>
    <li> <span class="sint">getch()</span> – ввод одного символа без отображения его на экране;
    </li>
<li> <span class="sint">getche()</span> – ввод одного символа с отображением его на экране;
    </li>
<li> <span class="sint">putchar(<i>int</i> c)</span> – вывод одного символа на экран.
</li>
</ul>

<p>
Все эти функции требуют включения заголовочного файла <span class="sint">&lt;conio.h&gt;</span>.

</p>
<p>
Все остальные функции ввода/вывода определены в заголовочном файле <span class="sint">&lt;stdio.h&gt;</span>.



</p>
<h2 id="l4_1_1">1.1.	Ввод/вывод с экрана</h2>

<p>
Для ввода и вывода на экран используются функции <i>scanf</i> и <i>printf</i> соответственно, прототипы которых имеют следующий вид:

<span class="sint">

<span class="type">int</span> <span class="fun">scanf</span> (<span class="type">char</span> *<var>format</var>, ...);
<span class="type">int</span> <span class="fun">printf</span>(<span class="type">char</span> *<var>format</var>, ...);
</span>

</p>
<p>
Вывод осуществляется функцией <i>printf</i>, которая имеет следующий синтаксис:

<span class="sint">

<b>printf</b>(<i>&lt;строка описания форматов&gt;</i> [, <i>&lt;список вывода&gt;</i>]);</span>

</p>
<p>
<i>Строка описания форматов</i> состоит из обычных символов, специальных <i></i> символов и <i></i>.

</p>
<p>
Обычные символы и управляющие последовательности просто копируются в стандартный выходной поток в порядке их появления.

</p>
<p>
Спецификации формата начинаются с символа <b>%</b> и заканчиваются символом, определяющим тип выводимого значения. Кроме того, спецификации формата могут содержать символы и цифры для управления видом выводимого значения (подробно см. ). <i>Список вывода</i> состоит из переменных и/или констант, значения которых должны быть выведены. <b>Количество спецификаций формата должно быть равно количеству выводимых значений, которые указываются в <i>списке вывода</i>.</b> Если это условие не будет соблюдаться, выполнение функции может привести к непредсказуемым результатам.

</p>
<p>
Ввод осуществляется функцией <i>scanf</i>, которая имеет следующий синтаксис:

<span class="sint">

<b>scanf</b>(<i>&lt;строка описания форматов&gt;</i> [, <i>&lt;список ввода&gt;</i>]);</span>

</p>
<p>
<i>Строка описания форматов</i> состоит из набора спецификаций формата, таких же, как для функции <i>printf</i>. <i>Список ввода</i> состоит из <b>адресов</b> переменных, куда будут заноситься вводимые значения. Адрес переменной вычисляется с помощью . Количество спецификаций формата должно быть равно количеству вводимых значений, которые указываются в <i>списке ввода</i>.

</p>
<p>
Функция <i>scanf</i> возвращает количество успешно введенных и преобразованных значений. Функция <i>printf</i> возвращает количество символов, записанных в выходной поток.

</p>
<p id="l4_escape">
К управляющим последовательностям относятся следующие последовательности символов.

</p>
<table>
 <tr>
  <th>
   Последовательность
  </th>
  <th>
   Дейcтвие
  </th>
 
 </tr>
<tr>
  <td>
   <b>\a</b>
  </td>
  <td>
    Звуковой сигнал
  </td>
 </tr>
 <tr>
  <td>
   <b>\b</b>
  </td>
  <td>
    Удаление предыдущего символа
  </td>
 </tr>
 <tr>
  <td>
   <b>\n</b>
  </td>
  <td>
    Новая строка
  </td>
 </tr>
 <tr>
  <td>
   <b>\r</b>
  </td>
  <td>
    Возврат каретки
  </td>
 </tr>
 <tr>
  <td>
   <b>\t</b>
  </td>
  <td>
    Табуляция
  </td>
 </tr>
 <tr>
  <td>
   <b>\'</b>
  </td>
  <td>
    Апостроф
  </td>
 </tr>
 <tr>
  <td>
   <b>\"</b>
  </td>
  <td>
    Кавычки
  </td>
 </tr>
 <tr>
  <td>
   <b>\\</b>
  </td>
  <td>
    Обратный слеш
  </td>
 </tr>
 <tr>
  <td>
   <b>\</b><i>ooo</i>
  </td>
  <td>
    ASCII символ в восьмеричной нотации
  </td>
 </tr>
 <tr>
  <td>
   <b>\x</b><i>ooo</i>
  </td>
  <td>
    ASCII символ в шестнадцатеричной нотации
  </td>
 </tr>
</table>


<p id="l4_format">
<i>Спецификация формата</i>, которая состоит из обязательных и необязательных полей, имеет следующий вид:

<span class="sint">
%[<i></i>]
 [<i></i>]
 [<i></i>]
 []
 <i></i>
</span>

</p>
<table id="l4_bandiere">
 <tr>
  <th>
   Флаги
  </th>
  <th>
   Значение
  </th>
  <th>
   По умолчанию
  </th>
 </tr>
  <tr>
  <td>
   –
  </td>
  <td>
   Выравнивание по левому краю.
  </td>
  <td>
   Выравнивание по правому краю.
  </td>
 </tr>
 <tr>
  <td>
   +
  </td>
  <td>
   Добавление знака + или – перед числами.
  </td>
  <td>
   Знак добавляется только перед отрицательными числами.
  </td>
 </tr>
 <tr>
  <td>
   0
  </td>
  <td>
   Добавление нулей перед выводимым значением. Если одновременно используются флаги – и 0, 0 игнорируется.
  </td>
  <td>
   Добавление пробелов.
  </td>
 </tr>
 <tr>
  <td>
   пробел
  </td>
  <td>
   Добавление пробела перед положительным числом. Если одновременно используются флаги пробел и +, пробел игнорируется.
  </td>
  <td>
   Пробел не добавляется.
  </td>
 </tr>
 <tr>
  <td rowspan="4">
   #
  </td>
  <td>
   Добавление символов 0, 0х или 0Х перед ненулевым значением, если флаг # используется с форматами о, х или Х соответственно.
  </td>
  <td>
   Символы 0, 0х и 0Х не добавляются.
  </td>
 </tr>
 <tr>
  <td>
   При использовании с форматами e, E и f флага #  выводимое число будет содержать десятичную точку в любом случае.
  </td>
  <td>
   Десятичная точка добавляется, только если за ней следуют цифры.
  </td>
 </tr>
 <tr>
  <td>
   При использовании с форматами g и G флага #  выводимое число будет содержать десятичную точку и хвостовые нули в любом случае.
  </td>
  <td>
   Десятичная точка добавляется, только если за ней следуют цифры.   Хвостовые нули не выводятся.
  </td>
 </tr>
 <tr>
  <td>
   Игнорируется при использовании с форматами c, d, i, u и s.
  </td>
  <td>
    
  </td>
 </tr>
</table>

 
<p id="l4_larghezza">
Поле <i>ширина</i> содержит минимальное количество выводимых символов – неотрицательное целое число. Если выводимое значение содержит меньше символов, то оно расширяется пробелами (если не задан флаг <b>0</b>). Если поле ширина содержит звездочку (*), то в качестве значения поля берётся целое число из списка аргументов, предшествующее выводимому значению.

</p>
<p id="l4_accuratezza">
Поле <i>точность</i> также представляет собой неотрицательное целое число. Действие зависит от  выводимого значения.

</p>
<table>
 <tr>
  <th>
   Тип
  </th>
  <th>
   Действие
  </th>
  <th>
   По умолчанию
  </th>
 </tr>
 <tr>
  <td>
   <b>c, C</b>
  </td>
  <td>
   Точность не имеет эффекта.
  </td>
  <td>
   Выводится символ.
  </td>
 </tr>
 <tr>
  <td>
   <b>d, i, u, o, x, X</b>
  </td>
  <td>
   Точность задаёт минимальное количество символов, которые будут напечатаны. Если число содержит меньше символов, оно расширяется нулями.
  </td>
  <td>
   Точность равна 1.
  </td>
 </tr>
 <tr>
  <td>
   <b>e, E, f</b>
  </td>
  <td>
   Точность задаёт количество символов после десятичной точки. Число округляется.
  </td>
  <td>
   Точность равна 6. Если точность равна 0 или опущена, десятичная точка не выводится.
  </td>
 </tr>
 <tr>
  <td>
   <b>g, G</b>
  </td>
  <td>
   Точность задаёт максимальное количество значащих цифр.
  </td>
  <td>
   Печатается 6 значащих цифр.
  </td>
 </tr>
 <tr>
  <td>
   <b>s, S</b>
  </td>
  <td>
   Точность задаёт максимальное количество выводимых символов.
  </td>
  <td>
   Выводятся все символы строки.
  </td>
 </tr>
</table>


<p>
Если поле <i>точность</i> содержит звездочку (*), то в качестве значения поля берётся целое число из списка аргументов, предшествующее выводимому значению.

</p>
<p id="l4_hli64">
Дополнительные префиксы <b>h</b>, <b>l</b>, <b>L</b> и <b>I64</b> задают «размер» аргумента – <i>long</i> или <i>short</i>, однобайтовый символ или расширенный символ, в зависимости от спецификации типа, которую они модифицируют.

</p>
<p id="l4_tipi">
Обязательное поле <i>тип</i> задаёт тип выводимого значения.

</p>
<table>
 <tr>
  <th>
   Символ
  </th>
  <th>
   Тип
  </th>
  <th>
   Формат вывода
  </th>
 </tr>
 <tr>
  <td>
   <b>c</b>
  </td>
  <td>
   <b>int</b> или <b>wint_t</b>
  </td>
  <td>
   При использовании с функцией <b>printf</b> определяет однобайтовый символ, при использовании с функцией <b>wprintf</b> определяет расширенный символ.
  </td>
 </tr>
 <tr>
  <td>
   <b>C</b>
  </td>
  <td>
   <b>int</b> или <b>wint_t</b>
  </td>
  <td>
   При использовании с функцией <b>printf</b> определяет расширенный символ, при использовании с функцией <b>wprintf</b> определяет однобайтовый символ.
  </td>
 </tr>
 <tr>
  <td>
   <b>d</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Знаковое десятичное целое.
  </td>
 </tr>
 <tr>
  <td>
   <b>i</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Знаковое десятичное целое.
  </td>
 </tr>
 <tr>
  <td>
   <b>o</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Беззнаковое восьмеричное целое.
  </td>
 </tr>
 <tr>
  <td>
   <b>u</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Беззнаковое десятичное целое.
  </td>
 </tr>
 <tr>
  <td>
   <b>x</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Беззнаковое шестнадцатеричное целое с использованием символов «abcdef».
  </td>
 </tr>
 <tr>
  <td>
   <b>X</b>
  </td>
  <td>
   <b>int</b>
  </td>
  <td>
   Беззнаковое шестнадцатеричное целое с использованием символов «ABCDEF».
  </td>
 </tr>
 <tr>
  <td>
   <b>e</b>
  </td>
  <td>
   <b>double</b>
  </td>
  <td>
   Знаковое число в форме [ – ]d.dddd <b>e</b> [знак]ddd, где d есть одна десятичная цифра, dddd – одна или более десятичных цифр, ddd – три десятичные цифры and знак есть + или –.
  </td>
 </tr>
 <tr>
  <td>
   <b>E</b>
  </td>
  <td>
   <b>double</b>
  </td>
  <td>
   Идентичен формату <b>e</b>, за исключением того, что символ <b>E</b>, а не <b>e</b> вводит экспоненту.
  </td>
 </tr>
 <tr>
  <td>
   <b>f</b>
  </td>
  <td>
   <b>double</b>
  </td>
  <td>
   Знаковое число в форме [ – ]dddd.dddd, где dddd есть одна или более десятичных цифр. Количество цифр перед десятичной точкой зависит от величины числа, а количество цифр после десятичной точки – от требуемой точности.
  </td>
 </tr>
 <tr>
  <td>
   <b>g</b>
  </td>
  <td>
   <b>double</b>
  </td>
  <td>
   Знаковое число в формате <b>f</b> или <b>e</b>, в зависимости от того, какой формат более компактен для заданного значения и точности.
  </td>
 </tr>
 <tr>
  <td>
   <b>G</b>
  </td>
  <td>
   <b>double</b>
  </td>
  <td>
   Идентичен формату <b>g</b>, за исключением того, что символ <b>E</b>, а не <b>e</b> вводит экспоненту.
  </td>
 </tr>
 <tr>
  <td>
   <b>n</b>
  </td>
  <td>
   pointer to <b>integer</b>
  </td>
  <td>
   Количество символов успешно записанных к данному моменту в выходной поток. Это значение сохраняется в целочисленной переменной, чей адрес задан как аргумент.
  </td>
 </tr>
 <tr>
  <td>
   <b>p</b>
  </td>
  <td>
   pointer to <b>void</b>
  </td>
  <td>
   Печатает адрес, заданный аргументом.
  </td>
 </tr>
 <tr>
  <td>
   <b>s</b>
  </td>
  <td>
   string
  </td>
  <td>
   При использовании с функцией  <b>printf</b> задаёт строку однобайтовых символов, при использовании с функцией <b>wprintf</b> задаёт строку расширенных символов. Символы печатаются до достижения признака конца строки.
  </td>
 </tr>
 <tr>
  <td>
   <b>S</b>
  </td>
  <td>
   string
  </td>
  <td>
   При использовании с функцией  <b>printf </b>задаёт строку расширенных символов, при использовании с функцией <b>wprintf</b> задаёт строку однобайтовых символов. Символы печатаются до достижения признака конца строки.
  </td>
 </tr>
</table>



<table>
<tr>
  <td class="esempi">
<span class="chiavi">int</span>    m, n, x;
<span class="chiavi">double</span> y;
<span class="chiavi">char</span>   c = '&amp;';
<span class="chiavi">char</span>   str[] = "String";
  </td>
  <td class="commenti">
     
  </td>

</tr>
<tr>
  <td class="esempi">scanf("%d%d", &amp;m, &amp;n); </td>
  
  <td class="commenti">// Ввод десятичных целых чисел в переменные <b>m</b> и <b>n</b> </td>

</tr>
<tr>
  <td class="esempi">printf("m = %5d\nn = %5d\n", m, n); </td>
  
  <td class="commenti">// Вывод переменных <b>m</b> и <b>n</b> в десятичном целом формате, используются как минимум 5 знаков </td>

</tr>
<tr>
  <td class="esempi">scanf("%d", &amp;x); </td>
  
  <td class="commenti">// Ввод десятичного целого числа в переменную <b>x</b> </td>

</tr>
<tr>
  <td class="esempi">printf("%#010x\n", x); </td>
  
  <td class="commenti">// Вывод переменной <b>x</b> в шестнадцатеричной системе, используются 10 знаков,
// впереди добавляются нули и символы <i>0х</i> </td>

</tr>
<tr>
  <td class="esempi">scanf("%lf", &amp;y); </td>
  
  <td class="commenti">// Ввод вещественного числа в переменную <b>y</b> </td>

</tr>
<tr>
  <td class="esempi">printf("y = %7.2lf\n", y); </td>
  
  <td class="commenti">// Вывод вещественной переменной, используются как минимум 7 знаков, из них 2 – после точки </td>

</tr>
<tr>
  <td class="esempi">printf("c = %c\n", c);  </td>
  
  <td class="commenti">// Вывод одного символа </td>

</tr>
<tr>
  <td class="esempi">printf("%.4s\n", str);  </td>
  
  <td class="commenti">// Вывод строки (не более 4 символов) </td>

</tr>
</table>
 
 
<h2 id="l4_1_2">1.2.	Чтение из строки/запись в строку </h2>

<p>
Функции <i>sprintf</i> и <i>sscanf</i> позволяют произвести запись значений переменных в форматированную строку или чтение переменных из строки:

<span class="sint">

<span class="type">int</span> <span class="fun">sscanf</span> (<span class="type">char</span> *<var>str</var>, <span class="type">char</span> *<var>format</var>, ...);
<span class="type">int</span> <span class="fun">sprintf</span>(<span class="type">char</span> *<var>str</var>, <span class="type">char</span> *<var>format</var>, ...);
</span>

</p>
<p>
Эти функции во всём аналогичны функциям <i>printf</i> и <i>scanf</i>, только в качестве первого параметра указывается строка, куда записываются или откуда считываются данные.


</p>
<h2 id="l4_1_3">1.3.	Работа с файлами </h2>

<table>
<tr>
  <td class="bnone">
<ul> <li> Объявление файловой переменной</li>
</ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">FILE</span> *<var>file</var>;    </span>
  </td>
  
</tr>
<tr>
  <td class="bnone">
<ul> <li> Открытие файла</li>
</ul>  </td>
  <td class="bnone">
<span class="sint"> – <span class="type">FILE</span> *<span class="fun">fopen</span>(<span class="type">char</span> *<var>name</var>, <span class="type">char</span> *<var>mode</var>); </span>  </td>

</tr>
<tr>
  <td class="bnone">
<ul> <li> Проверка достижения конца файла</li>
</ul>  </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span> <span class="fun">feof</span>(<span class="type">FILE</span> *<var>file</var>); </span>  </td>

</tr>
<tr>
  <td class="bnone">
<ul> <li> Закрытие файла</li>
</ul>  </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span> <span class="fun">fclose</span>(<span class="type">FILE</span> *<var>file</var>); </span>  </td>
</tr>
</table>

<p>
<i>FILE</i> – специальная структура, объявленная в файле <span class="sint">&lt;stdio.h&gt;</span>, которая используется при работе с файлами. Для работы с файлом нужно объявить переменную <span class="sint">FILE *&lt;имя&gt;</span>.

</p>
<p>
Функция <i>fopen</i> используется для открытия файла. Первый параметр задаёт имя файла. Второй параметр <i>mode</i> задаёт требуемый тип доступа к файлу.

</p>
<table>
 <tr>
  <th>
   Mode
  </th>
  <th>
   Действие
  </th>
 </tr>
 <tr>
  <td>
   <b>"r"</b>
  </td>
  <td>
   Открытие для чтения. Если файл не существует или не может быть найден, функция <i>fopen</i> возвращает признак 
ошибки.
  </td>
 </tr>
 <tr>
  <td>
   <b>"w"</b>
  </td>
  <td>
   Открытие для записи. Если файл существует, его содержимое уничтожается. Если файл не существует, он 
создаётся.
  </td>
 </tr>
 <tr>
  <td>
   <b>"a"</b>
  </td>
  <td>
   Открытие для добавления. Если файл не существует, он создаётся.
  </td>
 </tr>
 <tr>
  <td>
   <b>"r+"</b>
  </td>
  <td>
   Открытие для чтения и записи. Файл должен существовать.
  </td>
 </tr>
 <tr>
  <td>
   <b>"w+"</b>
  </td>
  <td>
   Открытие пустого файла для чтения и записи. Если файл существует, его содержимое уничтожается.
  </td>
 </tr>
 <tr>
  <td>
   <b>"a+"</b>
  </td>
  <td>
   Открытие для чтения и добавления. Если файл не существует, он создаётся.
  </td>
 </tr>
</table>


<p>
Кроме того, к параметру <i>mode</i> могут быть добавлены символы <b>t</b> и <b>b</b> для задания текстового и двоичного режимов соответственно. По умолчанию используется текстовый режим.

</p>
<p>
В случае ошибки функция <i>fopen</i> возвращает значение <b>NULL</b>.

</p>
<h3 id="l4_1_3_1">1.3.1.	Текстовый режим </h3>

<p>
При вводе/выводе в текстовом режиме происходит преобразование между внешним представлением значения и внутренним (машинным) представлением этого значения.

</p>
<table>
<tr>
  <td class="bnone">
<ul><li> Ввод одного символа</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span>     <span class="fun">getc</span>    (<span class="type">FILE</span> *<var>file</var>); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Вывод одного символа</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span>     <span class="fun">putc</span>    (<span class="type">int</span> <var>c</var>, <span class="type">FILE</span> *<var>file</var>); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Ввод</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span>     <span class="fun">fscanf</span> (<span class="type">FILE</span> *<var>file</var>, <span class="type">char</span> *<var>format</var>, ...); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Вывод</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span>     <span class="fun">fprintf</span>(<span class="type">FILE</span> *<var>file</var>, <span class="type">char</span> *<var>format</var>, ...); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Ввод строки</li></ul>  </td>
  <td class="bnone">
<span class="sint"> – <span class="type">char</span>* <span class="fun">fgets</span>   (<span class="type">char</span> *<var>line</var>, <span class="type">int</span> <var>maxline</var>, <span class="type">FILE</span> *<var>file</var>); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Вывод строки</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">int</span>     <span class="fun">fputs</span>   (<span class="type">char</span> *<var>line</var>, <span class="type">FILE</span> *<var>file</var>); </span> </td>
</tr>
</table>


<h3 id="l4_1_3_2">1.3.2.	Двоичный режим </h3>

<p>
В двоичном режиме никаких преобразований не производится, внутреннее представление значения записывается в файл. Для открытия файла в двоичном режиме необходимо в параметр <i>mode</i> функции <i>fopen</i> добавить символ <b>b</b>.

</p>
<table>
<tr>
  <td class="bnone">
<ul><li> Ввод из двоичного файла</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">unsigned</span> <span class="fun">fread</span>  (<span class="type">void</span> *<var>buf</var>, <span class="type">int</span> <var>bytes</var>, <span class="type">int</span> <var>num</var>, <span class="type">FILE</span> *<var>file</var>); </span> </td>

</tr>
<tr>
  <td class="bnone">
<ul><li> Вывод в двоичный файл</li></ul> </td>
  <td class="bnone">
<span class="sint"> – <span class="type">unsigned</span> <span class="fun">fwrite</span> (<span class="type">void</span> *<var>buf</var>, <span class="type">int</span> <var>bytes</var>, <span class="type">int</span> <var>num</var>, <span class="type">FILE</span> *<var>file</var>); </span> </td>

</tr>
</table>

<p>
Функция <i>fread </i> читает из файла <i>file</i> в переменную <i>buf num</i> элементов, каждый размером <i>bytes</i> байт. Функция <i>fwrite</i> записывает в файл <i>file</i> из переменной <i>buf num</i> элементов, каждый размером <i>bytes</i> байт. Функции возвращают количество прочитанных/записанных элементов.

</p>
<p>
В двоичном режиме возможен прямой доступ к файлу:

<span class="sint">
<i>int</i> <b>fseek</b>(<i>FILE</i> *file, <i>long</i> nbytes, <i>int</i> origin)
</span>

</p>
<p>
Данная функция смещает указатель в файле <i>file</i> на <i>nbytes</i> байт с позиции, определяемой параметром <i>origin</i>. При этом параметр <i>origin</i> может принимать следующие значения:
</p>
<ul>
	<li> <span class="sint">SEEK_SET     0     </span>– начало файла;
	</li>
<li> <span class="sint">SEEK_CUR     1     </span>– текущая позиция указателя;
	</li>
<li> <span class="sint">SEEK_END     2     </span>– конец файла.
</li>
</ul>

<p>
Функция <span class="sint"><i>long</i> <b>ftell</b>(<i>FILE</i> *file)</span> возвращает текущую позицию указателя в файле <i>file</i>.

</p>
<table>
<tr>
  <td class="esempi">fseek(file, 0, SEEK_END);
n = ftell(file);  </td>

  <td class="commenti">// Определение размера файла  </td>

</tr>
</table>

</section><section id="l4_2">
<h1>2.	Потоковый ввод/вывод </h1>

<p>
В языке С++ был разработан другой способ ввода/вывода с использованием так называемых <i>потоков</i> ввода и вывода.

</p>
<h2 id="l4_2_1">2.1.	Использование стандартных потоков <i>cin</i> и <i>cout</i> </h2>

<p>
Для того чтобы использовать стандартные потоки для ввода и вывода, необходимо включить заголовочный файл <span class="sint">&lt;iostream&gt;</span>. Для ввода используется операция <b>&gt;&gt;</b>, для вывода – операция <b>&lt;&lt;</b>. Компилятор определяет тип вводимой/выводимой переменной и соответствующим образом форматирует её.

</p>
<table>
<tr>
  <td class="esempi">
<span class="chiavi">#include</span> &lt;iostream&gt;
<span class="chiavi">using namespace</span> std;  </td>
    
  <td class="commenti">  </td>

</tr>
<tr>
  <td class="esempi">cin  &gt;&gt; x;  </td>
  
  <td class="commenti">// Ввод значения в переменную <b>x</b> из стандартного потока <i>cin</i>  </td>

</tr>
<tr>
  <td class="esempi">cout &lt;&lt; x;  </td>
  
  <td class="commenti">// Вывод значения переменной <b>x</b> в стандартный поток <i>cout</i>  </td>

</tr>
<tr>
  <td class="esempi">cin  &gt;&gt; x &gt;&gt; y;  </td>
  
  <td class="commenti">// Ввод двух переменных  </td>

</tr>
<tr>
  <td class="esempi">cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; "\ny = " &lt;&lt; y &lt;&lt; endl;  </td>
  
  <td class="commenti">// Функция <i>endl</i> осуществляет перевод строки  </td>

</tr>
</table>

<p>
Если при вводе или выводе произошла ошибка, в переменной состояния потока устанавливается соответствующий флаг. Проверить его значение можно с помощью функции <i>fail</i>.

</p>
<table>
<tr>
  <td class="esempi">cin &gt;&gt; x;
<span class="chiavi">if</span> (cin.fail())
 cout &lt;&lt; "Произошла ошибка при вводе\n";
</td>
</tr>
</table>


<h2 id="l4_2_2">2.2.	Форматирование </h2>

<p>
Для управления форматом вводимого/выводимого значения используются так называемые <i>манипуляторы</i>. Это функции, которые вставляются между вводимыми/выводимыми значениями и изменяют состояние потока.

</p>
<p>
Для использования манипуляторов необходимо включить заголовочный файл <span class="sint">&lt;iomanip&gt;</span>.

</p>
<p>
Несколько манипуляторов имеют параметр, который может быть задан литералом или переменной. Изменения, сделанные всеми манипуляторами, кроме <i>setw</i>, остаются в силе до отмены. Действие манипулятор <i>setw</i> распространяется только на одно вводимое/выводимое значение.

</p>
<table>
<tr>
  <th>
    Манипулятор
  </th>
  <th>
    Описание
  </th>
  <th>
    Примечание
  </th>
</tr>
<tr>
  <td>
    <b>boolalpha</b>
  </td>
  <td>
    Значения переменных типа <i>bool</i> выводятся как <i>true</i> и <i>false</i>.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>dec</b>
  </td>
  <td>
    Целые значения выводятся в десятичной системе счисления.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>fixed</b>
  </td>
  <td>
    Для вещественных чисел используется фиксированный формат.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>hex</b>
  </td>
  <td>
    Целые значения выводятся в шестнадцатеричной системе счисления.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>internal</b>
  </td>
  <td>
    Знак выравнивается по левому краю, а само число – по правому краю.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>left</b>
  </td>
  <td>
    Выравнивание по левому краю.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>noboolalpha</b>
  </td>
  <td>
    Значения переменных типа <i>bool</i> выводятся как <i>1</i> и <i>0</i>.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>noshowbase</b>
  </td>
  <td>
    Префиксы <i>0</i> и <i>0х</i>, обозначающие систему счисления, не выводятся.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>noshowpoint</b>
  </td>
  <td>
    Вывод только целой части вещественного числа (без точки), если дробная часть равна 0.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>noshowpos</b>
  </td>
  <td>
    Знак перед положительными числами не выводится.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>noskipws</b>
  </td>
  <td>
    Пробел рассматривается как признак завершения ввода.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>nouppercase</b>
  </td>
  <td>
    Шестнадцатеричные цифры и символ экспоненты в научном формате вещественного числа выводятся строчными буквами.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>oct</b>
  </td>
  <td>
    Целые значения выводятся в восьмеричной системе счисления.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>right</b>
  </td>
  <td>
    Выравнивание по правому краю.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>scientific</b>
  </td>
  <td>
    Для вещественных чисел используется научный формат.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>setfill(<i>c</i>)</b>
  </td>
  <td>
    Задаёт символ для заполнения. По умолчанию используется пробел.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>setprecision(<i>n</i>)</b>
  </td>
  <td>
    Задаёт точность для вещественных чисел. По умолчанию точность равна 6. Если не установлен ни фиксированный, ни научный формат вещественного числа, то точность задаёт количество выводимых цифр (всего, до точки и после точки). Если число слишком велико, оно автоматически отображается в научном формате, и тогда точность задаёт количество цифр в мантиссе. Если установлен фиксированный формат вещественного числа, точность задаёт количество цифр после точки. Если установлен научный формат вещественного числа, точность задаёт количество цифр в мантиссе.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>setw(<i>n</i>)</b>
  </td>
  <td>
    Устанавливает минимальное количество символов, используемых для вывода значения. Если значение представляется меньшим количеством символов, остальные позиции заполняются символом, установленным с помощью манипулятора <i>setfill</i>. Выравнивание задаётся манипуляторами <i>left</i>, <i>right</i> и <i>internal</i>. Чтобы установить поведение по умолчанию (столько символов, сколько необходимо), нужно использовать манипулятор <i>setw</i> с параметром <i>0</i>.
  </td>
  <td>
    <b>Влияет только на одно вводимое/выводимое значение!</b>
  </td>
</tr>
<tr>
  <td>
    <b>showbase</b>
  </td>
  <td>
    Вывод префиксов <i>0</i> и <i>0х</i> для обозначения системы счисления.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>showpoint</b>
  </td>
  <td>
    Вывод и целой, и дробной частей вещественного числа, даже если дробная часть равна 0.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>showpos</b>
  </td>
  <td>
    Вывод знака перед положительным числом.
  </td>
  <td>
     
  </td>
</tr>
<tr>
  <td>
    <b>skipws</b>
  </td>
  <td>
    Пробелы рассматриваются как разделители между значениями.
  </td>
  <td>
     Используется по умолчанию
  </td>
</tr>
<tr>
  <td>
    <b>uppercase</b>
  </td>
  <td>
    Шестнадцатеричные цифры и символ экспоненты в научном формате вещественного числа выводятся прописными буквами.
  </td>
  <td>
     
  </td>
</tr>
</table>

<p>

</p>
<table>
<tr>
  <td class="esempi">
<span class="chiavi">int</span>    m, n, x;
<span class="chiavi">double</span> y;

cin  &gt;&gt; m &gt;&gt; n;
cout &lt;&lt; "m = " &lt;&lt; setw(5) &lt;&lt; m &lt;&lt; "\nn = " &lt;&lt; setw(5) &lt;&lt; n &lt;&lt; endl;

cin  &gt;&gt; x;
cout &lt;&lt; setfill('0') &lt;&lt; showbase &lt;&lt; hex &lt;&lt; setw(10) &lt;&lt; internal &lt;&lt; x &lt;&lt; endl;

cin  &gt;&gt; y;
cout &lt;&lt; setfill(' ') &lt;&lt; fixed &lt;&lt; setw(7) &lt;&lt; setprecision(2) &lt;&lt; y &lt;&lt; endl;  </td>

</tr>
</table>


<h2 id="l4_2_3">2.3.	Связываение потоков </h2>

<p>
Рассмотрим пример.

<code>
<span class="chiavi">char</span> c;
cout &lt;&lt; "Введите символ: ";
cin  &gt;&gt; c;
</code>

</p>
<p>
Как нам гарантировать, что слова <b><i>Введите символ</i></b> появятся на экране прежде, чем будет выполнена операция считывания? Вывод в стандартный поток буферизуется, так что если потоки <i>cin</i> и <i>cout</i> не зависимы, то выводимый текст не появится на экране, пока не заполнится буфер вывода. Решение этой задачи заключается в том, что потоки связываются с помощью функции <i>tie</i>. Эта функция используется для того, чтобы устанавливать и разрывать связи между потоками ввода и вывода.

<code>
<span class="chiavi">char</span> c;
cin.tie(&amp;cout);
cout &lt;&lt; "Введите символ: ";
cin  &gt;&gt; c;
</code>

</p>
<p>
В каждый момент времени поток ввода может быть связан только с одним потоком вывода. Обращение <span class="sint">s.tie(0)</span> разрывает связь между потоком <var>s</var> и потоком, с которым он был связан. Как и большинство функций с потоками, устанавливающих значение, функция <i>tie</i> возвращает прежнее значение, т.е. она возвращает предыдущий связанный поток или 0. При вызове без аргументов функция <span class="sint">tie()</span> возвращает текущий связанный поток, не изменяя его.


</p>
<h2 id="l4_2_4">2.4.	Файловые потоки </h2>

<p>
Для ввода/вывода из файла/в файл существуют потоки, которые могут быть связаны с файлом на диске. Для использования файловых потоков необходимо включить заголовочный файл <span class="sint">&lt;fstream&gt;</span>. Существует три разновидности файловых потоков: <i>fstream</i>, <i>ifstream</i> и <i>ofstream</i>. Разница между ними состоит в том, что поток <i>fstream</i> по умолчанию открывается для ввода и вывода, поток <i>ifstream</i> по умолчанию открывается для ввода, а поток <i>ofstream</i> по умолчанию открывается для вывода. Изменить поведение по умолчанию, а также задать другие режимы открытия файла можно с помощью следующих констант:

</p>
<ul>
    <li>	<span class="sint">ios_base::app     </span> – открытие файла для добавления;
    </li>
<li>	<span class="sint">ios_base::binary </span> – открытие двоичного, а не текстового файла;
    </li>
<li>	<span class="sint">ios_base::in       </span> – открытие файла для чтения;
    </li>
<li>	<span class="sint">ios_base::out     </span> – открытие файла для записи;
    </li>
<li>	<span class="sint">ios_base::trunc  </span> – удаление содержимого файла при открытии.
</li>
</ul>


<p>
Режимы открытия файла комбинируются с помощью операции поразрядного ИЛИ (<b>|</b>).

</p>
<p>
Для открытия файла можно задать имя файла непосредственно в конструкторе потока или воспользоваться функцией <i>open</i>.

</p>
<table>
<tr>
  <td class="esempi">fstream   fs("f1.txt");  </td>
  <td class="commenti">// Открытие файла для чтения и записи  </td>

</tr>
<tr>
  <td class="esempi">ifstream ifs("f2.txt");  </td>
  <td class="commenti">// Открытие файла для чтения  </td>

</tr>
<tr>
  <td class="esempi">ofstream ofs("f3.txt");  </td>
  <td class="commenti">// Открытие файла для записи   </td>

</tr>
<tr>
  <td class="esempi">fstream   fs("f1.txt", ios_base::in | ios_base::out | ios_base::trunk);  </td>
  <td class="commenti">// Открытие файла для чтения и записи с удалением содержимого файла   </td>

</tr>
<tr>
  <td class="esempi">ifstream ifs("f2.txt", ios_base::in | ios_base::binary);  </td>
  <td class="commenti">// Открытие двоичного файла для чтения   </td>

</tr>
<tr>
  <td class="esempi">ofstream ofs;  </td>
  <td class="commenti">// Создаём поток, не связанный с файлом  </td>

</tr>
<tr>
  <td class="esempi">ofs.open("f3.txt");  </td>
  <td class="commenti">// Открываем файл для записи  </td>

</tr>
</table>

<p>
Если вы планируете использовать файл только для чтения или только для записи безопаснее воспользоваться соответствующим файловым потоком.

</p>
<p>
Для проверки открытия файла служит функция <i>is_open</i>.

</p>
<p>
Потоки автоматически закрываются при завершении программы. Однако при необходимости можно закрыть поток функцией <i>close</i> и затем снова открыть его, связав с другим файлом.

</p>
<p>
Для работы с текстовыми потоками используются операции <b>&lt;&lt;</b> и <b>&gt;&gt;</b>. Также возможно использование манипуляторов для форматирования вводимых/выводимых значений.

</p>
<table>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> x;
fstream f;
  </td>

  <td class="commenti">  </td>

</tr>
<tr>
  <td class="esempi">f.open("in.txt", ios_base::in);  </td>
  <td class="commenti">// Открываем файл для чтения  </td>

</tr>
<tr>
  <td class="esempi">
<span class="chiavi">if</span> (!f.is_open())  </td>
  <td class="commenti">// Проверяем открытие файла  </td>

</tr>
<tr>
  <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'in.txt'\n"; <span class="chiavi">return</span>; }  </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi">f &gt;&gt; x;  </td>
  <td class="commenti">// Чтение переменной <b>x</b> из файла  </td>

</tr>
<tr>
  <td class="esempi">
<span class="chiavi">if</span> (f.fail())  </td>
  <td class="commenti">// Проверка ошибок чтения  </td>

</tr>
<tr>
  <td class="esempi"> { cout &lt;&lt; "Ошибка чтения из файла 'in.txt'\n";  <span class="chiavi">return</span>; }  </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi">f.close();  </td>
  <td class="commenti">// Закрываем файл  </td>

</tr>
<tr>
  <td class="esempi">f.open("out.txt", ios_base::out);  </td>
  <td class="commenti">// Снова открываем файл, теперь для записи  </td>

</tr>
<tr>
  <td class="esempi">
<span class="chiavi">if</span> (!f.is_open())  </td>
  <td class="commenti">// Проверяем открытие файла  </td>

</tr>
<tr>
  <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'out.txt'\n"; <span class="chiavi">return</span>; }  </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi">f &lt;&lt; hex &lt;&lt; x &lt;&lt; endl;  </td>
  <td class="commenti">// Выводим значение переменной <b>x</b> в 16-ричной системе  </td>

</tr>
<tr>
  <td class="esempi">f.close();  </td>
  <td class="commenti">// Закрываем файл  </td>

</tr>
</table>

<p>
Для того чтобы проверить, достигнут ли конец файла, используется функция <i>eof</i>.

</p>
<table>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> n;
ifstream f("in.txt");
  </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi">
<span class="chiavi">if</span> (!f.is_open()) </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi"> { cout &lt;&lt; "Невозможно открыть файл 'in.txt'\n"; <span class="chiavi">return</span>; } </td>
  <td class="commenti"> </td>

</tr>
<tr>
  <td class="esempi">
<span class="chiavi">while</span> (!f.eof()) </td>
  <td class="commenti">// Пока не достигнут конец файла </td>

</tr>
<tr>
  <td class="esempi"> { f &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; } </td>
  <td class="commenti"> </td>

</tr>
</table>

<p>
Для организации прямого доступа к файлу используются функции <i>seekg/seekp</i> и <i>tellg/tellp</i>. Различие между функциями состоит в том, что функции, с именем, оканчивающимся символом ‘g’, используются для работы с потоками ввода, а функции, с именем, оканчивающимся символом ‘p’, – для работы с потоками вывода.

</p>
<p>
Функции <i>seekg/seekp</i> перемещают внутренний указатель файла на заданную позицию. Позиции соответствуют байтам, нумерация начинается с 0. Существует две разновидности функций – с одним параметром и с двумя параметрами. Один целочисленный параметр задаёт абсолютную позицию в файле. Два параметра задают смещение (целое число) и точку отсчёта. Этот параметр может принимать следующие значения:

</p>
<ul>
    <li>	<span class="sint">ios_base::beg</span> – начало файла;
    </li>
<li>	<span class="sint">ios_base::cur</span> – текущая позиция указателя;
    </li>
<li>	<span class="sint">ios_base::end</span> – конец файла.
</li>
</ul>

<p>
Функции <i>tellg/tellp</i> не имеют параметров. Они возвращают текущую позицию указателя в файле.

</p>
<p>
Функции <i>seekg/seekp</i> и <i>tellg/tellp</i> работают как с текстовыми, так и с двоичными потоками. В любом случае желательно либо знать структуру файла, либо работать с файлами, все записи в которых имеют одинаковую длину. В противном случае возможно перемещение указателя на позицию, не являющуюся началом записи.

</p>
<p>
Для работы с двоичными файлами используются функции <i>read</i> и <i>write</i>. В качестве параметров функции получают указатель (типа <span class="sint">char*</span> для функции <i>read</i> и типа <span class="sint">const char*</span> для функции <i>write</i>), который задаёт адрес начала массива для ввода/вывода, и целое число, задающее количество байт для ввода/вывода.


</p>
<p>
Пример использования потокового ввода из двоичного файла см. .

</p></section><section id="l4_3">
<h2>3.	Примеры </h2>

<h3 id="l4_3_1"> Пример 1. Ввод массива из текстового файла</h3>

<table>
<tr>
  <td class="commenti">// Функция ввода одномерного массива.
// Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
// <b>x</b> - вводимый массив,
// <b>n</b> - указатель на переменную, содержащую количество элементов массива,
// <b>fname</b> - имя файла для ввода.

</td>
</tr>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> ArrayInput(<span class="chiavi">double</span> x[], <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
 { <span class="chiavi">int</span>   i;
   FILE *file;

   <span class="chiavi">if</span> ((file = fopen(fname, "r")) == NULL)
    { printf("Невозможно открыть файл '%s'\n", fname);
      <span class="chiavi">return</span> 0;
     }
   <span class="chiavi">if</span> (fscanf(file, "%d", n) &lt; 1)
    { printf ("Ошибка чтения из файла '%s'\n", fname);
      fclose(file);
      <span class="chiavi">return</span> 0;
     }
   <span class="chiavi">if</span> (*n &lt; 0 || *n &gt; NMAX)
    { printf("Кол-во эл-тов масс. должно быть от 1 до %d! (файл '%s')\n", NMAX, fname);
      fclose(file);
      <span class="chiavi">return</span> 0; 
      }
   <span class="chiavi">for</span> (i = 0; i &lt; *n; i++)
    <span class="chiavi">if</span> (fscanf(file, "%lf", &amp;x[i]) &lt; 1)
     { printf ("Ошибка чтения из файла '%s'\n", fname);
       fclose(file);
       <span class="chiavi">return</span> 0;
      }
   fclose(file);
   <span class="chiavi">return</span> 1;
  }
</td>
</tr>
</table>

<h3 id="l4_3_2"> Пример 2. Вывод массива в двоичный файл</h3>

<table>
<tr>
  <td class="commenti">// Вывод массива в двоичный файл.
// Если вывод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
// <b>x</b> - выводимый массив,
// <b>n</b> - переменная, содержащая количество элементов массива,
// <b>fname</b> - имя файла для вывода.

</td>
</tr>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> BinOutput(<span class="chiavi">double</span> x[], <span class="chiavi"> int</span> n, <span class="chiavi"> char</span> *fname)
 { FILE *file;

   <span class="chiavi">if</span> ((file = fopen(fname, "wb")) == NULL)
    { printf("Невозможно открыть файл '%s'\n", fname);
      <span class="chiavi">return</span> 0;
     }
   <span class="chiavi">if</span> (fwrite(x, n * <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>), 1, file) &lt; 1)
    { printf ("Ошибка записи в файл '%s'\n", fname);
      fclose(file);
      <span class="chiavi">return</span> 0;
      }
   fclose(file);
   <span class="chiavi">return</span> 1;
  }
</td>
</tr>
</table>

<h3 id="l4_3_3"> Пример 3. Ввод массива из двоичного файла</h3>

<table>
<tr>
  <td class="commenti">// Ввод массива из двоичного файла.
// Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
// <b>x</b> - вводимый массив,
// <b>n</b> - указатель на переменную, содержащую количество элементов массива,
// <b>fname</b> - имя файла для ввода.

</td>
</tr>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[], <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
 { FILE *file;

   <span class="chiavi">if</span> ((file = fopen(fname, "rb")) == NULL)
    { printf("Невозможно открыть файл '%s'\n", fname);
      <span class="chiavi">return</span> 0;
     }
   <span class="chiavi">for </span>(*n = 0; ; (*n)++)
    <span class="chiavi">if</span> (fread(x + (*n), <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>), 1, file) &lt; 1)
     <span class="chiavi">if</span> (feof(file))
      <span class="chiavi">break</span>;
     <span class="chiavi">else</span>
      { printf ("Ошибка чтения из файла '%s'\n", fname);
        fclose(file);
        <span class="chiavi">return</span> 0;
       }
   fclose(file);
   <span class="chiavi">return</span> 1;
  }
</td>
</tr>
</table>


<table>
<tr>
  <td class="commenti">
  
// Другой способ 

</td>
</tr>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[], <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
 { FILE *file;

   <span class="chiavi">if</span> ((file = fopen(fname, "rb")) == NULL)
    { printf("Невозможно открыть файл '%s'\n", fname);
      <span class="chiavi">return</span> 0;
     }
   fseek(file, 0, SEEK_END);
   *n = ftell(file) / <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>);
   fseek(file, 0, SEEK_SET);
   <span class="chiavi">if</span> (fread(x, <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>), *n, file) &lt; *n)
    { printf ("Ошибка чтения из файла '%s'\n", fname);
      fclose(file);
      <span class="chiavi">return</span> 0;
     }
   fclose(file);
   <span class="chiavi">return</span> 1;
  }
</td>
</tr>
</table>



<h3 id="l4_3_4"> Пример 4. Потоковый ввод массива из двоичного файла</h3>

<table>
<tr>
  <td class="commenti">// Ввод массива из двоичного файла.
// Если ввод был осуществлен без ошибок, возвращается 1, в противном случае - 0.
// <b>x</b> - вводимый массив,
// <b>n</b> - указатель на переменную, содержащую количество элементов массива,
// <b>fname</b> - имя файла для ввода.

</td>
</tr>
<tr>
  <td class="esempi">
<span class="chiavi">int</span> BinInput(<span class="chiavi">double</span> x[], <span class="chiavi"> int</span> *n, <span class="chiavi"> char</span> *fname)
 { ifstream f(fname, ios_base::in | ios_base::binary);

   <span class="chiavi">if</span> (!f.is_open())
    { cout &lt;&lt; "Невозможно открыть файл '" &lt;&lt; fname &lt;&lt; "'\n";
      <span class="chiavi">return</span> 0;
     }
   f.seekg(0, ios_base::end);
   *n = f.tellg() / <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>);
   f.seekg(0, ios_base::beg);
   f.read(<span class="chiavi">reinterpret_cast</span>&lt;<span class="chiavi">char</span> *&gt;(x), *n * <span class="chiavi">sizeof</span>(<span class="chiavi">double</span>));
   <span class="chiavi">if</span> (f.fail())
    { cout &lt;&lt; "Ошибка чтения из файла '" &lt;&lt; fname &lt;&lt; "'\n";
      <span class="chiavi">return</span> 0;
     }
   <span class="chiavi">return</span> 1;
  }
</td>
</tr>
</table>

</section>